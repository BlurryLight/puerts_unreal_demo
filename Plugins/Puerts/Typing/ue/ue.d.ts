/// <reference path="puerts.d.ts" />
declare module "ue" {
    import {$Ref, $Nullable} from "puerts"

    import * as cpp from "cpp"

    import * as UE from "ue"

    class Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CreateDefaultSubobject(p0: string, p1: $Nullable<Class>, p2: $Nullable<Class>, p3: boolean, p4: boolean) : Object;
        ExecuteUbergraph(EntryPoint: number) : void;
        GetClass() : Class;
        GetName() : string;
        GetOuter() : Object;
        GetWorld() : World;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Object;
        static Load(InName: string): Object;
    }
    
    class AssetImportInfo {
        constructor();
        static StaticClass(): Class;
    }
    
    class AssetImportData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceFilePath: string;
        SourceFileTimestamp: string;
        SourceData: UE.AssetImportInfo;
        K2_ExtractFilenames() : TArray<string>;
        K2_GetFirstFilename() : string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetImportData;
        static Load(InName: string): AssetImportData;
    }
    
    enum EAlembicSamplingType { PerFrame, PerXFrames, PerTimeStep, EAlembicSamplingType_MAX}
    class AbcSamplingSettings {
        constructor();
        constructor(SamplingType: UE.EAlembicSamplingType, FrameSteps: number, TimeSteps: number, FrameStart: number, FrameEnd: number, bSkipEmpty: boolean);
        SamplingType: UE.EAlembicSamplingType;
        FrameSteps: number;
        TimeSteps: number;
        FrameStart: number;
        FrameEnd: number;
        bSkipEmpty: boolean;
        static StaticClass(): Class;
    }
    
    class AbcAssetImportData extends UE.AssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TrackNames: TArray<string>;
        SamplingSettings: UE.AbcSamplingSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AbcAssetImportData;
        static Load(InName: string): AbcAssetImportData;
    }
    
    enum EAlembicImportType { StaticMesh, GeometryCache, Skeletal, EAlembicImportType_MAX}
    class AbcNormalGenerationSettings {
        constructor();
        constructor(bForceOneSmoothingGroupPerObject: boolean, HardEdgeAngleThreshold: number, bRecomputeNormals: boolean, bIgnoreDegenerateTriangles: boolean);
        bForceOneSmoothingGroupPerObject: boolean;
        HardEdgeAngleThreshold: number;
        bRecomputeNormals: boolean;
        bIgnoreDegenerateTriangles: boolean;
        static StaticClass(): Class;
    }
    
    class AbcMaterialSettings {
        constructor();
        constructor(bCreateMaterials: boolean, bFindMaterials: boolean);
        bCreateMaterials: boolean;
        bFindMaterials: boolean;
        static StaticClass(): Class;
    }
    
    enum EBaseCalculationType { None, PercentageBased, FixedNumber, EBaseCalculationType_MAX}
    class AbcCompressionSettings {
        constructor();
        constructor(bMergeMeshes: boolean, bBakeMatrixAnimation: boolean, BaseCalculationType: UE.EBaseCalculationType, PercentageOfTotalBases: number, MaxNumberOfBases: number, MinimumNumberOfVertexInfluencePercentage: number);
        bMergeMeshes: boolean;
        bBakeMatrixAnimation: boolean;
        BaseCalculationType: UE.EBaseCalculationType;
        PercentageOfTotalBases: number;
        MaxNumberOfBases: number;
        MinimumNumberOfVertexInfluencePercentage: number;
        static StaticClass(): Class;
    }
    
    class AbcStaticMeshSettings {
        constructor();
        constructor(bMergeMeshes: boolean, bPropagateMatrixTransformations: boolean, bGenerateLightmapUVs: boolean);
        bMergeMeshes: boolean;
        bPropagateMatrixTransformations: boolean;
        bGenerateLightmapUVs: boolean;
        static StaticClass(): Class;
    }
    
    class AbcGeometryCacheSettings {
        constructor();
        constructor(bFlattenTracks: boolean, bApplyConstantTopologyOptimizations: boolean, bCalculateMotionVectorsDuringImport: boolean, bOptimizeIndexBuffers: boolean, CompressedPositionPrecision: number, CompressedTextureCoordinatesNumberOfBits: number);
        bFlattenTracks: boolean;
        bApplyConstantTopologyOptimizations: boolean;
        bCalculateMotionVectorsDuringImport: boolean;
        bOptimizeIndexBuffers: boolean;
        CompressedPositionPrecision: number;
        CompressedTextureCoordinatesNumberOfBits: number;
        static StaticClass(): Class;
    }
    
    enum EAbcConversionPreset { Maya, Max, Custom, EAbcConversionPreset_MAX}
    class AbcConversionSettings {
        constructor();
        constructor(Preset: UE.EAbcConversionPreset, bFlipU: boolean, bFlipV: boolean, Scale: UE.Vector, Rotation: UE.Vector);
        Preset: UE.EAbcConversionPreset;
        bFlipU: boolean;
        bFlipV: boolean;
        Scale: UE.Vector;
        Rotation: UE.Vector;
        static StaticClass(): Class;
    }
    
    class AbcImportSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportType: UE.EAlembicImportType;
        SamplingSettings: UE.AbcSamplingSettings;
        NormalGenerationSettings: UE.AbcNormalGenerationSettings;
        MaterialSettings: UE.AbcMaterialSettings;
        CompressionSettings: UE.AbcCompressionSettings;
        StaticMeshSettings: UE.AbcStaticMeshSettings;
        GeometryCacheSettings: UE.AbcGeometryCacheSettings;
        ConversionSettings: UE.AbcConversionSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AbcImportSettings;
        static Load(InName: string): AbcImportSettings;
    }
    
    enum ETickingGroup { TG_PrePhysics, TG_StartPhysics, TG_DuringPhysics, TG_EndPhysics, TG_PostPhysics, TG_PostUpdateWork, TG_LastDemotable, TG_NewlySpawned, TG_MAX}
    class TickFunction {
        constructor();
        constructor(TickGroup: UE.ETickingGroup, EndTickGroup: UE.ETickingGroup, bTickEvenWhenPaused: boolean, bCanEverTick: boolean, bStartWithTickEnabled: boolean, bAllowTickOnDedicatedServer: boolean, TickInterval: number);
        TickGroup: UE.ETickingGroup;
        EndTickGroup: UE.ETickingGroup;
        bTickEvenWhenPaused: boolean;
        bCanEverTick: boolean;
        bStartWithTickEnabled: boolean;
        bAllowTickOnDedicatedServer: boolean;
        TickInterval: number;
        static StaticClass(): Class;
    }
    
    class ActorTickFunction extends UE.TickFunction {
        constructor();
        static StaticClass(): Class;
    }
    
    enum EActorUpdateOverlapsMethod { UseConfigDefault, AlwaysUpdate, OnlyUpdateMovable, NeverUpdate, EActorUpdateOverlapsMethod_MAX}
    enum ENetRole { ROLE_None, ROLE_SimulatedProxy, ROLE_AutonomousProxy, ROLE_Authority, ROLE_MAX}
    enum EVectorQuantization { RoundWholeNumber, RoundOneDecimal, RoundTwoDecimals, EVectorQuantization_MAX}
    enum ERotatorQuantization { ByteComponents, ShortComponents, ERotatorQuantization_MAX}
    class RepMovement {
        constructor();
        constructor(LinearVelocity: UE.Vector, AngularVelocity: UE.Vector, Location: UE.Vector, Rotation: UE.Rotator, bSimulatedPhysicSleep: boolean, bRepPhysics: boolean, LocationQuantizationLevel: UE.EVectorQuantization, VelocityQuantizationLevel: UE.EVectorQuantization, RotationQuantizationLevel: UE.ERotatorQuantization);
        LinearVelocity: UE.Vector;
        AngularVelocity: UE.Vector;
        Location: UE.Vector;
        Rotation: UE.Rotator;
        bSimulatedPhysicSleep: boolean;
        bRepPhysics: boolean;
        LocationQuantizationLevel: UE.EVectorQuantization;
        VelocityQuantizationLevel: UE.EVectorQuantization;
        RotationQuantizationLevel: UE.ERotatorQuantization;
        static StaticClass(): Class;
    }
    
    class Vector_NetQuantize100 extends UE.Vector {
        constructor();
        static StaticClass(): Class;
    }
    
    class ActorComponentTickFunction extends UE.TickFunction {
        constructor();
        static StaticClass(): Class;
    }
    
    class AssetUserData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetUserData;
        static Load(InName: string): AssetUserData;
    }
    
    enum EComponentCreationMethod { Native, SimpleConstructionScript, UserConstructionScript, Instance, EComponentCreationMethod_MAX}
    class SimpleMemberReference {
        constructor();
        constructor(MemberParent: UE.Object, MemberName: string, MemberGuid: UE.Guid);
        MemberParent: UE.Object;
        MemberName: string;
        MemberGuid: UE.Guid;
        static StaticClass(): Class;
    }
    
    enum EEndPlayReason { Destroyed, LevelTransition, EndPlayInEditor, RemovedFromWorld, Quit, EEndPlayReason_MAX}
    class ActorComponent extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PrimaryComponentTick: UE.ActorComponentTickFunction;
        ComponentTags: TArray<string>;
        AssetUserData: TArray<UE.AssetUserData>;
        bReplicates: boolean;
        bNetAddressable: boolean;
        bCreatedByConstructionScript: boolean;
        bInstanceComponent: boolean;
        bAutoActivate: boolean;
        bIsActive: boolean;
        bEditableWhenInherited: boolean;
        bCanEverAffectNavigation: boolean;
        bIsEditorOnly: boolean;
        bIsVisualizationComponent: boolean;
        CreationMethod: UE.EComponentCreationMethod;
        OnComponentActivated: $MulticastDelegate<(Component: $Nullable<UE.ActorComponent>, bReset: boolean) => void>;
        OnComponentDeactivated: $MulticastDelegate<(Component: $Nullable<UE.ActorComponent>) => void>;
        UCSModifiedProperties: TArray<UE.SimpleMemberReference>;
        Activate(bReset?: boolean /* = false */) : void;
        AddTickPrerequisiteActor(PrerequisiteActor: $Nullable<UE.Actor>) : void;
        AddTickPrerequisiteComponent(PrerequisiteComponent: $Nullable<UE.ActorComponent>) : void;
        ComponentHasTag(Tag: string) : boolean;
        Deactivate() : void;
        GetComponentTickInterval() : number;
        GetOwner() : UE.Actor;
        IsActive() : boolean;
        IsBeingDestroyed() : boolean;
        IsComponentTickEnabled() : boolean;
        K2_DestroyComponent(Object: $Nullable<UE.Object>) : void;
        OnRep_IsActive() : void;
        ReceiveBeginPlay() : void;
        ReceiveEndPlay(EndPlayReason: UE.EEndPlayReason) : void;
        ReceiveTick(DeltaSeconds: number) : void;
        RemoveTickPrerequisiteActor(PrerequisiteActor: $Nullable<UE.Actor>) : void;
        RemoveTickPrerequisiteComponent(PrerequisiteComponent: $Nullable<UE.ActorComponent>) : void;
        SetActive(bNewActive: boolean, bReset?: boolean /* = false */) : void;
        SetAutoActivate(bNewAutoActivate: boolean) : void;
        SetComponentTickEnabled(bEnabled: boolean) : void;
        SetComponentTickInterval(TickInterval: number) : void;
        SetIsReplicated(ShouldReplicate: boolean) : void;
        SetTickableWhenPaused(bTickableWhenPaused: boolean) : void;
        SetTickGroup(NewTickGroup: UE.ETickingGroup) : void;
        ToggleActive() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorComponent;
        static Load(InName: string): ActorComponent;
    }
    
    enum EBrushType { Brush_Default, Brush_Add, Brush_Subtract, Brush_MAX}
    class Model extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Model;
        static Load(InName: string): Model;
    }
    
    enum ESceneDepthPriorityGroup { SDPG_World, SDPG_Foreground, SDPG_MAX}
    enum EIndirectLightingCacheQuality { ILCQ_Off, ILCQ_Point, ILCQ_Volume, ILCQ_MAX}
    enum ELightmapType { Default, ForceSurface, ForceVolumetric, ELightmapType_MAX}
    enum EHasCustomNavigableGeometry { No, Yes, EvenIfNotCollidable, DontExport, EHasCustomNavigableGeometry_MAX}
    enum ECanBeCharacterBase { ECB_No, ECB_Yes, ECB_Owner, ECB_MAX}
    class LightingChannels {
        constructor();
        constructor(bChannel0: boolean, bChannel1: boolean, bChannel2: boolean);
        bChannel0: boolean;
        bChannel1: boolean;
        bChannel2: boolean;
        static StaticClass(): Class;
    }
    
    enum ERendererStencilMask { ERSM_Default, ERSM_255, ERSM_1, ERSM_2, ERSM_4, ERSM_8, ERSM_16, ERSM_32, ERSM_64, ERSM_128, ERSM_MAX}
    class CustomPrimitiveData {
        constructor();
        constructor(Data: TArray<number>);
        Data: TArray<number>;
        static StaticClass(): Class;
    }
    
    enum ERuntimeVirtualTextureMaterialType { BaseColor, BaseColor_Normal_DEPRECATED, BaseColor_Normal_Specular, BaseColor_Normal_Specular_YCoCg, WorldHeight, Count, ERuntimeVirtualTextureMaterialType_MAX}
    class StreamableRenderAsset extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ForceMipLevelsToBeResidentTimestamp: number;
        NumCinematicMipLevels: number;
        StreamingIndex: number;
        CachedCombinedLODBias: number;
        CachedNumResidentLODs: number;
        bCachedReadyForStreaming: boolean;
        NeverStream: boolean;
        bGlobalForceMipLevelsToBeResident: boolean;
        bIsStreamable: boolean;
        bHasStreamingUpdatePending: boolean;
        bForceMiplevelsToBeResident: boolean;
        bIgnoreStreamingMipBias: boolean;
        bUseCinematicMipLevels: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StreamableRenderAsset;
        static Load(InName: string): StreamableRenderAsset;
    }
    
    enum ETextureSourceFormat { TSF_Invalid, TSF_G8, TSF_BGRA8, TSF_BGRE8, TSF_RGBA16, TSF_RGBA16F, TSF_RGBA8, TSF_RGBE8, TSF_G16, TSF_MAX}
    class TextureSourceBlock {
        constructor();
        constructor(BlockX: number, BlockY: number, SizeX: number, SizeY: number, NumSlices: number, NumMips: number);
        BlockX: number;
        BlockY: number;
        SizeX: number;
        SizeY: number;
        NumSlices: number;
        NumMips: number;
        static StaticClass(): Class;
    }
    
    class TextureSource {
        constructor();
        constructor(Id: UE.Guid, BaseBlockX: number, BaseBlockY: number, SizeX: number, SizeY: number, NumSlices: number, NumMips: number, NumLayers: number, bPNGCompressed: boolean, bGuidIsHash: boolean, Format: UE.ETextureSourceFormat, LayerFormat: TArray<UE.ETextureSourceFormat>, Blocks: TArray<UE.TextureSourceBlock>);
        Id: UE.Guid;
        BaseBlockX: number;
        BaseBlockY: number;
        SizeX: number;
        SizeY: number;
        NumSlices: number;
        NumMips: number;
        NumLayers: number;
        bPNGCompressed: boolean;
        bGuidIsHash: boolean;
        Format: UE.ETextureSourceFormat;
        LayerFormat: TArray<UE.ETextureSourceFormat>;
        Blocks: TArray<UE.TextureSourceBlock>;
        static StaticClass(): Class;
    }
    
    enum ETextureLossyCompressionAmount { TLCA_Default, TLCA_None, TLCA_Lowest, TLCA_Low, TLCA_Medium, TLCA_High, TLCA_Highest, TLCA_MAX}
    enum ETextureCompressionQuality { TCQ_Default, TCQ_Lowest, TCQ_Low, TCQ_Medium, TCQ_High, TCQ_Highest, TCQ_MAX}
    enum ETexturePowerOfTwoSetting { None, PadToPowerOfTwo, PadToSquarePowerOfTwo, ETexturePowerOfTwoSetting_MAX}
    enum TextureMipGenSettings { TMGS_FromTextureGroup, TMGS_SimpleAverage, TMGS_Sharpen0, TMGS_Sharpen1, TMGS_Sharpen2, TMGS_Sharpen3, TMGS_Sharpen4, TMGS_Sharpen5, TMGS_Sharpen6, TMGS_Sharpen7, TMGS_Sharpen8, TMGS_Sharpen9, TMGS_Sharpen10, TMGS_NoMipmaps, TMGS_LeaveExistingMips, TMGS_Blur1, TMGS_Blur2, TMGS_Blur3, TMGS_Blur4, TMGS_Blur5, TMGS_Unfiltered, TMGS_MAX}
    enum ECompositeTextureMode { CTM_Disabled, CTM_NormalRoughnessToRed, CTM_NormalRoughnessToGreen, CTM_NormalRoughnessToBlue, CTM_NormalRoughnessToAlpha, CTM_MAX}
    enum TextureCompressionSettings { TC_Default, TC_Normalmap, TC_Masks, TC_Grayscale, TC_Displacementmap, TC_VectorDisplacementmap, TC_HDR, TC_EditorIcon, TC_Alpha, TC_DistanceFieldFont, TC_HDR_Compressed, TC_BC7, TC_MAX}
    class TextureFormatSettings {
        constructor();
        constructor(CompressionSettings: UE.TextureCompressionSettings, CompressionNoAlpha: boolean, CompressionNone: boolean, CompressionYCoCg: boolean, SRGB: boolean);
        CompressionSettings: UE.TextureCompressionSettings;
        CompressionNoAlpha: boolean;
        CompressionNone: boolean;
        CompressionYCoCg: boolean;
        SRGB: boolean;
        static StaticClass(): Class;
    }
    
    enum TextureFilter { TF_Nearest, TF_Bilinear, TF_Trilinear, TF_Default, TF_MAX}
    enum ETextureMipLoadOptions { Default, AllMips, OnlyFirstMip, ETextureMipLoadOptions_MAX}
    enum TextureGroup { TEXTUREGROUP_World, TEXTUREGROUP_WorldNormalMap, TEXTUREGROUP_WorldSpecular, TEXTUREGROUP_Character, TEXTUREGROUP_CharacterNormalMap, TEXTUREGROUP_CharacterSpecular, TEXTUREGROUP_Weapon, TEXTUREGROUP_WeaponNormalMap, TEXTUREGROUP_WeaponSpecular, TEXTUREGROUP_Vehicle, TEXTUREGROUP_VehicleNormalMap, TEXTUREGROUP_VehicleSpecular, TEXTUREGROUP_Cinematic, TEXTUREGROUP_Effects, TEXTUREGROUP_EffectsNotFiltered, TEXTUREGROUP_Skybox, TEXTUREGROUP_UI, TEXTUREGROUP_Lightmap, TEXTUREGROUP_RenderTarget, TEXTUREGROUP_MobileFlattened, TEXTUREGROUP_ProcBuilding_Face, TEXTUREGROUP_ProcBuilding_LightMap, TEXTUREGROUP_Shadowmap, TEXTUREGROUP_ColorLookupTable, TEXTUREGROUP_Terrain_Heightmap, TEXTUREGROUP_Terrain_Weightmap, TEXTUREGROUP_Bokeh, TEXTUREGROUP_IESLightProfile, TEXTUREGROUP_Pixels2D, TEXTUREGROUP_HierarchicalLOD, TEXTUREGROUP_Impostor, TEXTUREGROUP_ImpostorNormalDepth, TEXTUREGROUP_8BitData, TEXTUREGROUP_16BitData, TEXTUREGROUP_Project01, TEXTUREGROUP_Project02, TEXTUREGROUP_Project03, TEXTUREGROUP_Project04, TEXTUREGROUP_Project05, TEXTUREGROUP_Project06, TEXTUREGROUP_Project07, TEXTUREGROUP_Project08, TEXTUREGROUP_Project09, TEXTUREGROUP_Project10, TEXTUREGROUP_MAX}
    class Texture extends UE.StreamableRenderAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Source: UE.TextureSource;
        LightingGuid: UE.Guid;
        SourceFilePath: string;
        AssetImportData: UE.AssetImportData;
        AdjustBrightness: number;
        AdjustBrightnessCurve: number;
        AdjustVibrance: number;
        AdjustSaturation: number;
        AdjustRGBCurve: number;
        AdjustHue: number;
        AdjustMinAlpha: number;
        AdjustMaxAlpha: number;
        CompressionNoAlpha: boolean;
        CompressionNone: boolean;
        DeferCompression: boolean;
        LossyCompressionAmount: UE.ETextureLossyCompressionAmount;
        MaxTextureSize: number;
        CompressionQuality: UE.ETextureCompressionQuality;
        bDitherMipMapAlpha: boolean;
        AlphaCoverageThresholds: UE.Vector4;
        bPreserveBorder: boolean;
        bFlipGreenChannel: boolean;
        bForcePVRTC4: boolean;
        PowerOfTwoMode: UE.ETexturePowerOfTwoSetting;
        PaddingColor: UE.Color;
        bChromaKeyTexture: boolean;
        ChromaKeyThreshold: number;
        ChromaKeyColor: UE.Color;
        MipGenSettings: UE.TextureMipGenSettings;
        CompositeTexture: UE.Texture;
        CompositeTextureMode: UE.ECompositeTextureMode;
        CompositePower: number;
        LayerFormatSettings: TArray<UE.TextureFormatSettings>;
        LODBias: number;
        CompressionSettings: UE.TextureCompressionSettings;
        Filter: UE.TextureFilter;
        MipLoadOptions: UE.ETextureMipLoadOptions;
        LODGroup: UE.TextureGroup;
        SRGB: boolean;
        bUseLegacyGamma: boolean;
        bNoTiling: boolean;
        VirtualTextureStreaming: boolean;
        CompressionYCoCg: boolean;
        bAsyncResourceReleaseHasBeenStarted: boolean;
        AssetUserData: TArray<UE.AssetUserData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Texture;
        static Load(InName: string): Texture;
    }
    
    enum TextureAddress { TA_Wrap, TA_Clamp, TA_Mirror, TA_MAX}
    class Texture2D extends UE.Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LevelIndex: number;
        FirstResourceMemMip: number;
        bTemporarilyDisableStreaming: boolean;
        bHasBeenPaintedInEditor: boolean;
        AddressX: UE.TextureAddress;
        AddressY: UE.TextureAddress;
        ImportedSize: UE.IntPoint;
        Blueprint_GetSizeX() : number;
        Blueprint_GetSizeY() : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Texture2D;
        static Load(InName: string): Texture2D;
    }
    
    class VirtualTextureBuildSettings {
        constructor();
        constructor(TileSize: number, TileBorderSize: number, bEnableCompressCrunch: boolean, bEnableCompressZlib: boolean);
        TileSize: number;
        TileBorderSize: number;
        bEnableCompressCrunch: boolean;
        bEnableCompressZlib: boolean;
        static StaticClass(): Class;
    }
    
    class RuntimeVirtualTextureStreamingProxy extends UE.Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: UE.VirtualTextureBuildSettings;
        bSinglePhysicalSpace: boolean;
        BuildHash: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTextureStreamingProxy;
        static Load(InName: string): RuntimeVirtualTextureStreamingProxy;
    }
    
    class RuntimeVirtualTexture extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialType: UE.ERuntimeVirtualTextureMaterialType;
        bCompressTextures: boolean;
        bEnable: boolean;
        bClearTextures: boolean;
        bSinglePhysicalSpace: boolean;
        bPrivateSpace: boolean;
        bEnableScalability: boolean;
        Size: number;
        TileCount: number;
        TileSize: number;
        TileBorderSize: number;
        RemoveLowMips: number;
        StreamLowMips: number;
        StreamingTexture: UE.RuntimeVirtualTextureStreamingProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTexture;
        static Load(InName: string): RuntimeVirtualTexture;
    }
    
    enum ERuntimeVirtualTextureMainPassType { Never, Exclusive, Always, ERuntimeVirtualTextureMainPassType_MAX}
    enum ECollisionChannel { ECC_WorldStatic, ECC_WorldDynamic, ECC_Pawn, ECC_Visibility, ECC_Camera, ECC_PhysicsBody, ECC_Vehicle, ECC_Destructible, ECC_EngineTraceChannel1, ECC_EngineTraceChannel2, ECC_EngineTraceChannel3, ECC_EngineTraceChannel4, ECC_EngineTraceChannel5, ECC_EngineTraceChannel6, ECC_GameTraceChannel1, ECC_GameTraceChannel2, ECC_GameTraceChannel3, ECC_GameTraceChannel4, ECC_GameTraceChannel5, ECC_GameTraceChannel6, ECC_GameTraceChannel7, ECC_GameTraceChannel8, ECC_GameTraceChannel9, ECC_GameTraceChannel10, ECC_GameTraceChannel11, ECC_GameTraceChannel12, ECC_GameTraceChannel13, ECC_GameTraceChannel14, ECC_GameTraceChannel15, ECC_GameTraceChannel16, ECC_GameTraceChannel17, ECC_GameTraceChannel18, ECC_OverlapAll_Deprecated, ECC_MAX}
    enum ECollisionEnabled { NoCollision, QueryOnly, PhysicsOnly, QueryAndPhysics, ECollisionEnabled_MAX}
    enum ESleepFamily { Normal, Sensitive, Custom, ESleepFamily_MAX}
    enum EDOFMode { Default, SixDOF, YZPlane, XZPlane, XYPlane, CustomPlane, None, EDOFMode_MAX}
    enum ECollisionResponse { ECR_Ignore, ECR_Overlap, ECR_Block, ECR_MAX}
    class CollisionResponseContainer {
        constructor();
        constructor(WorldStatic: UE.ECollisionResponse, WorldDynamic: UE.ECollisionResponse, Pawn: UE.ECollisionResponse, Visibility: UE.ECollisionResponse, Camera: UE.ECollisionResponse, PhysicsBody: UE.ECollisionResponse, Vehicle: UE.ECollisionResponse, Destructible: UE.ECollisionResponse, EngineTraceChannel1: UE.ECollisionResponse, EngineTraceChannel2: UE.ECollisionResponse, EngineTraceChannel3: UE.ECollisionResponse, EngineTraceChannel4: UE.ECollisionResponse, EngineTraceChannel5: UE.ECollisionResponse, EngineTraceChannel6: UE.ECollisionResponse, GameTraceChannel1: UE.ECollisionResponse, GameTraceChannel2: UE.ECollisionResponse, GameTraceChannel3: UE.ECollisionResponse, GameTraceChannel4: UE.ECollisionResponse, GameTraceChannel5: UE.ECollisionResponse, GameTraceChannel6: UE.ECollisionResponse, GameTraceChannel7: UE.ECollisionResponse, GameTraceChannel8: UE.ECollisionResponse, GameTraceChannel9: UE.ECollisionResponse, GameTraceChannel10: UE.ECollisionResponse, GameTraceChannel11: UE.ECollisionResponse, GameTraceChannel12: UE.ECollisionResponse, GameTraceChannel13: UE.ECollisionResponse, GameTraceChannel14: UE.ECollisionResponse, GameTraceChannel15: UE.ECollisionResponse, GameTraceChannel16: UE.ECollisionResponse, GameTraceChannel17: UE.ECollisionResponse, GameTraceChannel18: UE.ECollisionResponse);
        WorldStatic: UE.ECollisionResponse;
        WorldDynamic: UE.ECollisionResponse;
        Pawn: UE.ECollisionResponse;
        Visibility: UE.ECollisionResponse;
        Camera: UE.ECollisionResponse;
        PhysicsBody: UE.ECollisionResponse;
        Vehicle: UE.ECollisionResponse;
        Destructible: UE.ECollisionResponse;
        EngineTraceChannel1: UE.ECollisionResponse;
        EngineTraceChannel2: UE.ECollisionResponse;
        EngineTraceChannel3: UE.ECollisionResponse;
        EngineTraceChannel4: UE.ECollisionResponse;
        EngineTraceChannel5: UE.ECollisionResponse;
        EngineTraceChannel6: UE.ECollisionResponse;
        GameTraceChannel1: UE.ECollisionResponse;
        GameTraceChannel2: UE.ECollisionResponse;
        GameTraceChannel3: UE.ECollisionResponse;
        GameTraceChannel4: UE.ECollisionResponse;
        GameTraceChannel5: UE.ECollisionResponse;
        GameTraceChannel6: UE.ECollisionResponse;
        GameTraceChannel7: UE.ECollisionResponse;
        GameTraceChannel8: UE.ECollisionResponse;
        GameTraceChannel9: UE.ECollisionResponse;
        GameTraceChannel10: UE.ECollisionResponse;
        GameTraceChannel11: UE.ECollisionResponse;
        GameTraceChannel12: UE.ECollisionResponse;
        GameTraceChannel13: UE.ECollisionResponse;
        GameTraceChannel14: UE.ECollisionResponse;
        GameTraceChannel15: UE.ECollisionResponse;
        GameTraceChannel16: UE.ECollisionResponse;
        GameTraceChannel17: UE.ECollisionResponse;
        GameTraceChannel18: UE.ECollisionResponse;
        static StaticClass(): Class;
    }
    
    class ResponseChannel {
        constructor();
        constructor(Channel: string, Response: UE.ECollisionResponse);
        Channel: string;
        Response: UE.ECollisionResponse;
        static StaticClass(): Class;
    }
    
    class CollisionResponse {
        constructor();
        constructor(ResponseToChannels: UE.CollisionResponseContainer, ResponseArray: TArray<UE.ResponseChannel>);
        ResponseToChannels: UE.CollisionResponseContainer;
        ResponseArray: TArray<UE.ResponseChannel>;
        static StaticClass(): Class;
    }
    
    enum EWalkableSlopeBehavior { WalkableSlope_Default, WalkableSlope_Increase, WalkableSlope_Decrease, WalkableSlope_Unwalkable, WalkableSlope_Max, WalkableSlope_MAX}
    class WalkableSlopeOverride {
        constructor();
        constructor(WalkableSlopeBehavior: UE.EWalkableSlopeBehavior, WalkableSlopeAngle: number);
        WalkableSlopeBehavior: UE.EWalkableSlopeBehavior;
        WalkableSlopeAngle: number;
        static StaticClass(): Class;
    }
    
    enum EFrictionCombineMode { Average, Min, Multiply, Max, EFrictionCombineMode_MAX}
    class PhysicalMaterialPropertyBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicalMaterialPropertyBase;
        static Load(InName: string): PhysicalMaterialPropertyBase;
    }
    
    enum EPhysicalSurface { SurfaceType_Default, SurfaceType1, SurfaceType2, SurfaceType3, SurfaceType4, SurfaceType5, SurfaceType6, SurfaceType7, SurfaceType8, SurfaceType9, SurfaceType10, SurfaceType11, SurfaceType12, SurfaceType13, SurfaceType14, SurfaceType15, SurfaceType16, SurfaceType17, SurfaceType18, SurfaceType19, SurfaceType20, SurfaceType21, SurfaceType22, SurfaceType23, SurfaceType24, SurfaceType25, SurfaceType26, SurfaceType27, SurfaceType28, SurfaceType29, SurfaceType30, SurfaceType31, SurfaceType32, SurfaceType33, SurfaceType34, SurfaceType35, SurfaceType36, SurfaceType37, SurfaceType38, SurfaceType39, SurfaceType40, SurfaceType41, SurfaceType42, SurfaceType43, SurfaceType44, SurfaceType45, SurfaceType46, SurfaceType47, SurfaceType48, SurfaceType49, SurfaceType50, SurfaceType51, SurfaceType52, SurfaceType53, SurfaceType54, SurfaceType55, SurfaceType56, SurfaceType57, SurfaceType58, SurfaceType59, SurfaceType60, SurfaceType61, SurfaceType62, SurfaceType_Max, EPhysicalSurface_MAX}
    class Field extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Field;
        static Load(InName: string): Field;
    }
    
    class Struct extends UE.Field {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Struct;
        static Load(InName: string): Struct;
    }
    
    class Class extends UE.Struct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Class;
        static Load(InName: string): Class;
    }
    
    class DataAsset extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NativeClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DataAsset;
        static Load(InName: string): DataAsset;
    }
    
    class TireType extends UE.DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FrictionScale: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TireType;
        static Load(InName: string): TireType;
    }
    
    class TireFrictionScalePair {
        constructor();
        constructor(TireType: UE.TireType, FrictionScale: number);
        TireType: UE.TireType;
        FrictionScale: number;
        static StaticClass(): Class;
    }
    
    class PhysicalMaterial extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Friction: number;
        FrictionCombineMode: UE.EFrictionCombineMode;
        bOverrideFrictionCombineMode: boolean;
        Restitution: number;
        RestitutionCombineMode: UE.EFrictionCombineMode;
        bOverrideRestitutionCombineMode: boolean;
        Density: number;
        RaiseMassToPower: number;
        DestructibleDamageThresholdScale: number;
        PhysicalMaterialProperty: UE.PhysicalMaterialPropertyBase;
        SurfaceType: UE.EPhysicalSurface;
        TireFrictionScale: number;
        TireFrictionScales: TArray<UE.TireFrictionScalePair>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicalMaterial;
        static Load(InName: string): PhysicalMaterial;
    }
    
    class BodyInstance {
        constructor();
        constructor(ObjectType: UE.ECollisionChannel, CollisionEnabled: UE.ECollisionEnabled, SleepFamily: UE.ESleepFamily, DOFMode: UE.EDOFMode, bUseCCD: boolean, bNotifyRigidBodyCollision: boolean, bSimulatePhysics: boolean, bOverrideMass: boolean, bEnableGravity: boolean, bAutoWeld: boolean, bStartAwake: boolean, bGenerateWakeEvents: boolean, bUpdateMassWhenScaleChanges: boolean, bLockTranslation: boolean, bLockRotation: boolean, bLockXTranslation: boolean, bLockYTranslation: boolean, bLockZTranslation: boolean, bLockXRotation: boolean, bLockYRotation: boolean, bLockZRotation: boolean, bOverrideMaxAngularVelocity: boolean, bOverrideMaxDepenetrationVelocity: boolean, bOverrideWalkableSlopeOnInstance: boolean, bInterpolateWhenSubStepping: boolean, ResponseToChannels: UE.CollisionResponseContainer, CollisionProfileName: string, PositionSolverIterationCount: number, VelocitySolverIterationCount: number, CollisionResponses: UE.CollisionResponse, MaxDepenetrationVelocity: number, MassInKgOverride: number, LinearDamping: number, AngularDamping: number, CustomDOFPlaneNormal: UE.Vector, COMNudge: UE.Vector, MassScale: number, InertiaTensorScale: UE.Vector, WalkableSlopeOverride: UE.WalkableSlopeOverride, PhysMaterialOverride: UE.PhysicalMaterial, MaxAngularVelocity: number, CustomSleepThresholdMultiplier: number, StabilizationThresholdMultiplier: number, PhysicsBlendWeight: number);
        ObjectType: UE.ECollisionChannel;
        CollisionEnabled: UE.ECollisionEnabled;
        SleepFamily: UE.ESleepFamily;
        DOFMode: UE.EDOFMode;
        bUseCCD: boolean;
        bNotifyRigidBodyCollision: boolean;
        bSimulatePhysics: boolean;
        bOverrideMass: boolean;
        bEnableGravity: boolean;
        bAutoWeld: boolean;
        bStartAwake: boolean;
        bGenerateWakeEvents: boolean;
        bUpdateMassWhenScaleChanges: boolean;
        bLockTranslation: boolean;
        bLockRotation: boolean;
        bLockXTranslation: boolean;
        bLockYTranslation: boolean;
        bLockZTranslation: boolean;
        bLockXRotation: boolean;
        bLockYRotation: boolean;
        bLockZRotation: boolean;
        bOverrideMaxAngularVelocity: boolean;
        bOverrideMaxDepenetrationVelocity: boolean;
        bOverrideWalkableSlopeOnInstance: boolean;
        bInterpolateWhenSubStepping: boolean;
        ResponseToChannels: UE.CollisionResponseContainer;
        CollisionProfileName: string;
        PositionSolverIterationCount: number;
        VelocitySolverIterationCount: number;
        CollisionResponses: UE.CollisionResponse;
        MaxDepenetrationVelocity: number;
        MassInKgOverride: number;
        LinearDamping: number;
        AngularDamping: number;
        CustomDOFPlaneNormal: UE.Vector;
        COMNudge: UE.Vector;
        MassScale: number;
        InertiaTensorScale: UE.Vector;
        WalkableSlopeOverride: UE.WalkableSlopeOverride;
        PhysMaterialOverride: UE.PhysicalMaterial;
        MaxAngularVelocity: number;
        CustomSleepThresholdMultiplier: number;
        StabilizationThresholdMultiplier: number;
        PhysicsBlendWeight: number;
        static StaticClass(): Class;
    }
    
    class Vector_NetQuantize extends UE.Vector {
        constructor();
        static StaticClass(): Class;
    }
    
    class Vector_NetQuantizeNormal extends UE.Vector {
        constructor();
        static StaticClass(): Class;
    }
    
    class HitResult {
        constructor();
        constructor(bBlockingHit: boolean, bStartPenetrating: boolean, FaceIndex: number, Time: number, Distance: number, Location: UE.Vector_NetQuantize, ImpactPoint: UE.Vector_NetQuantize, Normal: UE.Vector_NetQuantizeNormal, ImpactNormal: UE.Vector_NetQuantizeNormal, TraceStart: UE.Vector_NetQuantize, TraceEnd: UE.Vector_NetQuantize, PenetrationDepth: number, Item: number, PhysMaterial: TWeakObjectPtr<UE.PhysicalMaterial>, Actor: TWeakObjectPtr<UE.Actor>, Component: TWeakObjectPtr<UE.PrimitiveComponent>, BoneName: string, MyBoneName: string);
        bBlockingHit: boolean;
        bStartPenetrating: boolean;
        FaceIndex: number;
        Time: number;
        Distance: number;
        Location: UE.Vector_NetQuantize;
        ImpactPoint: UE.Vector_NetQuantize;
        Normal: UE.Vector_NetQuantizeNormal;
        ImpactNormal: UE.Vector_NetQuantizeNormal;
        TraceStart: UE.Vector_NetQuantize;
        TraceEnd: UE.Vector_NetQuantize;
        PenetrationDepth: number;
        Item: number;
        PhysMaterial: TWeakObjectPtr<UE.PhysicalMaterial>;
        Actor: TWeakObjectPtr<UE.Actor>;
        Component: TWeakObjectPtr<UE.PrimitiveComponent>;
        BoneName: string;
        MyBoneName: string;
        static StaticClass(): Class;
    }
    
    class Key {
        constructor();
        constructor(KeyName: string);
        KeyName: string;
        static StaticClass(): Class;
    }
    
    enum ETouchIndex { Touch1, Touch2, Touch3, Touch4, Touch5, Touch6, Touch7, Touch8, Touch9, Touch10, CursorPointerIndex, MAX_TOUCHES, ETouchIndex_MAX}
    class SubsurfaceProfileStruct {
        constructor();
        constructor(SurfaceAlbedo: UE.LinearColor, MeanFreePathColor: UE.LinearColor, MeanFreePathDistance: number, WorldUnitScale: number, bEnableBurley: boolean, ScatterRadius: number, SubsurfaceColor: UE.LinearColor, FalloffColor: UE.LinearColor, BoundaryColorBleed: UE.LinearColor, ExtinctionScale: number, NormalScale: number, ScatteringDistribution: number, IOR: number, Roughness0: number, Roughness1: number, LobeMix: number, TransmissionTintColor: UE.LinearColor);
        SurfaceAlbedo: UE.LinearColor;
        MeanFreePathColor: UE.LinearColor;
        MeanFreePathDistance: number;
        WorldUnitScale: number;
        bEnableBurley: boolean;
        ScatterRadius: number;
        SubsurfaceColor: UE.LinearColor;
        FalloffColor: UE.LinearColor;
        BoundaryColorBleed: UE.LinearColor;
        ExtinctionScale: number;
        NormalScale: number;
        ScatteringDistribution: number;
        IOR: number;
        Roughness0: number;
        Roughness1: number;
        LobeMix: number;
        TransmissionTintColor: UE.LinearColor;
        static StaticClass(): Class;
    }
    
    class SubsurfaceProfile extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: UE.SubsurfaceProfileStruct;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubsurfaceProfile;
        static Load(InName: string): SubsurfaceProfile;
    }
    
    class LightmassMaterialInterfaceSettings {
        constructor();
        constructor(EmissiveBoost: number, DiffuseBoost: number, ExportResolutionScale: number, bCastShadowAsMasked: boolean, bOverrideCastShadowAsMasked: boolean, bOverrideEmissiveBoost: boolean, bOverrideDiffuseBoost: boolean, bOverrideExportResolutionScale: boolean);
        EmissiveBoost: number;
        DiffuseBoost: number;
        ExportResolutionScale: number;
        bCastShadowAsMasked: boolean;
        bOverrideCastShadowAsMasked: boolean;
        bOverrideEmissiveBoost: boolean;
        bOverrideDiffuseBoost: boolean;
        bOverrideExportResolutionScale: boolean;
        static StaticClass(): Class;
    }
    
    class SoftObjectPath {
        constructor();
        constructor(AssetPathName: string, SubPathString: string);
        AssetPathName: string;
        SubPathString: string;
        static StaticClass(): Class;
    }
    
    class MaterialTextureInfo {
        constructor();
        constructor(SamplingScale: number, UVChannelIndex: number, TextureName: string, TextureReference: UE.SoftObjectPath, TextureIndex: number);
        SamplingScale: number;
        UVChannelIndex: number;
        TextureName: string;
        TextureReference: UE.SoftObjectPath;
        TextureIndex: number;
        static StaticClass(): Class;
    }
    
    class ThumbnailInfo extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ThumbnailInfo;
        static Load(InName: string): ThumbnailInfo;
    }
    
    enum EEdGraphPinDirection { EGPD_Input, EGPD_Output, EGPD_MAX}
    class EdGraphTerminalType {
        constructor();
        constructor(TerminalCategory: string, TerminalSubCategory: string, TerminalSubCategoryObject: TWeakObjectPtr<UE.Object>, bTerminalIsConst: boolean, bTerminalIsWeakPointer: boolean);
        TerminalCategory: string;
        TerminalSubCategory: string;
        TerminalSubCategoryObject: TWeakObjectPtr<UE.Object>;
        bTerminalIsConst: boolean;
        bTerminalIsWeakPointer: boolean;
        static StaticClass(): Class;
    }
    
    enum EPinContainerType { None, Array, Set, Map, EPinContainerType_MAX}
    class EdGraphPinType {
        constructor();
        constructor(PinCategory: string, PinSubCategory: string, PinSubCategoryObject: TWeakObjectPtr<UE.Object>, PinSubCategoryMemberReference: UE.SimpleMemberReference, PinValueType: UE.EdGraphTerminalType, ContainerType: UE.EPinContainerType, bIsArray: boolean, bIsReference: boolean, bIsConst: boolean, bIsWeakPointer: boolean);
        PinCategory: string;
        PinSubCategory: string;
        PinSubCategoryObject: TWeakObjectPtr<UE.Object>;
        PinSubCategoryMemberReference: UE.SimpleMemberReference;
        PinValueType: UE.EdGraphTerminalType;
        ContainerType: UE.EPinContainerType;
        bIsArray: boolean;
        bIsReference: boolean;
        bIsConst: boolean;
        bIsWeakPointer: boolean;
        static StaticClass(): Class;
    }
    
    class EdGraphPin_Deprecated extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PinName: string;
        PinFriendlyName: string;
        PinToolTip: string;
        Direction: UE.EEdGraphPinDirection;
        PinType: UE.EdGraphPinType;
        DefaultValue: string;
        AutogeneratedDefaultValue: string;
        DefaultObject: UE.Object;
        DefaultTextValue: string;
        LinkedTo: TArray<UE.EdGraphPin_Deprecated>;
        SubPins: TArray<UE.EdGraphPin_Deprecated>;
        ParentPin: UE.EdGraphPin_Deprecated;
        ReferencePassThroughConnection: UE.EdGraphPin_Deprecated;
        bHidden: boolean;
        bNotConnectable: boolean;
        bDefaultValueIsReadOnly: boolean;
        bDefaultValueIsIgnored: boolean;
        bIsDiffing: boolean;
        bAdvancedView: boolean;
        bDisplayAsMutableRef: boolean;
        PersistentGuid: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphPin_Deprecated;
        static Load(InName: string): EdGraphPin_Deprecated;
    }
    
    enum ENodeAdvancedPins { NoPins, Shown, Hidden, ENodeAdvancedPins_MAX}
    enum ENodeEnabledState { Enabled, Disabled, DevelopmentOnly, ENodeEnabledState_MAX}
    class EdGraphNode extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DeprecatedPins: TArray<UE.EdGraphPin_Deprecated>;
        NodePosX: number;
        NodePosY: number;
        NodeWidth: number;
        NodeHeight: number;
        AdvancedPinDisplay: UE.ENodeAdvancedPins;
        EnabledState: UE.ENodeEnabledState;
        bDisplayAsDisabled: boolean;
        bUserSetEnabledState: boolean;
        bIsNodeEnabled: boolean;
        bCanResizeNode: boolean;
        bHasCompilerMessage: boolean;
        bCommentBubblePinned: boolean;
        bCommentBubbleVisible: boolean;
        bCommentBubbleMakeVisible: boolean;
        bCanRenameNode: boolean;
        NodeUpgradeMessage: string;
        NodeComment: string;
        ErrorType: number;
        ErrorMsg: string;
        NodeGuid: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphNode;
        static Load(InName: string): EdGraphNode;
    }
    
    enum EMaterialFunctionUsage { Default, MaterialLayer, MaterialLayerBlend, EMaterialFunctionUsage_MAX}
    class MaterialFunctionInterface extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StateId: UE.Guid;
        MaterialFunctionUsage: UE.EMaterialFunctionUsage;
        CombinedInputTypes: number;
        CombinedOutputTypes: number;
        ThumbnailInfo: UE.ThumbnailInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionInterface;
        static Load(InName: string): MaterialFunctionInterface;
    }
    
    class MaterialExpressionComment extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SizeX: number;
        SizeY: number;
        Text: string;
        CommentColor: UE.LinearColor;
        FontSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionComment;
        static Load(InName: string): MaterialExpressionComment;
    }
    
    class MaterialFunction extends UE.MaterialFunctionInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParentFunction: UE.MaterialFunction;
        Description: string;
        FunctionExpressions: TArray<UE.MaterialExpression>;
        bExposeToLibrary: boolean;
        bPrefixParameterNames: boolean;
        LibraryCategories: TArray<string>;
        LibraryCategoriesText: TArray<string>;
        FunctionEditorComments: TArray<UE.MaterialExpressionComment>;
        PreviewMaterial: UE.Material;
        bReentrantFlag: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunction;
        static Load(InName: string): MaterialFunction;
    }
    
    class ExpressionOutput {
        constructor();
        constructor(OutputName: string, Mask: number, MaskR: number, MaskG: number, MaskB: number, MaskA: number);
        OutputName: string;
        Mask: number;
        MaskR: number;
        MaskG: number;
        MaskB: number;
        MaskA: number;
        static StaticClass(): Class;
    }
    
    class MaterialExpression extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialExpressionEditorX: number;
        MaterialExpressionEditorY: number;
        GraphNode: UE.EdGraphNode;
        MaterialExpressionGuid: UE.Guid;
        Material: UE.Material;
        Function: UE.MaterialFunction;
        Desc: string;
        bRealtimePreview: boolean;
        bNeedToUpdatePreview: boolean;
        bIsParameterExpression: boolean;
        bCommentBubbleVisible: boolean;
        bShowOutputNameOnPin: boolean;
        bShowMaskColorsOnPin: boolean;
        bHidePreviewWindow: boolean;
        bCollapsed: boolean;
        bShaderInputData: boolean;
        bShowInputs: boolean;
        bShowOutputs: boolean;
        MenuCategories: TArray<string>;
        Outputs: TArray<UE.ExpressionOutput>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpression;
        static Load(InName: string): MaterialExpression;
    }
    
    class MaterialInput {
        constructor();
        constructor(Expression: UE.MaterialExpression, OutputIndex: number, InputName: string, Mask: number, MaskR: number, MaskG: number, MaskB: number, MaskA: number, ExpressionName: string);
        Expression: UE.MaterialExpression;
        OutputIndex: number;
        InputName: string;
        Mask: number;
        MaskR: number;
        MaskG: number;
        MaskB: number;
        MaskA: number;
        ExpressionName: string;
        static StaticClass(): Class;
    }
    
    class ColorMaterialInput extends UE.MaterialInput {
        constructor();
        constructor(UseConstant: boolean, Constant: UE.Color);
        UseConstant: boolean;
        Constant: UE.Color;
        static StaticClass(): Class;
    }
    
    class ScalarMaterialInput extends UE.MaterialInput {
        constructor();
        constructor(UseConstant: boolean, Constant: number);
        UseConstant: boolean;
        Constant: number;
        static StaticClass(): Class;
    }
    
    class VectorMaterialInput extends UE.MaterialInput {
        constructor();
        constructor(UseConstant: boolean, Constant: UE.Vector);
        UseConstant: boolean;
        Constant: UE.Vector;
        static StaticClass(): Class;
    }
    
    enum EMaterialDomain { MD_Surface, MD_DeferredDecal, MD_LightFunction, MD_Volume, MD_PostProcess, MD_UI, MD_RuntimeVirtualTexture, MD_MAX}
    enum EBlendMode { BLEND_Opaque, BLEND_Masked, BLEND_Translucent, BLEND_Additive, BLEND_Modulate, BLEND_AlphaComposite, BLEND_AlphaHoldout, BLEND_MAX}
    enum EDecalBlendMode { DBM_Translucent, DBM_Stain, DBM_Normal, DBM_Emissive, DBM_DBuffer_ColorNormalRoughness, DBM_DBuffer_Color, DBM_DBuffer_ColorNormal, DBM_DBuffer_ColorRoughness, DBM_DBuffer_Normal, DBM_DBuffer_NormalRoughness, DBM_DBuffer_Roughness, DBM_DBuffer_Emissive, DBM_DBuffer_AlphaComposite, DBM_DBuffer_EmissiveAlphaComposite, DBM_Volumetric_DistanceFunction, DBM_AlphaComposite, DBM_AmbientOcclusion, DBM_MAX}
    enum EMaterialDecalResponse { MDR_None, MDR_ColorNormalRoughness, MDR_Color, MDR_ColorNormal, MDR_ColorRoughness, MDR_Normal, MDR_NormalRoughness, MDR_Roughness, MDR_MAX}
    enum EMaterialShadingModel { MSM_Unlit, MSM_DefaultLit, MSM_Subsurface, MSM_PreintegratedSkin, MSM_ClearCoat, MSM_SubsurfaceProfile, MSM_TwoSidedFoliage, MSM_Hair, MSM_Cloth, MSM_Eye, MSM_SingleLayerWater, MSM_NUM, MSM_FromMaterialExpression, MSM_MAX}
    class MaterialShadingModelField {
        constructor();
        constructor(ShadingModelField: number);
        ShadingModelField: number;
        static StaticClass(): Class;
    }
    
    class Vector2MaterialInput extends UE.MaterialInput {
        constructor();
        constructor(UseConstant: boolean, ConstantX: number, ConstantY: number);
        UseConstant: boolean;
        ConstantX: number;
        ConstantY: number;
        static StaticClass(): Class;
    }
    
    class ExpressionInput {
        constructor();
        constructor(Expression: UE.MaterialExpression, OutputIndex: number, InputName: string, Mask: number, MaskR: number, MaskG: number, MaskB: number, MaskA: number, ExpressionName: string);
        Expression: UE.MaterialExpression;
        OutputIndex: number;
        InputName: string;
        Mask: number;
        MaskR: number;
        MaskG: number;
        MaskB: number;
        MaskA: number;
        ExpressionName: string;
        static StaticClass(): Class;
    }
    
    class MaterialAttributesInput extends UE.ExpressionInput {
        constructor();
        constructor(PropertyConnectedBitmask: number);
        PropertyConnectedBitmask: number;
        static StaticClass(): Class;
    }
    
    class ShadingModelMaterialInput extends UE.MaterialInput {
        constructor();
        static StaticClass(): Class;
    }
    
    enum ETranslucencyLightingMode { TLM_VolumetricNonDirectional, TLM_VolumetricDirectional, TLM_VolumetricPerVertexNonDirectional, TLM_VolumetricPerVertexDirectional, TLM_Surface, TLM_SurfacePerPixelLighting, TLM_MAX}
    enum EMaterialTessellationMode { MTM_NoTessellation, MTM_FlatTessellation, MTM_PNTriangles, MTM_MAX}
    class ParameterGroupData {
        constructor();
        constructor(GroupName: string, GroupSortPriority: number);
        GroupName: string;
        GroupSortPriority: number;
        static StaticClass(): Class;
    }
    
    class MaterialFunctionInfo {
        constructor();
        constructor(StateId: UE.Guid, Function: UE.MaterialFunctionInterface);
        StateId: UE.Guid;
        Function: UE.MaterialFunctionInterface;
        static StaticClass(): Class;
    }
    
    class CollectionParameterBase {
        constructor();
        constructor(ParameterName: string, Id: UE.Guid);
        ParameterName: string;
        Id: UE.Guid;
        static StaticClass(): Class;
    }
    
    class CollectionScalarParameter extends UE.CollectionParameterBase {
        constructor();
        constructor(DefaultValue: number);
        DefaultValue: number;
        static StaticClass(): Class;
    }
    
    class CollectionVectorParameter extends UE.CollectionParameterBase {
        constructor();
        constructor(DefaultValue: UE.LinearColor);
        DefaultValue: UE.LinearColor;
        static StaticClass(): Class;
    }
    
    class MaterialParameterCollection extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StateId: UE.Guid;
        ScalarParameters: TArray<UE.CollectionScalarParameter>;
        VectorParameters: TArray<UE.CollectionVectorParameter>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialParameterCollection;
        static Load(InName: string): MaterialParameterCollection;
    }
    
    class MaterialParameterCollectionInfo {
        constructor();
        constructor(StateId: UE.Guid, ParameterCollection: UE.MaterialParameterCollection);
        StateId: UE.Guid;
        ParameterCollection: UE.MaterialParameterCollection;
        static StaticClass(): Class;
    }
    
    enum EBlendableLocation { BL_AfterTonemapping, BL_BeforeTonemapping, BL_BeforeTranslucency, BL_ReplacingTonemapper, BL_SSRInput, BL_MAX}
    enum EMaterialStencilCompare { MSC_Less, MSC_LessEqual, MSC_Greater, MSC_GreaterEqual, MSC_Equal, MSC_NotEqual, MSC_Never, MSC_Always, MSC_Count, MSC_MAX}
    enum ERefractionMode { RM_IndexOfRefraction, RM_PixelNormalOffset, RM_MAX}
    class Material extends UE.MaterialInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysMaterial: UE.PhysicalMaterial;
        DiffuseColor: UE.ColorMaterialInput;
        SpecularColor: UE.ColorMaterialInput;
        BaseColor: UE.ColorMaterialInput;
        Metallic: UE.ScalarMaterialInput;
        Specular: UE.ScalarMaterialInput;
        Roughness: UE.ScalarMaterialInput;
        Normal: UE.VectorMaterialInput;
        EmissiveColor: UE.ColorMaterialInput;
        Opacity: UE.ScalarMaterialInput;
        OpacityMask: UE.ScalarMaterialInput;
        MaterialDomain: UE.EMaterialDomain;
        BlendMode: UE.EBlendMode;
        DecalBlendMode: UE.EDecalBlendMode;
        MaterialDecalResponse: UE.EMaterialDecalResponse;
        ShadingModel: UE.EMaterialShadingModel;
        bCastDynamicShadowAsMasked: boolean;
        ShadingModels: UE.MaterialShadingModelField;
        UsedShadingModels: string;
        OpacityMaskClipValue: number;
        WorldPositionOffset: UE.VectorMaterialInput;
        WorldDisplacement: UE.VectorMaterialInput;
        TessellationMultiplier: UE.ScalarMaterialInput;
        SubsurfaceColor: UE.ColorMaterialInput;
        ClearCoat: UE.ScalarMaterialInput;
        ClearCoatRoughness: UE.ScalarMaterialInput;
        AmbientOcclusion: UE.ScalarMaterialInput;
        Refraction: UE.ScalarMaterialInput;
        CustomizedUVs: FixSizeArray<UE.Vector2MaterialInput>;
        MaterialAttributes: UE.MaterialAttributesInput;
        PixelDepthOffset: UE.ScalarMaterialInput;
        ShadingModelFromMaterialExpression: UE.ShadingModelMaterialInput;
        bEnableSeparateTranslucency: boolean;
        bEnableResponsiveAA: boolean;
        bScreenSpaceReflections: boolean;
        bContactShadows: boolean;
        TwoSided: boolean;
        DitheredLODTransition: boolean;
        DitherOpacityMask: boolean;
        bAllowNegativeEmissiveColor: boolean;
        TranslucencyLightingMode: UE.ETranslucencyLightingMode;
        bEnableMobileSeparateTranslucency: boolean;
        NumCustomizedUVs: number;
        TranslucencyDirectionalLightingIntensity: number;
        TranslucentShadowDensityScale: number;
        TranslucentSelfShadowDensityScale: number;
        TranslucentSelfShadowSecondDensityScale: number;
        TranslucentSelfShadowSecondOpacity: number;
        TranslucentBackscatteringExponent: number;
        TranslucentMultipleScatteringExtinction: UE.LinearColor;
        TranslucentShadowStartOffset: number;
        bDisableDepthTest: boolean;
        bWriteOnlyAlpha: boolean;
        bGenerateSphericalParticleNormals: boolean;
        bTangentSpaceNormal: boolean;
        bUseEmissiveForDynamicAreaLighting: boolean;
        bBlockGI: boolean;
        bUsedAsSpecialEngineMaterial: boolean;
        bUsedWithSkeletalMesh: boolean;
        bUsedWithEditorCompositing: boolean;
        bUsedWithParticleSprites: boolean;
        bUsedWithBeamTrails: boolean;
        bUsedWithMeshParticles: boolean;
        bUsedWithNiagaraSprites: boolean;
        bUsedWithNiagaraRibbons: boolean;
        bUsedWithNiagaraMeshParticles: boolean;
        bUsedWithGeometryCache: boolean;
        bUsedWithStaticLighting: boolean;
        bUsedWithMorphTargets: boolean;
        bUsedWithSplineMeshes: boolean;
        bUsedWithInstancedStaticMeshes: boolean;
        bUsedWithGeometryCollections: boolean;
        bUsesDistortion: boolean;
        bUsedWithClothing: boolean;
        bUsedWithWater: boolean;
        bUsedWithHairStrands: boolean;
        bUsedWithUI: boolean;
        bAutomaticallySetUsageInEditor: boolean;
        bFullyRough: boolean;
        bUseFullPrecision: boolean;
        bUseLightmapDirectionality: boolean;
        bUseHQForwardReflections: boolean;
        bUsePlanarForwardReflections: boolean;
        bNormalCurvatureToRoughness: boolean;
        D3D11TessellationMode: UE.EMaterialTessellationMode;
        bEnableCrackFreeDisplacement: boolean;
        bEnableAdaptiveTessellation: boolean;
        AllowTranslucentCustomDepthWrites: boolean;
        Wireframe: boolean;
        bOutputVelocityOnBasePass: boolean;
        EditorX: number;
        EditorY: number;
        EditorPitch: number;
        EditorYaw: number;
        Expressions: TArray<UE.MaterialExpression>;
        EditorComments: TArray<UE.MaterialExpressionComment>;
        ParameterGroupData: TArray<UE.ParameterGroupData>;
        MaterialFunctionInfos: TArray<UE.MaterialFunctionInfo>;
        MaterialParameterCollectionInfos: TArray<UE.MaterialParameterCollectionInfo>;
        bCanMaskedBeAssumedOpaque: boolean;
        bIsMasked: boolean;
        bIsPreviewMaterial: boolean;
        bIsFunctionPreviewMaterial: boolean;
        bUseMaterialAttributes: boolean;
        bCastRayTracedShadows: boolean;
        bUseTranslucencyVertexFog: boolean;
        bIsSky: boolean;
        bComputeFogPerPixel: boolean;
        bOutputTranslucentVelocity: boolean;
        bAllowDevelopmentShaderCompile: boolean;
        bIsMaterialEditorStatsMaterial: boolean;
        BlendableLocation: UE.EBlendableLocation;
        BlendableOutputAlpha: boolean;
        bEnableStencilTest: boolean;
        StencilCompare: UE.EMaterialStencilCompare;
        StencilRefValue: number;
        RefractionMode: UE.ERefractionMode;
        BlendablePriority: number;
        UsageFlagWarnings: number;
        RefractionDepthBias: number;
        StateId: UE.Guid;
        MaxDisplacement: number;
        CachedQualityLevelsUsed: TArray<boolean>;
        ExpressionTextureReferences: TArray<UE.Object>;
        ReferencedTextureGuids: TArray<UE.Guid>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Material;
        static Load(InName: string): Material;
    }
    
    class MaterialInterface extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SubsurfaceProfile: UE.SubsurfaceProfile;
        LightmassSettings: UE.LightmassMaterialInterfaceSettings;
        bTextureStreamingDataSorted: boolean;
        TextureStreamingDataVersion: number;
        TextureStreamingData: TArray<UE.MaterialTextureInfo>;
        AssetUserData: TArray<UE.AssetUserData>;
        TextureStreamingDataMissingEntries: TArray<UE.MaterialTextureInfo>;
        PreviewMesh: UE.SoftObjectPath;
        ThumbnailInfo: UE.ThumbnailInfo;
        LayerParameterExpansion: TMap<string, boolean>;
        ParameterOverviewExpansion: TMap<string, boolean>;
        AssetImportData: UE.AssetImportData;
        LightingGuid: UE.Guid;
        GetBaseMaterial() : UE.Material;
        GetPhysicalMaterial() : UE.PhysicalMaterial;
        SetForceMipLevelsToBeResident(OverrideForceMiplevelsToBeResident: boolean, bForceMiplevelsToBeResidentValue: boolean, ForceDuration: number, CinematicTextureGroups?: number /* = 0 */, bFastResponse?: boolean /* = false */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialInterface;
        static Load(InName: string): MaterialInterface;
    }
    
    class Box {
        constructor();
        constructor(Min: UE.Vector, Max: UE.Vector, IsValid: number);
        Min: UE.Vector;
        Max: UE.Vector;
        IsValid: number;
        static StaticClass(): Class;
    }
    
    class CurveBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssetImportData: UE.AssetImportData;
        ImportPath: string;
        GetTimeRange(MinTime: $Ref<number>, MaxTime: $Ref<number>) : void;
        GetValueRange(MinValue: $Ref<number>, MaxValue: $Ref<number>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveBase;
        static Load(InName: string): CurveBase;
    }
    
    class KeyHandleMap {
        constructor();
        static StaticClass(): Class;
    }
    
    class IndexedCurve {
        constructor();
        constructor(KeyHandlesToIndices: UE.KeyHandleMap);
        KeyHandlesToIndices: UE.KeyHandleMap;
        static StaticClass(): Class;
    }
    
    enum ERichCurveExtrapolation { RCCE_Cycle, RCCE_CycleWithOffset, RCCE_Oscillate, RCCE_Linear, RCCE_Constant, RCCE_None, RCCE_MAX}
    class RealCurve extends UE.IndexedCurve {
        constructor();
        constructor(DefaultValue: number, PreInfinityExtrap: UE.ERichCurveExtrapolation, PostInfinityExtrap: UE.ERichCurveExtrapolation);
        DefaultValue: number;
        PreInfinityExtrap: UE.ERichCurveExtrapolation;
        PostInfinityExtrap: UE.ERichCurveExtrapolation;
        static StaticClass(): Class;
    }
    
    enum ERichCurveInterpMode { RCIM_Linear, RCIM_Constant, RCIM_Cubic, RCIM_None, RCIM_MAX}
    enum ERichCurveTangentMode { RCTM_Auto, RCTM_User, RCTM_Break, RCTM_None, RCTM_MAX}
    enum ERichCurveTangentWeightMode { RCTWM_WeightedNone, RCTWM_WeightedArrive, RCTWM_WeightedLeave, RCTWM_WeightedBoth, RCTWM_MAX}
    class RichCurveKey {
        constructor();
        constructor(InterpMode: UE.ERichCurveInterpMode, TangentMode: UE.ERichCurveTangentMode, TangentWeightMode: UE.ERichCurveTangentWeightMode, Time: number, Value: number, ArriveTangent: number, ArriveTangentWeight: number, LeaveTangent: number, LeaveTangentWeight: number);
        InterpMode: UE.ERichCurveInterpMode;
        TangentMode: UE.ERichCurveTangentMode;
        TangentWeightMode: UE.ERichCurveTangentWeightMode;
        Time: number;
        Value: number;
        ArriveTangent: number;
        ArriveTangentWeight: number;
        LeaveTangent: number;
        LeaveTangentWeight: number;
        static StaticClass(): Class;
    }
    
    class RichCurve extends UE.RealCurve {
        constructor();
        constructor(Keys: TArray<UE.RichCurveKey>);
        Keys: TArray<UE.RichCurveKey>;
        static StaticClass(): Class;
    }
    
    class CurveLinearColor extends UE.CurveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FloatCurves: FixSizeArray<UE.RichCurve>;
        AdjustHue: number;
        AdjustSaturation: number;
        AdjustBrightness: number;
        AdjustBrightnessCurve: number;
        AdjustVibrance: number;
        AdjustMinAlpha: number;
        AdjustMaxAlpha: number;
        GetClampedLinearColorValue(InTime: number) : UE.LinearColor;
        GetLinearColorValue(InTime: number) : UE.LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveLinearColor;
        static Load(InName: string): CurveLinearColor;
    }
    
    class CurveLinearColorAtlas extends UE.Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsDirty: boolean;
        TextureSize: number;
        GradientCurves: TArray<UE.CurveLinearColor>;
        GetCurvePosition(InCurve: $Nullable<UE.CurveLinearColor>, Position: $Ref<number>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveLinearColorAtlas;
        static Load(InName: string): CurveLinearColorAtlas;
    }
    
    class ScalarParameterAtlasInstanceData {
        constructor();
        constructor(bIsUsedAsAtlasPosition: boolean, Curve: TSoftObjectPtr<UE.CurveLinearColor>, Atlas: TSoftObjectPtr<UE.CurveLinearColorAtlas>);
        bIsUsedAsAtlasPosition: boolean;
        Curve: TSoftObjectPtr<UE.CurveLinearColor>;
        Atlas: TSoftObjectPtr<UE.CurveLinearColorAtlas>;
        static StaticClass(): Class;
    }
    
    enum EMaterialParameterAssociation { LayerParameter, BlendParameter, GlobalParameter, EMaterialParameterAssociation_MAX}
    class MaterialParameterInfo {
        constructor();
        constructor(Name: string, Association: UE.EMaterialParameterAssociation, Index: number, ParameterLocation: UE.SoftObjectPath);
        Name: string;
        Association: UE.EMaterialParameterAssociation;
        Index: number;
        ParameterLocation: UE.SoftObjectPath;
        static StaticClass(): Class;
    }
    
    class ScalarParameterValue {
        constructor();
        constructor(ParameterName: string, AtlasData: UE.ScalarParameterAtlasInstanceData, ParameterInfo: UE.MaterialParameterInfo, ParameterValue: number, ExpressionGUID: UE.Guid);
        ParameterName: string;
        AtlasData: UE.ScalarParameterAtlasInstanceData;
        ParameterInfo: UE.MaterialParameterInfo;
        ParameterValue: number;
        ExpressionGUID: UE.Guid;
        static StaticClass(): Class;
    }
    
    class VectorParameterValue {
        constructor();
        constructor(ParameterName: string, ParameterInfo: UE.MaterialParameterInfo, ParameterValue: UE.LinearColor, ExpressionGUID: UE.Guid);
        ParameterName: string;
        ParameterInfo: UE.MaterialParameterInfo;
        ParameterValue: UE.LinearColor;
        ExpressionGUID: UE.Guid;
        static StaticClass(): Class;
    }
    
    class TextureParameterValue {
        constructor();
        constructor(ParameterName: string, ParameterInfo: UE.MaterialParameterInfo, ParameterValue: UE.Texture, ExpressionGUID: UE.Guid);
        ParameterName: string;
        ParameterInfo: UE.MaterialParameterInfo;
        ParameterValue: UE.Texture;
        ExpressionGUID: UE.Guid;
        static StaticClass(): Class;
    }
    
    class RuntimeVirtualTextureParameterValue {
        constructor();
        constructor(ParameterInfo: UE.MaterialParameterInfo, ParameterValue: UE.RuntimeVirtualTexture, ExpressionGUID: UE.Guid);
        ParameterInfo: UE.MaterialParameterInfo;
        ParameterValue: UE.RuntimeVirtualTexture;
        ExpressionGUID: UE.Guid;
        static StaticClass(): Class;
    }
    
    enum EFontCacheType { Offline, Runtime, EFontCacheType_MAX}
    class FontCharacter {
        constructor();
        constructor(StartU: number, StartV: number, USize: number, VSize: number, TextureIndex: number, VerticalOffset: number);
        StartU: number;
        StartV: number;
        USize: number;
        VSize: number;
        TextureIndex: number;
        VerticalOffset: number;
        static StaticClass(): Class;
    }
    
    enum EFontImportCharacterSet { FontICS_Default, FontICS_Ansi, FontICS_Symbol, FontICS_MAX}
    class FontImportOptionsData {
        constructor();
        constructor(FontName: string, Height: number, bEnableAntialiasing: boolean, bEnableBold: boolean, bEnableItalic: boolean, bEnableUnderline: boolean, bAlphaOnly: boolean, CharacterSet: UE.EFontImportCharacterSet, Chars: string, UnicodeRange: string, CharsFilePath: string, CharsFileWildcard: string, bCreatePrintableOnly: boolean, bIncludeASCIIRange: boolean, ForegroundColor: UE.LinearColor, bEnableDropShadow: boolean, TexturePageWidth: number, TexturePageMaxHeight: number, XPadding: number, YPadding: number, ExtendBoxTop: number, ExtendBoxBottom: number, ExtendBoxRight: number, ExtendBoxLeft: number, bEnableLegacyMode: boolean, Kerning: number, bUseDistanceFieldAlpha: boolean, DistanceFieldScaleFactor: number, DistanceFieldScanRadiusScale: number);
        FontName: string;
        Height: number;
        bEnableAntialiasing: boolean;
        bEnableBold: boolean;
        bEnableItalic: boolean;
        bEnableUnderline: boolean;
        bAlphaOnly: boolean;
        CharacterSet: UE.EFontImportCharacterSet;
        Chars: string;
        UnicodeRange: string;
        CharsFilePath: string;
        CharsFileWildcard: string;
        bCreatePrintableOnly: boolean;
        bIncludeASCIIRange: boolean;
        ForegroundColor: UE.LinearColor;
        bEnableDropShadow: boolean;
        TexturePageWidth: number;
        TexturePageMaxHeight: number;
        XPadding: number;
        YPadding: number;
        ExtendBoxTop: number;
        ExtendBoxBottom: number;
        ExtendBoxRight: number;
        ExtendBoxLeft: number;
        bEnableLegacyMode: boolean;
        Kerning: number;
        bUseDistanceFieldAlpha: boolean;
        DistanceFieldScaleFactor: number;
        DistanceFieldScanRadiusScale: number;
        static StaticClass(): Class;
    }
    
    enum EFontHinting { Default, Auto, AutoLight, Monochrome, None, EFontHinting_MAX}
    enum EFontLoadingPolicy { LazyLoad, Stream, Inline, EFontLoadingPolicy_MAX}
    class FontBulkData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FontBulkData;
        static Load(InName: string): FontBulkData;
    }
    
    class FontData {
        constructor();
        constructor(FontFilename: string, Hinting: UE.EFontHinting, LoadingPolicy: UE.EFontLoadingPolicy, SubFaceIndex: number, FontFaceAsset: UE.Object, BulkDataPtr: UE.FontBulkData, FontData: TArray<number>);
        FontFilename: string;
        Hinting: UE.EFontHinting;
        LoadingPolicy: UE.EFontLoadingPolicy;
        SubFaceIndex: number;
        FontFaceAsset: UE.Object;
        BulkDataPtr: UE.FontBulkData;
        FontData: TArray<number>;
        static StaticClass(): Class;
    }
    
    class TypefaceEntry {
        constructor();
        constructor(Name: string, Font: UE.FontData);
        Name: string;
        Font: UE.FontData;
        static StaticClass(): Class;
    }
    
    class Typeface {
        constructor();
        constructor(Fonts: TArray<UE.TypefaceEntry>);
        Fonts: TArray<UE.TypefaceEntry>;
        static StaticClass(): Class;
    }
    
    class CompositeFallbackFont {
        constructor();
        constructor(Typeface: UE.Typeface, ScalingFactor: number);
        Typeface: UE.Typeface;
        ScalingFactor: number;
        static StaticClass(): Class;
    }
    
    enum ERangeBoundTypes { Exclusive, Inclusive, Open, ERangeBoundTypes_MAX}
    class Int32RangeBound {
        constructor();
        constructor(Type: UE.ERangeBoundTypes, Value: number);
        Type: UE.ERangeBoundTypes;
        Value: number;
        static StaticClass(): Class;
    }
    
    class Int32Range {
        constructor();
        constructor(LowerBound: UE.Int32RangeBound, UpperBound: UE.Int32RangeBound);
        LowerBound: UE.Int32RangeBound;
        UpperBound: UE.Int32RangeBound;
        static StaticClass(): Class;
    }
    
    class CompositeSubFont extends UE.CompositeFallbackFont {
        constructor();
        constructor(CharacterRanges: TArray<UE.Int32Range>, Cultures: string, EditorName: string);
        CharacterRanges: TArray<UE.Int32Range>;
        Cultures: string;
        EditorName: string;
        static StaticClass(): Class;
    }
    
    class CompositeFont {
        constructor();
        constructor(DefaultTypeface: UE.Typeface, FallbackTypeface: UE.CompositeFallbackFont, SubTypefaces: TArray<UE.CompositeSubFont>);
        DefaultTypeface: UE.Typeface;
        FallbackTypeface: UE.CompositeFallbackFont;
        SubTypefaces: TArray<UE.CompositeSubFont>;
        static StaticClass(): Class;
    }
    
    class Font extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FontCacheType: UE.EFontCacheType;
        Characters: TArray<UE.FontCharacter>;
        Textures: TArray<UE.Texture2D>;
        IsRemapped: number;
        EmScale: number;
        Ascent: number;
        Descent: number;
        Leading: number;
        Kerning: number;
        ImportOptions: UE.FontImportOptionsData;
        NumCharacters: number;
        MaxCharHeight: TArray<number>;
        ScalingFactor: number;
        LegacyFontSize: number;
        LegacyFontName: string;
        CompositeFont: UE.CompositeFont;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Font;
        static Load(InName: string): Font;
    }
    
    class FontParameterValue {
        constructor();
        constructor(ParameterName: string, ParameterInfo: UE.MaterialParameterInfo, FontValue: UE.Font, FontPage: number, ExpressionGUID: UE.Guid);
        ParameterName: string;
        ParameterInfo: UE.MaterialParameterInfo;
        FontValue: UE.Font;
        FontPage: number;
        ExpressionGUID: UE.Guid;
        static StaticClass(): Class;
    }
    
    class MaterialInstanceBasePropertyOverrides {
        constructor();
        constructor(bOverride_OpacityMaskClipValue: boolean, bOverride_BlendMode: boolean, bOverride_ShadingModel: boolean, bOverride_DitheredLODTransition: boolean, bOverride_CastDynamicShadowAsMasked: boolean, bOverride_TwoSided: boolean, TwoSided: boolean, DitheredLODTransition: boolean, bCastDynamicShadowAsMasked: boolean, BlendMode: UE.EBlendMode, ShadingModel: UE.EMaterialShadingModel, OpacityMaskClipValue: number);
        bOverride_OpacityMaskClipValue: boolean;
        bOverride_BlendMode: boolean;
        bOverride_ShadingModel: boolean;
        bOverride_DitheredLODTransition: boolean;
        bOverride_CastDynamicShadowAsMasked: boolean;
        bOverride_TwoSided: boolean;
        TwoSided: boolean;
        DitheredLODTransition: boolean;
        bCastDynamicShadowAsMasked: boolean;
        BlendMode: UE.EBlendMode;
        ShadingModel: UE.EMaterialShadingModel;
        OpacityMaskClipValue: number;
        static StaticClass(): Class;
    }
    
    class StaticParameterBase {
        constructor();
        constructor(ParameterInfo: UE.MaterialParameterInfo, bOverride: boolean, ExpressionGUID: UE.Guid);
        ParameterInfo: UE.MaterialParameterInfo;
        bOverride: boolean;
        ExpressionGUID: UE.Guid;
        static StaticClass(): Class;
    }
    
    class StaticSwitchParameter extends UE.StaticParameterBase {
        constructor();
        constructor(Value: boolean);
        Value: boolean;
        static StaticClass(): Class;
    }
    
    class StaticComponentMaskParameter extends UE.StaticParameterBase {
        constructor();
        constructor(R: boolean, G: boolean, B: boolean, A: boolean);
        R: boolean;
        G: boolean;
        B: boolean;
        A: boolean;
        static StaticClass(): Class;
    }
    
    class StaticTerrainLayerWeightParameter extends UE.StaticParameterBase {
        constructor();
        constructor(WeightmapIndex: number, bWeightBasedBlend: boolean);
        WeightmapIndex: number;
        bWeightBasedBlend: boolean;
        static StaticClass(): Class;
    }
    
    class MaterialLayersFunctions {
        constructor();
        constructor(Layers: TArray<UE.MaterialFunctionInterface>, Blends: TArray<UE.MaterialFunctionInterface>, LayerNames: TArray<string>, RestrictToLayerRelatives: TArray<boolean>, RestrictToBlendRelatives: TArray<boolean>, LayerStates: TArray<boolean>, KeyString: string);
        Layers: TArray<UE.MaterialFunctionInterface>;
        Blends: TArray<UE.MaterialFunctionInterface>;
        LayerNames: TArray<string>;
        RestrictToLayerRelatives: TArray<boolean>;
        RestrictToBlendRelatives: TArray<boolean>;
        LayerStates: TArray<boolean>;
        KeyString: string;
        static StaticClass(): Class;
    }
    
    class StaticMaterialLayersParameter extends UE.StaticParameterBase {
        constructor();
        constructor(Value: UE.MaterialLayersFunctions);
        Value: UE.MaterialLayersFunctions;
        static StaticClass(): Class;
    }
    
    class StaticParameterSet {
        constructor();
        constructor(StaticSwitchParameters: TArray<UE.StaticSwitchParameter>, StaticComponentMaskParameters: TArray<UE.StaticComponentMaskParameter>, TerrainLayerWeightParameters: TArray<UE.StaticTerrainLayerWeightParameter>, MaterialLayersParameters: TArray<UE.StaticMaterialLayersParameter>);
        StaticSwitchParameters: TArray<UE.StaticSwitchParameter>;
        StaticComponentMaskParameters: TArray<UE.StaticComponentMaskParameter>;
        TerrainLayerWeightParameters: TArray<UE.StaticTerrainLayerWeightParameter>;
        MaterialLayersParameters: TArray<UE.StaticMaterialLayersParameter>;
        static StaticClass(): Class;
    }
    
    class MaterialInstance extends UE.MaterialInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysMaterial: UE.PhysicalMaterial;
        Parent: UE.MaterialInterface;
        bHasStaticPermutationResource: boolean;
        bOverrideSubsurfaceProfile: boolean;
        ScalarParameterValues: TArray<UE.ScalarParameterValue>;
        VectorParameterValues: TArray<UE.VectorParameterValue>;
        TextureParameterValues: TArray<UE.TextureParameterValue>;
        RuntimeVirtualTextureParameterValues: TArray<UE.RuntimeVirtualTextureParameterValue>;
        FontParameterValues: TArray<UE.FontParameterValue>;
        bOverrideBaseProperties: boolean;
        BasePropertyOverrides: UE.MaterialInstanceBasePropertyOverrides;
        PermutationTextureReferences: TArray<UE.Object>;
        ReferencedTextureGuids: TArray<UE.Guid>;
        StaticParameters: UE.StaticParameterSet;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialInstance;
        static Load(InName: string): MaterialInstance;
    }
    
    class MaterialInstanceDynamic extends UE.MaterialInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CopyInterpParameters(Source: $Nullable<UE.MaterialInstance>) : void;
        CopyParameterOverrides(MaterialInstance: $Nullable<UE.MaterialInstance>) : void;
        K2_CopyMaterialInstanceParameters(Source: $Nullable<UE.MaterialInterface>, bQuickParametersOnly?: boolean /* = false */) : void;
        K2_GetScalarParameterValue(ParameterName: string) : number;
        K2_GetTextureParameterValue(ParameterName: string) : UE.Texture;
        K2_GetVectorParameterValue(ParameterName: string) : UE.LinearColor;
        K2_InterpolateMaterialInstanceParams(SourceA: $Nullable<UE.MaterialInstance>, SourceB: $Nullable<UE.MaterialInstance>, Alpha: number) : void;
        SetScalarParameterValue(ParameterName: string, Value: number) : void;
        SetTextureParameterValue(ParameterName: string, Value: $Nullable<UE.Texture>) : void;
        SetVectorParameterValue(ParameterName: string, Value: UE.LinearColor) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialInstanceDynamic;
        static Load(InName: string): MaterialInstanceDynamic;
    }
    
    enum EAutoReceiveInput { Disabled, Player0, Player1, Player2, Player3, Player4, Player5, Player6, Player7, EAutoReceiveInput_MAX}
    enum EAutoPossessAI { Disabled, PlacedInWorld, Spawned, PlacedInWorldOrSpawned, EAutoPossessAI_MAX}
    class SpriteCategoryInfo {
        constructor();
        constructor(Category: string, DisplayName: string, Description: string);
        Category: string;
        DisplayName: string;
        Description: string;
        static StaticClass(): Class;
    }
    
    class BillboardComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sprite: UE.Texture2D;
        bIsScreenSizeScaled: boolean;
        ScreenSize: number;
        U: number;
        UL: number;
        V: number;
        VL: number;
        SpriteCategoryName: string;
        SpriteInfo: UE.SpriteCategoryInfo;
        bUseInEditorScaling: boolean;
        SetSprite(NewSprite: $Nullable<UE.Texture2D>) : void;
        SetSpriteAndUV(NewSprite: $Nullable<UE.Texture2D>, NewU: number, NewUL: number, NewV: number, NewVL: number) : void;
        SetUV(NewU: number, NewUL: number, NewV: number, NewVL: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BillboardComponent;
        static Load(InName: string): BillboardComponent;
    }
    
    class Info extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpriteComponent: UE.BillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Info;
        static Load(InName: string): Info;
    }
    
    class UniqueNetIdWrapper {
        constructor();
        static StaticClass(): Class;
    }
    
    class UniqueNetIdRepl extends UE.UniqueNetIdWrapper {
        constructor();
        constructor(ReplicationBytes: TArray<number>);
        ReplicationBytes: TArray<number>;
        static StaticClass(): Class;
    }
    
    class PlayerState extends UE.Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Score: number;
        PlayerName: string;
        PlayerId: number;
        Ping: number;
        bShouldUpdateReplicatedPing: boolean;
        bIsSpectator: boolean;
        bOnlySpectator: boolean;
        bIsABot: boolean;
        bIsInactive: boolean;
        bFromPreviousLevel: boolean;
        StartTime: number;
        EngineMessageClass: UE.Class;
        SavedNetworkAddress: string;
        UniqueId: UE.UniqueNetIdRepl;
        PawnPrivate: UE.Pawn;
        PlayerNamePrivate: string;
        GetPlayerName() : string;
        OnRep_bIsInactive() : void;
        OnRep_PlayerId() : void;
        OnRep_PlayerName() : void;
        OnRep_Score() : void;
        OnRep_UniqueId() : void;
        ReceiveCopyProperties(NewPlayerState: $Nullable<UE.PlayerState>) : void;
        ReceiveOverrideWith(OldPlayerState: $Nullable<UE.PlayerState>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlayerState;
        static Load(InName: string): PlayerState;
    }
    
    class DamageType extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCausedByWorld: boolean;
        bScaleMomentumByMass: boolean;
        bRadialDamageVelChange: boolean;
        DamageImpulse: number;
        DestructibleImpulse: number;
        DestructibleDamageSpreadScale: number;
        DamageFalloff: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DamageType;
        static Load(InName: string): DamageType;
    }
    
    class MeshComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OverrideMaterials: TArray<UE.MaterialInterface>;
        bEnableMaterialParameterCaching: boolean;
        GetMaterialIndex(MaterialSlotName: string) : number;
        GetMaterials() : TArray<UE.MaterialInterface>;
        GetMaterialSlotNames() : TArray<string>;
        IsMaterialSlotNameValid(MaterialSlotName: string) : boolean;
        PrestreamTextures(Seconds: number, bPrioritizeCharacterTextures: boolean, CinematicTextureGroups?: number /* = 0 */) : void;
        SetScalarParameterValueOnMaterials(ParameterName: string, ParameterValue: number) : void;
        SetVectorParameterValueOnMaterials(ParameterName: string, ParameterValue: UE.Vector) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshComponent;
        static Load(InName: string): MeshComponent;
    }
    
    enum EBoneTranslationRetargetingMode { Animation, Skeleton, AnimationScaled, AnimationRelative, OrientAndScale, EBoneTranslationRetargetingMode_MAX}
    class BoneNode {
        constructor();
        constructor(Name: string, ParentIndex: number, TranslationRetargetingMode: UE.EBoneTranslationRetargetingMode);
        Name: string;
        ParentIndex: number;
        TranslationRetargetingMode: UE.EBoneTranslationRetargetingMode;
        static StaticClass(): Class;
    }
    
    class VirtualBone {
        constructor();
        constructor(SourceBoneName: string, TargetBoneName: string, VirtualBoneName: string);
        SourceBoneName: string;
        TargetBoneName: string;
        VirtualBoneName: string;
        static StaticClass(): Class;
    }
    
    class SkeletalMeshSocket extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SocketName: string;
        BoneName: string;
        RelativeLocation: UE.Vector;
        RelativeRotation: UE.Rotator;
        RelativeScale: UE.Vector;
        bForceAlwaysAnimated: boolean;
        GetSocketLocation(SkelComp: $Nullable<UE.SkeletalMeshComponent>) : UE.Vector;
        InitializeSocketFromLocation(SkelComp: $Nullable<UE.SkeletalMeshComponent>, WorldLocation: UE.Vector, WorldNormal: UE.Vector) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshSocket;
        static Load(InName: string): SkeletalMeshSocket;
    }
    
    class SmartNameContainer {
        constructor();
        static StaticClass(): Class;
    }
    
    class BoneReference {
        constructor();
        constructor(BoneName: string);
        BoneName: string;
        static StaticClass(): Class;
    }
    
    class BlendProfileBoneEntry {
        constructor();
        constructor(BoneReference: UE.BoneReference, BlendScale: number);
        BoneReference: UE.BoneReference;
        BlendScale: number;
        static StaticClass(): Class;
    }
    
    class BlendProfile extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OwningSkeleton: UE.Skeleton;
        ProfileEntries: TArray<UE.BlendProfileBoneEntry>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlendProfile;
        static Load(InName: string): BlendProfile;
    }
    
    class AnimSlotGroup {
        constructor();
        constructor(GroupName: string, SlotNames: TArray<string>);
        GroupName: string;
        SlotNames: TArray<string>;
        static StaticClass(): Class;
    }
    
    enum EConstraintTransform { Absolute, Relative, EConstraintTransform_MAX}
    class RigTransformConstraint {
        constructor();
        constructor(TranformType: UE.EConstraintTransform, ParentSpace: string, Weight: number);
        TranformType: UE.EConstraintTransform;
        ParentSpace: string;
        Weight: number;
        static StaticClass(): Class;
    }
    
    class TransformBaseConstraint {
        constructor();
        constructor(TransformConstraints: TArray<UE.RigTransformConstraint>);
        TransformConstraints: TArray<UE.RigTransformConstraint>;
        static StaticClass(): Class;
    }
    
    class TransformBase {
        constructor();
        constructor(Node: string, Constraints: FixSizeArray<UE.TransformBaseConstraint>);
        Node: string;
        Constraints: FixSizeArray<UE.TransformBaseConstraint>;
        static StaticClass(): Class;
    }
    
    class Node {
        constructor();
        constructor(Name: string, ParentName: string, Transform: UE.Transform, DisplayName: string, bAdvanced: boolean);
        Name: string;
        ParentName: string;
        Transform: UE.Transform;
        DisplayName: string;
        bAdvanced: boolean;
        static StaticClass(): Class;
    }
    
    class Rig extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TransformBases: TArray<UE.TransformBase>;
        Nodes: TArray<UE.Node>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Rig;
        static Load(InName: string): Rig;
    }
    
    class NameMapping {
        constructor();
        constructor(NodeName: string, BoneName: string);
        NodeName: string;
        BoneName: string;
        static StaticClass(): Class;
    }
    
    class RigConfiguration {
        constructor();
        constructor(Rig: UE.Rig, BoneMappingTable: TArray<UE.NameMapping>);
        Rig: UE.Rig;
        BoneMappingTable: TArray<UE.NameMapping>;
        static StaticClass(): Class;
    }
    
    class PreviewAttachedObjectPair {
        constructor();
        constructor(AttachedObject: TSoftObjectPtr<UE.Object>, Object: UE.Object, AttachedTo: string);
        AttachedObject: TSoftObjectPtr<UE.Object>;
        Object: UE.Object;
        AttachedTo: string;
        static StaticClass(): Class;
    }
    
    class PreviewAssetAttachContainer {
        constructor();
        constructor(AttachedObjects: TArray<UE.PreviewAttachedObjectPair>);
        AttachedObjects: TArray<UE.PreviewAttachedObjectPair>;
        static StaticClass(): Class;
    }
    
    class Skeleton extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoneTree: TArray<UE.BoneNode>;
        RefLocalPoses: TArray<UE.Transform>;
        VirtualBoneGuid: UE.Guid;
        VirtualBones: TArray<UE.VirtualBone>;
        Sockets: TArray<UE.SkeletalMeshSocket>;
        SmartNames: UE.SmartNameContainer;
        BlendProfiles: TArray<UE.BlendProfile>;
        SlotGroups: TArray<UE.AnimSlotGroup>;
        PreviewSkeletalMesh: TSoftObjectPtr<UE.SkeletalMesh>;
        AdditionalPreviewSkeletalMeshes: TSoftObjectPtr<UE.DataAsset>;
        RigConfig: UE.RigConfiguration;
        AnimationNotifies: TArray<string>;
        PreviewAttachedAssetContainer: UE.PreviewAssetAttachContainer;
        AssetUserData: TArray<UE.AssetUserData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Skeleton;
        static Load(InName: string): Skeleton;
    }
    
    class BoxSphereBounds {
        constructor();
        constructor(Origin: UE.Vector, BoxExtent: UE.Vector, SphereRadius: number);
        Origin: UE.Vector;
        BoxExtent: UE.Vector;
        SphereRadius: number;
        static StaticClass(): Class;
    }
    
    class MeshUVChannelInfo {
        constructor();
        constructor(bInitialized: boolean, bOverrideDensities: boolean, LocalUVDensities: FixSizeArray<number>);
        bInitialized: boolean;
        bOverrideDensities: boolean;
        LocalUVDensities: FixSizeArray<number>;
        static StaticClass(): Class;
    }
    
    class SkeletalMaterial {
        constructor();
        constructor(MaterialInterface: UE.MaterialInterface, MaterialSlotName: string, bEnableShadowCasting: boolean, bRecomputeTangent: boolean, ImportedMaterialSlotName: string, UVChannelData: UE.MeshUVChannelInfo);
        MaterialInterface: UE.MaterialInterface;
        MaterialSlotName: string;
        bEnableShadowCasting: boolean;
        bRecomputeTangent: boolean;
        ImportedMaterialSlotName: string;
        UVChannelData: UE.MeshUVChannelInfo;
        static StaticClass(): Class;
    }
    
    enum EAxis { None, X, Y, Z, EAxis_MAX}
    class BoneMirrorInfo {
        constructor();
        constructor(SourceIndex: number, BoneFlipAxis: UE.EAxis);
        SourceIndex: number;
        BoneFlipAxis: UE.EAxis;
        static StaticClass(): Class;
    }
    
    class PerPlatformFloat {
        constructor();
        constructor(Default: number, PerPlatform: TMap<string, number>);
        Default: number;
        PerPlatform: TMap<string, number>;
        static StaticClass(): Class;
    }
    
    class SkeletalMeshBuildSettings {
        constructor();
        constructor(bRecomputeNormals: boolean, bRecomputeTangents: boolean, bUseMikkTSpace: boolean, bComputeWeightedNormals: boolean, bRemoveDegenerates: boolean, bUseHighPrecisionTangentBasis: boolean, bUseFullPrecisionUVs: boolean, bBuildAdjacencyBuffer: boolean, ThresholdPosition: number, ThresholdTangentNormal: number, ThresholdUV: number);
        bRecomputeNormals: boolean;
        bRecomputeTangents: boolean;
        bUseMikkTSpace: boolean;
        bComputeWeightedNormals: boolean;
        bRemoveDegenerates: boolean;
        bUseHighPrecisionTangentBasis: boolean;
        bUseFullPrecisionUVs: boolean;
        bBuildAdjacencyBuffer: boolean;
        ThresholdPosition: number;
        ThresholdTangentNormal: number;
        ThresholdUV: number;
        static StaticClass(): Class;
    }
    
    enum SkeletalMeshTerminationCriterion { SMTC_NumOfTriangles, SMTC_NumOfVerts, SMTC_TriangleOrVert, SMTC_AbsNumOfTriangles, SMTC_AbsNumOfVerts, SMTC_AbsTriangleOrVert, SMTC_MAX}
    enum SkeletalMeshOptimizationType { SMOT_NumOfTriangles, SMOT_MaxDeviation, SMOT_TriangleOrDeviation, SMOT_MAX}
    enum SkeletalMeshOptimizationImportance { SMOI_Off, SMOI_Lowest, SMOI_Low, SMOI_Normal, SMOI_High, SMOI_Highest, SMOI_MAX}
    class AnimMetaData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimMetaData;
        static Load(InName: string): AnimMetaData;
    }
    
    class AssetMapping {
        constructor();
        constructor(SourceAsset: UE.AnimationAsset, TargetAsset: UE.AnimationAsset);
        SourceAsset: UE.AnimationAsset;
        TargetAsset: UE.AnimationAsset;
        static StaticClass(): Class;
    }
    
    class AssetMappingTable extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MappedAssets: TArray<UE.AssetMapping>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetMappingTable;
        static Load(InName: string): AssetMappingTable;
    }
    
    class SmartName {
        constructor();
        constructor(DisplayName: string);
        DisplayName: string;
        static StaticClass(): Class;
    }
    
    class PoseData {
        constructor();
        constructor(SourceLocalSpacePose: TArray<UE.Transform>, SourceCurveData: TArray<number>, LocalSpacePose: TArray<UE.Transform>, TrackToBufferIndex: TMap<number, number>, CurveData: TArray<number>);
        SourceLocalSpacePose: TArray<UE.Transform>;
        SourceCurveData: TArray<number>;
        LocalSpacePose: TArray<UE.Transform>;
        TrackToBufferIndex: TMap<number, number>;
        CurveData: TArray<number>;
        static StaticClass(): Class;
    }
    
    class AnimCurveBase {
        constructor();
        constructor(LastObservedName: string, Name: UE.SmartName, CurveTypeFlags: number);
        LastObservedName: string;
        Name: UE.SmartName;
        CurveTypeFlags: number;
        static StaticClass(): Class;
    }
    
    class PoseDataContainer {
        constructor();
        constructor(PoseNames: TArray<UE.SmartName>, Tracks: TArray<string>, TrackMap: TMap<string, number>, Poses: TArray<UE.PoseData>, Curves: TArray<UE.AnimCurveBase>);
        PoseNames: TArray<UE.SmartName>;
        Tracks: TArray<string>;
        TrackMap: TMap<string, number>;
        Poses: TArray<UE.PoseData>;
        Curves: TArray<UE.AnimCurveBase>;
        static StaticClass(): Class;
    }
    
    class PoseAsset extends UE.AnimationAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PoseContainer: UE.PoseDataContainer;
        bAdditivePose: boolean;
        BasePoseIndex: number;
        RetargetSource: string;
        SourceAnimation: UE.AnimSequence;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PoseAsset;
        static Load(InName: string): PoseAsset;
    }
    
    class AnimationAsset extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Skeleton: UE.Skeleton;
        MetaData: TArray<UE.AnimMetaData>;
        ParentAsset: UE.AnimationAsset;
        ChildrenAssets: TArray<UE.AnimationAsset>;
        AssetMappingTable: UE.AssetMappingTable;
        AssetUserData: TArray<UE.AssetUserData>;
        ThumbnailInfo: UE.ThumbnailInfo;
        PreviewPoseAsset: UE.PoseAsset;
        PreviewSkeletalMesh: TSoftObjectPtr<UE.SkeletalMesh>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationAsset;
        static Load(InName: string): AnimationAsset;
    }
    
    class AnimCompositeBase extends UE.AnimSequenceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompositeBase;
        static Load(InName: string): AnimCompositeBase;
    }
    
    class CurveFloat extends UE.CurveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FloatCurve: UE.RichCurve;
        bIsEventCurve: boolean;
        GetFloatValue(InTime: number) : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveFloat;
        static Load(InName: string): CurveFloat;
    }
    
    enum EAlphaBlendOption { Linear, Cubic, HermiteCubic, Sinusoidal, QuadraticInOut, CubicInOut, QuarticInOut, QuinticInOut, CircularIn, CircularOut, CircularInOut, ExpIn, ExpOut, ExpInOut, Custom, EAlphaBlendOption_MAX}
    class AlphaBlend {
        constructor();
        constructor(CustomCurve: UE.CurveFloat, BlendTime: number, BlendOption: UE.EAlphaBlendOption);
        CustomCurve: UE.CurveFloat;
        BlendTime: number;
        BlendOption: UE.EAlphaBlendOption;
        static StaticClass(): Class;
    }
    
    class AnimSyncMarker {
        constructor();
        constructor(MarkerName: string, Time: number, TrackIndex: number);
        MarkerName: string;
        Time: number;
        TrackIndex: number;
        static StaticClass(): Class;
    }
    
    class MarkerSyncData {
        constructor();
        constructor(AuthoredSyncMarkers: TArray<UE.AnimSyncMarker>);
        AuthoredSyncMarkers: TArray<UE.AnimSyncMarker>;
        static StaticClass(): Class;
    }
    
    class CompositeSection extends UE.AnimLinkableElement {
        constructor();
        constructor(SectionName: string, StartTime: number, NextSectionName: string, MetaData: TArray<UE.AnimMetaData>);
        SectionName: string;
        StartTime: number;
        NextSectionName: string;
        MetaData: TArray<UE.AnimMetaData>;
        static StaticClass(): Class;
    }
    
    class AnimSegment {
        constructor();
        constructor(AnimReference: UE.AnimSequenceBase, StartPos: number, AnimStartTime: number, AnimEndTime: number, AnimPlayRate: number, LoopingCount: number);
        AnimReference: UE.AnimSequenceBase;
        StartPos: number;
        AnimStartTime: number;
        AnimEndTime: number;
        AnimPlayRate: number;
        LoopingCount: number;
        static StaticClass(): Class;
    }
    
    class AnimTrack {
        constructor();
        constructor(AnimSegments: TArray<UE.AnimSegment>);
        AnimSegments: TArray<UE.AnimSegment>;
        static StaticClass(): Class;
    }
    
    class SlotAnimationTrack {
        constructor();
        constructor(SlotName: string, AnimTrack: UE.AnimTrack);
        SlotName: string;
        AnimTrack: UE.AnimTrack;
        static StaticClass(): Class;
    }
    
    class BranchingPoint extends UE.AnimLinkableElement {
        constructor();
        constructor(EventName: string, DisplayTime: number, TriggerTimeOffset: number);
        EventName: string;
        DisplayTime: number;
        TriggerTimeOffset: number;
        static StaticClass(): Class;
    }
    
    enum ERootMotionRootLock { RefPose, AnimFirstFrame, Zero, ERootMotionRootLock_MAX}
    enum EAnimNotifyEventType { Begin, End, EAnimNotifyEventType_MAX}
    class BranchingPointMarker {
        constructor();
        constructor(NotifyIndex: number, TriggerTime: number, NotifyEventType: UE.EAnimNotifyEventType);
        NotifyIndex: number;
        TriggerTime: number;
        NotifyEventType: UE.EAnimNotifyEventType;
        static StaticClass(): Class;
    }
    
    class TimeStretchCurveMarker {
        constructor();
        constructor(Time: FixSizeArray<number>, Alpha: number);
        Time: FixSizeArray<number>;
        Alpha: number;
        static StaticClass(): Class;
    }
    
    class TimeStretchCurve {
        constructor();
        constructor(SamplingRate: number, CurveValueMinPrecision: number, Markers: TArray<UE.TimeStretchCurveMarker>, Sum_dT_i_by_C_i: FixSizeArray<number>);
        SamplingRate: number;
        CurveValueMinPrecision: number;
        Markers: TArray<UE.TimeStretchCurveMarker>;
        Sum_dT_i_by_C_i: FixSizeArray<number>;
        static StaticClass(): Class;
    }
    
    class AnimMontage extends UE.AnimCompositeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlendIn: UE.AlphaBlend;
        BlendInTime: number;
        BlendOut: UE.AlphaBlend;
        BlendOutTime: number;
        BlendOutTriggerTime: number;
        SyncGroup: string;
        SyncSlotIndex: number;
        MarkerData: UE.MarkerSyncData;
        CompositeSections: TArray<UE.CompositeSection>;
        SlotAnimTracks: TArray<UE.SlotAnimationTrack>;
        BranchingPoints: TArray<UE.BranchingPoint>;
        bEnableRootMotionTranslation: boolean;
        bEnableRootMotionRotation: boolean;
        bEnableAutoBlendOut: boolean;
        RootMotionRootLock: UE.ERootMotionRootLock;
        PreviewBasePose: UE.AnimSequence;
        BranchingPointMarkers: TArray<UE.BranchingPointMarker>;
        BranchingPointStateNotifyIndices: TArray<number>;
        TimeStretchCurve: UE.TimeStretchCurve;
        TimeStretchCurveName: string;
        GetDefaultBlendOutTime() : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimMontage;
        static Load(InName: string): AnimMontage;
    }
    
    enum EAnimLinkMethod { Absolute, Relative, Proportional, EAnimLinkMethod_MAX}
    class AnimLinkableElement {
        constructor();
        constructor(LinkedMontage: UE.AnimMontage, SlotIndex: number, SegmentIndex: number, LinkMethod: UE.EAnimLinkMethod, CachedLinkMethod: UE.EAnimLinkMethod, SegmentBeginTime: number, SegmentLength: number, LinkValue: number, LinkedSequence: UE.AnimSequenceBase);
        LinkedMontage: UE.AnimMontage;
        SlotIndex: number;
        SegmentIndex: number;
        LinkMethod: UE.EAnimLinkMethod;
        CachedLinkMethod: UE.EAnimLinkMethod;
        SegmentBeginTime: number;
        SegmentLength: number;
        LinkValue: number;
        LinkedSequence: UE.AnimSequenceBase;
        static StaticClass(): Class;
    }
    
    class AnimNotify extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NotifyColor: UE.Color;
        GetNotifyName() : string;
        Received_Notify(MeshComp: $Nullable<UE.SkeletalMeshComponent>, Animation: $Nullable<UE.AnimSequenceBase>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify;
        static Load(InName: string): AnimNotify;
    }
    
    class AnimNotifyState extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NotifyColor: UE.Color;
        GetNotifyName() : string;
        Received_NotifyBegin(MeshComp: $Nullable<UE.SkeletalMeshComponent>, Animation: $Nullable<UE.AnimSequenceBase>, TotalDuration: number) : boolean;
        Received_NotifyEnd(MeshComp: $Nullable<UE.SkeletalMeshComponent>, Animation: $Nullable<UE.AnimSequenceBase>) : boolean;
        Received_NotifyTick(MeshComp: $Nullable<UE.SkeletalMeshComponent>, Animation: $Nullable<UE.AnimSequenceBase>, FrameDeltaTime: number) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotifyState;
        static Load(InName: string): AnimNotifyState;
    }
    
    enum EMontageNotifyTickType { Queued, BranchingPoint, EMontageNotifyTickType_MAX}
    enum ENotifyFilterType { NoFiltering, LOD, ENotifyFilterType_MAX}
    class AnimNotifyEvent extends UE.AnimLinkableElement {
        constructor();
        constructor(DisplayTime: number, TriggerTimeOffset: number, EndTriggerTimeOffset: number, TriggerWeightThreshold: number, NotifyName: string, Notify: UE.AnimNotify, NotifyStateClass: UE.AnimNotifyState, Duration: number, EndLink: UE.AnimLinkableElement, bConvertedFromBranchingPoint: boolean, MontageTickType: UE.EMontageNotifyTickType, NotifyTriggerChance: number, NotifyFilterType: UE.ENotifyFilterType, NotifyFilterLOD: number, bTriggerOnDedicatedServer: boolean, bTriggerOnFollower: boolean, NotifyColor: UE.Color, TrackIndex: number);
        DisplayTime: number;
        TriggerTimeOffset: number;
        EndTriggerTimeOffset: number;
        TriggerWeightThreshold: number;
        NotifyName: string;
        Notify: UE.AnimNotify;
        NotifyStateClass: UE.AnimNotifyState;
        Duration: number;
        EndLink: UE.AnimLinkableElement;
        bConvertedFromBranchingPoint: boolean;
        MontageTickType: UE.EMontageNotifyTickType;
        NotifyTriggerChance: number;
        NotifyFilterType: UE.ENotifyFilterType;
        NotifyFilterLOD: number;
        bTriggerOnDedicatedServer: boolean;
        bTriggerOnFollower: boolean;
        NotifyColor: UE.Color;
        TrackIndex: number;
        static StaticClass(): Class;
    }
    
    class FloatCurve extends UE.AnimCurveBase {
        constructor();
        constructor(FloatCurve: UE.RichCurve);
        FloatCurve: UE.RichCurve;
        static StaticClass(): Class;
    }
    
    class VectorCurve extends UE.AnimCurveBase {
        constructor();
        constructor(FloatCurves: FixSizeArray<UE.RichCurve>);
        FloatCurves: FixSizeArray<UE.RichCurve>;
        static StaticClass(): Class;
    }
    
    class TransformCurve extends UE.AnimCurveBase {
        constructor();
        constructor(TranslationCurve: UE.VectorCurve, RotationCurve: UE.VectorCurve, ScaleCurve: UE.VectorCurve);
        TranslationCurve: UE.VectorCurve;
        RotationCurve: UE.VectorCurve;
        ScaleCurve: UE.VectorCurve;
        static StaticClass(): Class;
    }
    
    class RawCurveTracks {
        constructor();
        constructor(FloatCurves: TArray<UE.FloatCurve>, VectorCurves: TArray<UE.VectorCurve>, TransformCurves: TArray<UE.TransformCurve>);
        FloatCurves: TArray<UE.FloatCurve>;
        VectorCurves: TArray<UE.VectorCurve>;
        TransformCurves: TArray<UE.TransformCurve>;
        static StaticClass(): Class;
    }
    
    class AnimNotifyTrack {
        constructor();
        constructor(TrackName: string, TrackColor: UE.LinearColor);
        TrackName: string;
        TrackColor: UE.LinearColor;
        static StaticClass(): Class;
    }
    
    class AnimSequenceBase extends UE.AnimationAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Notifies: TArray<UE.AnimNotifyEvent>;
        SequenceLength: number;
        RateScale: number;
        RawCurveData: UE.RawCurveTracks;
        AnimNotifyTracks: TArray<UE.AnimNotifyTrack>;
        GetPlayLength() : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSequenceBase;
        static Load(InName: string): AnimSequenceBase;
    }
    
    class TrackToSkeletonMap {
        constructor();
        constructor(BoneTreeIndex: number);
        BoneTreeIndex: number;
        static StaticClass(): Class;
    }
    
    enum AnimationCompressionFormat { ACF_None, ACF_Float96NoW, ACF_Fixed48NoW, ACF_IntervalFixed32NoW, ACF_Fixed32NoW, ACF_Float32NoW, ACF_Identity, ACF_MAX}
    class AnimCompress extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Description: string;
        bNeedsSkeleton: boolean;
        bEnableSegmenting: boolean;
        IdealNumFramesPerSegment: number;
        MaxNumFramesPerSegment: number;
        TranslationCompressionFormat: UE.AnimationCompressionFormat;
        RotationCompressionFormat: UE.AnimationCompressionFormat;
        ScaleCompressionFormat: UE.AnimationCompressionFormat;
        MaxCurveError: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompress;
        static Load(InName: string): AnimCompress;
    }
    
    class AnimCurveCompressionCodec extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionCodec;
        static Load(InName: string): AnimCurveCompressionCodec;
    }
    
    class AnimCurveCompressionSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Codec: UE.AnimCurveCompressionCodec;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionSettings;
        static Load(InName: string): AnimCurveCompressionSettings;
    }
    
    enum EAdditiveAnimationType { AAT_None, AAT_LocalSpaceBase, AAT_RotationOffsetMeshSpace, AAT_MAX}
    enum EAdditiveBasePoseType { ABPT_None, ABPT_RefPose, ABPT_AnimScaled, ABPT_AnimFrame, ABPT_MAX}
    enum EAnimInterpolationType { Linear, Step, EAnimInterpolationType_MAX}
    class AnimSequence extends UE.AnimSequenceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportFileFramerate: number;
        ImportResampleFramerate: number;
        NumFrames: number;
        TrackToSkeletonMapTable: TArray<UE.TrackToSkeletonMap>;
        RawDataGuid: UE.Guid;
        AnimationTrackNames: TArray<string>;
        CompressionScheme: UE.AnimCompress;
        bAllowFrameStripping: boolean;
        CompressionErrorThresholdScale: number;
        CurveCompressionSettings: UE.AnimCurveCompressionSettings;
        AdditiveAnimType: UE.EAdditiveAnimationType;
        RefPoseType: UE.EAdditiveBasePoseType;
        RefPoseSeq: UE.AnimSequence;
        RefFrameIndex: number;
        RetargetSource: string;
        Interpolation: UE.EAnimInterpolationType;
        bEnableRootMotion: boolean;
        RootMotionRootLock: UE.ERootMotionRootLock;
        bForceRootLock: boolean;
        bUseNormalizedRootMotionScale: boolean;
        bRootMotionSettingsCopiedFromMontage: boolean;
        CompressCommandletVersion: number;
        bDoNotOverrideCompression: boolean;
        AssetImportData: UE.AssetImportData;
        SourceFilePath: string;
        SourceFileTimestamp: string;
        bNeedsRebake: boolean;
        AuthoredSyncMarkers: TArray<UE.AnimSyncMarker>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSequence;
        static Load(InName: string): AnimSequence;
    }
    
    class SkeletalMeshOptimizationSettings {
        constructor();
        constructor(TerminationCriterion: UE.SkeletalMeshTerminationCriterion, NumOfTrianglesPercentage: number, NumOfVertPercentage: number, MaxNumOfTriangles: number, MaxNumOfVerts: number, MaxDeviationPercentage: number, ReductionMethod: UE.SkeletalMeshOptimizationType, SilhouetteImportance: UE.SkeletalMeshOptimizationImportance, TextureImportance: UE.SkeletalMeshOptimizationImportance, ShadingImportance: UE.SkeletalMeshOptimizationImportance, SkinningImportance: UE.SkeletalMeshOptimizationImportance, bRemapMorphTargets: boolean, bRecalcNormals: boolean, WeldingThreshold: number, NormalsThreshold: number, MaxBonesPerVertex: number, bEnforceBoneBoundaries: boolean, VolumeImportance: number, bLockEdges: boolean, BaseLOD: number, BonesToRemove: TArray<UE.BoneReference>, BakePose: UE.AnimSequence);
        TerminationCriterion: UE.SkeletalMeshTerminationCriterion;
        NumOfTrianglesPercentage: number;
        NumOfVertPercentage: number;
        MaxNumOfTriangles: number;
        MaxNumOfVerts: number;
        MaxDeviationPercentage: number;
        ReductionMethod: UE.SkeletalMeshOptimizationType;
        SilhouetteImportance: UE.SkeletalMeshOptimizationImportance;
        TextureImportance: UE.SkeletalMeshOptimizationImportance;
        ShadingImportance: UE.SkeletalMeshOptimizationImportance;
        SkinningImportance: UE.SkeletalMeshOptimizationImportance;
        bRemapMorphTargets: boolean;
        bRecalcNormals: boolean;
        WeldingThreshold: number;
        NormalsThreshold: number;
        MaxBonesPerVertex: number;
        bEnforceBoneBoundaries: boolean;
        VolumeImportance: number;
        bLockEdges: boolean;
        BaseLOD: number;
        BonesToRemove: TArray<UE.BoneReference>;
        BakePose: UE.AnimSequence;
        static StaticClass(): Class;
    }
    
    class SkeletalMeshLODInfo {
        constructor();
        constructor(ScreenSize: UE.PerPlatformFloat, LODHysteresis: number, LODMaterialMap: TArray<number>, bEnableShadowCasting: TArray<boolean>, RemovedBones: TArray<string>, BuildSettings: UE.SkeletalMeshBuildSettings, ReductionSettings: UE.SkeletalMeshOptimizationSettings, BonesToRemove: TArray<UE.BoneReference>, BonesToPrioritize: TArray<UE.BoneReference>, WeightOfPrioritization: number, BakePose: UE.AnimSequence, BakePoseOverride: UE.AnimSequence, SourceImportFilename: string, bHasBeenSimplified: boolean, bHasPerLODVertexColors: boolean, bAllowCPUAccess: boolean, bSupportUniformlyDistributedSampling: boolean, bImportWithBaseMesh: boolean);
        ScreenSize: UE.PerPlatformFloat;
        LODHysteresis: number;
        LODMaterialMap: TArray<number>;
        bEnableShadowCasting: TArray<boolean>;
        RemovedBones: TArray<string>;
        BuildSettings: UE.SkeletalMeshBuildSettings;
        ReductionSettings: UE.SkeletalMeshOptimizationSettings;
        BonesToRemove: TArray<UE.BoneReference>;
        BonesToPrioritize: TArray<UE.BoneReference>;
        WeightOfPrioritization: number;
        BakePose: UE.AnimSequence;
        BakePoseOverride: UE.AnimSequence;
        SourceImportFilename: string;
        bHasBeenSimplified: boolean;
        bHasPerLODVertexColors: boolean;
        bAllowCPUAccess: boolean;
        bSupportUniformlyDistributedSampling: boolean;
        bImportWithBaseMesh: boolean;
        static StaticClass(): Class;
    }
    
    class PerPlatformInt {
        constructor();
        constructor(Default: number, PerPlatform: TMap<string, number>);
        Default: number;
        PerPlatform: TMap<string, number>;
        static StaticClass(): Class;
    }
    
    class PerPlatformBool {
        constructor();
        constructor(Default: boolean, PerPlatform: TMap<string, boolean>);
        Default: boolean;
        PerPlatform: TMap<string, boolean>;
        static StaticClass(): Class;
    }
    
    enum EBoneFilterActionOption { Remove, Keep, Invalid, EBoneFilterActionOption_MAX}
    class BoneFilter {
        constructor();
        constructor(bExcludeSelf: boolean, BoneName: string);
        bExcludeSelf: boolean;
        BoneName: string;
        static StaticClass(): Class;
    }
    
    class SkeletalMeshLODGroupSettings {
        constructor();
        constructor(ScreenSize: UE.PerPlatformFloat, LODHysteresis: number, BoneFilterActionOption: UE.EBoneFilterActionOption, BoneList: TArray<UE.BoneFilter>, BonesToPrioritize: TArray<string>, WeightOfPrioritization: number, BakePose: UE.AnimSequence, ReductionSettings: UE.SkeletalMeshOptimizationSettings);
        ScreenSize: UE.PerPlatformFloat;
        LODHysteresis: number;
        BoneFilterActionOption: UE.EBoneFilterActionOption;
        BoneList: TArray<UE.BoneFilter>;
        BonesToPrioritize: TArray<string>;
        WeightOfPrioritization: number;
        BakePose: UE.AnimSequence;
        ReductionSettings: UE.SkeletalMeshOptimizationSettings;
        static StaticClass(): Class;
    }
    
    class SkeletalMeshLODSettings extends UE.DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MinLod: UE.PerPlatformInt;
        DisableBelowMinLodStripping: UE.PerPlatformBool;
        bSupportLODStreaming: UE.PerPlatformBool;
        MaxNumStreamedLODs: UE.PerPlatformInt;
        MaxNumOptionalLODs: UE.PerPlatformInt;
        LODGroups: TArray<UE.SkeletalMeshLODGroupSettings>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshLODSettings;
        static Load(InName: string): SkeletalMeshLODSettings;
    }
    
    class KShapeElem {
        constructor();
        constructor(RestOffset: number, Name: string, bContributeToMass: boolean);
        RestOffset: number;
        Name: string;
        bContributeToMass: boolean;
        static StaticClass(): Class;
    }
    
    class Plane extends UE.Vector {
        constructor();
        constructor(W: number);
        W: number;
        static StaticClass(): Class;
    }
    
    class Matrix {
        constructor();
        constructor(XPlane: UE.Plane, YPlane: UE.Plane, ZPlane: UE.Plane, WPlane: UE.Plane);
        XPlane: UE.Plane;
        YPlane: UE.Plane;
        ZPlane: UE.Plane;
        WPlane: UE.Plane;
        static StaticClass(): Class;
    }
    
    class KSphereElem extends UE.KShapeElem {
        constructor();
        constructor(TM: UE.Matrix, Center: UE.Vector, Radius: number);
        TM: UE.Matrix;
        Center: UE.Vector;
        Radius: number;
        static StaticClass(): Class;
    }
    
    class KBoxElem extends UE.KShapeElem {
        constructor();
        constructor(TM: UE.Matrix, Orientation: UE.Quat, Center: UE.Vector, Rotation: UE.Rotator, X: number, Y: number, Z: number);
        TM: UE.Matrix;
        Orientation: UE.Quat;
        Center: UE.Vector;
        Rotation: UE.Rotator;
        X: number;
        Y: number;
        Z: number;
        static StaticClass(): Class;
    }
    
    class KSphylElem extends UE.KShapeElem {
        constructor();
        constructor(TM: UE.Matrix, Orientation: UE.Quat, Center: UE.Vector, Rotation: UE.Rotator, Radius: number, Length: number);
        TM: UE.Matrix;
        Orientation: UE.Quat;
        Center: UE.Vector;
        Rotation: UE.Rotator;
        Radius: number;
        Length: number;
        static StaticClass(): Class;
    }
    
    class KConvexElem extends UE.KShapeElem {
        constructor();
        constructor(VertexData: TArray<UE.Vector>, ElemBox: UE.Box, Transform: UE.Transform);
        VertexData: TArray<UE.Vector>;
        ElemBox: UE.Box;
        Transform: UE.Transform;
        static StaticClass(): Class;
    }
    
    class KTaperedCapsuleElem extends UE.KShapeElem {
        constructor();
        constructor(Center: UE.Vector, Rotation: UE.Rotator, Radius0: number, Radius1: number, Length: number);
        Center: UE.Vector;
        Rotation: UE.Rotator;
        Radius0: number;
        Radius1: number;
        Length: number;
        static StaticClass(): Class;
    }
    
    class KAggregateGeom {
        constructor();
        constructor(SphereElems: TArray<UE.KSphereElem>, BoxElems: TArray<UE.KBoxElem>, SphylElems: TArray<UE.KSphylElem>, ConvexElems: TArray<UE.KConvexElem>, TaperedCapsuleElems: TArray<UE.KTaperedCapsuleElem>);
        SphereElems: TArray<UE.KSphereElem>;
        BoxElems: TArray<UE.KBoxElem>;
        SphylElems: TArray<UE.KSphylElem>;
        ConvexElems: TArray<UE.KConvexElem>;
        TaperedCapsuleElems: TArray<UE.KTaperedCapsuleElem>;
        static StaticClass(): Class;
    }
    
    enum EPhysicsType { PhysType_Default, PhysType_Kinematic, PhysType_Simulated, PhysType_MAX}
    enum EBodyCollisionResponse { BodyCollision_Enabled, BodyCollision_Disabled, BodyCollision_MAX}
    enum ECollisionTraceFlag { CTF_UseDefault, CTF_UseSimpleAndComplex, CTF_UseSimpleAsComplex, CTF_UseComplexAsSimple, CTF_MAX}
    class BodySetup extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AggGeom: UE.KAggregateGeom;
        BoneName: string;
        PhysicsType: UE.EPhysicsType;
        bAlwaysFullAnimWeight: boolean;
        bConsiderForBounds: boolean;
        bMeshCollideAll: boolean;
        bDoubleSidedGeometry: boolean;
        bGenerateNonMirroredCollision: boolean;
        bSharedCookedData: boolean;
        bGenerateMirroredCollision: boolean;
        CollisionReponse: UE.EBodyCollisionResponse;
        CollisionTraceFlag: UE.ECollisionTraceFlag;
        PhysMaterial: UE.PhysicalMaterial;
        WalkableSlopeOverride: UE.WalkableSlopeOverride;
        BuildScale: number;
        DefaultInstance: UE.BodyInstance;
        BuildScale3D: UE.Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BodySetup;
        static Load(InName: string): BodySetup;
    }
    
    class PhysicalAnimationData {
        constructor();
        constructor(BodyName: string, bIsLocalSimulation: boolean, OrientationStrength: number, AngularVelocityStrength: number, PositionStrength: number, VelocityStrength: number, MaxLinearForce: number, MaxAngularForce: number);
        BodyName: string;
        bIsLocalSimulation: boolean;
        OrientationStrength: number;
        AngularVelocityStrength: number;
        PositionStrength: number;
        VelocityStrength: number;
        MaxLinearForce: number;
        MaxAngularForce: number;
        static StaticClass(): Class;
    }
    
    class PhysicalAnimationProfile {
        constructor();
        constructor(ProfileName: string, PhysicalAnimationData: UE.PhysicalAnimationData);
        ProfileName: string;
        PhysicalAnimationData: UE.PhysicalAnimationData;
        static StaticClass(): Class;
    }
    
    class SkeletalBodySetup extends UE.BodySetup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurrentPhysicalAnimationProfile: UE.PhysicalAnimationProfile;
        bSkipScaleFromAnimation: boolean;
        PhysicalAnimationData: TArray<UE.PhysicalAnimationProfile>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalBodySetup;
        static Load(InName: string): SkeletalBodySetup;
    }
    
    class ConstraintBaseParams {
        constructor();
        constructor(Stiffness: number, Damping: number, Restitution: number, ContactDistance: number, bSoftConstraint: boolean);
        Stiffness: number;
        Damping: number;
        Restitution: number;
        ContactDistance: number;
        bSoftConstraint: boolean;
        static StaticClass(): Class;
    }
    
    enum ELinearConstraintMotion { LCM_Free, LCM_Limited, LCM_Locked, LCM_MAX}
    class LinearConstraint extends UE.ConstraintBaseParams {
        constructor();
        constructor(Limit: number, XMotion: UE.ELinearConstraintMotion, YMotion: UE.ELinearConstraintMotion, ZMotion: UE.ELinearConstraintMotion);
        Limit: number;
        XMotion: UE.ELinearConstraintMotion;
        YMotion: UE.ELinearConstraintMotion;
        ZMotion: UE.ELinearConstraintMotion;
        static StaticClass(): Class;
    }
    
    enum EAngularConstraintMotion { ACM_Free, ACM_Limited, ACM_Locked, ACM_MAX}
    class ConeConstraint extends UE.ConstraintBaseParams {
        constructor();
        constructor(Swing1LimitDegrees: number, Swing2LimitDegrees: number, Swing1Motion: UE.EAngularConstraintMotion, Swing2Motion: UE.EAngularConstraintMotion);
        Swing1LimitDegrees: number;
        Swing2LimitDegrees: number;
        Swing1Motion: UE.EAngularConstraintMotion;
        Swing2Motion: UE.EAngularConstraintMotion;
        static StaticClass(): Class;
    }
    
    class TwistConstraint extends UE.ConstraintBaseParams {
        constructor();
        constructor(TwistLimitDegrees: number, TwistMotion: UE.EAngularConstraintMotion);
        TwistLimitDegrees: number;
        TwistMotion: UE.EAngularConstraintMotion;
        static StaticClass(): Class;
    }
    
    class ConstraintDrive {
        constructor();
        constructor(Stiffness: number, Damping: number, MaxForce: number, bEnablePositionDrive: boolean, bEnableVelocityDrive: boolean);
        Stiffness: number;
        Damping: number;
        MaxForce: number;
        bEnablePositionDrive: boolean;
        bEnableVelocityDrive: boolean;
        static StaticClass(): Class;
    }
    
    class LinearDriveConstraint {
        constructor();
        constructor(PositionTarget: UE.Vector, VelocityTarget: UE.Vector, XDrive: UE.ConstraintDrive, YDrive: UE.ConstraintDrive, ZDrive: UE.ConstraintDrive, bEnablePositionDrive: boolean);
        PositionTarget: UE.Vector;
        VelocityTarget: UE.Vector;
        XDrive: UE.ConstraintDrive;
        YDrive: UE.ConstraintDrive;
        ZDrive: UE.ConstraintDrive;
        bEnablePositionDrive: boolean;
        static StaticClass(): Class;
    }
    
    enum EAngularDriveMode { SLERP, TwistAndSwing, EAngularDriveMode_MAX}
    class AngularDriveConstraint {
        constructor();
        constructor(TwistDrive: UE.ConstraintDrive, SwingDrive: UE.ConstraintDrive, SlerpDrive: UE.ConstraintDrive, OrientationTarget: UE.Rotator, AngularVelocityTarget: UE.Vector, AngularDriveMode: UE.EAngularDriveMode);
        TwistDrive: UE.ConstraintDrive;
        SwingDrive: UE.ConstraintDrive;
        SlerpDrive: UE.ConstraintDrive;
        OrientationTarget: UE.Rotator;
        AngularVelocityTarget: UE.Vector;
        AngularDriveMode: UE.EAngularDriveMode;
        static StaticClass(): Class;
    }
    
    class ConstraintProfileProperties {
        constructor();
        constructor(ProjectionLinearTolerance: number, ProjectionAngularTolerance: number, LinearBreakThreshold: number, AngularBreakThreshold: number, LinearLimit: UE.LinearConstraint, ConeLimit: UE.ConeConstraint, TwistLimit: UE.TwistConstraint, LinearDrive: UE.LinearDriveConstraint, AngularDrive: UE.AngularDriveConstraint, bDisableCollision: boolean, bParentDominates: boolean, bEnableProjection: boolean, bAngularBreakable: boolean, bLinearBreakable: boolean);
        ProjectionLinearTolerance: number;
        ProjectionAngularTolerance: number;
        LinearBreakThreshold: number;
        AngularBreakThreshold: number;
        LinearLimit: UE.LinearConstraint;
        ConeLimit: UE.ConeConstraint;
        TwistLimit: UE.TwistConstraint;
        LinearDrive: UE.LinearDriveConstraint;
        AngularDrive: UE.AngularDriveConstraint;
        bDisableCollision: boolean;
        bParentDominates: boolean;
        bEnableProjection: boolean;
        bAngularBreakable: boolean;
        bLinearBreakable: boolean;
        static StaticClass(): Class;
    }
    
    class ConstraintInstance {
        constructor();
        constructor(JointName: string, ConstraintBone1: string, ConstraintBone2: string, Pos1: UE.Vector, PriAxis1: UE.Vector, SecAxis1: UE.Vector, Pos2: UE.Vector, PriAxis2: UE.Vector, SecAxis2: UE.Vector, AngularRotationOffset: UE.Rotator, bScaleLinearLimits: boolean, ProfileInstance: UE.ConstraintProfileProperties, bDisableCollision: boolean, bEnableProjection: boolean, ProjectionLinearTolerance: number, ProjectionAngularTolerance: number, LinearXMotion: UE.ELinearConstraintMotion, LinearYMotion: UE.ELinearConstraintMotion, LinearZMotion: UE.ELinearConstraintMotion, LinearLimitSize: number, bLinearLimitSoft: boolean, LinearLimitStiffness: number, LinearLimitDamping: number, bLinearBreakable: boolean, LinearBreakThreshold: number, AngularSwing1Motion: UE.EAngularConstraintMotion, AngularTwistMotion: UE.EAngularConstraintMotion, AngularSwing2Motion: UE.EAngularConstraintMotion, bSwingLimitSoft: boolean, bTwistLimitSoft: boolean, Swing1LimitAngle: number, TwistLimitAngle: number, Swing2LimitAngle: number, SwingLimitStiffness: number, SwingLimitDamping: number, TwistLimitStiffness: number, TwistLimitDamping: number, bAngularBreakable: boolean, AngularBreakThreshold: number, bLinearXPositionDrive: boolean, bLinearXVelocityDrive: boolean, bLinearYPositionDrive: boolean, bLinearYVelocityDrive: boolean, bLinearZPositionDrive: boolean, bLinearZVelocityDrive: boolean, bLinearPositionDrive: boolean, bLinearVelocityDrive: boolean, LinearPositionTarget: UE.Vector, LinearVelocityTarget: UE.Vector, LinearDriveSpring: number, LinearDriveDamping: number, LinearDriveForceLimit: number, bSwingPositionDrive: boolean, bSwingVelocityDrive: boolean, bTwistPositionDrive: boolean, bTwistVelocityDrive: boolean, bAngularSlerpDrive: boolean, bAngularOrientationDrive: boolean, bEnableSwingDrive: boolean, bEnableTwistDrive: boolean, bAngularVelocityDrive: boolean, AngularPositionTarget: UE.Quat, AngularDriveMode: UE.EAngularDriveMode, AngularOrientationTarget: UE.Rotator, AngularVelocityTarget: UE.Vector, AngularDriveSpring: number, AngularDriveDamping: number, AngularDriveForceLimit: number);
        JointName: string;
        ConstraintBone1: string;
        ConstraintBone2: string;
        Pos1: UE.Vector;
        PriAxis1: UE.Vector;
        SecAxis1: UE.Vector;
        Pos2: UE.Vector;
        PriAxis2: UE.Vector;
        SecAxis2: UE.Vector;
        AngularRotationOffset: UE.Rotator;
        bScaleLinearLimits: boolean;
        ProfileInstance: UE.ConstraintProfileProperties;
        bDisableCollision: boolean;
        bEnableProjection: boolean;
        ProjectionLinearTolerance: number;
        ProjectionAngularTolerance: number;
        LinearXMotion: UE.ELinearConstraintMotion;
        LinearYMotion: UE.ELinearConstraintMotion;
        LinearZMotion: UE.ELinearConstraintMotion;
        LinearLimitSize: number;
        bLinearLimitSoft: boolean;
        LinearLimitStiffness: number;
        LinearLimitDamping: number;
        bLinearBreakable: boolean;
        LinearBreakThreshold: number;
        AngularSwing1Motion: UE.EAngularConstraintMotion;
        AngularTwistMotion: UE.EAngularConstraintMotion;
        AngularSwing2Motion: UE.EAngularConstraintMotion;
        bSwingLimitSoft: boolean;
        bTwistLimitSoft: boolean;
        Swing1LimitAngle: number;
        TwistLimitAngle: number;
        Swing2LimitAngle: number;
        SwingLimitStiffness: number;
        SwingLimitDamping: number;
        TwistLimitStiffness: number;
        TwistLimitDamping: number;
        bAngularBreakable: boolean;
        AngularBreakThreshold: number;
        bLinearXPositionDrive: boolean;
        bLinearXVelocityDrive: boolean;
        bLinearYPositionDrive: boolean;
        bLinearYVelocityDrive: boolean;
        bLinearZPositionDrive: boolean;
        bLinearZVelocityDrive: boolean;
        bLinearPositionDrive: boolean;
        bLinearVelocityDrive: boolean;
        LinearPositionTarget: UE.Vector;
        LinearVelocityTarget: UE.Vector;
        LinearDriveSpring: number;
        LinearDriveDamping: number;
        LinearDriveForceLimit: number;
        bSwingPositionDrive: boolean;
        bSwingVelocityDrive: boolean;
        bTwistPositionDrive: boolean;
        bTwistVelocityDrive: boolean;
        bAngularSlerpDrive: boolean;
        bAngularOrientationDrive: boolean;
        bEnableSwingDrive: boolean;
        bEnableTwistDrive: boolean;
        bAngularVelocityDrive: boolean;
        AngularPositionTarget: UE.Quat;
        AngularDriveMode: UE.EAngularDriveMode;
        AngularOrientationTarget: UE.Rotator;
        AngularVelocityTarget: UE.Vector;
        AngularDriveSpring: number;
        AngularDriveDamping: number;
        AngularDriveForceLimit: number;
        static StaticClass(): Class;
    }
    
    class PhysicsConstraintProfileHandle {
        constructor();
        constructor(ProfileProperties: UE.ConstraintProfileProperties, ProfileName: string);
        ProfileProperties: UE.ConstraintProfileProperties;
        ProfileName: string;
        static StaticClass(): Class;
    }
    
    class PhysicsConstraintTemplate extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultInstance: UE.ConstraintInstance;
        ProfileHandles: TArray<UE.PhysicsConstraintProfileHandle>;
        DefaultProfile: UE.ConstraintProfileProperties;
        JointName: string;
        ConstraintBone1: string;
        ConstraintBone2: string;
        Pos1: UE.Vector;
        PriAxis1: UE.Vector;
        SecAxis1: UE.Vector;
        Pos2: UE.Vector;
        PriAxis2: UE.Vector;
        SecAxis2: UE.Vector;
        bEnableProjection: boolean;
        ProjectionLinearTolerance: number;
        ProjectionAngularTolerance: number;
        LinearXMotion: UE.ELinearConstraintMotion;
        LinearYMotion: UE.ELinearConstraintMotion;
        LinearZMotion: UE.ELinearConstraintMotion;
        LinearLimitSize: number;
        bLinearLimitSoft: boolean;
        LinearLimitStiffness: number;
        LinearLimitDamping: number;
        bLinearBreakable: boolean;
        LinearBreakThreshold: number;
        AngularSwing1Motion: UE.EAngularConstraintMotion;
        AngularSwing2Motion: UE.EAngularConstraintMotion;
        AngularTwistMotion: UE.EAngularConstraintMotion;
        bSwingLimitSoft: boolean;
        bTwistLimitSoft: boolean;
        Swing1LimitAngle: number;
        Swing2LimitAngle: number;
        TwistLimitAngle: number;
        SwingLimitStiffness: number;
        SwingLimitDamping: number;
        TwistLimitStiffness: number;
        TwistLimitDamping: number;
        bAngularBreakable: boolean;
        AngularBreakThreshold: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsConstraintTemplate;
        static Load(InName: string): PhysicsConstraintTemplate;
    }
    
    class PhysicsAsset extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultSkelMesh: UE.SkeletalMesh;
        PreviewSkeletalMesh: TSoftObjectPtr<UE.SkeletalMesh>;
        PhysicalAnimationProfiles: TArray<string>;
        ConstraintProfiles: TArray<string>;
        CurrentPhysicalAnimationProfileName: string;
        CurrentConstraintProfileName: string;
        BoundsBodies: TArray<number>;
        SkeletalBodySetups: TArray<UE.SkeletalBodySetup>;
        ConstraintSetup: TArray<UE.PhysicsConstraintTemplate>;
        bNotForDedicatedServer: boolean;
        ThumbnailInfo: UE.ThumbnailInfo;
        BodySetup: TArray<UE.BodySetup>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsAsset;
        static Load(InName: string): PhysicsAsset;
    }
    
    class NodeItem {
        constructor();
        constructor(ParentName: string, Transform: UE.Transform);
        ParentName: string;
        Transform: UE.Transform;
        static StaticClass(): Class;
    }
    
    class NodeMappingContainer extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceItems: TMap<string, UE.NodeItem>;
        TargetItems: TMap<string, UE.NodeItem>;
        SourceToTarget: TMap<string, string>;
        SourceAsset: TSoftObjectPtr<UE.Object>;
        TargetAsset: TSoftObjectPtr<UE.Object>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NodeMappingContainer;
        static Load(InName: string): NodeMappingContainer;
    }
    
    class MorphTarget extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseSkelMesh: UE.SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MorphTarget;
        static Load(InName: string): MorphTarget;
    }
    
    class ClothPhysicsProperties_Legacy {
        constructor();
        constructor(VerticalResistance: number, HorizontalResistance: number, BendResistance: number, ShearResistance: number, Friction: number, Damping: number, TetherStiffness: number, TetherLimit: number, Drag: number, StiffnessFrequency: number, GravityScale: number, MassScale: number, InertiaBlend: number, SelfCollisionThickness: number, SelfCollisionSquashScale: number, SelfCollisionStiffness: number, SolverFrequency: number, FiberCompression: number, FiberExpansion: number, FiberResistance: number);
        VerticalResistance: number;
        HorizontalResistance: number;
        BendResistance: number;
        ShearResistance: number;
        Friction: number;
        Damping: number;
        TetherStiffness: number;
        TetherLimit: number;
        Drag: number;
        StiffnessFrequency: number;
        GravityScale: number;
        MassScale: number;
        InertiaBlend: number;
        SelfCollisionThickness: number;
        SelfCollisionSquashScale: number;
        SelfCollisionStiffness: number;
        SolverFrequency: number;
        FiberCompression: number;
        FiberExpansion: number;
        FiberResistance: number;
        static StaticClass(): Class;
    }
    
    class ClothingAssetData_Legacy {
        constructor();
        constructor(AssetName: string, ApexFileName: string, bClothPropertiesChanged: boolean, PhysicsProperties: UE.ClothPhysicsProperties_Legacy);
        AssetName: string;
        ApexFileName: string;
        bClothPropertiesChanged: boolean;
        PhysicsProperties: UE.ClothPhysicsProperties_Legacy;
        static StaticClass(): Class;
    }
    
    class ClothingAssetBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportedFilePath: string;
        AssetGuid: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingAssetBase;
        static Load(InName: string): ClothingAssetBase;
    }
    
    class SkeletalMeshSamplingRegionMaterialFilter {
        constructor();
        constructor(MaterialName: string);
        MaterialName: string;
        static StaticClass(): Class;
    }
    
    class SkeletalMeshSamplingRegionBoneFilter {
        constructor();
        constructor(BoneName: string, bIncludeOrExclude: boolean, bApplyToChildren: boolean);
        BoneName: string;
        bIncludeOrExclude: boolean;
        bApplyToChildren: boolean;
        static StaticClass(): Class;
    }
    
    class SkeletalMeshSamplingRegion {
        constructor();
        constructor(Name: string, LODIndex: number, bSupportUniformlyDistributedSampling: boolean, MaterialFilters: TArray<UE.SkeletalMeshSamplingRegionMaterialFilter>, BoneFilters: TArray<UE.SkeletalMeshSamplingRegionBoneFilter>);
        Name: string;
        LODIndex: number;
        bSupportUniformlyDistributedSampling: boolean;
        MaterialFilters: TArray<UE.SkeletalMeshSamplingRegionMaterialFilter>;
        BoneFilters: TArray<UE.SkeletalMeshSamplingRegionBoneFilter>;
        static StaticClass(): Class;
    }
    
    class SkeletalMeshSamplingLODBuiltData {
        constructor();
        static StaticClass(): Class;
    }
    
    class SkeletalMeshSamplingRegionBuiltData {
        constructor();
        static StaticClass(): Class;
    }
    
    class SkeletalMeshSamplingBuiltData {
        constructor();
        constructor(WholeMeshBuiltData: TArray<UE.SkeletalMeshSamplingLODBuiltData>, RegionBuiltData: TArray<UE.SkeletalMeshSamplingRegionBuiltData>);
        WholeMeshBuiltData: TArray<UE.SkeletalMeshSamplingLODBuiltData>;
        RegionBuiltData: TArray<UE.SkeletalMeshSamplingRegionBuiltData>;
        static StaticClass(): Class;
    }
    
    class SkeletalMeshSamplingInfo {
        constructor();
        constructor(Regions: TArray<UE.SkeletalMeshSamplingRegion>, BuiltData: UE.SkeletalMeshSamplingBuiltData);
        Regions: TArray<UE.SkeletalMeshSamplingRegion>;
        BuiltData: UE.SkeletalMeshSamplingBuiltData;
        static StaticClass(): Class;
    }
    
    class SkinWeightProfileInfo {
        constructor();
        constructor(Name: string, DefaultProfile: UE.PerPlatformBool, DefaultProfileFromLODIndex: UE.PerPlatformInt, PerLODSourceFiles: TMap<number, string>);
        Name: string;
        DefaultProfile: UE.PerPlatformBool;
        DefaultProfileFromLODIndex: UE.PerPlatformInt;
        PerLODSourceFiles: TMap<number, string>;
        static StaticClass(): Class;
    }
    
    class BlueprintCore extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SkeletonGeneratedClass: UE.Class;
        GeneratedClass: UE.Class;
        bLegacyNeedToPurgeSkelRefs: boolean;
        BlueprintGuid: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintCore;
        static Load(InName: string): BlueprintCore;
    }
    
    enum EBlueprintType { BPTYPE_Normal, BPTYPE_Const, BPTYPE_MacroLibrary, BPTYPE_Interface, BPTYPE_LevelScript, BPTYPE_FunctionLibrary, BPTYPE_MAX}
    enum EBlueprintNativizationFlag { Disabled, Dependency, ExplicitlyEnabled, EBlueprintNativizationFlag_MAX}
    enum EBlueprintCompileMode { Default, Development, FinalRelease, EBlueprintCompileMode_MAX}
    enum EBlueprintStatus { BS_Unknown, BS_Dirty, BS_Error, BS_UpToDate, BS_BeingCreated, BS_UpToDateWithWarnings, BS_MAX}
    class BlueprintComponentChangedPropertyInfo {
        constructor();
        constructor(PropertyName: string, ArrayIndex: number, PropertyScope: UE.Struct);
        PropertyName: string;
        ArrayIndex: number;
        PropertyScope: UE.Struct;
        static StaticClass(): Class;
    }
    
    class BlueprintCookedComponentInstancingData {
        constructor();
        constructor(ChangedPropertyList: TArray<UE.BlueprintComponentChangedPropertyInfo>, bHasValidCookedData: boolean);
        ChangedPropertyList: TArray<UE.BlueprintComponentChangedPropertyInfo>;
        bHasValidCookedData: boolean;
        static StaticClass(): Class;
    }
    
    class BPVariableMetaDataEntry {
        constructor();
        constructor(DataKey: string, DataValue: string);
        DataKey: string;
        DataValue: string;
        static StaticClass(): Class;
    }
    
    class SCS_Node extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ComponentClass: UE.Class;
        ComponentTemplate: UE.ActorComponent;
        CookedComponentInstancingData: UE.BlueprintCookedComponentInstancingData;
        CategoryName: string;
        AttachToName: string;
        ParentComponentOrVariableName: string;
        ParentComponentOwnerClassName: string;
        bIsParentComponentNative: boolean;
        ChildNodes: TArray<UE.SCS_Node>;
        MetaDataArray: TArray<UE.BPVariableMetaDataEntry>;
        VariableGuid: UE.Guid;
        bIsNative: boolean;
        NativeComponentName: string;
        bVariableNameAutoGenerated: boolean;
        InternalVariableName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SCS_Node;
        static Load(InName: string): SCS_Node;
    }
    
    class SimpleConstructionScript extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RootNodes: TArray<UE.SCS_Node>;
        AllNodes: TArray<UE.SCS_Node>;
        DefaultSceneRootNode: UE.SCS_Node;
        RootNode: UE.SCS_Node;
        ActorComponentNodes: TArray<UE.SCS_Node>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SimpleConstructionScript;
        static Load(InName: string): SimpleConstructionScript;
    }
    
    class EdGraph extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Schema: UE.Class;
        Nodes: TArray<UE.EdGraphNode>;
        bEditable: boolean;
        bAllowDeletion: boolean;
        bAllowRenaming: boolean;
        SubGraphs: TArray<UE.EdGraph>;
        GraphGuid: UE.Guid;
        InterfaceGuid: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraph;
        static Load(InName: string): EdGraph;
    }
    
    class BlueprintMacroCosmeticInfo {
        constructor();
        static StaticClass(): Class;
    }
    
    enum ETimelineLengthMode { TL_TimelineLength, TL_LastKeyFrame, TL_MAX}
    class TTTrackBase {
        constructor();
        constructor(TrackName: string, bIsExternalCurve: boolean);
        TrackName: string;
        bIsExternalCurve: boolean;
        static StaticClass(): Class;
    }
    
    class TTEventTrack extends UE.TTTrackBase {
        constructor();
        constructor(FunctionName: string, CurveKeys: UE.CurveFloat);
        FunctionName: string;
        CurveKeys: UE.CurveFloat;
        static StaticClass(): Class;
    }
    
    class TTPropertyTrack extends UE.TTTrackBase {
        constructor();
        constructor(PropertyName: string);
        PropertyName: string;
        static StaticClass(): Class;
    }
    
    class TTFloatTrack extends UE.TTPropertyTrack {
        constructor();
        constructor(CurveFloat: UE.CurveFloat);
        CurveFloat: UE.CurveFloat;
        static StaticClass(): Class;
    }
    
    class CurveVector extends UE.CurveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FloatCurves: FixSizeArray<UE.RichCurve>;
        GetVectorValue(InTime: number) : UE.Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveVector;
        static Load(InName: string): CurveVector;
    }
    
    class TTVectorTrack extends UE.TTPropertyTrack {
        constructor();
        constructor(CurveVector: UE.CurveVector);
        CurveVector: UE.CurveVector;
        static StaticClass(): Class;
    }
    
    class TTLinearColorTrack extends UE.TTPropertyTrack {
        constructor();
        constructor(CurveLinearColor: UE.CurveLinearColor);
        CurveLinearColor: UE.CurveLinearColor;
        static StaticClass(): Class;
    }
    
    class TimelineTemplate extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TimelineLength: number;
        LengthMode: UE.ETimelineLengthMode;
        bAutoPlay: boolean;
        bLoop: boolean;
        bReplicated: boolean;
        bIgnoreTimeDilation: boolean;
        EventTracks: TArray<UE.TTEventTrack>;
        FloatTracks: TArray<UE.TTFloatTrack>;
        VectorTracks: TArray<UE.TTVectorTrack>;
        LinearColorTracks: TArray<UE.TTLinearColorTrack>;
        MetaDataArray: TArray<UE.BPVariableMetaDataEntry>;
        TimelineGuid: UE.Guid;
        VariableName: string;
        DirectionPropertyName: string;
        UpdateFunctionName: string;
        FinishedFunctionName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TimelineTemplate;
        static Load(InName: string): TimelineTemplate;
    }
    
    class BPComponentClassOverride {
        constructor();
        constructor(ComponentName: string, ComponentClass: UE.Class);
        ComponentName: string;
        ComponentClass: UE.Class;
        static StaticClass(): Class;
    }
    
    class ComponentKey {
        constructor();
        constructor(OwnerClass: UE.Class, SCSVariableName: string, AssociatedGuid: UE.Guid);
        OwnerClass: UE.Class;
        SCSVariableName: string;
        AssociatedGuid: UE.Guid;
        static StaticClass(): Class;
    }
    
    class ComponentOverrideRecord {
        constructor();
        constructor(ComponentClass: UE.Class, ComponentTemplate: UE.ActorComponent, ComponentKey: UE.ComponentKey, CookedComponentInstancingData: UE.BlueprintCookedComponentInstancingData);
        ComponentClass: UE.Class;
        ComponentTemplate: UE.ActorComponent;
        ComponentKey: UE.ComponentKey;
        CookedComponentInstancingData: UE.BlueprintCookedComponentInstancingData;
        static StaticClass(): Class;
    }
    
    class InheritableComponentHandler extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Records: TArray<UE.ComponentOverrideRecord>;
        UnnecessaryComponents: TArray<UE.ActorComponent>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InheritableComponentHandler;
        static Load(InName: string): InheritableComponentHandler;
    }
    
    enum ELifetimeCondition { COND_None, COND_InitialOnly, COND_OwnerOnly, COND_SkipOwner, COND_SimulatedOnly, COND_AutonomousOnly, COND_SimulatedOrPhysics, COND_InitialOrOwner, COND_Custom, COND_ReplayOrOwner, COND_ReplayOnly, COND_SimulatedOnlyNoReplay, COND_SimulatedOrPhysicsNoReplay, COND_SkipReplay, COND_Never, COND_Max, COND_MAX}
    class BPVariableDescription {
        constructor();
        constructor(VarName: string, VarGuid: UE.Guid, VarType: UE.EdGraphPinType, FriendlyName: string, Category: string, PropertyFlags: bigint, RepNotifyFunc: string, ReplicationCondition: UE.ELifetimeCondition, MetaDataArray: TArray<UE.BPVariableMetaDataEntry>, DefaultValue: string);
        VarName: string;
        VarGuid: UE.Guid;
        VarType: UE.EdGraphPinType;
        FriendlyName: string;
        Category: string;
        PropertyFlags: bigint;
        RepNotifyFunc: string;
        ReplicationCondition: UE.ELifetimeCondition;
        MetaDataArray: TArray<UE.BPVariableMetaDataEntry>;
        DefaultValue: string;
        static StaticClass(): Class;
    }
    
    class BPInterfaceDescription {
        constructor();
        constructor(Interface: UE.Class, Graphs: TArray<UE.EdGraph>);
        Interface: UE.Class;
        Graphs: TArray<UE.EdGraph>;
        static StaticClass(): Class;
    }
    
    class EditedDocumentInfo {
        constructor();
        constructor(EditedObjectPath: UE.SoftObjectPath, SavedViewOffset: UE.Vector2D, SavedZoomAmount: number, EditedObject: UE.Object);
        EditedObjectPath: UE.SoftObjectPath;
        SavedViewOffset: UE.Vector2D;
        SavedZoomAmount: number;
        EditedObject: UE.Object;
        static StaticClass(): Class;
    }
    
    class BPEditorBookmarkNode {
        constructor();
        constructor(NodeGuid: UE.Guid, ParentGuid: UE.Guid, DisplayName: string);
        NodeGuid: UE.Guid;
        ParentGuid: UE.Guid;
        DisplayName: string;
        static StaticClass(): Class;
    }
    
    class Breakpoint extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnabled: boolean;
        Node: UE.EdGraphNode;
        bStepOnce: boolean;
        bStepOnce_WasPreviouslyDisabled: boolean;
        bStepOnce_RemoveAfterHit: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Breakpoint;
        static Load(InName: string): Breakpoint;
    }
    
    class EdGraphPinReference {
        constructor();
        constructor(OwningNode: TWeakObjectPtr<UE.EdGraphNode>, PinId: UE.Guid);
        OwningNode: TWeakObjectPtr<UE.EdGraphNode>;
        PinId: UE.Guid;
        static StaticClass(): Class;
    }
    
    class BlueprintExtension extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintExtension;
        static Load(InName: string): BlueprintExtension;
    }
    
    class Blueprint extends UE.BlueprintCore {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParentClass: UE.Class;
        BlueprintType: UE.EBlueprintType;
        bRecompileOnLoad: boolean;
        bHasBeenRegenerated: boolean;
        bIsRegeneratingOnLoad: boolean;
        bBeingCompiled: boolean;
        bIsNewlyCreated: boolean;
        bForceFullEditor: boolean;
        bQueuedForCompilation: boolean;
        bRunConstructionScriptOnDrag: boolean;
        bRunConstructionScriptInSequencer: boolean;
        bGenerateConstClass: boolean;
        bGenerateAbstractClass: boolean;
        bDisplayCompilePIEWarning: boolean;
        bDeprecate: boolean;
        bDuplicatingReadOnly: boolean;
        bNativize: boolean;
        NativizationFlag: UE.EBlueprintNativizationFlag;
        CompileMode: UE.EBlueprintCompileMode;
        Status: UE.EBlueprintStatus;
        BlueprintDisplayName: string;
        BlueprintDescription: string;
        BlueprintCategory: string;
        HideCategories: TArray<string>;
        SearchGuid: UE.Guid;
        BlueprintSystemVersion: number;
        SimpleConstructionScript: UE.SimpleConstructionScript;
        UbergraphPages: TArray<UE.EdGraph>;
        FunctionGraphs: TArray<UE.EdGraph>;
        DelegateSignatureGraphs: TArray<UE.EdGraph>;
        MacroGraphs: TArray<UE.EdGraph>;
        IntermediateGeneratedGraphs: TArray<UE.EdGraph>;
        EventGraphs: TArray<UE.EdGraph>;
        PRIVATE_CachedMacroInfo: TMap<UE.EdGraph, UE.BlueprintMacroCosmeticInfo>;
        ComponentTemplates: TArray<UE.ActorComponent>;
        Timelines: TArray<UE.TimelineTemplate>;
        ComponentClassOverrides: TArray<UE.BPComponentClassOverride>;
        InheritableComponentHandler: UE.InheritableComponentHandler;
        NewVariables: TArray<UE.BPVariableDescription>;
        CategorySorting: TArray<string>;
        ImplementedInterfaces: TArray<UE.BPInterfaceDescription>;
        LastEditedDocuments: TArray<UE.EditedDocumentInfo>;
        Bookmarks: TMap<UE.Guid, UE.EditedDocumentInfo>;
        BookmarkNodes: TArray<UE.BPEditorBookmarkNode>;
        Breakpoints: TArray<UE.Breakpoint>;
        WatchedPins: TArray<UE.EdGraphPinReference>;
        DeprecatedPinWatches: TArray<UE.EdGraphPin_Deprecated>;
        ComponentTemplateNameIndex: TMap<string, number>;
        OldToNewComponentTemplateNames: TMap<string, string>;
        Extensions: TArray<UE.BlueprintExtension>;
        ThumbnailInfo: UE.ThumbnailInfo;
        CrcLastCompiledCDO: number;
        CrcLastCompiledSignature: number;
        OriginalClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Blueprint;
        static Load(InName: string): Blueprint;
    }
    
    class SkeletalMesh extends UE.StreamableRenderAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Skeleton: UE.Skeleton;
        ImportedBounds: UE.BoxSphereBounds;
        ExtendedBounds: UE.BoxSphereBounds;
        PositiveBoundsExtension: UE.Vector;
        NegativeBoundsExtension: UE.Vector;
        Materials: TArray<UE.SkeletalMaterial>;
        SkelMirrorTable: TArray<UE.BoneMirrorInfo>;
        LODInfo: TArray<UE.SkeletalMeshLODInfo>;
        MinLod: UE.PerPlatformInt;
        DisableBelowMinLodStripping: UE.PerPlatformBool;
        bSupportLODStreaming: UE.PerPlatformBool;
        MaxNumStreamedLODs: UE.PerPlatformInt;
        MaxNumOptionalLODs: UE.PerPlatformInt;
        LODSettings: UE.SkeletalMeshLODSettings;
        SkelMirrorAxis: UE.EAxis;
        SkelMirrorFlipAxis: UE.EAxis;
        bUseFullPrecisionUVs: boolean;
        bUseHighPrecisionTangentBasis: boolean;
        bHasBeenSimplified: boolean;
        bHasVertexColors: boolean;
        bEnablePerPolyCollision: boolean;
        VertexColorGuid: UE.Guid;
        BodySetup: UE.BodySetup;
        PhysicsAsset: UE.PhysicsAsset;
        ShadowPhysicsAsset: UE.PhysicsAsset;
        NodeMappingData: TArray<UE.NodeMappingContainer>;
        AssetImportData: UE.AssetImportData;
        SourceFilePath: string;
        SourceFileTimestamp: string;
        ThumbnailInfo: UE.ThumbnailInfo;
        bHasCustomDefaultEditorCamera: boolean;
        DefaultEditorCameraLocation: UE.Vector;
        DefaultEditorCameraRotation: UE.Rotator;
        DefaultEditorCameraLookAt: UE.Vector;
        DefaultEditorCameraOrthoZoom: number;
        PreviewAttachedAssetContainer: UE.PreviewAssetAttachContainer;
        MorphTargets: TArray<UE.MorphTarget>;
        FloorOffset: number;
        RetargetBasePose: TArray<UE.Transform>;
        ClothingAssets: TArray<UE.ClothingAssetData_Legacy>;
        PostProcessAnimBlueprint: UE.Class;
        MeshClothingAssets: TArray<UE.ClothingAssetBase>;
        SamplingInfo: UE.SkeletalMeshSamplingInfo;
        AssetUserData: TArray<UE.AssetUserData>;
        Sockets: TArray<UE.SkeletalMeshSocket>;
        SkinWeightProfiles: TArray<UE.SkinWeightProfileInfo>;
        FindSocket(InSocketName: string) : UE.SkeletalMeshSocket;
        FindSocketAndIndex(InSocketName: string, OutIndex: $Ref<number>) : UE.SkeletalMeshSocket;
        FindSocketInfo(InSocketName: string, OutTransform: $Ref<UE.Transform>, OutBoneIndex: $Ref<number>, OutIndex: $Ref<number>) : UE.SkeletalMeshSocket;
        GetBounds() : UE.BoxSphereBounds;
        GetImportedBounds() : UE.BoxSphereBounds;
        GetNodeMappingContainer(SourceAsset: $Nullable<UE.Blueprint>) : UE.NodeMappingContainer;
        GetSocketByIndex(Index: number) : UE.SkeletalMeshSocket;
        IsSectionUsingCloth(InSectionIndex: number, bCheckCorrespondingSections?: boolean /* = true */) : boolean;
        K2_GetAllMorphTargetNames() : TArray<string>;
        NumSockets() : number;
        SetLODSettings(InLODSettings: $Nullable<UE.SkeletalMeshLODSettings>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMesh;
        static Load(InName: string): SkeletalMesh;
    }
    
    class SkelMeshComponentLODInfo {
        constructor();
        constructor(HiddenMaterials: TArray<boolean>);
        HiddenMaterials: TArray<boolean>;
        static StaticClass(): Class;
    }
    
    enum EVisibilityBasedAnimTickOption { AlwaysTickPoseAndRefreshBones, AlwaysTickPose, OnlyTickMontagesWhenNotRendered, OnlyTickPoseWhenRendered, EVisibilityBasedAnimTickOption_MAX}
    class SkelMeshSkinWeightInfo {
        constructor();
        constructor(Bones: FixSizeArray<number>, Weights: FixSizeArray<number>);
        Bones: FixSizeArray<number>;
        Weights: FixSizeArray<number>;
        static StaticClass(): Class;
    }
    
    enum EPhysBodyOp { PBO_None, PBO_Term, PBO_MAX}
    class SkinnedMeshComponent extends UE.MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SkeletalMesh: UE.SkeletalMesh;
        MasterPoseComponent: TWeakObjectPtr<UE.SkinnedMeshComponent>;
        WireframeColor: UE.Color;
        PhysicsAssetOverride: UE.PhysicsAsset;
        ForcedLodModel: number;
        MinLodModel: number;
        StreamingDistanceMultiplier: number;
        LODInfo: TArray<UE.SkelMeshComponentLODInfo>;
        VisibilityBasedAnimTickOption: UE.EVisibilityBasedAnimTickOption;
        bOverrideMinLod: boolean;
        bUseBoundsFromMasterPoseComponent: boolean;
        bForceWireframe: boolean;
        bDisplayBones: boolean;
        bDisableMorphTarget: boolean;
        bHideSkin: boolean;
        bPerBoneMotionBlur: boolean;
        bComponentUseFixedSkelBounds: boolean;
        bConsiderAllBodiesForBounds: boolean;
        bSyncAttachParentLOD: boolean;
        bCanHighlightSelectedSections: boolean;
        bRecentlyRendered: boolean;
        bCastCapsuleDirectShadow: boolean;
        bCastCapsuleIndirectShadow: boolean;
        bCPUSkinning: boolean;
        bEnableUpdateRateOptimizations: boolean;
        bDisplayDebugUpdateRateOptimizations: boolean;
        bRenderStatic: boolean;
        bIgnoreMasterPoseComponentLOD: boolean;
        bCachedLocalBoundsUpToDate: boolean;
        bForceMeshObjectUpdate: boolean;
        CapsuleIndirectShadowMinVisibility: number;
        CachedWorldSpaceBounds: UE.BoxSphereBounds;
        CachedWorldToLocalTransform: UE.Matrix;
        BoneIsChildOf(BoneName: string, ParentBoneName: string) : boolean;
        ClearSkinWeightOverride(LODIndex: number) : void;
        ClearSkinWeightProfile() : void;
        ClearVertexColorOverride(LODIndex: number) : void;
        FindClosestBone_K2(TestLocation: UE.Vector, BoneLocation: $Ref<UE.Vector>, IgnoreScale?: number /* = 0.000000 */, bRequirePhysicsAsset?: boolean /* = false */) : string;
        GetBoneIndex(BoneName: string) : number;
        GetBoneName(BoneIndex: number) : string;
        GetCurrentSkinWeightProfileName() : string;
        GetDeltaTransformFromRefPose(BoneName: string, BaseName?: string /* = "None" */) : UE.Transform;
        GetForcedLOD() : number;
        GetNumBones() : number;
        GetNumLODs() : number;
        GetParentBone(BoneName: string) : string;
        GetRefPosePosition(BoneIndex: number) : UE.Vector;
        GetSocketBoneName(InSocketName: string) : string;
        GetTwistAndSwingAngleOfDeltaRotationFromRefPose(BoneName: string, OutTwistAngle: $Ref<number>, OutSwingAngle: $Ref<number>) : boolean;
        HideBoneByName(BoneName: string, PhysBodyOption: UE.EPhysBodyOp) : void;
        IsBoneHiddenByName(BoneName: string) : boolean;
        IsMaterialSectionShown(MaterialID: number, LODIndex: number) : boolean;
        IsUsingSkinWeightProfile() : boolean;
        SetCapsuleIndirectShadowMinVisibility(NewValue: number) : void;
        SetCastCapsuleDirectShadow(bNewValue: boolean) : void;
        SetCastCapsuleIndirectShadow(bNewValue: boolean) : void;
        SetForcedLOD(InNewForcedLOD: number) : void;
        SetMasterPoseComponent(NewMasterBoneComponent: $Nullable<UE.SkinnedMeshComponent>, bForceUpdate?: boolean /* = false */) : void;
        SetMinLOD(InNewMinLOD: number) : void;
        SetPhysicsAsset(NewPhysicsAsset: $Nullable<UE.PhysicsAsset>, bForceReInit?: boolean /* = false */) : void;
        SetRenderStatic(bNewValue: boolean) : void;
        SetSkeletalMesh(NewMesh: $Nullable<UE.SkeletalMesh>, bReinitPose?: boolean /* = true */) : void;
        SetSkinWeightOverride(LODIndex: number, SkinWeights: TArray<UE.SkelMeshSkinWeightInfo>) : void;
        SetSkinWeightProfile(InProfileName: string) : boolean;
        SetVertexColorOverride_LinearColor(LODIndex: number, VertexColors: TArray<UE.LinearColor>) : void;
        ShowAllMaterialSections(LODIndex: number) : void;
        ShowMaterialSection(MaterialID: number, SectionIndex: number, bShow: boolean, LODIndex: number) : void;
        TransformFromBoneSpace(BoneName: string, InPosition: UE.Vector, InRotation: UE.Rotator, OutPosition: $Ref<UE.Vector>, OutRotation: $Ref<UE.Rotator>) : void;
        TransformToBoneSpace(BoneName: string, InPosition: UE.Vector, InRotation: UE.Rotator, OutPosition: $Ref<UE.Vector>, OutRotation: $Ref<UE.Rotator>) : void;
        UnHideBoneByName(BoneName: string) : void;
        UnloadSkinWeightProfile(InProfileName: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkinnedMeshComponent;
        static Load(InName: string): SkinnedMeshComponent;
    }
    
    class AnimGroupInfo {
        constructor();
        constructor(Name: string, Color: UE.LinearColor);
        Name: string;
        Color: UE.LinearColor;
        static StaticClass(): Class;
    }
    
    class AnimParentNodeAssetOverride {
        constructor();
        constructor(NewAsset: UE.AnimationAsset, ParentNodeGuid: UE.Guid);
        NewAsset: UE.AnimationAsset;
        ParentNodeGuid: UE.Guid;
        static StaticClass(): Class;
    }
    
    class PoseWatch extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.EdGraphNode;
        PoseWatchColour: UE.Color;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PoseWatch;
        static Load(InName: string): PoseWatch;
    }
    
    enum EPreviewAnimationBlueprintApplicationMethod { LinkedLayers, LinkedAnimGraph, EPreviewAnimationBlueprintApplicationMethod_MAX}
    class AnimBlueprint extends UE.Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeleton: UE.Skeleton;
        Groups: TArray<UE.AnimGroupInfo>;
        bUseMultiThreadedAnimationUpdate: boolean;
        bWarnAboutBlueprintUsage: boolean;
        ParentAssetOverrides: TArray<UE.AnimParentNodeAssetOverride>;
        PoseWatches: TArray<UE.PoseWatch>;
        PreviewSkeletalMesh: TSoftObjectPtr<UE.SkeletalMesh>;
        PreviewAnimationBlueprint: TSoftObjectPtr<UE.AnimBlueprint>;
        PreviewAnimationBlueprintApplicationMethod: UE.EPreviewAnimationBlueprintApplicationMethod;
        PreviewAnimationBlueprintTag: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimBlueprint;
        static Load(InName: string): AnimBlueprint;
    }
    
    class DynamicBlueprintBinding extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DynamicBlueprintBinding;
        static Load(InName: string): DynamicBlueprintBinding;
    }
    
    class Property extends UE.Field {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Property;
        static Load(InName: string): Property;
    }
    
    class StructProperty extends UE.Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StructProperty;
        static Load(InName: string): StructProperty;
    }
    
    class Function extends UE.Struct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Function;
        static Load(InName: string): Function;
    }
    
    class EventGraphFastCallPair {
        constructor();
        constructor(FunctionToPatch: UE.Function, EventGraphCallOffset: number);
        FunctionToPatch: UE.Function;
        EventGraphCallOffset: number;
        static StaticClass(): Class;
    }
    
    class BlueprintGeneratedClass extends UE.Class {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumReplicatedProperties: number;
        bHasNativizedParent: boolean;
        bHasCookedComponentInstancingData: boolean;
        bIsSparseClassDataSerializable: boolean;
        DynamicBindingObjects: TArray<UE.DynamicBlueprintBinding>;
        ComponentTemplates: TArray<UE.ActorComponent>;
        Timelines: TArray<UE.TimelineTemplate>;
        ComponentClassOverrides: TArray<UE.BPComponentClassOverride>;
        SimpleConstructionScript: UE.SimpleConstructionScript;
        InheritableComponentHandler: UE.InheritableComponentHandler;
        UberGraphFramePointerProperty: UE.StructProperty;
        UberGraphFunction: UE.Function;
        FastCallPairs: TArray<UE.EventGraphFastCallPair>;
        OverridenArchetypeForCDO: UE.Object;
        PropertyGuids: TMap<string, UE.Guid>;
        CalledFunctions: TArray<UE.Function>;
        CookedComponentInstancingData: TMap<string, UE.BlueprintCookedComponentInstancingData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintGeneratedClass;
        static Load(InName: string): BlueprintGeneratedClass;
    }
    
    class BakedStateExitTransition {
        constructor();
        constructor(CanTakeDelegateIndex: number, CustomResultNodeIndex: number, TransitionIndex: number, bDesiredTransitionReturnValue: boolean, bAutomaticRemainingTimeRule: boolean, PoseEvaluatorLinks: TArray<number>);
        CanTakeDelegateIndex: number;
        CustomResultNodeIndex: number;
        TransitionIndex: number;
        bDesiredTransitionReturnValue: boolean;
        bAutomaticRemainingTimeRule: boolean;
        PoseEvaluatorLinks: TArray<number>;
        static StaticClass(): Class;
    }
    
    class BakedAnimationState {
        constructor();
        constructor(StateName: string, Transitions: TArray<UE.BakedStateExitTransition>, StateRootNodeIndex: number, StartNotify: number, EndNotify: number, FullyBlendedNotify: number, bIsAConduit: boolean, EntryRuleNodeIndex: number, PlayerNodeIndices: TArray<number>, LayerNodeIndices: TArray<number>, bAlwaysResetOnEntry: boolean);
        StateName: string;
        Transitions: TArray<UE.BakedStateExitTransition>;
        StateRootNodeIndex: number;
        StartNotify: number;
        EndNotify: number;
        FullyBlendedNotify: number;
        bIsAConduit: boolean;
        EntryRuleNodeIndex: number;
        PlayerNodeIndices: TArray<number>;
        LayerNodeIndices: TArray<number>;
        bAlwaysResetOnEntry: boolean;
        static StaticClass(): Class;
    }
    
    class AnimationStateBase {
        constructor();
        constructor(StateName: string);
        StateName: string;
        static StaticClass(): Class;
    }
    
    enum ETransitionLogicType { TLT_StandardBlend, TLT_Inertialization, TLT_Custom, TLT_MAX}
    class AnimationTransitionBetweenStates extends UE.AnimationStateBase {
        constructor();
        constructor(PreviousState: number, NextState: number, CrossfadeDuration: number, StartNotify: number, EndNotify: number, InterruptNotify: number, BlendMode: UE.EAlphaBlendOption, CustomCurve: UE.CurveFloat, BlendProfile: UE.BlendProfile, LogicType: UE.ETransitionLogicType);
        PreviousState: number;
        NextState: number;
        CrossfadeDuration: number;
        StartNotify: number;
        EndNotify: number;
        InterruptNotify: number;
        BlendMode: UE.EAlphaBlendOption;
        CustomCurve: UE.CurveFloat;
        BlendProfile: UE.BlendProfile;
        LogicType: UE.ETransitionLogicType;
        static StaticClass(): Class;
    }
    
    class BakedAnimationStateMachine {
        constructor();
        constructor(MachineName: string, InitialState: number, States: TArray<UE.BakedAnimationState>, Transitions: TArray<UE.AnimationTransitionBetweenStates>);
        MachineName: string;
        InitialState: number;
        States: TArray<UE.BakedAnimationState>;
        Transitions: TArray<UE.AnimationTransitionBetweenStates>;
        static StaticClass(): Class;
    }
    
    class CachedPoseIndices {
        constructor();
        constructor(OrderedSavedPoseNodeIndices: TArray<number>);
        OrderedSavedPoseNodeIndices: TArray<number>;
        static StaticClass(): Class;
    }
    
    enum EPostCopyOperation { None, LogicalNegateBool, EPostCopyOperation_MAX}
    enum ECopyType { MemCopy, BoolProperty, StructProperty, ObjectProperty, ECopyType_MAX}
    class ExposedValueCopyRecord {
        constructor();
        constructor(SourceProperty: UE.Property, SourcePropertyName: string, SourceSubPropertyName: string, SourceArrayIndex: number, bInstanceIsTarget: boolean, PostCopyOperation: UE.EPostCopyOperation, CopyType: UE.ECopyType, DestProperty: UE.Property, DestArrayIndex: number, Size: number, CachedSourceProperty: UE.Property, CachedSourceStructSubProperty: UE.Property);
        SourceProperty: UE.Property;
        SourcePropertyName: string;
        SourceSubPropertyName: string;
        SourceArrayIndex: number;
        bInstanceIsTarget: boolean;
        PostCopyOperation: UE.EPostCopyOperation;
        CopyType: UE.ECopyType;
        DestProperty: UE.Property;
        DestArrayIndex: number;
        Size: number;
        CachedSourceProperty: UE.Property;
        CachedSourceStructSubProperty: UE.Property;
        static StaticClass(): Class;
    }
    
    class ExposedValueHandler {
        constructor();
        constructor(BoundFunction: string, CopyRecords: TArray<UE.ExposedValueCopyRecord>, Function: UE.Function, ValueHandlerNodeProperty: UE.StructProperty);
        BoundFunction: string;
        CopyRecords: TArray<UE.ExposedValueCopyRecord>;
        Function: UE.Function;
        ValueHandlerNodeProperty: UE.StructProperty;
        static StaticClass(): Class;
    }
    
    class GraphAssetPlayerInformation {
        constructor();
        constructor(PlayerNodeIndices: TArray<number>);
        PlayerNodeIndices: TArray<number>;
        static StaticClass(): Class;
    }
    
    class AnimGraphBlendOptions {
        constructor();
        constructor(BlendInTime: number, BlendOutTime: number);
        BlendInTime: number;
        BlendOutTime: number;
        static StaticClass(): Class;
    }
    
    class AnimBlueprintGeneratedClass extends UE.BlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BakedStateMachines: TArray<UE.BakedAnimationStateMachine>;
        TargetSkeleton: UE.Skeleton;
        AnimNotifies: TArray<UE.AnimNotifyEvent>;
        OrderedSavedPoseIndicesMap: TMap<string, UE.CachedPoseIndices>;
        SyncGroupNames: TArray<string>;
        EvaluateGraphExposedInputs: TArray<UE.ExposedValueHandler>;
        GraphAssetPlayerInformation: TMap<string, UE.GraphAssetPlayerInformation>;
        GraphBlendOptions: TMap<string, UE.AnimGraphBlendOptions>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimBlueprintGeneratedClass;
        static Load(InName: string): AnimBlueprintGeneratedClass;
    }
    
    enum ERootMotionMode { NoRootMotionExtraction, IgnoreRootMotion, RootMotionFromEverything, RootMotionFromMontagesOnly, ERootMotionMode_MAX}
    class SoftClassPath extends UE.SoftObjectPath {
        constructor();
        static StaticClass(): Class;
    }
    
    class AnimNotifyEventReference {
        constructor();
        constructor(NotifySource: UE.Object);
        NotifySource: UE.Object;
        static StaticClass(): Class;
    }
    
    class AnimNotifyArray {
        constructor();
        constructor(Notifies: TArray<UE.AnimNotifyEventReference>);
        Notifies: TArray<UE.AnimNotifyEventReference>;
        static StaticClass(): Class;
    }
    
    class AnimNotifyQueue {
        constructor();
        constructor(AnimNotifies: TArray<UE.AnimNotifyEventReference>, UnfilteredMontageAnimNotifies: TMap<string, UE.AnimNotifyArray>);
        AnimNotifies: TArray<UE.AnimNotifyEventReference>;
        UnfilteredMontageAnimNotifies: TMap<string, UE.AnimNotifyArray>;
        static StaticClass(): Class;
    }
    
    class PoseSnapshot {
        constructor();
        constructor(LocalTransforms: TArray<UE.Transform>, BoneNames: TArray<string>, SkeletalMeshName: string, SnapshotName: string, bIsValid: boolean);
        LocalTransforms: TArray<UE.Transform>;
        BoneNames: TArray<string>;
        SkeletalMeshName: string;
        SnapshotName: string;
        bIsValid: boolean;
        static StaticClass(): Class;
    }
    
    enum ETeleportType { None, TeleportPhysics, ResetPhysics, ETeleportType_MAX}
    enum EMontagePlayReturnType { MontageLength, Duration, EMontagePlayReturnType_MAX}
    class MarkerSyncAnimPosition {
        constructor();
        constructor(PreviousMarkerName: string, NextMarkerName: string, PositionBetweenMarkers: number);
        PreviousMarkerName: string;
        NextMarkerName: string;
        PositionBetweenMarkers: number;
        static StaticClass(): Class;
    }
    
    enum EAnimCurveType { AttributeCurve, MaterialCurve, MorphTargetCurve, MaxAnimCurveType, EAnimCurveType_MAX}
    class AnimInstance extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurrentSkeleton: UE.Skeleton;
        RootMotionMode: UE.ERootMotionMode;
        DeltaTime: number;
        bRunUpdatesInWorkerThreads: boolean;
        bCanUseParallelUpdateAnimation: boolean;
        bWarnAboutBlueprintUsage: boolean;
        bUseMultiThreadedAnimationUpdate: boolean;
        bUsingCopyPoseFromMesh: boolean;
        bQueueMontageEvents: boolean;
        OnMontageBlendingOut: $MulticastDelegate<(Montage: $Nullable<UE.AnimMontage>, bInterrupted: boolean) => void>;
        OnMontageStarted: $MulticastDelegate<(Montage: $Nullable<UE.AnimMontage>) => void>;
        OnMontageEnded: $MulticastDelegate<(Montage: $Nullable<UE.AnimMontage>, bInterrupted: boolean) => void>;
        OnAllMontageInstancesEnded: $MulticastDelegate<() => void>;
        PostCompileValidationClassName: UE.SoftClassPath;
        NotifyQueue: UE.AnimNotifyQueue;
        ActiveAnimNotifyState: TArray<UE.AnimNotifyEvent>;
        BlueprintBeginPlay() : void;
        BlueprintInitializeAnimation() : void;
        BlueprintPostEvaluateAnimation() : void;
        BlueprintUpdateAnimation(DeltaTimeX: number) : void;
        CalculateDirection(Velocity: UE.Vector, BaseRotation: UE.Rotator) : number;
        ClearMorphTargets() : void;
        GetActiveCurveNames(CurveType: UE.EAnimCurveType, OutNames: $Ref<TArray<string>>) : void;
        GetAllCurveNames(OutNames: $Ref<TArray<string>>) : void;
        GetCurrentActiveMontage() : UE.AnimMontage;
        GetCurrentStateName(MachineIndex: number) : string;
        GetCurveValue(CurveName: string) : number;
        GetInstanceAssetPlayerLength(AssetPlayerIndex: number) : number;
        GetInstanceAssetPlayerTime(AssetPlayerIndex: number) : number;
        GetInstanceAssetPlayerTimeFraction(AssetPlayerIndex: number) : number;
        GetInstanceAssetPlayerTimeFromEnd(AssetPlayerIndex: number) : number;
        GetInstanceAssetPlayerTimeFromEndFraction(AssetPlayerIndex: number) : number;
        GetInstanceCurrentStateElapsedTime(MachineIndex: number) : number;
        GetInstanceMachineWeight(MachineIndex: number) : number;
        GetInstanceStateWeight(MachineIndex: number, StateIndex: number) : number;
        GetInstanceTransitionCrossfadeDuration(MachineIndex: number, TransitionIndex: number) : number;
        GetInstanceTransitionTimeElapsed(MachineIndex: number, TransitionIndex: number) : number;
        GetInstanceTransitionTimeElapsedFraction(MachineIndex: number, TransitionIndex: number) : number;
        GetLinkedAnimGraphInstanceByTag(InTag: string) : UE.AnimInstance;
        GetLinkedAnimGraphInstancesByTag(InTag: string, OutLinkedInstances: $Ref<TArray<UE.AnimInstance>>) : void;
        GetLinkedAnimLayerInstanceByClass(InClass: $Nullable<UE.Class>) : UE.AnimInstance;
        GetLinkedAnimLayerInstanceByGroup(InGroup: string) : UE.AnimInstance;
        GetOwningActor() : UE.Actor;
        GetOwningComponent() : UE.SkeletalMeshComponent;
        GetRelevantAnimLength(MachineIndex: number, StateIndex: number) : number;
        GetRelevantAnimTime(MachineIndex: number, StateIndex: number) : number;
        GetRelevantAnimTimeFraction(MachineIndex: number, StateIndex: number) : number;
        GetRelevantAnimTimeRemaining(MachineIndex: number, StateIndex: number) : number;
        GetRelevantAnimTimeRemainingFraction(MachineIndex: number, StateIndex: number) : number;
        GetSyncGroupPosition(InSyncGroupName: string) : UE.MarkerSyncAnimPosition;
        GetTimeToClosestMarker(SyncGroup: string, MarkerName: string, OutMarkerTime: $Ref<number>) : boolean;
        HasMarkerBeenHitThisFrame(SyncGroup: string, MarkerName: string) : boolean;
        IsAnyMontagePlaying() : boolean;
        IsPlayingSlotAnimation(Asset: $Nullable<UE.AnimSequenceBase>, SlotNodeName: string) : boolean;
        IsSyncGroupBetweenMarkers(InSyncGroupName: string, PreviousMarker: string, NextMarker: string, bRespectMarkerOrder?: boolean /* = true */) : boolean;
        LinkAnimClassLayers(InClass: $Nullable<UE.Class>) : void;
        LinkAnimGraphByTag(InTag: string, InClass: $Nullable<UE.Class>) : void;
        LockAIResources(bLockMovement: boolean, LockAILogic: boolean) : void;
        Montage_GetBlendTime(Montage: $Nullable<UE.AnimMontage>) : number;
        Montage_GetCurrentSection(Montage?: UE.AnimMontage /* = None */) : string;
        Montage_GetIsStopped(Montage: $Nullable<UE.AnimMontage>) : boolean;
        Montage_GetPlayRate(Montage: $Nullable<UE.AnimMontage>) : number;
        Montage_GetPosition(Montage: $Nullable<UE.AnimMontage>) : number;
        Montage_IsActive(Montage: $Nullable<UE.AnimMontage>) : boolean;
        Montage_IsPlaying(Montage: $Nullable<UE.AnimMontage>) : boolean;
        Montage_JumpToSection(SectionName: string, Montage?: UE.AnimMontage /* = None */) : void;
        Montage_JumpToSectionsEnd(SectionName: string, Montage?: UE.AnimMontage /* = None */) : void;
        Montage_Pause(Montage?: UE.AnimMontage /* = None */) : void;
        Montage_Play(MontageToPlay: $Nullable<UE.AnimMontage>, InPlayRate?: number /* = 1.000000 */, ReturnValueType?: UE.EMontagePlayReturnType /* = MontageLength */, InTimeToStartMontageAt?: number /* = 0.000000 */, bStopAllMontages?: boolean /* = true */) : number;
        Montage_Resume(Montage: $Nullable<UE.AnimMontage>) : void;
        Montage_SetNextSection(SectionNameToChange: string, NextSection: string, Montage?: UE.AnimMontage /* = None */) : void;
        Montage_SetPlayRate(Montage: $Nullable<UE.AnimMontage>, NewPlayRate?: number /* = 1.000000 */) : void;
        Montage_SetPosition(Montage: $Nullable<UE.AnimMontage>, NewPosition: number) : void;
        Montage_Stop(InBlendOutTime: number, Montage?: UE.AnimMontage /* = None */) : void;
        PlaySlotAnimation(Asset: $Nullable<UE.AnimSequenceBase>, SlotNodeName: string, BlendInTime?: number /* = 0.250000 */, BlendOutTime?: number /* = 0.250000 */, InPlayRate?: number /* = 1.000000 */, LoopCount?: number /* = 1 */) : number;
        PlaySlotAnimationAsDynamicMontage(Asset: $Nullable<UE.AnimSequenceBase>, SlotNodeName: string, BlendInTime?: number /* = 0.250000 */, BlendOutTime?: number /* = 0.250000 */, InPlayRate?: number /* = 1.000000 */, LoopCount?: number /* = 1 */, BlendOutTriggerTime?: number /* = -1.000000 */, InTimeToStartMontageAt?: number /* = 0.000000 */) : UE.AnimMontage;
        ResetDynamics(InTeleportType: UE.ETeleportType) : void;
        SavePoseSnapshot(SnapshotName: string) : void;
        SetMorphTarget(MorphTargetName: string, Value: number) : void;
        SetRootMotionMode(Value: UE.ERootMotionMode) : void;
        SnapshotPose(Snapshot: $Ref<UE.PoseSnapshot>) : void;
        StopSlotAnimation(InBlendOutTime?: number /* = 0.250000 */, SlotNodeName?: string /* = "None" */) : void;
        TryGetPawnOwner() : UE.Pawn;
        UnlinkAnimClassLayers(InClass: $Nullable<UE.Class>) : void;
        UnlockAIResources(bUnlockMovement: boolean, UnlockAILogic: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimInstance;
        static Load(InName: string): AnimInstance;
    }
    
    class SingleAnimationPlayData {
        constructor();
        constructor(AnimToPlay: UE.AnimationAsset, bSavedLooping: boolean, bSavedPlaying: boolean, SavedPosition: number, SavedPlayRate: number);
        AnimToPlay: UE.AnimationAsset;
        bSavedLooping: boolean;
        bSavedPlaying: boolean;
        SavedPosition: number;
        SavedPlayRate: number;
        static StaticClass(): Class;
    }
    
    enum EKinematicBonesUpdateToPhysics { SkipSimulatingBones, SkipAllBones, EKinematicBonesUpdateToPhysics_MAX}
    enum EPhysicsTransformUpdateMode { SimulationUpatesComponentTransform, ComponentTransformIsKinematic, EPhysicsTransformUpdateMode_MAX}
    enum EAnimationMode { AnimationBlueprint, AnimationSingleNode, AnimationCustomMode, EAnimationMode_MAX}
    enum EClothMassMode { UniformMass, TotalMass, Density, MaxClothMassMode, EClothMassMode_MAX}
    class ClothingSimulationInteractor extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ClothConfigUpdated() : void;
        PhysicsAssetUpdated() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingSimulationInteractor;
        static Load(InName: string): ClothingSimulationInteractor;
    }
    
    class SkeletalMeshComponent extends UE.SkinnedMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimationBlueprint: UE.AnimBlueprint;
        AnimBlueprintGeneratedClass: UE.AnimBlueprintGeneratedClass;
        AnimClass: UE.Class;
        AnimScriptInstance: UE.AnimInstance;
        SubInstances: TArray<UE.AnimInstance>;
        PostProcessAnimInstance: UE.AnimInstance;
        AnimationData: UE.SingleAnimationPlayData;
        RootBoneTranslation: UE.Vector;
        LineCheckBoundsScale: UE.Vector;
        LinkedInstances: TArray<UE.AnimInstance>;
        CachedBoneSpaceTransforms: TArray<UE.Transform>;
        CachedComponentSpaceTransforms: TArray<UE.Transform>;
        GlobalAnimRateScale: number;
        KinematicBonesUpdateType: UE.EKinematicBonesUpdateToPhysics;
        PhysicsTransformUpdateMode: UE.EPhysicsTransformUpdateMode;
        AnimationMode: UE.EAnimationMode;
        bDisablePostProcessBlueprint: boolean;
        bUpdateOverlapsOnAnimationFinalize: boolean;
        bHasValidBodies: boolean;
        bBlendPhysics: boolean;
        bEnablePhysicsOnDedicatedServer: boolean;
        bUpdateJointsFromAnimation: boolean;
        bDisableClothSimulation: boolean;
        bAllowAnimCurveEvaluation: boolean;
        bDisableAnimCurves: boolean;
        bCollideWithEnvironment: boolean;
        bCollideWithAttachedChildren: boolean;
        bLocalSpaceSimulation: boolean;
        bResetAfterTeleport: boolean;
        bDeferKinematicBoneUpdate: boolean;
        bNoSkeletonUpdate: boolean;
        bPauseAnims: boolean;
        bUseRefPoseOnInitAnim: boolean;
        bEnablePerPolyCollision: boolean;
        bForceRefpose: boolean;
        bOnlyAllowAutonomousTickPose: boolean;
        bIsAutonomousTickPose: boolean;
        bOldForceRefPose: boolean;
        bShowPrePhysBones: boolean;
        bRequiredBonesUpToDate: boolean;
        bAnimTreeInitialised: boolean;
        bIncludeComponentLocationIntoBounds: boolean;
        bEnableLineCheckWithBounds: boolean;
        bUseBendingElements: boolean;
        bUseTetrahedralConstraints: boolean;
        bUseThinShellVolumeConstraints: boolean;
        bUseSelfCollisions: boolean;
        bUseContinuousCollisionDetection: boolean;
        bPropagateCurvesToSlaves: boolean;
        bSkipKinematicUpdateWhenInterpolating: boolean;
        bSkipBoundsUpdateWhenInterpolating: boolean;
        bUpdateAnimationInEditor: boolean;
        bNeedsQueuedAnimEventsDispatched: boolean;
        CachedAnimCurveUidVersion: number;
        MassMode: UE.EClothMassMode;
        UniformMass: number;
        TotalMass: number;
        Density: number;
        MinPerParticleMass: number;
        ClothBlendWeight: number;
        EdgeStiffness: number;
        BendingStiffness: number;
        AreaStiffness: number;
        VolumeStiffness: number;
        StrainLimitingStiffness: number;
        ShapeTargetStiffness: number;
        DisallowedAnimCurves: TArray<string>;
        BodySetup: UE.BodySetup;
        OnConstraintBroken: $MulticastDelegate<(ConstraintIndex: number) => void>;
        ClothingSimulationFactory: UE.Class;
        TeleportDistanceThreshold: number;
        TeleportRotationThreshold: number;
        LastPoseTickFrame: number;
        ClothingInteractor: UE.ClothingSimulationInteractor;
        OnAnimInitialized: $MulticastDelegate<() => void>;
        SequenceToPlay: UE.AnimSequence;
        AnimToPlay: UE.AnimationAsset;
        bDefaultLooping: boolean;
        bDefaultPlaying: boolean;
        DefaultPosition: number;
        DefaultPlayRate: number;
        AccumulateAllBodiesBelowPhysicsBlendWeight(InBoneName: string, AddPhysicsBlendWeight: number, bSkipCustomPhysicsType?: boolean /* = false */) : void;
        AddForceToAllBodiesBelow(Force: UE.Vector, BoneName?: string /* = "None" */, bAccelChange?: boolean /* = false */, bIncludeSelf?: boolean /* = true */) : void;
        AddImpulseToAllBodiesBelow(Impulse: UE.Vector, BoneName?: string /* = "None" */, bVelChange?: boolean /* = false */, bIncludeSelf?: boolean /* = true */) : void;
        AllowAnimCurveEvaluation(NameOfCurve: string, bAllow: boolean) : void;
        BindClothToMasterPoseComponent() : void;
        BreakConstraint(Impulse: UE.Vector, HitLocation: UE.Vector, InBoneName: string) : void;
        ClearMorphTargets() : void;
        FindConstraintBoneName(ConstraintIndex: number) : string;
        ForceClothNextUpdateTeleport() : void;
        ForceClothNextUpdateTeleportAndReset() : void;
        GetAllowedAnimCurveEvaluate() : boolean;
        GetAnimationMode() : UE.EAnimationMode;
        GetAnimClass() : UE.Class;
        GetAnimInstance() : UE.AnimInstance;
        GetBoneMass(BoneName?: string /* = "None" */, bScaleMass?: boolean /* = true */) : number;
        GetClothingSimulationInteractor() : UE.ClothingSimulationInteractor;
        GetClothMaxDistanceScale() : number;
        GetCurrentJointAngles(InBoneName: string, Swing1Angle: $Ref<number>, TwistAngle: $Ref<number>, Swing2Angle: $Ref<number>) : void;
        GetDisableAnimCurves() : boolean;
        GetDisablePostProcessBlueprint() : boolean;
        GetLinkedAnimGraphInstanceByTag(InTag: string) : UE.AnimInstance;
        GetLinkedAnimGraphInstancesByTag(InTag: string, OutLinkedInstances: $Ref<TArray<UE.AnimInstance>>) : void;
        GetLinkedAnimLayerInstanceByClass(InClass: $Nullable<UE.Class>) : UE.AnimInstance;
        GetLinkedAnimLayerInstanceByGroup(InGroup: string) : UE.AnimInstance;
        GetMorphTarget(MorphTargetName: string) : number;
        GetPlayRate() : number;
        GetPosition() : number;
        GetPostProcessInstance() : UE.AnimInstance;
        GetSkeletalCenterOfMass() : UE.Vector;
        GetTeleportDistanceThreshold() : number;
        GetTeleportRotationThreshold() : number;
        HasValidAnimationInstance() : boolean;
        IsBodyGravityEnabled(BoneName: string) : boolean;
        IsClothingSimulationSuspended() : boolean;
        IsPlaying() : boolean;
        K2_GetClosestPointOnPhysicsAsset(WorldPosition: UE.Vector, ClosestWorldPosition: $Ref<UE.Vector>, Normal: $Ref<UE.Vector>, BoneName: $Ref<string>, Distance: $Ref<number>) : boolean;
        LinkAnimClassLayers(InClass: $Nullable<UE.Class>) : void;
        LinkAnimGraphByTag(InTag: string, InClass: $Nullable<UE.Class>) : void;
        OverrideAnimationData(InAnimToPlay: $Nullable<UE.AnimationAsset>, bIsLooping?: boolean /* = true */, bIsPlaying?: boolean /* = true */, Position?: number /* = 0.000000 */, PlayRate?: number /* = 1.000000 */) : void;
        Play(bLooping: boolean) : void;
        PlayAnimation(NewAnimToPlay: $Nullable<UE.AnimationAsset>, bLooping: boolean) : void;
        ResetAllBodiesSimulatePhysics() : void;
        ResetAllowedAnimCurveEvaluation() : void;
        ResetAnimInstanceDynamics(InTeleportType?: UE.ETeleportType /* = ResetPhysics */) : void;
        ResetClothTeleportMode() : void;
        ResumeClothingSimulation() : void;
        SetAllBodiesBelowPhysicsBlendWeight(InBoneName: string, PhysicsBlendWeight: number, bSkipCustomPhysicsType?: boolean /* = false */, bIncludeSelf?: boolean /* = true */) : void;
        SetAllBodiesBelowSimulatePhysics(InBoneName: string, bNewSimulate: boolean, bIncludeSelf?: boolean /* = true */) : void;
        SetAllBodiesPhysicsBlendWeight(PhysicsBlendWeight: number, bSkipCustomPhysicsType?: boolean /* = false */) : void;
        SetAllBodiesSimulatePhysics(bNewSimulate: boolean) : void;
        SetAllMotorsAngularDriveParams(InSpring: number, InDamping: number, InForceLimit: number, bSkipCustomPhysicsType?: boolean /* = false */) : void;
        SetAllMotorsAngularPositionDrive(bEnableSwingDrive: boolean, bEnableTwistDrive: boolean, bSkipCustomPhysicsType?: boolean /* = false */) : void;
        SetAllMotorsAngularVelocityDrive(bEnableSwingDrive: boolean, bEnableTwistDrive: boolean, bSkipCustomPhysicsType?: boolean /* = false */) : void;
        SetAllowAnimCurveEvaluation(bInAllow: boolean) : void;
        SetAllowedAnimCurvesEvaluation(List: TArray<string>, bAllow: boolean) : void;
        SetAngularLimits(InBoneName: string, Swing1LimitAngle: number, TwistLimitAngle: number, Swing2LimitAngle: number) : void;
        SetAnimation(NewAnimToPlay: $Nullable<UE.AnimationAsset>) : void;
        SetAnimationMode(InAnimationMode: UE.EAnimationMode) : void;
        SetAnimClass(NewClass: $Nullable<UE.Class>) : void;
        SetBodyNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision: boolean, BoneName?: string /* = "None" */) : void;
        SetClothMaxDistanceScale(Scale: number) : void;
        SetConstraintProfile(JointName: string, ProfileName: string, bDefaultIfNotFound?: boolean /* = false */) : void;
        SetConstraintProfileForAll(ProfileName: string, bDefaultIfNotFound?: boolean /* = false */) : void;
        SetDisableAnimCurves(bInDisableAnimCurves: boolean) : void;
        SetDisablePostProcessBlueprint(bInDisablePostProcess: boolean) : void;
        SetEnableBodyGravity(bEnableGravity: boolean, BoneName: string) : void;
        SetEnableGravityOnAllBodiesBelow(bEnableGravity: boolean, BoneName: string, bIncludeSelf?: boolean /* = true */) : void;
        SetEnablePhysicsBlending(bNewBlendPhysics: boolean) : void;
        SetMorphTarget(MorphTargetName: string, Value: number, bRemoveZeroWeight?: boolean /* = true */) : void;
        SetNotifyRigidBodyCollisionBelow(bNewNotifyRigidBodyCollision: boolean, BoneName?: string /* = "None" */, bIncludeSelf?: boolean /* = true */) : void;
        SetPhysicsBlendWeight(PhysicsBlendWeight: number) : void;
        SetPlayRate(Rate: number) : void;
        SetPosition(InPos: number, bFireNotifies?: boolean /* = true */) : void;
        SetTeleportDistanceThreshold(Threshold: number) : void;
        SetTeleportRotationThreshold(Threshold: number) : void;
        SetUpdateAnimationInEditor(NewUpdateState: boolean) : void;
        SnapshotPose(Snapshot: $Ref<UE.PoseSnapshot>) : void;
        Stop() : void;
        SuspendClothingSimulation() : void;
        TermBodiesBelow(ParentBoneName: string) : void;
        ToggleDisablePostProcessBlueprint() : void;
        UnbindClothFromMasterPoseComponent(bRestoreSimulationSpace?: boolean /* = true */) : void;
        UnlinkAnimClassLayers(InClass: $Nullable<UE.Class>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshComponent;
        static Load(InName: string): SkeletalMeshComponent;
    }
    
    enum EPlaneConstraintAxisSetting { Custom, X, Y, Z, UseGlobalPhysicsSetting, EPlaneConstraintAxisSetting_MAX}
    class MovementComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UpdatedComponent: UE.SceneComponent;
        UpdatedPrimitive: UE.PrimitiveComponent;
        Velocity: UE.Vector;
        PlaneConstraintNormal: UE.Vector;
        PlaneConstraintOrigin: UE.Vector;
        bUpdateOnlyIfRendered: boolean;
        bAutoUpdateTickRegistration: boolean;
        bTickBeforeOwner: boolean;
        bAutoRegisterUpdatedComponent: boolean;
        bConstrainToPlane: boolean;
        bSnapToPlaneAtStart: boolean;
        bAutoRegisterPhysicsVolumeUpdates: boolean;
        bComponentShouldUpdatePhysicsVolume: boolean;
        PlaneConstraintAxisSetting: UE.EPlaneConstraintAxisSetting;
        ConstrainDirectionToPlane(Direction: UE.Vector) : UE.Vector;
        ConstrainLocationToPlane(Location: UE.Vector) : UE.Vector;
        ConstrainNormalToPlane(Normal: UE.Vector) : UE.Vector;
        GetGravityZ() : number;
        GetMaxSpeed() : number;
        GetPhysicsVolume() : UE.PhysicsVolume;
        GetPlaneConstraintAxisSetting() : UE.EPlaneConstraintAxisSetting;
        GetPlaneConstraintNormal() : UE.Vector;
        GetPlaneConstraintOrigin() : UE.Vector;
        IsExceedingMaxSpeed(MaxSpeed: number) : boolean;
        K2_GetMaxSpeedModifier() : number;
        K2_GetModifiedMaxSpeed() : number;
        K2_MoveUpdatedComponent(Delta: UE.Vector, NewRotation: UE.Rotator, OutHit: $Ref<UE.HitResult>, bSweep?: boolean /* = true */, bTeleport?: boolean /* = false */) : boolean;
        PhysicsVolumeChanged(NewVolume: $Nullable<UE.PhysicsVolume>) : void;
        SetPlaneConstraintAxisSetting(NewAxisSetting: UE.EPlaneConstraintAxisSetting) : void;
        SetPlaneConstraintEnabled(bEnabled: boolean) : void;
        SetPlaneConstraintFromVectors(Forward: UE.Vector, Up: UE.Vector) : void;
        SetPlaneConstraintNormal(PlaneNormal: UE.Vector) : void;
        SetPlaneConstraintOrigin(PlaneOrigin: UE.Vector) : void;
        SetUpdatedComponent(NewUpdatedComponent: $Nullable<UE.SceneComponent>) : void;
        SnapUpdatedComponentToPlane() : void;
        StopMovementImmediately() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovementComponent;
        static Load(InName: string): MovementComponent;
    }
    
    class MovementProperties {
        constructor();
        constructor(bCanCrouch: boolean, bCanJump: boolean, bCanWalk: boolean, bCanSwim: boolean, bCanFly: boolean);
        bCanCrouch: boolean;
        bCanJump: boolean;
        bCanWalk: boolean;
        bCanSwim: boolean;
        bCanFly: boolean;
        static StaticClass(): Class;
    }
    
    class NavAgentProperties extends UE.MovementProperties {
        constructor();
        constructor(AgentRadius: number, AgentHeight: number, AgentStepHeight: number, NavWalkingSearchHeightScale: number, PreferredNavData: UE.SoftClassPath);
        AgentRadius: number;
        AgentHeight: number;
        AgentStepHeight: number;
        NavWalkingSearchHeightScale: number;
        PreferredNavData: UE.SoftClassPath;
        static StaticClass(): Class;
    }
    
    class NavMovementComponent extends UE.MovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NavAgentProps: UE.NavAgentProperties;
        FixedPathBrakingDistance: number;
        bUpdateNavAgentWithOwnersCollision: boolean;
        bUseAccelerationForPaths: boolean;
        bUseFixedBrakingDistanceForPaths: boolean;
        MovementState: UE.MovementProperties;
        PathFollowingComp: UE.Object;
        IsCrouching() : boolean;
        IsFalling() : boolean;
        IsFlying() : boolean;
        IsMovingOnGround() : boolean;
        IsSwimming() : boolean;
        StopActiveMovement() : void;
        StopMovementKeepPathing() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavMovementComponent;
        static Load(InName: string): NavMovementComponent;
    }
    
    class PawnMovementComponent extends UE.NavMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PawnOwner: UE.Pawn;
        AddInputVector(WorldVector: UE.Vector, bForce?: boolean /* = false */) : void;
        ConsumeInputVector() : UE.Vector;
        GetLastInputVector() : UE.Vector;
        GetPawnOwner() : UE.Pawn;
        GetPendingInputVector() : UE.Vector;
        IsMoveInputIgnored() : boolean;
        K2_GetInputVector() : UE.Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnMovementComponent;
        static Load(InName: string): PawnMovementComponent;
    }
    
    enum EMovementMode { MOVE_None, MOVE_Walking, MOVE_NavWalking, MOVE_Falling, MOVE_Swimming, MOVE_Flying, MOVE_Custom, MOVE_MAX}
    enum ENetworkSmoothingMode { Disabled, Linear, Exponential, Replay, ENetworkSmoothingMode_MAX}
    class FindFloorResult {
        constructor();
        constructor(bBlockingHit: boolean, bWalkableFloor: boolean, bLineTrace: boolean, FloorDist: number, LineDist: number, HitResult: UE.HitResult);
        bBlockingHit: boolean;
        bWalkableFloor: boolean;
        bLineTrace: boolean;
        FloorDist: number;
        LineDist: number;
        HitResult: UE.HitResult;
        static StaticClass(): Class;
    }
    
    class NavAvoidanceMask {
        constructor();
        constructor(bGroup0: boolean, bGroup1: boolean, bGroup2: boolean, bGroup3: boolean, bGroup4: boolean, bGroup5: boolean, bGroup6: boolean, bGroup7: boolean, bGroup8: boolean, bGroup9: boolean, bGroup10: boolean, bGroup11: boolean, bGroup12: boolean, bGroup13: boolean, bGroup14: boolean, bGroup15: boolean, bGroup16: boolean, bGroup17: boolean, bGroup18: boolean, bGroup19: boolean, bGroup20: boolean, bGroup21: boolean, bGroup22: boolean, bGroup23: boolean, bGroup24: boolean, bGroup25: boolean, bGroup26: boolean, bGroup27: boolean, bGroup28: boolean, bGroup29: boolean, bGroup30: boolean, bGroup31: boolean);
        bGroup0: boolean;
        bGroup1: boolean;
        bGroup2: boolean;
        bGroup3: boolean;
        bGroup4: boolean;
        bGroup5: boolean;
        bGroup6: boolean;
        bGroup7: boolean;
        bGroup8: boolean;
        bGroup9: boolean;
        bGroup10: boolean;
        bGroup11: boolean;
        bGroup12: boolean;
        bGroup13: boolean;
        bGroup14: boolean;
        bGroup15: boolean;
        bGroup16: boolean;
        bGroup17: boolean;
        bGroup18: boolean;
        bGroup19: boolean;
        bGroup20: boolean;
        bGroup21: boolean;
        bGroup22: boolean;
        bGroup23: boolean;
        bGroup24: boolean;
        bGroup25: boolean;
        bGroup26: boolean;
        bGroup27: boolean;
        bGroup28: boolean;
        bGroup29: boolean;
        bGroup30: boolean;
        bGroup31: boolean;
        static StaticClass(): Class;
    }
    
    class CharacterMovementComponentPostPhysicsTickFunction extends UE.TickFunction {
        constructor();
        static StaticClass(): Class;
    }
    
    class RootMotionSourceSettings {
        constructor();
        constructor(Flags: number);
        Flags: number;
        static StaticClass(): Class;
    }
    
    class Vector_NetQuantize10 extends UE.Vector {
        constructor();
        static StaticClass(): Class;
    }
    
    class RootMotionSourceGroup {
        constructor();
        constructor(bHasAdditiveSources: boolean, bHasOverrideSources: boolean, bIsAdditiveVelocityApplied: boolean, LastAccumulatedSettings: UE.RootMotionSourceSettings, LastPreAdditiveVelocity: UE.Vector_NetQuantize10);
        bHasAdditiveSources: boolean;
        bHasOverrideSources: boolean;
        bIsAdditiveVelocityApplied: boolean;
        LastAccumulatedSettings: UE.RootMotionSourceSettings;
        LastPreAdditiveVelocity: UE.Vector_NetQuantize10;
        static StaticClass(): Class;
    }
    
    class RootMotionMovementParams {
        constructor();
        constructor(bHasRootMotion: boolean, BlendWeight: number, RootMotionTransform: UE.Transform);
        bHasRootMotion: boolean;
        BlendWeight: number;
        RootMotionTransform: UE.Transform;
        static StaticClass(): Class;
    }
    
    class CharacterMovementComponent extends UE.PawnMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CharacterOwner: UE.Character;
        GravityScale: number;
        MaxStepHeight: number;
        JumpZVelocity: number;
        JumpOffJumpZFactor: number;
        WalkableFloorAngle: number;
        WalkableFloorZ: number;
        MovementMode: UE.EMovementMode;
        CustomMovementMode: number;
        NetworkSmoothingMode: UE.ENetworkSmoothingMode;
        GroundFriction: number;
        MaxWalkSpeed: number;
        MaxWalkSpeedCrouched: number;
        MaxSwimSpeed: number;
        MaxFlySpeed: number;
        MaxCustomMovementSpeed: number;
        MaxAcceleration: number;
        MinAnalogWalkSpeed: number;
        BrakingFrictionFactor: number;
        BrakingFriction: number;
        BrakingSubStepTime: number;
        BrakingDecelerationWalking: number;
        BrakingDecelerationFalling: number;
        BrakingDecelerationSwimming: number;
        BrakingDecelerationFlying: number;
        AirControl: number;
        AirControlBoostMultiplier: number;
        AirControlBoostVelocityThreshold: number;
        FallingLateralFriction: number;
        CrouchedHalfHeight: number;
        Buoyancy: number;
        PerchRadiusThreshold: number;
        PerchAdditionalHeight: number;
        RotationRate: UE.Rotator;
        bUseSeparateBrakingFriction: boolean;
        bApplyGravityWhileJumping: boolean;
        bUseControllerDesiredRotation: boolean;
        bOrientRotationToMovement: boolean;
        bSweepWhileNavWalking: boolean;
        bMovementInProgress: boolean;
        bEnableScopedMovementUpdates: boolean;
        bEnableServerDualMoveScopedMovementUpdates: boolean;
        bForceMaxAccel: boolean;
        bRunPhysicsWithNoController: boolean;
        bForceNextFloorCheck: boolean;
        bShrinkProxyCapsule: boolean;
        bCanWalkOffLedges: boolean;
        bCanWalkOffLedgesWhenCrouching: boolean;
        bNetworkSkipProxyPredictionOnNetUpdate: boolean;
        bNetworkAlwaysReplicateTransformUpdateTimestamp: boolean;
        bDeferUpdateMoveComponent: boolean;
        bEnablePhysicsInteraction: boolean;
        bTouchForceScaledToMass: boolean;
        bPushForceScaledToMass: boolean;
        bPushForceUsingZOffset: boolean;
        bScalePushForceToVelocity: boolean;
        DeferredUpdatedMoveComponent: UE.SceneComponent;
        MaxOutOfWaterStepHeight: number;
        OutofWaterZ: number;
        Mass: number;
        StandingDownwardForceScale: number;
        InitialPushForceFactor: number;
        PushForceFactor: number;
        PushForcePointZOffsetFactor: number;
        TouchForceFactor: number;
        MinTouchForce: number;
        MaxTouchForce: number;
        RepulsionForce: number;
        bForceBraking: boolean;
        CrouchedSpeedMultiplier: number;
        UpperImpactNormalScale: number;
        Acceleration: UE.Vector;
        LastUpdateRotation: UE.Quat;
        LastUpdateLocation: UE.Vector;
        LastUpdateVelocity: UE.Vector;
        ServerLastTransformUpdateTimeStamp: number;
        ServerLastClientGoodMoveAckTime: number;
        ServerLastClientAdjustmentTime: number;
        PendingImpulseToApply: UE.Vector;
        PendingForceToApply: UE.Vector;
        AnalogInputModifier: number;
        MaxSimulationTimeStep: number;
        MaxSimulationIterations: number;
        MaxJumpApexAttemptsPerSimulation: number;
        MaxDepenetrationWithGeometry: number;
        MaxDepenetrationWithGeometryAsProxy: number;
        MaxDepenetrationWithPawn: number;
        MaxDepenetrationWithPawnAsProxy: number;
        NetworkSimulatedSmoothLocationTime: number;
        NetworkSimulatedSmoothRotationTime: number;
        ListenServerNetworkSimulatedSmoothLocationTime: number;
        ListenServerNetworkSimulatedSmoothRotationTime: number;
        NetProxyShrinkRadius: number;
        NetProxyShrinkHalfHeight: number;
        NetworkMaxSmoothUpdateDistance: number;
        NetworkNoSmoothUpdateDistance: number;
        NetworkMinTimeBetweenClientAckGoodMoves: number;
        NetworkMinTimeBetweenClientAdjustments: number;
        NetworkMinTimeBetweenClientAdjustmentsLargeCorrection: number;
        NetworkLargeClientCorrectionDistance: number;
        LedgeCheckThreshold: number;
        JumpOutOfWaterPitch: number;
        CurrentFloor: UE.FindFloorResult;
        DefaultLandMovementMode: UE.EMovementMode;
        DefaultWaterMovementMode: UE.EMovementMode;
        GroundMovementMode: UE.EMovementMode;
        bMaintainHorizontalGroundVelocity: boolean;
        bImpartBaseVelocityX: boolean;
        bImpartBaseVelocityY: boolean;
        bImpartBaseVelocityZ: boolean;
        bImpartBaseAngularVelocity: boolean;
        bJustTeleported: boolean;
        bNetworkUpdateReceived: boolean;
        bNetworkMovementModeChanged: boolean;
        bIgnoreClientMovementErrorChecksAndCorrection: boolean;
        bServerAcceptClientAuthoritativePosition: boolean;
        bNotifyApex: boolean;
        bCheatFlying: boolean;
        bWantsToCrouch: boolean;
        bCrouchMaintainsBaseLocation: boolean;
        bIgnoreBaseRotation: boolean;
        bFastAttachedMove: boolean;
        bAlwaysCheckFloor: boolean;
        bUseFlatBaseForFloorChecks: boolean;
        bPerformingJumpOff: boolean;
        bWantsToLeaveNavWalking: boolean;
        bUseRVOAvoidance: boolean;
        bRequestedMoveUseAcceleration: boolean;
        bWasSimulatingRootMotion: boolean;
        bAllowPhysicsRotationDuringAnimRootMotion: boolean;
        bHasRequestedVelocity: boolean;
        bRequestedMoveWithMaxSpeed: boolean;
        bWasAvoidanceUpdated: boolean;
        bProjectNavMeshWalking: boolean;
        bProjectNavMeshOnBothWorldChannels: boolean;
        AvoidanceConsiderationRadius: number;
        RequestedVelocity: UE.Vector;
        AvoidanceUID: number;
        AvoidanceGroup: UE.NavAvoidanceMask;
        GroupsToAvoid: UE.NavAvoidanceMask;
        GroupsToIgnore: UE.NavAvoidanceMask;
        AvoidanceWeight: number;
        PendingLaunchVelocity: UE.Vector;
        NavMeshProjectionInterval: number;
        NavMeshProjectionTimer: number;
        NavMeshProjectionInterpSpeed: number;
        NavMeshProjectionHeightScaleUp: number;
        NavMeshProjectionHeightScaleDown: number;
        NavWalkingFloorDistTolerance: number;
        PostPhysicsTickFunction: UE.CharacterMovementComponentPostPhysicsTickFunction;
        MinTimeBetweenTimeStampResets: number;
        CurrentRootMotion: UE.RootMotionSourceGroup;
        RootMotionParams: UE.RootMotionMovementParams;
        AnimRootMotionVelocity: UE.Vector;
        AddForce(Force: UE.Vector) : void;
        AddImpulse(Impulse: UE.Vector, bVelocityChange?: boolean /* = false */) : void;
        CalcVelocity(DeltaTime: number, Friction: number, bFluid: boolean, BrakingDeceleration: number) : void;
        CapsuleTouched(OverlappedComp: $Nullable<UE.PrimitiveComponent>, Other: $Nullable<UE.Actor>, OtherComp: $Nullable<UE.PrimitiveComponent>, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: UE.HitResult) : void;
        ClearAccumulatedForces() : void;
        DisableMovement() : void;
        GetAnalogInputModifier() : number;
        GetCharacterOwner() : UE.Character;
        GetCurrentAcceleration() : UE.Vector;
        GetImpartedMovementBaseVelocity() : UE.Vector;
        GetLastUpdateLocation() : UE.Vector;
        GetLastUpdateRotation() : UE.Rotator;
        GetLastUpdateVelocity() : UE.Vector;
        GetMaxAcceleration() : number;
        GetMaxBrakingDeceleration() : number;
        GetMaxJumpHeight() : number;
        GetMaxJumpHeightWithJumpTime() : number;
        GetMinAnalogSpeed() : number;
        GetMovementBase() : UE.PrimitiveComponent;
        GetPerchRadiusThreshold() : number;
        GetValidPerchRadius() : number;
        IsWalkable(Hit: UE.HitResult) : boolean;
        IsWalking() : boolean;
        K2_ComputeFloorDist(CapsuleLocation: UE.Vector, LineDistance: number, SweepDistance: number, SweepRadius: number, FloorResult: $Ref<UE.FindFloorResult>) : void;
        K2_FindFloor(CapsuleLocation: UE.Vector, FloorResult: $Ref<UE.FindFloorResult>) : void;
        K2_GetModifiedMaxAcceleration() : number;
        K2_GetWalkableFloorAngle() : number;
        K2_GetWalkableFloorZ() : number;
        SetAvoidanceEnabled(bEnable: boolean) : void;
        SetAvoidanceGroup(GroupFlags: number) : void;
        SetAvoidanceGroupMask(GroupMask: UE.NavAvoidanceMask) : void;
        SetGroupsToAvoid(GroupFlags: number) : void;
        SetGroupsToAvoidMask(GroupMask: UE.NavAvoidanceMask) : void;
        SetGroupsToIgnore(GroupFlags: number) : void;
        SetGroupsToIgnoreMask(GroupMask: UE.NavAvoidanceMask) : void;
        SetMovementMode(NewMovementMode: UE.EMovementMode, NewCustomMode?: number /* = 0 */) : void;
        SetWalkableFloorAngle(InWalkableFloorAngle: number) : void;
        SetWalkableFloorZ(InWalkableFloorZ: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CharacterMovementComponent;
        static Load(InName: string): CharacterMovementComponent;
    }
    
    class ShapeComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShapeBodySetup: UE.BodySetup;
        AreaClass: UE.Class;
        ShapeColor: UE.Color;
        bDrawOnlyIfSelected: boolean;
        bShouldCollideWhenPlacing: boolean;
        bDynamicObstacle: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ShapeComponent;
        static Load(InName: string): ShapeComponent;
    }
    
    class CapsuleComponent extends UE.ShapeComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CapsuleHalfHeight: number;
        CapsuleRadius: number;
        CapsuleHeight: number;
        GetScaledCapsuleHalfHeight() : number;
        GetScaledCapsuleHalfHeight_WithoutHemisphere() : number;
        GetScaledCapsuleRadius() : number;
        GetScaledCapsuleSize(OutRadius: $Ref<number>, OutHalfHeight: $Ref<number>) : void;
        GetScaledCapsuleSize_WithoutHemisphere(OutRadius: $Ref<number>, OutHalfHeightWithoutHemisphere: $Ref<number>) : void;
        GetShapeScale() : number;
        GetUnscaledCapsuleHalfHeight() : number;
        GetUnscaledCapsuleHalfHeight_WithoutHemisphere() : number;
        GetUnscaledCapsuleRadius() : number;
        GetUnscaledCapsuleSize(OutRadius: $Ref<number>, OutHalfHeight: $Ref<number>) : void;
        GetUnscaledCapsuleSize_WithoutHemisphere(OutRadius: $Ref<number>, OutHalfHeightWithoutHemisphere: $Ref<number>) : void;
        SetCapsuleHalfHeight(HalfHeight: number, bUpdateOverlaps?: boolean /* = true */) : void;
        SetCapsuleRadius(Radius: number, bUpdateOverlaps?: boolean /* = true */) : void;
        SetCapsuleSize(InRadius: number, InHalfHeight: number, bUpdateOverlaps?: boolean /* = true */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CapsuleComponent;
        static Load(InName: string): CapsuleComponent;
    }
    
    class ArrowComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ArrowColor: UE.Color;
        ArrowSize: number;
        ScreenSize: number;
        bIsScreenSizeScaled: boolean;
        bTreatAsASprite: boolean;
        SpriteCategoryName: string;
        SpriteInfo: UE.SpriteCategoryInfo;
        bLightAttachment: boolean;
        bUseInEditorScaling: boolean;
        SetArrowColor(NewColor: UE.LinearColor) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ArrowComponent;
        static Load(InName: string): ArrowComponent;
    }
    
    class BasedMovementInfo {
        constructor();
        constructor(MovementBase: UE.PrimitiveComponent, BoneName: string, Location: UE.Vector_NetQuantize100, Rotation: UE.Rotator, bServerHasBaseComponent: boolean, bRelativeRotation: boolean, bServerHasVelocity: boolean);
        MovementBase: UE.PrimitiveComponent;
        BoneName: string;
        Location: UE.Vector_NetQuantize100;
        Rotation: UE.Rotator;
        bServerHasBaseComponent: boolean;
        bRelativeRotation: boolean;
        bServerHasVelocity: boolean;
        static StaticClass(): Class;
    }
    
    class RepRootMotionMontage {
        constructor();
        constructor(bIsActive: boolean, AnimMontage: UE.AnimMontage, Position: number, Location: UE.Vector_NetQuantize100, Rotation: UE.Rotator, MovementBase: UE.PrimitiveComponent, MovementBaseBoneName: string, bRelativePosition: boolean, bRelativeRotation: boolean, AuthoritativeRootMotion: UE.RootMotionSourceGroup, Acceleration: UE.Vector_NetQuantize10, LinearVelocity: UE.Vector_NetQuantize10);
        bIsActive: boolean;
        AnimMontage: UE.AnimMontage;
        Position: number;
        Location: UE.Vector_NetQuantize100;
        Rotation: UE.Rotator;
        MovementBase: UE.PrimitiveComponent;
        MovementBaseBoneName: string;
        bRelativePosition: boolean;
        bRelativeRotation: boolean;
        AuthoritativeRootMotion: UE.RootMotionSourceGroup;
        Acceleration: UE.Vector_NetQuantize10;
        LinearVelocity: UE.Vector_NetQuantize10;
        static StaticClass(): Class;
    }
    
    class SimulatedRootMotionReplicatedMove {
        constructor();
        constructor(Time: number, RootMotion: UE.RepRootMotionMontage);
        Time: number;
        RootMotion: UE.RepRootMotionMontage;
        static StaticClass(): Class;
    }
    
    class Character extends UE.Pawn {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Mesh: UE.SkeletalMeshComponent;
        CharacterMovement: UE.CharacterMovementComponent;
        CapsuleComponent: UE.CapsuleComponent;
        ArrowComponent: UE.ArrowComponent;
        BasedMovement: UE.BasedMovementInfo;
        ReplicatedBasedMovement: UE.BasedMovementInfo;
        AnimRootMotionTranslationScale: number;
        BaseTranslationOffset: UE.Vector;
        BaseRotationOffset: UE.Quat;
        ReplicatedServerLastTransformUpdateTimeStamp: number;
        ReplayLastTransformUpdateTimeStamp: number;
        ReplicatedMovementMode: number;
        bInBaseReplication: boolean;
        CrouchedEyeHeight: number;
        bIsCrouched: boolean;
        bProxyIsJumpForceApplied: boolean;
        bPressedJump: boolean;
        bClientUpdating: boolean;
        bClientWasFalling: boolean;
        bClientResimulateRootMotion: boolean;
        bClientResimulateRootMotionSources: boolean;
        bSimGravityDisabled: boolean;
        bClientCheckEncroachmentOnNetUpdate: boolean;
        bServerMoveIgnoreRootMotion: boolean;
        bWasJumping: boolean;
        JumpKeyHoldTime: number;
        JumpForceTimeRemaining: number;
        ProxyJumpForceStartedTime: number;
        JumpMaxHoldTime: number;
        JumpMaxCount: number;
        JumpCurrentCount: number;
        OnReachedJumpApex: $MulticastDelegate<() => void>;
        MovementModeChangedDelegate: $MulticastDelegate<(Character: $Nullable<UE.Character>, PrevMovementMode: UE.EMovementMode, PreviousCustomMode: number) => void>;
        OnCharacterMovementUpdated: $MulticastDelegate<(DeltaSeconds: number, OldLocation: UE.Vector, OldVelocity: UE.Vector) => void>;
        SavedRootMotion: UE.RootMotionSourceGroup;
        ClientRootMotionParams: UE.RootMotionMovementParams;
        RootMotionRepMoves: TArray<UE.SimulatedRootMotionReplicatedMove>;
        RepRootMotion: UE.RepRootMotionMontage;
        CacheInitialMeshOffset(MeshRelativeLocation: UE.Vector, MeshRelativeRotation: UE.Rotator) : void;
        CanCrouch() : boolean;
        CanJump() : boolean;
        CanJumpInternal() : boolean;
        ClientAckGoodMove(TimeStamp: number) : void;
        ClientAdjustPosition(TimeStamp: number, NewLoc: UE.Vector, NewVel: UE.Vector, NewBase: $Nullable<UE.PrimitiveComponent>, NewBaseBoneName: string, bHasBase: boolean, bBaseRelativePosition: boolean, ServerMovementMode: number) : void;
        ClientAdjustRootMotionPosition(TimeStamp: number, ServerMontageTrackPosition: number, ServerLoc: UE.Vector, ServerRotation: UE.Vector_NetQuantizeNormal, ServerVelZ: number, ServerBase: $Nullable<UE.PrimitiveComponent>, ServerBoneName: string, bHasBase: boolean, bBaseRelativePosition: boolean, ServerMovementMode: number) : void;
        ClientAdjustRootMotionSourcePosition(TimeStamp: number, ServerRootMotion: UE.RootMotionSourceGroup, bHasAnimRootMotion: boolean, ServerMontageTrackPosition: number, ServerLoc: UE.Vector, ServerRotation: UE.Vector_NetQuantizeNormal, ServerVelZ: number, ServerBase: $Nullable<UE.PrimitiveComponent>, ServerBoneName: string, bHasBase: boolean, bBaseRelativePosition: boolean, ServerMovementMode: number) : void;
        ClientCheatFly() : void;
        ClientCheatGhost() : void;
        ClientCheatWalk() : void;
        ClientVeryShortAdjustPosition(TimeStamp: number, NewLoc: UE.Vector, NewBase: $Nullable<UE.PrimitiveComponent>, NewBaseBoneName: string, bHasBase: boolean, bBaseRelativePosition: boolean, ServerMovementMode: number) : void;
        Crouch(bClientSimulation?: boolean /* = false */) : void;
        GetAnimRootMotionTranslationScale() : number;
        GetBaseRotationOffsetRotator() : UE.Rotator;
        GetBaseTranslationOffset() : UE.Vector;
        GetCurrentMontage() : UE.AnimMontage;
        HasAnyRootMotion() : boolean;
        IsJumpProvidingForce() : boolean;
        IsPlayingNetworkedRootMotionMontage() : boolean;
        IsPlayingRootMotion() : boolean;
        Jump() : void;
        K2_OnEndCrouch(HalfHeightAdjust: number, ScaledHalfHeightAdjust: number) : void;
        K2_OnMovementModeChanged(PrevMovementMode: UE.EMovementMode, NewMovementMode: UE.EMovementMode, PrevCustomMode: number, NewCustomMode: number) : void;
        K2_OnStartCrouch(HalfHeightAdjust: number, ScaledHalfHeightAdjust: number) : void;
        K2_UpdateCustomMovement(DeltaTime: number) : void;
        LaunchCharacter(LaunchVelocity: UE.Vector, bXYOverride: boolean, bZOverride: boolean) : void;
        OnJumped() : void;
        OnLanded(Hit: UE.HitResult) : void;
        OnLaunched(LaunchVelocity: UE.Vector, bXYOverride: boolean, bZOverride: boolean) : void;
        OnRep_IsCrouched() : void;
        OnRep_ReplayLastTransformUpdateTimeStamp() : void;
        OnRep_ReplicatedBasedMovement() : void;
        OnRep_RootMotion() : void;
        OnWalkingOffLedge(PreviousFloorImpactNormal: UE.Vector, PreviousFloorContactNormal: UE.Vector, PreviousLocation: UE.Vector, TimeDelta: number) : void;
        PlayAnimMontage(AnimMontage: $Nullable<UE.AnimMontage>, InPlayRate?: number /* = 1.000000 */, StartSectionName?: string /* = "None" */) : number;
        RootMotionDebugClientPrintOnScreen(InString: string) : void;
        ServerMove(TimeStamp: number, InAccel: UE.Vector_NetQuantize10, ClientLoc: UE.Vector_NetQuantize100, CompressedMoveFlags: number, ClientRoll: number, View: number, ClientMovementBase: $Nullable<UE.PrimitiveComponent>, ClientBaseBoneName: string, ClientMovementMode: number) : void;
        ServerMoveDual(TimeStamp0: number, InAccel0: UE.Vector_NetQuantize10, PendingFlags: number, View0: number, TimeStamp: number, InAccel: UE.Vector_NetQuantize10, ClientLoc: UE.Vector_NetQuantize100, NewFlags: number, ClientRoll: number, View: number, ClientMovementBase: $Nullable<UE.PrimitiveComponent>, ClientBaseBoneName: string, ClientMovementMode: number) : void;
        ServerMoveDualHybridRootMotion(TimeStamp0: number, InAccel0: UE.Vector_NetQuantize10, PendingFlags: number, View0: number, TimeStamp: number, InAccel: UE.Vector_NetQuantize10, ClientLoc: UE.Vector_NetQuantize100, NewFlags: number, ClientRoll: number, View: number, ClientMovementBase: $Nullable<UE.PrimitiveComponent>, ClientBaseBoneName: string, ClientMovementMode: number) : void;
        ServerMoveDualNoBase(TimeStamp0: number, InAccel0: UE.Vector_NetQuantize10, PendingFlags: number, View0: number, TimeStamp: number, InAccel: UE.Vector_NetQuantize10, ClientLoc: UE.Vector_NetQuantize100, NewFlags: number, ClientRoll: number, View: number, ClientMovementMode: number) : void;
        ServerMoveNoBase(TimeStamp: number, InAccel: UE.Vector_NetQuantize10, ClientLoc: UE.Vector_NetQuantize100, CompressedMoveFlags: number, ClientRoll: number, View: number, ClientMovementMode: number) : void;
        ServerMoveOld(OldTimeStamp: number, OldAccel: UE.Vector_NetQuantize10, OldMoveFlags: number) : void;
        StopAnimMontage(AnimMontage?: UE.AnimMontage /* = None */) : void;
        StopJumping() : void;
        UnCrouch(bClientSimulation?: boolean /* = false */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Character;
        static Load(InName: string): Character;
    }
    
    class Player extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlayerController: UE.PlayerController;
        CurrentNetSpeed: number;
        ConfiguredInternetSpeed: number;
        ConfiguredLanSpeed: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Player;
        static Load(InName: string): Player;
    }
    
    class InterpTrackInst extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInst;
        static Load(InName: string): InterpTrackInst;
    }
    
    class InterpTrackInstDirector extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OldViewTarget: UE.Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstDirector;
        static Load(InName: string): InterpTrackInstDirector;
    }
    
    class ReporterBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReporterBase;
        static Load(InName: string): ReporterBase;
    }
    
    class ReporterGraph extends UE.ReporterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReporterGraph;
        static Load(InName: string): ReporterGraph;
    }
    
    class CanvasUVTri {
        constructor();
        constructor(V0_Pos: UE.Vector2D, V0_UV: UE.Vector2D, V0_Color: UE.LinearColor, V1_Pos: UE.Vector2D, V1_UV: UE.Vector2D, V1_Color: UE.LinearColor, V2_Pos: UE.Vector2D, V2_UV: UE.Vector2D, V2_Color: UE.LinearColor);
        V0_Pos: UE.Vector2D;
        V0_UV: UE.Vector2D;
        V0_Color: UE.LinearColor;
        V1_Pos: UE.Vector2D;
        V1_UV: UE.Vector2D;
        V1_Color: UE.LinearColor;
        V2_Pos: UE.Vector2D;
        V2_UV: UE.Vector2D;
        V2_Color: UE.LinearColor;
        static StaticClass(): Class;
    }
    
    class Canvas extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OrgX: number;
        OrgY: number;
        ClipX: number;
        ClipY: number;
        DrawColor: UE.Color;
        bCenterX: boolean;
        bCenterY: boolean;
        bNoSmooth: boolean;
        SizeX: number;
        SizeY: number;
        ColorModulate: UE.Plane;
        DefaultTexture: UE.Texture2D;
        GradientTexture0: UE.Texture2D;
        ReporterGraph: UE.ReporterGraph;
        K2_Deproject(ScreenPosition: UE.Vector2D, WorldOrigin: $Ref<UE.Vector>, WorldDirection: $Ref<UE.Vector>) : void;
        K2_DrawBorder(BorderTexture: $Nullable<UE.Texture>, BackgroundTexture: $Nullable<UE.Texture>, LeftBorderTexture: $Nullable<UE.Texture>, RightBorderTexture: $Nullable<UE.Texture>, TopBorderTexture: $Nullable<UE.Texture>, BottomBorderTexture: $Nullable<UE.Texture>, ScreenPosition: UE.Vector2D, ScreenSize: UE.Vector2D, CoordinatePosition: UE.Vector2D, CoordinateSize?: UE.Vector2D /* = (X=1.000,Y=1.000) */, RenderColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, BorderScale?: UE.Vector2D /* = (X=0.100,Y=0.100) */, BackgroundScale?: UE.Vector2D /* = (X=0.100,Y=0.100) */, Rotation?: number /* = 0.000000 */, PivotPoint?: UE.Vector2D /* = (X=0.500,Y=0.500) */, CornerSize?: UE.Vector2D /* =  */) : void;
        K2_DrawBox(ScreenPosition: UE.Vector2D, ScreenSize: UE.Vector2D, Thickness?: number /* = 1.000000 */, RenderColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */) : void;
        K2_DrawLine(ScreenPositionA?: UE.Vector2D /* =  */, ScreenPositionB?: UE.Vector2D /* =  */, Thickness?: number /* = 1.000000 */, RenderColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */) : void;
        K2_DrawMaterial(RenderMaterial: $Nullable<UE.MaterialInterface>, ScreenPosition: UE.Vector2D, ScreenSize: UE.Vector2D, CoordinatePosition: UE.Vector2D, CoordinateSize?: UE.Vector2D /* = (X=1.000,Y=1.000) */, Rotation?: number /* = 0.000000 */, PivotPoint?: UE.Vector2D /* = (X=0.500,Y=0.500) */) : void;
        K2_DrawMaterialTriangle(RenderMaterial: $Nullable<UE.MaterialInterface>, Triangles: TArray<UE.CanvasUVTri>) : void;
        K2_DrawPolygon(RenderTexture: $Nullable<UE.Texture>, ScreenPosition: UE.Vector2D, Radius?: UE.Vector2D /* = (X=1.000,Y=1.000) */, NumberOfSides?: number /* = 3 */, RenderColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */) : void;
        K2_DrawText(RenderFont: $Nullable<UE.Font>, RenderText: string, ScreenPosition: UE.Vector2D, Scale?: UE.Vector2D /* = (X=1.000,Y=1.000) */, RenderColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Kerning?: number /* = 0.000000 */, ShadowColor?: UE.LinearColor /* = (R=0.000000,G=0.000000,B=0.000000,A=1.000000) */, ShadowOffset?: UE.Vector2D /* = (X=1.000,Y=1.000) */, bCentreX?: boolean /* = false */, bCentreY?: boolean /* = false */, bOutlined?: boolean /* = false */, OutlineColor?: UE.LinearColor /* = (R=0.000000,G=0.000000,B=0.000000,A=1.000000) */) : void;
        K2_DrawTexture(RenderTexture: $Nullable<UE.Texture>, ScreenPosition: UE.Vector2D, ScreenSize: UE.Vector2D, CoordinatePosition: UE.Vector2D, CoordinateSize?: UE.Vector2D /* = (X=1.000,Y=1.000) */, RenderColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, BlendMode?: UE.EBlendMode /* = BLEND_Translucent */, Rotation?: number /* = 0.000000 */, PivotPoint?: UE.Vector2D /* = (X=0.500,Y=0.500) */) : void;
        K2_DrawTriangle(RenderTexture: $Nullable<UE.Texture>, Triangles: TArray<UE.CanvasUVTri>) : void;
        K2_Project(WorldLocation: UE.Vector) : UE.Vector;
        K2_StrLen(RenderFont: $Nullable<UE.Font>, RenderText: string) : UE.Vector2D;
        K2_TextSize(RenderFont: $Nullable<UE.Font>, RenderText: string, Scale?: UE.Vector2D /* = (X=1.000,Y=1.000) */) : UE.Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Canvas;
        static Load(InName: string): Canvas;
    }
    
    class DebugTextInfo {
        constructor();
        constructor(SrcActor: UE.Actor, SrcActorOffset: UE.Vector, SrcActorDesiredOffset: UE.Vector, DebugText: string, TimeRemaining: number, Duration: number, TextColor: UE.Color, bAbsoluteLocation: boolean, bKeepAttachedToActor: boolean, bDrawShadow: boolean, OrigActorLocation: UE.Vector, Font: UE.Font, FontScale: number);
        SrcActor: UE.Actor;
        SrcActorOffset: UE.Vector;
        SrcActorDesiredOffset: UE.Vector;
        DebugText: string;
        TimeRemaining: number;
        Duration: number;
        TextColor: UE.Color;
        bAbsoluteLocation: boolean;
        bKeepAttachedToActor: boolean;
        bDrawShadow: boolean;
        OrigActorLocation: UE.Vector;
        Font: UE.Font;
        FontScale: number;
        static StaticClass(): Class;
    }
    
    class HUD extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlayerOwner: UE.PlayerController;
        bLostFocusPaused: boolean;
        bShowHUD: boolean;
        bShowDebugInfo: boolean;
        CurrentTargetIndex: number;
        bShowHitBoxDebugInfo: boolean;
        bShowOverlays: boolean;
        bEnableDebugTextShadow: boolean;
        PostRenderedActors: TArray<UE.Actor>;
        DebugDisplay: TArray<string>;
        ToggledDebugCategories: TArray<string>;
        Canvas: UE.Canvas;
        DebugCanvas: UE.Canvas;
        DebugTextList: TArray<UE.DebugTextInfo>;
        ShowDebugTargetDesiredClass: UE.Class;
        ShowDebugTargetActor: UE.Actor;
        AddDebugText(DebugText: string, SrcActor: $Nullable<UE.Actor>, Duration: number, Offset: UE.Vector, DesiredOffset: UE.Vector, TextColor: UE.Color, bSkipOverwriteCheck: boolean, bAbsoluteLocation: boolean, bKeepAttachedToActor: boolean, InFont: $Nullable<UE.Font>, FontScale: number, bDrawShadow: boolean) : void;
        AddHitBox(Position: UE.Vector2D, Size: UE.Vector2D, InName: string, bConsumesInput: boolean, Priority?: number /* = 0 */) : void;
        Deproject(ScreenX: number, ScreenY: number, WorldPosition: $Ref<UE.Vector>, WorldDirection: $Ref<UE.Vector>) : void;
        DrawLine(StartScreenX: number, StartScreenY: number, EndScreenX: number, EndScreenY: number, LineColor: UE.LinearColor, LineThickness?: number /* = 0.000000 */) : void;
        DrawMaterial(Material: $Nullable<UE.MaterialInterface>, ScreenX: number, ScreenY: number, ScreenW: number, ScreenH: number, MaterialU: number, MaterialV: number, MaterialUWidth: number, MaterialVHeight: number, Scale?: number /* = 1.000000 */, bScalePosition?: boolean /* = false */, Rotation?: number /* = 0.000000 */, RotPivot?: UE.Vector2D /* =  */) : void;
        DrawMaterialSimple(Material: $Nullable<UE.MaterialInterface>, ScreenX: number, ScreenY: number, ScreenW: number, ScreenH: number, Scale?: number /* = 1.000000 */, bScalePosition?: boolean /* = false */) : void;
        DrawMaterialTriangle(Material: $Nullable<UE.MaterialInterface>, V0_Pos: UE.Vector2D, V1_Pos: UE.Vector2D, V2_Pos: UE.Vector2D, V0_UV: UE.Vector2D, V1_UV: UE.Vector2D, V2_UV: UE.Vector2D, V0_Color?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, V1_Color?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, V2_Color?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */) : void;
        DrawRect(RectColor: UE.LinearColor, ScreenX: number, ScreenY: number, ScreenW: number, ScreenH: number) : void;
        DrawText(Text: string, TextColor: UE.LinearColor, ScreenX: number, ScreenY: number, Font?: UE.Font /* = None */, Scale?: number /* = 1.000000 */, bScalePosition?: boolean /* = false */) : void;
        DrawTexture(Texture: $Nullable<UE.Texture>, ScreenX: number, ScreenY: number, ScreenW: number, ScreenH: number, TextureU: number, TextureV: number, TextureUWidth: number, TextureVHeight: number, TintColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, BlendMode?: UE.EBlendMode /* = BLEND_Translucent */, Scale?: number /* = 1.000000 */, bScalePosition?: boolean /* = false */, Rotation?: number /* = 0.000000 */, RotPivot?: UE.Vector2D /* =  */) : void;
        DrawTextureSimple(Texture: $Nullable<UE.Texture>, ScreenX: number, ScreenY: number, Scale?: number /* = 1.000000 */, bScalePosition?: boolean /* = false */) : void;
        GetActorsInSelectionRectangle(ClassFilter: $Nullable<UE.Class>, FirstPoint: UE.Vector2D, SecondPoint: UE.Vector2D, OutActors: $Ref<TArray<UE.Actor>>, bIncludeNonCollidingComponents?: boolean /* = true */, bActorMustBeFullyEnclosed?: boolean /* = false */) : void;
        GetOwningPawn() : UE.Pawn;
        GetOwningPlayerController() : UE.PlayerController;
        GetTextSize(Text: string, OutWidth: $Ref<number>, OutHeight: $Ref<number>, Font?: UE.Font /* = None */, Scale?: number /* = 1.000000 */) : void;
        NextDebugTarget() : void;
        PreviousDebugTarget() : void;
        Project(Location: UE.Vector) : UE.Vector;
        ReceiveDrawHUD(SizeX: number, SizeY: number) : void;
        ReceiveHitBoxBeginCursorOver(BoxName: string) : void;
        ReceiveHitBoxClick(BoxName: string) : void;
        ReceiveHitBoxEndCursorOver(BoxName: string) : void;
        ReceiveHitBoxRelease(BoxName: string) : void;
        RemoveAllDebugStrings() : void;
        RemoveDebugText(SrcActor: $Nullable<UE.Actor>, bLeaveDurationText: boolean) : void;
        ShowDebug(DebugType?: string /* = "None" */) : void;
        ShowDebugForReticleTargetToggle(DesiredClass: $Nullable<UE.Class>) : void;
        ShowDebugToggleSubCategory(Category: string) : void;
        ShowHUD() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HUD;
        static Load(InName: string): HUD;
    }
    
    enum ECameraProjectionMode { Perspective, Orthographic, ECameraProjectionMode_MAX}
    enum EBloomMethod { BM_SOG, BM_FFT, BM_MAX}
    enum EAutoExposureMethod { AEM_Histogram, AEM_Basic, AEM_Manual, AEM_MAX}
    enum EDepthOfFieldMethod { DOFM_BokehDOF, DOFM_Gaussian, DOFM_CircleDOF, DOFM_MAX}
    class TextureCube extends UE.Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureCube;
        static Load(InName: string): TextureCube;
    }
    
    enum ERayTracingGlobalIlluminationType { Disabled, BruteForce, FinalGather, ERayTracingGlobalIlluminationType_MAX}
    enum EReflectionsType { ScreenSpace, RayTracing, EReflectionsType_MAX}
    enum EReflectedAndRefractedRayTracedShadows { Disabled, Hard_shadows, Area_shadows, EReflectedAndRefractedRayTracedShadows_MAX}
    enum ETranslucencyType { Raster, RayTracing, ETranslucencyType_MAX}
    class WeightedBlendable {
        constructor();
        constructor(Weight: number, Object: UE.Object);
        Weight: number;
        Object: UE.Object;
        static StaticClass(): Class;
    }
    
    class WeightedBlendables {
        constructor();
        constructor(Array: TArray<UE.WeightedBlendable>);
        Array: TArray<UE.WeightedBlendable>;
        static StaticClass(): Class;
    }
    
    class PostProcessSettings {
        constructor();
        constructor(bOverride_WhiteTemp: boolean, bOverride_WhiteTint: boolean, bOverride_ColorSaturation: boolean, bOverride_ColorContrast: boolean, bOverride_ColorGamma: boolean, bOverride_ColorGain: boolean, bOverride_ColorOffset: boolean, bOverride_ColorSaturationShadows: boolean, bOverride_ColorContrastShadows: boolean, bOverride_ColorGammaShadows: boolean, bOverride_ColorGainShadows: boolean, bOverride_ColorOffsetShadows: boolean, bOverride_ColorSaturationMidtones: boolean, bOverride_ColorContrastMidtones: boolean, bOverride_ColorGammaMidtones: boolean, bOverride_ColorGainMidtones: boolean, bOverride_ColorOffsetMidtones: boolean, bOverride_ColorSaturationHighlights: boolean, bOverride_ColorContrastHighlights: boolean, bOverride_ColorGammaHighlights: boolean, bOverride_ColorGainHighlights: boolean, bOverride_ColorOffsetHighlights: boolean, bOverride_ColorCorrectionShadowsMax: boolean, bOverride_ColorCorrectionHighlightsMin: boolean, bOverride_BlueCorrection: boolean, bOverride_ExpandGamut: boolean, bOverride_FilmWhitePoint: boolean, bOverride_FilmSaturation: boolean, bOverride_FilmChannelMixerRed: boolean, bOverride_FilmChannelMixerGreen: boolean, bOverride_FilmChannelMixerBlue: boolean, bOverride_FilmContrast: boolean, bOverride_FilmDynamicRange: boolean, bOverride_FilmHealAmount: boolean, bOverride_FilmToeAmount: boolean, bOverride_FilmShadowTint: boolean, bOverride_FilmShadowTintBlend: boolean, bOverride_FilmShadowTintAmount: boolean, bOverride_FilmSlope: boolean, bOverride_FilmToe: boolean, bOverride_FilmShoulder: boolean, bOverride_FilmBlackClip: boolean, bOverride_FilmWhiteClip: boolean, bOverride_SceneColorTint: boolean, bOverride_SceneFringeIntensity: boolean, bOverride_ChromaticAberrationStartOffset: boolean, bOverride_AmbientCubemapTint: boolean, bOverride_AmbientCubemapIntensity: boolean, bOverride_BloomMethod: boolean, bOverride_BloomIntensity: boolean, bOverride_BloomThreshold: boolean, bOverride_Bloom1Tint: boolean, bOverride_Bloom1Size: boolean, bOverride_Bloom2Size: boolean, bOverride_Bloom2Tint: boolean, bOverride_Bloom3Tint: boolean, bOverride_Bloom3Size: boolean, bOverride_Bloom4Tint: boolean, bOverride_Bloom4Size: boolean, bOverride_Bloom5Tint: boolean, bOverride_Bloom5Size: boolean, bOverride_Bloom6Tint: boolean, bOverride_Bloom6Size: boolean, bOverride_BloomSizeScale: boolean, bOverride_BloomConvolutionTexture: boolean, bOverride_BloomConvolutionSize: boolean, bOverride_BloomConvolutionCenterUV: boolean, bOverride_BloomConvolutionPreFilter: boolean, bOverride_BloomConvolutionPreFilterMin: boolean, bOverride_BloomConvolutionPreFilterMax: boolean, bOverride_BloomConvolutionPreFilterMult: boolean, bOverride_BloomConvolutionBufferScale: boolean, bOverride_BloomDirtMaskIntensity: boolean, bOverride_BloomDirtMaskTint: boolean, bOverride_BloomDirtMask: boolean, bOverride_CameraShutterSpeed: boolean, bOverride_CameraISO: boolean, bOverride_AutoExposureMethod: boolean, bOverride_AutoExposureLowPercent: boolean, bOverride_AutoExposureHighPercent: boolean, bOverride_AutoExposureMinBrightness: boolean, bOverride_AutoExposureMaxBrightness: boolean, bOverride_AutoExposureCalibrationConstant: boolean, bOverride_AutoExposureSpeedUp: boolean, bOverride_AutoExposureSpeedDown: boolean, bOverride_AutoExposureBias: boolean, bOverride_AutoExposureBiasCurve: boolean, bOverride_HistogramLogMin: boolean, bOverride_HistogramLogMax: boolean, bOverride_LensFlareIntensity: boolean, bOverride_LensFlareTint: boolean, bOverride_LensFlareTints: boolean, bOverride_LensFlareBokehSize: boolean, bOverride_LensFlareBokehShape: boolean, bOverride_LensFlareThreshold: boolean, bOverride_VignetteIntensity: boolean, bOverride_GrainIntensity: boolean, bOverride_GrainJitter: boolean, bOverride_AmbientOcclusionIntensity: boolean, bOverride_AmbientOcclusionStaticFraction: boolean, bOverride_AmbientOcclusionRadius: boolean, bOverride_AmbientOcclusionFadeDistance: boolean, bOverride_AmbientOcclusionFadeRadius: boolean, bOverride_AmbientOcclusionDistance: boolean, bOverride_AmbientOcclusionRadiusInWS: boolean, bOverride_AmbientOcclusionPower: boolean, bOverride_AmbientOcclusionBias: boolean, bOverride_AmbientOcclusionQuality: boolean, bOverride_AmbientOcclusionMipBlend: boolean, bOverride_AmbientOcclusionMipScale: boolean, bOverride_AmbientOcclusionMipThreshold: boolean, bOverride_RayTracingAO: boolean, bOverride_RayTracingAOSamplesPerPixel: boolean, bOverride_LPVIntensity: boolean, bOverride_LPVDirectionalOcclusionIntensity: boolean, bOverride_LPVDirectionalOcclusionRadius: boolean, bOverride_LPVDiffuseOcclusionExponent: boolean, bOverride_LPVSpecularOcclusionExponent: boolean, bOverride_LPVDiffuseOcclusionIntensity: boolean, bOverride_LPVSpecularOcclusionIntensity: boolean, bOverride_LPVSize: boolean, bOverride_LPVSecondaryOcclusionIntensity: boolean, bOverride_LPVSecondaryBounceIntensity: boolean, bOverride_LPVGeometryVolumeBias: boolean, bOverride_LPVVplInjectionBias: boolean, bOverride_LPVEmissiveInjectionIntensity: boolean, bOverride_LPVFadeRange: boolean, bOverride_LPVDirectionalOcclusionFadeRange: boolean, bOverride_IndirectLightingColor: boolean, bOverride_IndirectLightingIntensity: boolean, bOverride_ColorGradingIntensity: boolean, bOverride_ColorGradingLUT: boolean, bOverride_DepthOfFieldFocalDistance: boolean, bOverride_DepthOfFieldFstop: boolean, bOverride_DepthOfFieldMinFstop: boolean, bOverride_DepthOfFieldBladeCount: boolean, bOverride_DepthOfFieldSensorWidth: boolean, bOverride_DepthOfFieldDepthBlurRadius: boolean, bOverride_DepthOfFieldDepthBlurAmount: boolean, bOverride_DepthOfFieldFocalRegion: boolean, bOverride_DepthOfFieldNearTransitionRegion: boolean, bOverride_DepthOfFieldFarTransitionRegion: boolean, bOverride_DepthOfFieldScale: boolean, bOverride_DepthOfFieldNearBlurSize: boolean, bOverride_DepthOfFieldFarBlurSize: boolean, bOverride_MobileHQGaussian: boolean, bOverride_DepthOfFieldOcclusion: boolean, bOverride_DepthOfFieldSkyFocusDistance: boolean, bOverride_DepthOfFieldVignetteSize: boolean, bOverride_MotionBlurAmount: boolean, bOverride_MotionBlurMax: boolean, bOverride_MotionBlurTargetFPS: boolean, bOverride_MotionBlurPerObjectSize: boolean, bOverride_ScreenPercentage: boolean, bOverride_ScreenSpaceReflectionIntensity: boolean, bOverride_ScreenSpaceReflectionQuality: boolean, bOverride_ScreenSpaceReflectionMaxRoughness: boolean, bOverride_ScreenSpaceReflectionRoughnessScale: boolean, bOverride_ReflectionsType: boolean, bOverride_RayTracingReflectionsMaxRoughness: boolean, bOverride_RayTracingReflectionsMaxBounces: boolean, bOverride_RayTracingReflectionsSamplesPerPixel: boolean, bOverride_RayTracingReflectionsShadows: boolean, bOverride_RayTracingReflectionsTranslucency: boolean, bOverride_TranslucencyType: boolean, bOverride_RayTracingTranslucencyMaxRoughness: boolean, bOverride_RayTracingTranslucencyRefractionRays: boolean, bOverride_RayTracingTranslucencySamplesPerPixel: boolean, bOverride_RayTracingTranslucencyShadows: boolean, bOverride_RayTracingTranslucencyRefraction: boolean, bOverride_RayTracingGI: boolean, bOverride_RayTracingGIMaxBounces: boolean, bOverride_RayTracingGISamplesPerPixel: boolean, bOverride_PathTracingMaxBounces: boolean, bOverride_PathTracingSamplesPerPixel: boolean, bMobileHQGaussian: boolean, BloomMethod: UE.EBloomMethod, AutoExposureMethod: UE.EAutoExposureMethod, DepthOfFieldMethod: UE.EDepthOfFieldMethod, WhiteTemp: number, WhiteTint: number, ColorSaturation: UE.Vector4, ColorContrast: UE.Vector4, ColorGamma: UE.Vector4, ColorGain: UE.Vector4, ColorOffset: UE.Vector4, ColorSaturationShadows: UE.Vector4, ColorContrastShadows: UE.Vector4, ColorGammaShadows: UE.Vector4, ColorGainShadows: UE.Vector4, ColorOffsetShadows: UE.Vector4, ColorSaturationMidtones: UE.Vector4, ColorContrastMidtones: UE.Vector4, ColorGammaMidtones: UE.Vector4, ColorGainMidtones: UE.Vector4, ColorOffsetMidtones: UE.Vector4, ColorSaturationHighlights: UE.Vector4, ColorContrastHighlights: UE.Vector4, ColorGammaHighlights: UE.Vector4, ColorGainHighlights: UE.Vector4, ColorOffsetHighlights: UE.Vector4, ColorCorrectionHighlightsMin: number, ColorCorrectionShadowsMax: number, BlueCorrection: number, ExpandGamut: number, FilmSlope: number, FilmToe: number, FilmShoulder: number, FilmBlackClip: number, FilmWhiteClip: number, FilmWhitePoint: UE.LinearColor, FilmShadowTint: UE.LinearColor, FilmShadowTintBlend: number, FilmShadowTintAmount: number, FilmSaturation: number, FilmChannelMixerRed: UE.LinearColor, FilmChannelMixerGreen: UE.LinearColor, FilmChannelMixerBlue: UE.LinearColor, FilmContrast: number, FilmToeAmount: number, FilmHealAmount: number, FilmDynamicRange: number, SceneColorTint: UE.LinearColor, SceneFringeIntensity: number, ChromaticAberrationStartOffset: number, BloomIntensity: number, BloomThreshold: number, BloomSizeScale: number, Bloom1Size: number, Bloom2Size: number, Bloom3Size: number, Bloom4Size: number, Bloom5Size: number, Bloom6Size: number, Bloom1Tint: UE.LinearColor, Bloom2Tint: UE.LinearColor, Bloom3Tint: UE.LinearColor, Bloom4Tint: UE.LinearColor, Bloom5Tint: UE.LinearColor, Bloom6Tint: UE.LinearColor, BloomConvolutionSize: number, BloomConvolutionTexture: UE.Texture2D, BloomConvolutionCenterUV: UE.Vector2D, BloomConvolutionPreFilter: UE.Vector, BloomConvolutionPreFilterMin: number, BloomConvolutionPreFilterMax: number, BloomConvolutionPreFilterMult: number, BloomConvolutionBufferScale: number, BloomDirtMask: UE.Texture, BloomDirtMaskIntensity: number, BloomDirtMaskTint: UE.LinearColor, AmbientCubemapTint: UE.LinearColor, AmbientCubemapIntensity: number, AmbientCubemap: UE.TextureCube, CameraShutterSpeed: number, CameraISO: number, DepthOfFieldFstop: number, DepthOfFieldMinFstop: number, DepthOfFieldBladeCount: number, AutoExposureBias: number, AutoExposureBiasCurve: UE.CurveFloat, AutoExposureLowPercent: number, AutoExposureHighPercent: number, AutoExposureMinBrightness: number, AutoExposureMaxBrightness: number, AutoExposureSpeedUp: number, AutoExposureSpeedDown: number, HistogramLogMin: number, HistogramLogMax: number, AutoExposureCalibrationConstant: number, LensFlareIntensity: number, LensFlareTint: UE.LinearColor, LensFlareBokehSize: number, LensFlareThreshold: number, LensFlareBokehShape: UE.Texture, LensFlareTints: FixSizeArray<UE.LinearColor>, VignetteIntensity: number, GrainJitter: number, GrainIntensity: number, AmbientOcclusionIntensity: number, AmbientOcclusionStaticFraction: number, AmbientOcclusionRadius: number, AmbientOcclusionRadiusInWS: boolean, AmbientOcclusionFadeDistance: number, AmbientOcclusionFadeRadius: number, AmbientOcclusionDistance: number, AmbientOcclusionPower: number, AmbientOcclusionBias: number, AmbientOcclusionQuality: number, AmbientOcclusionMipBlend: number, AmbientOcclusionMipScale: number, AmbientOcclusionMipThreshold: number, RayTracingAO: boolean, RayTracingAOSamplesPerPixel: number, IndirectLightingColor: UE.LinearColor, IndirectLightingIntensity: number, RayTracingGI: boolean, RayTracingGIType: UE.ERayTracingGlobalIlluminationType, RayTracingGIMaxBounces: number, RayTracingGISamplesPerPixel: number, ColorGradingIntensity: number, ColorGradingLUT: UE.Texture, DepthOfFieldSensorWidth: number, DepthOfFieldFocalDistance: number, DepthOfFieldDepthBlurAmount: number, DepthOfFieldDepthBlurRadius: number, DepthOfFieldFocalRegion: number, DepthOfFieldNearTransitionRegion: number, DepthOfFieldFarTransitionRegion: number, DepthOfFieldScale: number, DepthOfFieldNearBlurSize: number, DepthOfFieldFarBlurSize: number, DepthOfFieldOcclusion: number, DepthOfFieldSkyFocusDistance: number, DepthOfFieldVignetteSize: number, MotionBlurAmount: number, MotionBlurMax: number, MotionBlurTargetFPS: number, MotionBlurPerObjectSize: number, LPVIntensity: number, LPVVplInjectionBias: number, LPVSize: number, LPVSecondaryOcclusionIntensity: number, LPVSecondaryBounceIntensity: number, LPVGeometryVolumeBias: number, LPVEmissiveInjectionIntensity: number, LPVDirectionalOcclusionIntensity: number, LPVDirectionalOcclusionRadius: number, LPVDiffuseOcclusionExponent: number, LPVSpecularOcclusionExponent: number, LPVDiffuseOcclusionIntensity: number, LPVSpecularOcclusionIntensity: number, ReflectionsType: UE.EReflectionsType, ScreenSpaceReflectionIntensity: number, ScreenSpaceReflectionQuality: number, ScreenSpaceReflectionMaxRoughness: number, RayTracingReflectionsMaxRoughness: number, RayTracingReflectionsMaxBounces: number, RayTracingReflectionsSamplesPerPixel: number, RayTracingReflectionsShadows: UE.EReflectedAndRefractedRayTracedShadows, RayTracingReflectionsTranslucency: boolean, TranslucencyType: UE.ETranslucencyType, RayTracingTranslucencyMaxRoughness: number, RayTracingTranslucencyRefractionRays: number, RayTracingTranslucencySamplesPerPixel: number, RayTracingTranslucencyShadows: UE.EReflectedAndRefractedRayTracedShadows, RayTracingTranslucencyRefraction: boolean, PathTracingMaxBounces: number, PathTracingSamplesPerPixel: number, LPVFadeRange: number, LPVDirectionalOcclusionFadeRange: number, ScreenPercentage: number, WeightedBlendables: UE.WeightedBlendables, Blendables: TArray<UE.Object>);
        bOverride_WhiteTemp: boolean;
        bOverride_WhiteTint: boolean;
        bOverride_ColorSaturation: boolean;
        bOverride_ColorContrast: boolean;
        bOverride_ColorGamma: boolean;
        bOverride_ColorGain: boolean;
        bOverride_ColorOffset: boolean;
        bOverride_ColorSaturationShadows: boolean;
        bOverride_ColorContrastShadows: boolean;
        bOverride_ColorGammaShadows: boolean;
        bOverride_ColorGainShadows: boolean;
        bOverride_ColorOffsetShadows: boolean;
        bOverride_ColorSaturationMidtones: boolean;
        bOverride_ColorContrastMidtones: boolean;
        bOverride_ColorGammaMidtones: boolean;
        bOverride_ColorGainMidtones: boolean;
        bOverride_ColorOffsetMidtones: boolean;
        bOverride_ColorSaturationHighlights: boolean;
        bOverride_ColorContrastHighlights: boolean;
        bOverride_ColorGammaHighlights: boolean;
        bOverride_ColorGainHighlights: boolean;
        bOverride_ColorOffsetHighlights: boolean;
        bOverride_ColorCorrectionShadowsMax: boolean;
        bOverride_ColorCorrectionHighlightsMin: boolean;
        bOverride_BlueCorrection: boolean;
        bOverride_ExpandGamut: boolean;
        bOverride_FilmWhitePoint: boolean;
        bOverride_FilmSaturation: boolean;
        bOverride_FilmChannelMixerRed: boolean;
        bOverride_FilmChannelMixerGreen: boolean;
        bOverride_FilmChannelMixerBlue: boolean;
        bOverride_FilmContrast: boolean;
        bOverride_FilmDynamicRange: boolean;
        bOverride_FilmHealAmount: boolean;
        bOverride_FilmToeAmount: boolean;
        bOverride_FilmShadowTint: boolean;
        bOverride_FilmShadowTintBlend: boolean;
        bOverride_FilmShadowTintAmount: boolean;
        bOverride_FilmSlope: boolean;
        bOverride_FilmToe: boolean;
        bOverride_FilmShoulder: boolean;
        bOverride_FilmBlackClip: boolean;
        bOverride_FilmWhiteClip: boolean;
        bOverride_SceneColorTint: boolean;
        bOverride_SceneFringeIntensity: boolean;
        bOverride_ChromaticAberrationStartOffset: boolean;
        bOverride_AmbientCubemapTint: boolean;
        bOverride_AmbientCubemapIntensity: boolean;
        bOverride_BloomMethod: boolean;
        bOverride_BloomIntensity: boolean;
        bOverride_BloomThreshold: boolean;
        bOverride_Bloom1Tint: boolean;
        bOverride_Bloom1Size: boolean;
        bOverride_Bloom2Size: boolean;
        bOverride_Bloom2Tint: boolean;
        bOverride_Bloom3Tint: boolean;
        bOverride_Bloom3Size: boolean;
        bOverride_Bloom4Tint: boolean;
        bOverride_Bloom4Size: boolean;
        bOverride_Bloom5Tint: boolean;
        bOverride_Bloom5Size: boolean;
        bOverride_Bloom6Tint: boolean;
        bOverride_Bloom6Size: boolean;
        bOverride_BloomSizeScale: boolean;
        bOverride_BloomConvolutionTexture: boolean;
        bOverride_BloomConvolutionSize: boolean;
        bOverride_BloomConvolutionCenterUV: boolean;
        bOverride_BloomConvolutionPreFilter: boolean;
        bOverride_BloomConvolutionPreFilterMin: boolean;
        bOverride_BloomConvolutionPreFilterMax: boolean;
        bOverride_BloomConvolutionPreFilterMult: boolean;
        bOverride_BloomConvolutionBufferScale: boolean;
        bOverride_BloomDirtMaskIntensity: boolean;
        bOverride_BloomDirtMaskTint: boolean;
        bOverride_BloomDirtMask: boolean;
        bOverride_CameraShutterSpeed: boolean;
        bOverride_CameraISO: boolean;
        bOverride_AutoExposureMethod: boolean;
        bOverride_AutoExposureLowPercent: boolean;
        bOverride_AutoExposureHighPercent: boolean;
        bOverride_AutoExposureMinBrightness: boolean;
        bOverride_AutoExposureMaxBrightness: boolean;
        bOverride_AutoExposureCalibrationConstant: boolean;
        bOverride_AutoExposureSpeedUp: boolean;
        bOverride_AutoExposureSpeedDown: boolean;
        bOverride_AutoExposureBias: boolean;
        bOverride_AutoExposureBiasCurve: boolean;
        bOverride_HistogramLogMin: boolean;
        bOverride_HistogramLogMax: boolean;
        bOverride_LensFlareIntensity: boolean;
        bOverride_LensFlareTint: boolean;
        bOverride_LensFlareTints: boolean;
        bOverride_LensFlareBokehSize: boolean;
        bOverride_LensFlareBokehShape: boolean;
        bOverride_LensFlareThreshold: boolean;
        bOverride_VignetteIntensity: boolean;
        bOverride_GrainIntensity: boolean;
        bOverride_GrainJitter: boolean;
        bOverride_AmbientOcclusionIntensity: boolean;
        bOverride_AmbientOcclusionStaticFraction: boolean;
        bOverride_AmbientOcclusionRadius: boolean;
        bOverride_AmbientOcclusionFadeDistance: boolean;
        bOverride_AmbientOcclusionFadeRadius: boolean;
        bOverride_AmbientOcclusionDistance: boolean;
        bOverride_AmbientOcclusionRadiusInWS: boolean;
        bOverride_AmbientOcclusionPower: boolean;
        bOverride_AmbientOcclusionBias: boolean;
        bOverride_AmbientOcclusionQuality: boolean;
        bOverride_AmbientOcclusionMipBlend: boolean;
        bOverride_AmbientOcclusionMipScale: boolean;
        bOverride_AmbientOcclusionMipThreshold: boolean;
        bOverride_RayTracingAO: boolean;
        bOverride_RayTracingAOSamplesPerPixel: boolean;
        bOverride_LPVIntensity: boolean;
        bOverride_LPVDirectionalOcclusionIntensity: boolean;
        bOverride_LPVDirectionalOcclusionRadius: boolean;
        bOverride_LPVDiffuseOcclusionExponent: boolean;
        bOverride_LPVSpecularOcclusionExponent: boolean;
        bOverride_LPVDiffuseOcclusionIntensity: boolean;
        bOverride_LPVSpecularOcclusionIntensity: boolean;
        bOverride_LPVSize: boolean;
        bOverride_LPVSecondaryOcclusionIntensity: boolean;
        bOverride_LPVSecondaryBounceIntensity: boolean;
        bOverride_LPVGeometryVolumeBias: boolean;
        bOverride_LPVVplInjectionBias: boolean;
        bOverride_LPVEmissiveInjectionIntensity: boolean;
        bOverride_LPVFadeRange: boolean;
        bOverride_LPVDirectionalOcclusionFadeRange: boolean;
        bOverride_IndirectLightingColor: boolean;
        bOverride_IndirectLightingIntensity: boolean;
        bOverride_ColorGradingIntensity: boolean;
        bOverride_ColorGradingLUT: boolean;
        bOverride_DepthOfFieldFocalDistance: boolean;
        bOverride_DepthOfFieldFstop: boolean;
        bOverride_DepthOfFieldMinFstop: boolean;
        bOverride_DepthOfFieldBladeCount: boolean;
        bOverride_DepthOfFieldSensorWidth: boolean;
        bOverride_DepthOfFieldDepthBlurRadius: boolean;
        bOverride_DepthOfFieldDepthBlurAmount: boolean;
        bOverride_DepthOfFieldFocalRegion: boolean;
        bOverride_DepthOfFieldNearTransitionRegion: boolean;
        bOverride_DepthOfFieldFarTransitionRegion: boolean;
        bOverride_DepthOfFieldScale: boolean;
        bOverride_DepthOfFieldNearBlurSize: boolean;
        bOverride_DepthOfFieldFarBlurSize: boolean;
        bOverride_MobileHQGaussian: boolean;
        bOverride_DepthOfFieldOcclusion: boolean;
        bOverride_DepthOfFieldSkyFocusDistance: boolean;
        bOverride_DepthOfFieldVignetteSize: boolean;
        bOverride_MotionBlurAmount: boolean;
        bOverride_MotionBlurMax: boolean;
        bOverride_MotionBlurTargetFPS: boolean;
        bOverride_MotionBlurPerObjectSize: boolean;
        bOverride_ScreenPercentage: boolean;
        bOverride_ScreenSpaceReflectionIntensity: boolean;
        bOverride_ScreenSpaceReflectionQuality: boolean;
        bOverride_ScreenSpaceReflectionMaxRoughness: boolean;
        bOverride_ScreenSpaceReflectionRoughnessScale: boolean;
        bOverride_ReflectionsType: boolean;
        bOverride_RayTracingReflectionsMaxRoughness: boolean;
        bOverride_RayTracingReflectionsMaxBounces: boolean;
        bOverride_RayTracingReflectionsSamplesPerPixel: boolean;
        bOverride_RayTracingReflectionsShadows: boolean;
        bOverride_RayTracingReflectionsTranslucency: boolean;
        bOverride_TranslucencyType: boolean;
        bOverride_RayTracingTranslucencyMaxRoughness: boolean;
        bOverride_RayTracingTranslucencyRefractionRays: boolean;
        bOverride_RayTracingTranslucencySamplesPerPixel: boolean;
        bOverride_RayTracingTranslucencyShadows: boolean;
        bOverride_RayTracingTranslucencyRefraction: boolean;
        bOverride_RayTracingGI: boolean;
        bOverride_RayTracingGIMaxBounces: boolean;
        bOverride_RayTracingGISamplesPerPixel: boolean;
        bOverride_PathTracingMaxBounces: boolean;
        bOverride_PathTracingSamplesPerPixel: boolean;
        bMobileHQGaussian: boolean;
        BloomMethod: UE.EBloomMethod;
        AutoExposureMethod: UE.EAutoExposureMethod;
        DepthOfFieldMethod: UE.EDepthOfFieldMethod;
        WhiteTemp: number;
        WhiteTint: number;
        ColorSaturation: UE.Vector4;
        ColorContrast: UE.Vector4;
        ColorGamma: UE.Vector4;
        ColorGain: UE.Vector4;
        ColorOffset: UE.Vector4;
        ColorSaturationShadows: UE.Vector4;
        ColorContrastShadows: UE.Vector4;
        ColorGammaShadows: UE.Vector4;
        ColorGainShadows: UE.Vector4;
        ColorOffsetShadows: UE.Vector4;
        ColorSaturationMidtones: UE.Vector4;
        ColorContrastMidtones: UE.Vector4;
        ColorGammaMidtones: UE.Vector4;
        ColorGainMidtones: UE.Vector4;
        ColorOffsetMidtones: UE.Vector4;
        ColorSaturationHighlights: UE.Vector4;
        ColorContrastHighlights: UE.Vector4;
        ColorGammaHighlights: UE.Vector4;
        ColorGainHighlights: UE.Vector4;
        ColorOffsetHighlights: UE.Vector4;
        ColorCorrectionHighlightsMin: number;
        ColorCorrectionShadowsMax: number;
        BlueCorrection: number;
        ExpandGamut: number;
        FilmSlope: number;
        FilmToe: number;
        FilmShoulder: number;
        FilmBlackClip: number;
        FilmWhiteClip: number;
        FilmWhitePoint: UE.LinearColor;
        FilmShadowTint: UE.LinearColor;
        FilmShadowTintBlend: number;
        FilmShadowTintAmount: number;
        FilmSaturation: number;
        FilmChannelMixerRed: UE.LinearColor;
        FilmChannelMixerGreen: UE.LinearColor;
        FilmChannelMixerBlue: UE.LinearColor;
        FilmContrast: number;
        FilmToeAmount: number;
        FilmHealAmount: number;
        FilmDynamicRange: number;
        SceneColorTint: UE.LinearColor;
        SceneFringeIntensity: number;
        ChromaticAberrationStartOffset: number;
        BloomIntensity: number;
        BloomThreshold: number;
        BloomSizeScale: number;
        Bloom1Size: number;
        Bloom2Size: number;
        Bloom3Size: number;
        Bloom4Size: number;
        Bloom5Size: number;
        Bloom6Size: number;
        Bloom1Tint: UE.LinearColor;
        Bloom2Tint: UE.LinearColor;
        Bloom3Tint: UE.LinearColor;
        Bloom4Tint: UE.LinearColor;
        Bloom5Tint: UE.LinearColor;
        Bloom6Tint: UE.LinearColor;
        BloomConvolutionSize: number;
        BloomConvolutionTexture: UE.Texture2D;
        BloomConvolutionCenterUV: UE.Vector2D;
        BloomConvolutionPreFilter: UE.Vector;
        BloomConvolutionPreFilterMin: number;
        BloomConvolutionPreFilterMax: number;
        BloomConvolutionPreFilterMult: number;
        BloomConvolutionBufferScale: number;
        BloomDirtMask: UE.Texture;
        BloomDirtMaskIntensity: number;
        BloomDirtMaskTint: UE.LinearColor;
        AmbientCubemapTint: UE.LinearColor;
        AmbientCubemapIntensity: number;
        AmbientCubemap: UE.TextureCube;
        CameraShutterSpeed: number;
        CameraISO: number;
        DepthOfFieldFstop: number;
        DepthOfFieldMinFstop: number;
        DepthOfFieldBladeCount: number;
        AutoExposureBias: number;
        AutoExposureBiasCurve: UE.CurveFloat;
        AutoExposureLowPercent: number;
        AutoExposureHighPercent: number;
        AutoExposureMinBrightness: number;
        AutoExposureMaxBrightness: number;
        AutoExposureSpeedUp: number;
        AutoExposureSpeedDown: number;
        HistogramLogMin: number;
        HistogramLogMax: number;
        AutoExposureCalibrationConstant: number;
        LensFlareIntensity: number;
        LensFlareTint: UE.LinearColor;
        LensFlareBokehSize: number;
        LensFlareThreshold: number;
        LensFlareBokehShape: UE.Texture;
        LensFlareTints: FixSizeArray<UE.LinearColor>;
        VignetteIntensity: number;
        GrainJitter: number;
        GrainIntensity: number;
        AmbientOcclusionIntensity: number;
        AmbientOcclusionStaticFraction: number;
        AmbientOcclusionRadius: number;
        AmbientOcclusionRadiusInWS: boolean;
        AmbientOcclusionFadeDistance: number;
        AmbientOcclusionFadeRadius: number;
        AmbientOcclusionDistance: number;
        AmbientOcclusionPower: number;
        AmbientOcclusionBias: number;
        AmbientOcclusionQuality: number;
        AmbientOcclusionMipBlend: number;
        AmbientOcclusionMipScale: number;
        AmbientOcclusionMipThreshold: number;
        RayTracingAO: boolean;
        RayTracingAOSamplesPerPixel: number;
        IndirectLightingColor: UE.LinearColor;
        IndirectLightingIntensity: number;
        RayTracingGI: boolean;
        RayTracingGIType: UE.ERayTracingGlobalIlluminationType;
        RayTracingGIMaxBounces: number;
        RayTracingGISamplesPerPixel: number;
        ColorGradingIntensity: number;
        ColorGradingLUT: UE.Texture;
        DepthOfFieldSensorWidth: number;
        DepthOfFieldFocalDistance: number;
        DepthOfFieldDepthBlurAmount: number;
        DepthOfFieldDepthBlurRadius: number;
        DepthOfFieldFocalRegion: number;
        DepthOfFieldNearTransitionRegion: number;
        DepthOfFieldFarTransitionRegion: number;
        DepthOfFieldScale: number;
        DepthOfFieldNearBlurSize: number;
        DepthOfFieldFarBlurSize: number;
        DepthOfFieldOcclusion: number;
        DepthOfFieldSkyFocusDistance: number;
        DepthOfFieldVignetteSize: number;
        MotionBlurAmount: number;
        MotionBlurMax: number;
        MotionBlurTargetFPS: number;
        MotionBlurPerObjectSize: number;
        LPVIntensity: number;
        LPVVplInjectionBias: number;
        LPVSize: number;
        LPVSecondaryOcclusionIntensity: number;
        LPVSecondaryBounceIntensity: number;
        LPVGeometryVolumeBias: number;
        LPVEmissiveInjectionIntensity: number;
        LPVDirectionalOcclusionIntensity: number;
        LPVDirectionalOcclusionRadius: number;
        LPVDiffuseOcclusionExponent: number;
        LPVSpecularOcclusionExponent: number;
        LPVDiffuseOcclusionIntensity: number;
        LPVSpecularOcclusionIntensity: number;
        ReflectionsType: UE.EReflectionsType;
        ScreenSpaceReflectionIntensity: number;
        ScreenSpaceReflectionQuality: number;
        ScreenSpaceReflectionMaxRoughness: number;
        RayTracingReflectionsMaxRoughness: number;
        RayTracingReflectionsMaxBounces: number;
        RayTracingReflectionsSamplesPerPixel: number;
        RayTracingReflectionsShadows: UE.EReflectedAndRefractedRayTracedShadows;
        RayTracingReflectionsTranslucency: boolean;
        TranslucencyType: UE.ETranslucencyType;
        RayTracingTranslucencyMaxRoughness: number;
        RayTracingTranslucencyRefractionRays: number;
        RayTracingTranslucencySamplesPerPixel: number;
        RayTracingTranslucencyShadows: UE.EReflectedAndRefractedRayTracedShadows;
        RayTracingTranslucencyRefraction: boolean;
        PathTracingMaxBounces: number;
        PathTracingSamplesPerPixel: number;
        LPVFadeRange: number;
        LPVDirectionalOcclusionFadeRange: number;
        ScreenPercentage: number;
        WeightedBlendables: UE.WeightedBlendables;
        Blendables: TArray<UE.Object>;
        static StaticClass(): Class;
    }
    
    class MinimalViewInfo {
        constructor();
        constructor(Location: UE.Vector, Rotation: UE.Rotator, FOV: number, DesiredFOV: number, OrthoWidth: number, OrthoNearClipPlane: number, OrthoFarClipPlane: number, AspectRatio: number, bConstrainAspectRatio: boolean, bUseFieldOfViewForLOD: boolean, ProjectionMode: UE.ECameraProjectionMode, PostProcessBlendWeight: number, PostProcessSettings: UE.PostProcessSettings, OffCenterProjectionOffset: UE.Vector2D);
        Location: UE.Vector;
        Rotation: UE.Rotator;
        FOV: number;
        DesiredFOV: number;
        OrthoWidth: number;
        OrthoNearClipPlane: number;
        OrthoFarClipPlane: number;
        AspectRatio: number;
        bConstrainAspectRatio: boolean;
        bUseFieldOfViewForLOD: boolean;
        ProjectionMode: UE.ECameraProjectionMode;
        PostProcessBlendWeight: number;
        PostProcessSettings: UE.PostProcessSettings;
        OffCenterProjectionOffset: UE.Vector2D;
        static StaticClass(): Class;
    }
    
    class CameraCacheEntry {
        constructor();
        constructor(TimeStamp: number, POV: UE.MinimalViewInfo);
        TimeStamp: number;
        POV: UE.MinimalViewInfo;
        static StaticClass(): Class;
    }
    
    class TViewTarget {
        constructor();
        constructor(Target: UE.Actor, POV: UE.MinimalViewInfo, PlayerState: UE.PlayerState);
        Target: UE.Actor;
        POV: UE.MinimalViewInfo;
        PlayerState: UE.PlayerState;
        static StaticClass(): Class;
    }
    
    class CameraModifier extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDebug: boolean;
        bExclusive: boolean;
        Priority: number;
        CameraOwner: UE.PlayerCameraManager;
        AlphaInTime: number;
        AlphaOutTime: number;
        Alpha: number;
        BlueprintModifyCamera(DeltaTime: number, ViewLocation: UE.Vector, ViewRotation: UE.Rotator, FOV: number, NewViewLocation: $Ref<UE.Vector>, NewViewRotation: $Ref<UE.Rotator>, NewFOV: $Ref<number>) : void;
        BlueprintModifyPostProcess(DeltaTime: number, PostProcessBlendWeight: $Ref<number>, PostProcessSettings: $Ref<UE.PostProcessSettings>) : void;
        DisableModifier(bImmediate?: boolean /* = false */) : void;
        EnableModifier() : void;
        GetViewTarget() : UE.Actor;
        IsDisabled() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraModifier;
        static Load(InName: string): CameraModifier;
    }
    
    enum EAttachmentRule { KeepRelative, KeepWorld, SnapToTarget, EAttachmentRule_MAX}
    class FXSystemAsset extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxPoolSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FXSystemAsset;
        static Load(InName: string): FXSystemAsset;
    }
    
    class FXSystemComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetFXSystemAsset() : UE.FXSystemAsset;
        ReleaseToPool() : void;
        SetActorParameter(ParameterName: string, Param: $Nullable<UE.Actor>) : void;
        SetAutoAttachmentParameters(Parent: $Nullable<UE.SceneComponent>, SocketName: string, LocationRule: UE.EAttachmentRule, RotationRule: UE.EAttachmentRule, ScaleRule: UE.EAttachmentRule) : void;
        SetColorParameter(ParameterName: string, Param: UE.LinearColor) : void;
        SetEmitterEnable(EmitterName: string, bNewEnableState: boolean) : void;
        SetFloatParameter(ParameterName: string, Param: number) : void;
        SetUseAutoManageAttachment(bAutoManage: boolean) : void;
        SetVectorParameter(ParameterName: string, Param: UE.Vector) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FXSystemComponent;
        static Load(InName: string): FXSystemComponent;
    }
    
    enum EEmitterRenderMode { ERM_Normal, ERM_Point, ERM_Cross, ERM_LightsOnly, ERM_None, ERM_MAX}
    enum EParticleSignificanceLevel { Low, Medium, High, Critical, Num, EParticleSignificanceLevel_MAX}
    enum EDetailMode { DM_Low, DM_Medium, DM_High, DM_MAX}
    class ParticleModule extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bSpawnModule: boolean;
        bUpdateModule: boolean;
        bFinalUpdateModule: boolean;
        bUpdateForGPUEmitter: boolean;
        bCurvesAsColor: boolean;
        b3DDrawMode: boolean;
        bSupported3DDrawMode: boolean;
        bEnabled: boolean;
        bEditable: boolean;
        LODDuplicate: boolean;
        bSupportsRandomSeed: boolean;
        bRequiresLoopingNotification: boolean;
        LODValidity: number;
        ModuleEditorColor: UE.Color;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModule;
        static Load(InName: string): ParticleModule;
    }
    
    enum EParticleScreenAlignment { PSA_FacingCameraPosition, PSA_Square, PSA_Rectangle, PSA_Velocity, PSA_AwayFromCenter, PSA_TypeSpecific, PSA_FacingCameraDistanceBlend, PSA_MAX}
    enum EParticleSortMode { PSORTMODE_None, PSORTMODE_ViewProjDepth, PSORTMODE_DistanceToView, PSORTMODE_Age_OldestFirst, PSORTMODE_Age_NewestFirst, PSORTMODE_MAX}
    class DistributionLookupTable {
        constructor();
        constructor(TimeScale: number, TimeBias: number, Values: TArray<number>, Op: number, EntryCount: number, EntryStride: number, SubEntryStride: number, LockFlag: number);
        TimeScale: number;
        TimeBias: number;
        Values: TArray<number>;
        Op: number;
        EntryCount: number;
        EntryStride: number;
        SubEntryStride: number;
        LockFlag: number;
        static StaticClass(): Class;
    }
    
    class RawDistribution {
        constructor();
        constructor(Table: UE.DistributionLookupTable);
        Table: UE.DistributionLookupTable;
        static StaticClass(): Class;
    }
    
    class Distribution extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Distribution;
        static Load(InName: string): Distribution;
    }
    
    class DistributionFloat extends UE.Distribution {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCanBeBaked: boolean;
        bBakedDataSuccesfully: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionFloat;
        static Load(InName: string): DistributionFloat;
    }
    
    class RawDistributionFloat extends UE.RawDistribution {
        constructor();
        constructor(MinValue: number, MaxValue: number, Distribution: UE.DistributionFloat);
        MinValue: number;
        MaxValue: number;
        Distribution: UE.DistributionFloat;
        static StaticClass(): Class;
    }
    
    class ParticleBurst {
        constructor();
        constructor(Count: number, CountLow: number, Time: number);
        Count: number;
        CountLow: number;
        Time: number;
        static StaticClass(): Class;
    }
    
    enum EParticleSubUVInterpMethod { PSUVIM_None, PSUVIM_Linear, PSUVIM_Linear_Blend, PSUVIM_Random, PSUVIM_Random_Blend, PSUVIM_MAX}
    enum EParticleBurstMethod { EPBM_Instant, EPBM_Interpolated, EPBM_MAX}
    enum EOpacitySourceMode { OSM_Alpha, OSM_ColorBrightness, OSM_RedChannel, OSM_GreenChannel, OSM_BlueChannel, OSM_MAX}
    enum EEmitterNormalsMode { ENM_CameraFacing, ENM_Spherical, ENM_Cylindrical, ENM_MAX}
    enum EParticleUVFlipMode { None, FlipUV, FlipUOnly, FlipVOnly, RandomFlipUV, RandomFlipUOnly, RandomFlipVOnly, RandomFlipUVIndependent, EParticleUVFlipMode_MAX}
    enum ESubUVBoundingVertexCount { BVC_FourVertices, BVC_EightVertices, BVC_MAX}
    class ParticleModuleRequired extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Material: UE.MaterialInterface;
        MinFacingCameraBlendDistance: number;
        MaxFacingCameraBlendDistance: number;
        EmitterOrigin: UE.Vector;
        EmitterRotation: UE.Rotator;
        ScreenAlignment: UE.EParticleScreenAlignment;
        bUseLocalSpace: boolean;
        bKillOnDeactivate: boolean;
        bKillOnCompleted: boolean;
        SortMode: UE.EParticleSortMode;
        bUseLegacyEmitterTime: boolean;
        bRemoveHMDRoll: boolean;
        bEmitterDurationUseRange: boolean;
        EmitterDuration: number;
        SpawnRate: UE.RawDistributionFloat;
        BurstList: TArray<UE.ParticleBurst>;
        EmitterDelay: number;
        EmitterDelayLow: number;
        bDelayFirstLoopOnly: boolean;
        InterpolationMethod: UE.EParticleSubUVInterpMethod;
        bScaleUV: boolean;
        bEmitterDelayUseRange: boolean;
        ParticleBurstMethod: UE.EParticleBurstMethod;
        bOverrideSystemMacroUV: boolean;
        bUseMaxDrawCount: boolean;
        OpacitySourceMode: UE.EOpacitySourceMode;
        EmitterNormalsMode: UE.EEmitterNormalsMode;
        bOrbitModuleAffectsVelocityAlignment: boolean;
        SubImages_Horizontal: number;
        SubImages_Vertical: number;
        RandomImageTime: number;
        RandomImageChanges: number;
        MacroUVPosition: UE.Vector;
        MacroUVRadius: number;
        UVFlippingMode: UE.EParticleUVFlipMode;
        BoundingMode: UE.ESubUVBoundingVertexCount;
        bDurationRecalcEachLoop: boolean;
        NormalsSphereCenter: UE.Vector;
        AlphaThreshold: number;
        EmitterLoops: number;
        CutoutTexture: UE.Texture2D;
        MaxDrawCount: number;
        EmitterDurationLow: number;
        NormalsCylinderDirection: UE.Vector;
        NamedMaterialOverrides: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRequired;
        static Load(InName: string): ParticleModuleRequired;
    }
    
    class ParticleModuleTypeDataBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataBase;
        static Load(InName: string): ParticleModuleTypeDataBase;
    }
    
    class ParticleModuleSpawnBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bProcessSpawnRate: boolean;
        bProcessBurstList: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSpawnBase;
        static Load(InName: string): ParticleModuleSpawnBase;
    }
    
    class ParticleModuleSpawn extends UE.ParticleModuleSpawnBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Rate: UE.RawDistributionFloat;
        RateScale: UE.RawDistributionFloat;
        ParticleBurstMethod: UE.EParticleBurstMethod;
        BurstList: TArray<UE.ParticleBurst>;
        BurstScale: UE.RawDistributionFloat;
        bApplyGlobalSpawnRateScale: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSpawn;
        static Load(InName: string): ParticleModuleSpawn;
    }
    
    class ParticleModuleEventBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventBase;
        static Load(InName: string): ParticleModuleEventBase;
    }
    
    enum EParticleEventType { EPET_Any, EPET_Spawn, EPET_Death, EPET_Collision, EPET_Burst, EPET_Blueprint, EPET_MAX}
    class ParticleModuleEventSendToGame extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventSendToGame;
        static Load(InName: string): ParticleModuleEventSendToGame;
    }
    
    class ParticleEvent_GenerateInfo {
        constructor();
        constructor(Type: UE.EParticleEventType, Frequency: number, ParticleFrequency: number, FirstTimeOnly: boolean, LastTimeOnly: boolean, UseReflectedImpactVector: boolean, bUseOrbitOffset: boolean, CustomName: string, ParticleModuleEventsToSendToGame: TArray<UE.ParticleModuleEventSendToGame>);
        Type: UE.EParticleEventType;
        Frequency: number;
        ParticleFrequency: number;
        FirstTimeOnly: boolean;
        LastTimeOnly: boolean;
        UseReflectedImpactVector: boolean;
        bUseOrbitOffset: boolean;
        CustomName: string;
        ParticleModuleEventsToSendToGame: TArray<UE.ParticleModuleEventSendToGame>;
        static StaticClass(): Class;
    }
    
    class ParticleModuleEventGenerator extends UE.ParticleModuleEventBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Events: TArray<UE.ParticleEvent_GenerateInfo>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventGenerator;
        static Load(InName: string): ParticleModuleEventGenerator;
    }
    
    class ParticleModuleOrbitBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseEmitterTime: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleOrbitBase;
        static Load(InName: string): ParticleModuleOrbitBase;
    }
    
    enum EOrbitChainMode { EOChainMode_Add, EOChainMode_Scale, EOChainMode_Link, EOChainMode_MAX}
    class DistributionVector extends UE.Distribution {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCanBeBaked: boolean;
        bIsDirty: boolean;
        bBakedDataSuccesfully: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionVector;
        static Load(InName: string): DistributionVector;
    }
    
    class RawDistributionVector extends UE.RawDistribution {
        constructor();
        constructor(MinValue: number, MaxValue: number, MinValueVec: UE.Vector, MaxValueVec: UE.Vector, Distribution: UE.DistributionVector);
        MinValue: number;
        MaxValue: number;
        MinValueVec: UE.Vector;
        MaxValueVec: UE.Vector;
        Distribution: UE.DistributionVector;
        static StaticClass(): Class;
    }
    
    class OrbitOptions {
        constructor();
        constructor(bProcessDuringSpawn: boolean, bProcessDuringUpdate: boolean, bUseEmitterTime: boolean);
        bProcessDuringSpawn: boolean;
        bProcessDuringUpdate: boolean;
        bUseEmitterTime: boolean;
        static StaticClass(): Class;
    }
    
    class ParticleModuleOrbit extends UE.ParticleModuleOrbitBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChainMode: UE.EOrbitChainMode;
        OffsetAmount: UE.RawDistributionVector;
        OffsetOptions: UE.OrbitOptions;
        RotationAmount: UE.RawDistributionVector;
        RotationOptions: UE.OrbitOptions;
        RotationRateAmount: UE.RawDistributionVector;
        RotationRateOptions: UE.OrbitOptions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleOrbit;
        static Load(InName: string): ParticleModuleOrbit;
    }
    
    class ParticleModuleEventReceiverBase extends UE.ParticleModuleEventBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EventGeneratorType: UE.EParticleEventType;
        EventName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventReceiverBase;
        static Load(InName: string): ParticleModuleEventReceiverBase;
    }
    
    class ParticleLODLevel extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Level: number;
        bEnabled: boolean;
        RequiredModule: UE.ParticleModuleRequired;
        Modules: TArray<UE.ParticleModule>;
        TypeDataModule: UE.ParticleModuleTypeDataBase;
        SpawnModule: UE.ParticleModuleSpawn;
        EventGenerator: UE.ParticleModuleEventGenerator;
        SpawningModules: TArray<UE.ParticleModuleSpawnBase>;
        SpawnModules: TArray<UE.ParticleModule>;
        UpdateModules: TArray<UE.ParticleModule>;
        OrbitModules: TArray<UE.ParticleModuleOrbit>;
        EventReceiverModules: TArray<UE.ParticleModuleEventReceiverBase>;
        ConvertedModules: boolean;
        PeakActiveParticles: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleLODLevel;
        static Load(InName: string): ParticleLODLevel;
    }
    
    class ParticleEmitter extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EmitterName: string;
        SubUVDataOffset: number;
        EmitterRenderMode: UE.EEmitterRenderMode;
        SignificanceLevel: UE.EParticleSignificanceLevel;
        bUseLegacySpawningBehavior: boolean;
        ConvertedModules: boolean;
        bIsSoloing: boolean;
        bCookedOut: boolean;
        bDisabledLODsKeepEmitterAlive: boolean;
        bDisableWhenInsignficant: boolean;
        bCollapsed: boolean;
        DetailMode: UE.EDetailMode;
        EmitterEditorColor: UE.Color;
        LODLevels: TArray<UE.ParticleLODLevel>;
        PeakActiveParticles: number;
        InitialAllocationCount: number;
        QualityLevelSpawnRateScale: number;
        DetailModeBitmask: number;
        DetailModeDisplay: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleEmitter;
        static Load(InName: string): ParticleEmitter;
    }
    
    class CurveEdEntry {
        constructor();
        constructor(CurveObject: UE.Object, CurveColor: UE.Color, CurveName: string, bHideCurve: number, bColorCurve: number, bFloatingPointColorCurve: number, bClamp: number, ClampLow: number, ClampHigh: number);
        CurveObject: UE.Object;
        CurveColor: UE.Color;
        CurveName: string;
        bHideCurve: number;
        bColorCurve: number;
        bFloatingPointColorCurve: number;
        bClamp: number;
        ClampLow: number;
        ClampHigh: number;
        static StaticClass(): Class;
    }
    
    class CurveEdTab {
        constructor();
        constructor(TabName: string, Curves: TArray<UE.CurveEdEntry>, ViewStartInput: number, ViewEndInput: number, ViewStartOutput: number, ViewEndOutput: number);
        TabName: string;
        Curves: TArray<UE.CurveEdEntry>;
        ViewStartInput: number;
        ViewEndInput: number;
        ViewStartOutput: number;
        ViewEndOutput: number;
        static StaticClass(): Class;
    }
    
    class InterpCurveEdSetup extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Tabs: TArray<UE.CurveEdTab>;
        ActiveTab: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpCurveEdSetup;
        static Load(InName: string): InterpCurveEdSetup;
    }
    
    class ParticleSystemLOD {
        constructor();
        static StaticClass(): Class;
    }
    
    enum EParticleSystemUpdateMode { EPSUM_RealTime, EPSUM_FixedTime, EPSUM_MAX}
    enum ParticleSystemLODMethod { PARTICLESYSTEMLODMETHOD_Automatic, PARTICLESYSTEMLODMETHOD_DirectSet, PARTICLESYSTEMLODMETHOD_ActivateAutomatic, PARTICLESYSTEMLODMETHOD_MAX}
    enum EParticleSystemInsignificanceReaction { Auto, Complete, DisableTick, DisableTickAndKill, Num, EParticleSystemInsignificanceReaction_MAX}
    enum EParticleSystemOcclusionBoundsMethod { EPSOBM_None, EPSOBM_ParticleBounds, EPSOBM_CustomBounds, EPSOBM_MAX}
    class LODSoloTrack {
        constructor();
        constructor(SoloEnableSetting: TArray<number>);
        SoloEnableSetting: TArray<number>;
        static StaticClass(): Class;
    }
    
    class NamedEmitterMaterial {
        constructor();
        constructor(Name: string, Material: UE.MaterialInterface);
        Name: string;
        Material: UE.MaterialInterface;
        static StaticClass(): Class;
    }
    
    class ParticleSystem extends UE.FXSystemAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UpdateTime_FPS: number;
        UpdateTime_Delta: number;
        WarmupTime: number;
        WarmupTickRate: number;
        Emitters: TArray<UE.ParticleEmitter>;
        PreviewComponent: UE.ParticleSystemComponent;
        ThumbnailAngle: UE.Rotator;
        ThumbnailDistance: number;
        ThumbnailWarmup: number;
        CurveEdSetup: UE.InterpCurveEdSetup;
        LODDistanceCheckTime: number;
        MacroUVRadius: number;
        LODDistances: TArray<number>;
        EditorLODSetting: number;
        LODSettings: TArray<UE.ParticleSystemLOD>;
        FixedRelativeBoundingBox: UE.Box;
        SecondsBeforeInactive: number;
        FloorMesh: string;
        FloorPosition: UE.Vector;
        FloorRotation: UE.Rotator;
        FloorScale: number;
        FloorScale3D: UE.Vector;
        BackgroundColor: UE.Color;
        Delay: number;
        DelayLow: number;
        bOrientZAxisTowardCamera: boolean;
        bUseFixedRelativeBoundingBox: boolean;
        bShouldResetPeakCounts: boolean;
        bHasPhysics: boolean;
        bUseRealtimeThumbnail: boolean;
        ThumbnailImageOutOfDate: boolean;
        ThumbnailImage: UE.Texture2D;
        bUseDelayRange: boolean;
        bAllowManagedTicking: boolean;
        bAutoDeactivate: boolean;
        bRegenerateLODDuplicate: boolean;
        SystemUpdateMode: UE.EParticleSystemUpdateMode;
        LODMethod: UE.ParticleSystemLODMethod;
        InsignificantReaction: UE.EParticleSystemInsignificanceReaction;
        OcclusionBoundsMethod: UE.EParticleSystemOcclusionBoundsMethod;
        MaxSignificanceLevel: UE.EParticleSignificanceLevel;
        MinTimeBetweenTicks: number;
        InsignificanceDelay: number;
        MacroUVPosition: UE.Vector;
        CustomOcclusionBounds: UE.Box;
        SoloTracking: TArray<UE.LODSoloTrack>;
        NamedMaterialSlots: TArray<UE.NamedEmitterMaterial>;
        ContainsEmitterType(TypeData: $Nullable<UE.Class>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleSystem;
        static Load(InName: string): ParticleSystem;
    }
    
    enum EParticleSysParamType { PSPT_None, PSPT_Scalar, PSPT_ScalarRand, PSPT_Vector, PSPT_VectorRand, PSPT_Color, PSPT_Actor, PSPT_Material, PSPT_VectorUnitRand, PSPT_MAX}
    class ParticleSysParam {
        constructor();
        constructor(Name: string, ParamType: UE.EParticleSysParamType, Scalar: number, Scalar_Low: number, Vector: UE.Vector, Vector_Low: UE.Vector, Color: UE.Color, Actor: UE.Actor, Material: UE.MaterialInterface);
        Name: string;
        ParamType: UE.EParticleSysParamType;
        Scalar: number;
        Scalar_Low: number;
        Vector: UE.Vector;
        Vector_Low: UE.Vector;
        Color: UE.Color;
        Actor: UE.Actor;
        Material: UE.MaterialInterface;
        static StaticClass(): Class;
    }
    
    class ParticleSystemReplay extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ClipIDNumber: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleSystemReplay;
        static Load(InName: string): ParticleSystemReplay;
    }
    
    enum EAttachLocation { KeepRelativeOffset, KeepWorldPosition, SnapToTarget, SnapToTargetIncludingScale, EAttachLocation_MAX}
    enum ETrailWidthMode { ETrailWidthMode_FromCentre, ETrailWidthMode_FromFirst, ETrailWidthMode_FromSecond, ETrailWidthMode_MAX}
    class ParticleSystemComponent extends UE.FXSystemComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Template: UE.ParticleSystem;
        EmitterMaterials: TArray<UE.MaterialInterface>;
        SkelMeshComponents: TArray<UE.SkeletalMeshComponent>;
        bResetOnDetach: boolean;
        bUpdateOnDedicatedServer: boolean;
        bAllowRecycling: boolean;
        bAutoManageAttachment: boolean;
        bWarmingUp: boolean;
        bOverrideLODMethod: boolean;
        bSkipUpdateDynamicDataDuringTick: boolean;
        LODMethod: UE.ParticleSystemLODMethod;
        RequiredSignificance: UE.EParticleSignificanceLevel;
        InstanceParameters: TArray<UE.ParticleSysParam>;
        OnParticleSpawn: $MulticastDelegate<(EventName: string, EmitterTime: number, Location: UE.Vector, Velocity: UE.Vector) => void>;
        OnParticleBurst: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleCount: number) => void>;
        OnParticleDeath: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: UE.Vector, Velocity: UE.Vector, Direction: UE.Vector) => void>;
        OnParticleCollide: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: UE.Vector, Velocity: UE.Vector, Direction: UE.Vector, Normal: UE.Vector, BoneName: string, PhysMat: $Nullable<UE.PhysicalMaterial>) => void>;
        OldPosition: UE.Vector;
        PartSysVelocity: UE.Vector;
        WarmupTime: number;
        WarmupTickRate: number;
        SecondsBeforeInactive: number;
        MaxTimeBeforeForceUpdateTransform: number;
        EditorLODLevel: number;
        EditorDetailMode: number;
        ReplayClips: TArray<UE.ParticleSystemReplay>;
        CustomTimeDilation: number;
        AutoAttachParent: TWeakObjectPtr<UE.SceneComponent>;
        AutoAttachSocketName: string;
        AutoAttachLocationType: UE.EAttachLocation;
        AutoAttachLocationRule: UE.EAttachmentRule;
        AutoAttachRotationRule: UE.EAttachmentRule;
        AutoAttachScaleRule: UE.EAttachmentRule;
        OnSystemFinished: $MulticastDelegate<(PSystem: $Nullable<UE.ParticleSystemComponent>) => void>;
        BeginTrails(InFirstSocketName: string, InSecondSocketName: string, InWidthMode: UE.ETrailWidthMode, InWidth: number) : void;
        CreateNamedDynamicMaterialInstance(InName: string, SourceMaterial?: UE.MaterialInterface /* = None */) : UE.MaterialInstanceDynamic;
        EndTrails() : void;
        GenerateParticleEvent(InEventName: string, InEmitterTime: number, InLocation: UE.Vector, InDirection: UE.Vector, InVelocity: UE.Vector) : void;
        GetBeamEndPoint(EmitterIndex: number, OutEndPoint: $Ref<UE.Vector>) : boolean;
        GetBeamSourcePoint(EmitterIndex: number, SourceIndex: number, OutSourcePoint: $Ref<UE.Vector>) : boolean;
        GetBeamSourceStrength(EmitterIndex: number, SourceIndex: number, OutSourceStrength: $Ref<number>) : boolean;
        GetBeamSourceTangent(EmitterIndex: number, SourceIndex: number, OutTangentPoint: $Ref<UE.Vector>) : boolean;
        GetBeamTargetPoint(EmitterIndex: number, TargetIndex: number, OutTargetPoint: $Ref<UE.Vector>) : boolean;
        GetBeamTargetStrength(EmitterIndex: number, TargetIndex: number, OutTargetStrength: $Ref<number>) : boolean;
        GetBeamTargetTangent(EmitterIndex: number, TargetIndex: number, OutTangentPoint: $Ref<UE.Vector>) : boolean;
        GetNamedMaterial(InName: string) : UE.MaterialInterface;
        GetNumActiveParticles() : number;
        SetAutoAttachParams(Parent: $Nullable<UE.SceneComponent>, SocketName?: string /* = "None" */, LocationType?: UE.EAttachLocation /* = KeepRelativeOffset */) : void;
        SetBeamEndPoint(EmitterIndex: number, NewEndPoint: UE.Vector) : void;
        SetBeamSourcePoint(EmitterIndex: number, NewSourcePoint: UE.Vector, SourceIndex: number) : void;
        SetBeamSourceStrength(EmitterIndex: number, NewSourceStrength: number, SourceIndex: number) : void;
        SetBeamSourceTangent(EmitterIndex: number, NewTangentPoint: UE.Vector, SourceIndex: number) : void;
        SetBeamTargetPoint(EmitterIndex: number, NewTargetPoint: UE.Vector, TargetIndex: number) : void;
        SetBeamTargetStrength(EmitterIndex: number, NewTargetStrength: number, TargetIndex: number) : void;
        SetBeamTargetTangent(EmitterIndex: number, NewTangentPoint: UE.Vector, TargetIndex: number) : void;
        SetMaterialParameter(ParameterName: string, Param: $Nullable<UE.MaterialInterface>) : void;
        SetTemplate(NewTemplate: $Nullable<UE.ParticleSystem>) : void;
        SetTrailSourceData(InFirstSocketName: string, InSecondSocketName: string, InWidthMode: UE.ETrailWidthMode, InWidth: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleSystemComponent;
        static Load(InName: string): ParticleSystemComponent;
    }
    
    class Emitter extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParticleSystemComponent: UE.ParticleSystemComponent;
        bDestroyOnSystemFinish: boolean;
        bPostUpdateTickGroup: boolean;
        bCurrentlyActive: boolean;
        OnParticleSpawn: $MulticastDelegate<(EventName: string, EmitterTime: number, Location: UE.Vector, Velocity: UE.Vector) => void>;
        OnParticleBurst: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleCount: number) => void>;
        OnParticleDeath: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: UE.Vector, Velocity: UE.Vector, Direction: UE.Vector) => void>;
        OnParticleCollide: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: UE.Vector, Velocity: UE.Vector, Direction: UE.Vector, Normal: UE.Vector, BoneName: string, PhysMat: $Nullable<UE.PhysicalMaterial>) => void>;
        SpriteComponent: UE.BillboardComponent;
        ArrowComponent: UE.ArrowComponent;
        Activate() : void;
        Deactivate() : void;
        IsActive() : boolean;
        OnParticleSystemFinished(FinishedComponent: $Nullable<UE.ParticleSystemComponent>) : void;
        OnRep_bCurrentlyActive() : void;
        SetActorParameter(ParameterName: string, Param: $Nullable<UE.Actor>) : void;
        SetColorParameter(ParameterName: string, Param: UE.LinearColor) : void;
        SetFloatParameter(ParameterName: string, Param: number) : void;
        SetMaterialParameter(ParameterName: string, Param: $Nullable<UE.MaterialInterface>) : void;
        SetTemplate(NewTemplate: $Nullable<UE.ParticleSystem>) : void;
        SetVectorParameter(ParameterName: string, Param: UE.Vector) : void;
        ToggleActive() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Emitter;
        static Load(InName: string): Emitter;
    }
    
    class EmitterCameraLensEffectBase extends UE.Emitter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PS_CameraEffect: UE.ParticleSystem;
        PS_CameraEffectNonExtremeContent: UE.ParticleSystem;
        BaseCamera: UE.PlayerCameraManager;
        RelativeTransform: UE.Transform;
        BaseFOV: number;
        bAllowMultipleInstances: boolean;
        bResetWhenRetriggered: boolean;
        EmittersToTreatAsSame: TArray<UE.Class>;
        DistFromCamera: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EmitterCameraLensEffectBase;
        static Load(InName: string): EmitterCameraLensEffectBase;
    }
    
    enum EInitialOscillatorOffset { EOO_OffsetRandom, EOO_OffsetZero, EOO_MAX}
    enum EOscillatorWaveform { SineWave, PerlinNoise, EOscillatorWaveform_MAX}
    class FOscillator {
        constructor();
        constructor(Amplitude: number, Frequency: number, InitialOffset: UE.EInitialOscillatorOffset, Waveform: UE.EOscillatorWaveform);
        Amplitude: number;
        Frequency: number;
        InitialOffset: UE.EInitialOscillatorOffset;
        Waveform: UE.EOscillatorWaveform;
        static StaticClass(): Class;
    }
    
    class ROscillator {
        constructor();
        constructor(Pitch: UE.FOscillator, Yaw: UE.FOscillator, Roll: UE.FOscillator);
        Pitch: UE.FOscillator;
        Yaw: UE.FOscillator;
        Roll: UE.FOscillator;
        static StaticClass(): Class;
    }
    
    class VOscillator {
        constructor();
        constructor(X: UE.FOscillator, Y: UE.FOscillator, Z: UE.FOscillator);
        X: UE.FOscillator;
        Y: UE.FOscillator;
        Z: UE.FOscillator;
        static StaticClass(): Class;
    }
    
    class SubTrackGroup {
        constructor();
        constructor(GroupName: string, TrackIndices: TArray<number>, bIsCollapsed: boolean, bIsSelected: boolean);
        GroupName: string;
        TrackIndices: TArray<number>;
        bIsCollapsed: boolean;
        bIsSelected: boolean;
        static StaticClass(): Class;
    }
    
    class SupportedSubTrackInfo {
        constructor();
        constructor(SupportedClass: UE.Class, SubTrackName: string, GroupIndex: number);
        SupportedClass: UE.Class;
        SubTrackName: string;
        GroupIndex: number;
        static StaticClass(): Class;
    }
    
    enum ETrackActiveCondition { ETAC_Always, ETAC_GoreEnabled, ETAC_GoreDisabled, ETAC_MAX}
    class InterpTrack extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SubTracks: TArray<UE.InterpTrack>;
        SubTrackGroups: TArray<UE.SubTrackGroup>;
        SupportedSubTracks: TArray<UE.SupportedSubTrackInfo>;
        TrackInstClass: UE.Class;
        ActiveCondition: UE.ETrackActiveCondition;
        TrackTitle: string;
        bOnePerGroup: boolean;
        bDirGroupOnly: boolean;
        bDisableTrack: boolean;
        bIsSelected: boolean;
        TrackIcon: UE.Texture2D;
        bIsAnimControlTrack: boolean;
        bSubTrackOnly: boolean;
        bVisible: boolean;
        bIsRecording: boolean;
        bIsCollapsed: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrack;
        static Load(InName: string): InterpTrack;
    }
    
    class InterpGroup extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InterpTracks: TArray<UE.InterpTrack>;
        GroupName: string;
        GroupColor: UE.Color;
        bCollapsed: boolean;
        bVisible: boolean;
        bIsFolder: boolean;
        bIsParented: boolean;
        bIsSelected: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpGroup;
        static Load(InName: string): InterpGroup;
    }
    
    class CameraAnim extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CameraInterpGroup: UE.InterpGroup;
        PreviewInterpGroup: UE.InterpGroup;
        AnimLength: number;
        BoundingBox: UE.Box;
        bRelativeToInitialTransform: boolean;
        bRelativeToInitialFOV: boolean;
        BaseFOV: number;
        BasePostProcessSettings: UE.PostProcessSettings;
        BasePostProcessBlendWeight: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraAnim;
        static Load(InName: string): CameraAnim;
    }
    
    class InterpGroupInst extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Group: UE.InterpGroup;
        GroupActor: UE.Actor;
        TrackInst: TArray<UE.InterpTrackInst>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpGroupInst;
        static Load(InName: string): InterpGroupInst;
    }
    
    enum EInterpCurveMode { CIM_Linear, CIM_CurveAuto, CIM_Constant, CIM_CurveUser, CIM_CurveBreak, CIM_CurveAutoClamped, CIM_MAX}
    class InterpCurvePointVector {
        constructor();
        constructor(InVal: number, OutVal: UE.Vector, ArriveTangent: UE.Vector, LeaveTangent: UE.Vector, InterpMode: UE.EInterpCurveMode);
        InVal: number;
        OutVal: UE.Vector;
        ArriveTangent: UE.Vector;
        LeaveTangent: UE.Vector;
        InterpMode: UE.EInterpCurveMode;
        static StaticClass(): Class;
    }
    
    class InterpCurveVector {
        constructor();
        constructor(Points: TArray<UE.InterpCurvePointVector>, bIsLooped: boolean, LoopKeyOffset: number);
        Points: TArray<UE.InterpCurvePointVector>;
        bIsLooped: boolean;
        LoopKeyOffset: number;
        static StaticClass(): Class;
    }
    
    class InterpLookupPoint {
        constructor();
        constructor(GroupName: string, Time: number);
        GroupName: string;
        Time: number;
        static StaticClass(): Class;
    }
    
    class InterpLookupTrack {
        constructor();
        constructor(Points: TArray<UE.InterpLookupPoint>);
        Points: TArray<UE.InterpLookupPoint>;
        static StaticClass(): Class;
    }
    
    enum EInterpTrackMoveRotMode { IMR_Keyframed, IMR_LookAtGroup, IMR_Ignore, IMR_MAX}
    class InterpTrackMove extends UE.InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PosTrack: UE.InterpCurveVector;
        EulerTrack: UE.InterpCurveVector;
        LookupTrack: UE.InterpLookupTrack;
        LookAtGroupName: string;
        LinCurveTension: number;
        AngCurveTension: number;
        bUseQuatInterpolation: boolean;
        bShowArrowAtKeys: boolean;
        bDisableMovement: boolean;
        bShowTranslationOnCurveEd: boolean;
        bShowRotationOnCurveEd: boolean;
        bHide3DTrack: boolean;
        RotMode: UE.EInterpTrackMoveRotMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackMove;
        static Load(InName: string): InterpTrackMove;
    }
    
    class InterpTrackInstMove extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ResetLocation: UE.Vector;
        ResetRotation: UE.Rotator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstMove;
        static Load(InName: string): InterpTrackInstMove;
    }
    
    enum ECameraAnimPlaySpace { CameraLocal, World, UserDefined, ECameraAnimPlaySpace_MAX}
    class CameraAnimInst extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CamAnim: UE.CameraAnim;
        InterpGroupInst: UE.InterpGroupInst;
        PlayRate: number;
        MoveTrack: UE.InterpTrackMove;
        MoveInst: UE.InterpTrackInstMove;
        PlaySpace: UE.ECameraAnimPlaySpace;
        SetDuration(NewDuration: number) : void;
        SetScale(NewDuration: number) : void;
        Stop(bImmediate?: boolean /* = false */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraAnimInst;
        static Load(InName: string): CameraAnimInst;
    }
    
    class CameraShake extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bSingleInstance: boolean;
        OscillationDuration: number;
        OscillationBlendInTime: number;
        OscillationBlendOutTime: number;
        RotOscillation: UE.ROscillator;
        LocOscillation: UE.VOscillator;
        FOVOscillation: UE.FOscillator;
        AnimPlayRate: number;
        AnimScale: number;
        AnimBlendInTime: number;
        AnimBlendOutTime: number;
        RandomAnimSegmentDuration: number;
        Anim: UE.CameraAnim;
        bRandomAnimSegment: boolean;
        CameraOwner: UE.PlayerCameraManager;
        ShakeScale: number;
        OscillatorTimeRemaining: number;
        AnimInst: UE.CameraAnimInst;
        BlueprintUpdateCameraShake(DeltaTime: number, Alpha: number, POV: UE.MinimalViewInfo, ModifiedPOV: $Ref<UE.MinimalViewInfo>) : void;
        ReceiveIsFinished() : boolean;
        ReceivePlayShake(Scale: number) : void;
        ReceiveStopShake(bImmediately: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraShake;
        static Load(InName: string): CameraShake;
    }
    
    class PooledCameraShakes {
        constructor();
        constructor(PooledShakes: TArray<UE.CameraShake>);
        PooledShakes: TArray<UE.CameraShake>;
        static StaticClass(): Class;
    }
    
    class CameraModifier_CameraShake extends UE.CameraModifier {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActiveShakes: TArray<UE.CameraShake>;
        ExpiredPooledShakesMap: TMap<UE.Class, UE.PooledCameraShakes>;
        SplitScreenShakeScale: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraModifier_CameraShake;
        static Load(InName: string): CameraModifier_CameraShake;
    }
    
    class MeshBuildSettings {
        constructor();
        constructor(bUseMikkTSpace: boolean, bRecomputeNormals: boolean, bRecomputeTangents: boolean, bComputeWeightedNormals: boolean, bRemoveDegenerates: boolean, bBuildAdjacencyBuffer: boolean, bBuildReversedIndexBuffer: boolean, bUseHighPrecisionTangentBasis: boolean, bUseFullPrecisionUVs: boolean, bGenerateLightmapUVs: boolean, bGenerateDistanceFieldAsIfTwoSided: boolean, MinLightmapResolution: number, SrcLightmapIndex: number, DstLightmapIndex: number, BuildScale: number, BuildScale3D: UE.Vector, DistanceFieldResolutionScale: number, DistanceFieldBias: number, DistanceFieldReplacementMesh: UE.StaticMesh);
        bUseMikkTSpace: boolean;
        bRecomputeNormals: boolean;
        bRecomputeTangents: boolean;
        bComputeWeightedNormals: boolean;
        bRemoveDegenerates: boolean;
        bBuildAdjacencyBuffer: boolean;
        bBuildReversedIndexBuffer: boolean;
        bUseHighPrecisionTangentBasis: boolean;
        bUseFullPrecisionUVs: boolean;
        bGenerateLightmapUVs: boolean;
        bGenerateDistanceFieldAsIfTwoSided: boolean;
        MinLightmapResolution: number;
        SrcLightmapIndex: number;
        DstLightmapIndex: number;
        BuildScale: number;
        BuildScale3D: UE.Vector;
        DistanceFieldResolutionScale: number;
        DistanceFieldBias: number;
        DistanceFieldReplacementMesh: UE.StaticMesh;
        static StaticClass(): Class;
    }
    
    enum EMeshFeatureImportance { Off, Lowest, Low, Normal, High, Highest, EMeshFeatureImportance_MAX}
    enum EStaticMeshReductionTerimationCriterion { Triangles, Vertices, Any, EStaticMeshReductionTerimationCriterion_MAX}
    class MeshReductionSettings {
        constructor();
        constructor(PercentTriangles: number, PercentVertices: number, MaxDeviation: number, PixelError: number, WeldingThreshold: number, HardAngleThreshold: number, BaseLODModel: number, SilhouetteImportance: UE.EMeshFeatureImportance, TextureImportance: UE.EMeshFeatureImportance, ShadingImportance: UE.EMeshFeatureImportance, bRecalculateNormals: boolean, bGenerateUniqueLightmapUVs: boolean, bKeepSymmetry: boolean, bVisibilityAided: boolean, bCullOccluded: boolean, TerminationCriterion: UE.EStaticMeshReductionTerimationCriterion, VisibilityAggressiveness: UE.EMeshFeatureImportance, VertexColorImportance: UE.EMeshFeatureImportance);
        PercentTriangles: number;
        PercentVertices: number;
        MaxDeviation: number;
        PixelError: number;
        WeldingThreshold: number;
        HardAngleThreshold: number;
        BaseLODModel: number;
        SilhouetteImportance: UE.EMeshFeatureImportance;
        TextureImportance: UE.EMeshFeatureImportance;
        ShadingImportance: UE.EMeshFeatureImportance;
        bRecalculateNormals: boolean;
        bGenerateUniqueLightmapUVs: boolean;
        bKeepSymmetry: boolean;
        bVisibilityAided: boolean;
        bCullOccluded: boolean;
        TerminationCriterion: UE.EStaticMeshReductionTerimationCriterion;
        VisibilityAggressiveness: UE.EMeshFeatureImportance;
        VertexColorImportance: UE.EMeshFeatureImportance;
        static StaticClass(): Class;
    }
    
    class StaticMeshSourceModel {
        constructor();
        constructor(BuildSettings: UE.MeshBuildSettings, ReductionSettings: UE.MeshReductionSettings, LODDistance: number, ScreenSize: UE.PerPlatformFloat, SourceImportFilename: string, bImportWithBaseMesh: boolean);
        BuildSettings: UE.MeshBuildSettings;
        ReductionSettings: UE.MeshReductionSettings;
        LODDistance: number;
        ScreenSize: UE.PerPlatformFloat;
        SourceImportFilename: string;
        bImportWithBaseMesh: boolean;
        static StaticClass(): Class;
    }
    
    class MeshSectionInfo {
        constructor();
        constructor(MaterialIndex: number, bEnableCollision: boolean, bCastShadow: boolean);
        MaterialIndex: number;
        bEnableCollision: boolean;
        bCastShadow: boolean;
        static StaticClass(): Class;
    }
    
    class MeshSectionInfoMap {
        constructor();
        constructor(Map: TMap<number, UE.MeshSectionInfo>);
        Map: TMap<number, UE.MeshSectionInfo>;
        static StaticClass(): Class;
    }
    
    class MaterialRemapIndex {
        constructor();
        constructor(ImportVersionKey: number, MaterialRemap: TArray<number>);
        ImportVersionKey: number;
        MaterialRemap: TArray<number>;
        static StaticClass(): Class;
    }
    
    class StaticMaterial {
        constructor();
        constructor(MaterialInterface: UE.MaterialInterface, MaterialSlotName: string, ImportedMaterialSlotName: string, UVChannelData: UE.MeshUVChannelInfo);
        MaterialInterface: UE.MaterialInterface;
        MaterialSlotName: string;
        ImportedMaterialSlotName: string;
        UVChannelData: UE.MeshUVChannelInfo;
        static StaticClass(): Class;
    }
    
    class AssetEditorOrbitCameraPosition {
        constructor();
        constructor(bIsSet: boolean, CamOrbitPoint: UE.Vector, CamOrbitZoom: UE.Vector, CamOrbitRotation: UE.Rotator);
        bIsSet: boolean;
        CamOrbitPoint: UE.Vector;
        CamOrbitZoom: UE.Vector;
        CamOrbitRotation: UE.Rotator;
        static StaticClass(): Class;
    }
    
    class StaticMeshSocket extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SocketName: string;
        RelativeLocation: UE.Vector;
        RelativeRotation: UE.Rotator;
        RelativeScale: UE.Vector;
        Tag: string;
        PreviewStaticMesh: UE.StaticMesh;
        bSocketCreatedAtImport: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshSocket;
        static Load(InName: string): StaticMeshSocket;
    }
    
    class NavCollisionBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsDynamicObstacle: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavCollisionBase;
        static Load(InName: string): NavCollisionBase;
    }
    
    class ElementID {
        constructor();
        constructor(IDValue: number);
        IDValue: number;
        static StaticClass(): Class;
    }
    
    class VertexID extends UE.ElementID {
        constructor();
        static StaticClass(): Class;
    }
    
    class PolygonID extends UE.ElementID {
        constructor();
        static StaticClass(): Class;
    }
    
    class VertexInstanceID extends UE.ElementID {
        constructor();
        static StaticClass(): Class;
    }
    
    class PolygonGroupID extends UE.ElementID {
        constructor();
        static StaticClass(): Class;
    }
    
    class TriangleID extends UE.ElementID {
        constructor();
        static StaticClass(): Class;
    }
    
    class EdgeID extends UE.ElementID {
        constructor();
        static StaticClass(): Class;
    }
    
    class MeshDescriptionBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ComputePolygonTriangulation(PolygonID: UE.PolygonID) : void;
        CreateEdge(VertexID0: UE.VertexID, VertexID1: UE.VertexID) : UE.EdgeID;
        CreateEdgeWithID(EdgeID: UE.EdgeID, VertexID0: UE.VertexID, VertexID1: UE.VertexID) : void;
        CreatePolygon(PolygonGroupID: UE.PolygonGroupID, VertexInstanceIDs: $Ref<TArray<UE.VertexInstanceID>>, NewEdgeIDs: $Ref<TArray<UE.EdgeID>>) : UE.PolygonID;
        CreatePolygonGroup() : UE.PolygonGroupID;
        CreatePolygonGroupWithID(PolygonGroupID: UE.PolygonGroupID) : void;
        CreatePolygonWithID(PolygonID: UE.PolygonID, PolygonGroupID: UE.PolygonGroupID, VertexInstanceIDs: $Ref<TArray<UE.VertexInstanceID>>, NewEdgeIDs: $Ref<TArray<UE.EdgeID>>) : void;
        CreateTriangle(PolygonGroupID: UE.PolygonGroupID, VertexInstanceIDs: TArray<UE.VertexInstanceID>, NewEdgeIDs: $Ref<TArray<UE.EdgeID>>) : UE.TriangleID;
        CreateTriangleWithID(TriangleID: UE.TriangleID, PolygonGroupID: UE.PolygonGroupID, VertexInstanceIDs: TArray<UE.VertexInstanceID>, NewEdgeIDs: $Ref<TArray<UE.EdgeID>>) : void;
        CreateVertex() : UE.VertexID;
        CreateVertexInstance(VertexID: UE.VertexID) : UE.VertexInstanceID;
        CreateVertexInstanceWithID(VertexInstanceID: UE.VertexInstanceID, VertexID: UE.VertexID) : void;
        CreateVertexWithID(VertexID: UE.VertexID) : void;
        DeleteEdge(EdgeID: UE.EdgeID, OrphanedVertices: $Ref<TArray<UE.VertexID>>) : void;
        DeletePolygon(PolygonID: UE.PolygonID, OrphanedEdges: $Ref<TArray<UE.EdgeID>>, OrphanedVertexInstances: $Ref<TArray<UE.VertexInstanceID>>, OrphanedPolygonGroups: $Ref<TArray<UE.PolygonGroupID>>) : void;
        DeletePolygonGroup(PolygonGroupID: UE.PolygonGroupID) : void;
        DeleteTriangle(TriangleID: UE.TriangleID, OrphanedEdges: $Ref<TArray<UE.EdgeID>>, OrphanedVertexInstances: $Ref<TArray<UE.VertexInstanceID>>, OrphanedPolygonGroupsPtr: $Ref<TArray<UE.PolygonGroupID>>) : void;
        DeleteVertex(VertexID: UE.VertexID) : void;
        DeleteVertexInstance(VertexInstanceID: UE.VertexInstanceID, OrphanedVertices: $Ref<TArray<UE.VertexID>>) : void;
        Empty() : void;
        GetEdgeConnectedPolygons(EdgeID: UE.EdgeID, OutConnectedPolygonIDs: $Ref<TArray<UE.PolygonID>>) : void;
        GetEdgeConnectedTriangles(EdgeID: UE.EdgeID, OutConnectedTriangleIDs: $Ref<TArray<UE.TriangleID>>) : void;
        GetEdgeVertex(EdgeID: UE.EdgeID, VertexNumber: number) : UE.VertexID;
        GetEdgeVertices(EdgeID: UE.EdgeID, OutVertexIDs: $Ref<TArray<UE.VertexID>>) : void;
        GetNumEdgeConnectedPolygons(EdgeID: UE.EdgeID) : number;
        GetNumEdgeConnectedTriangles(EdgeID: UE.EdgeID) : number;
        GetNumPolygonGroupPolygons(PolygonGroupID: UE.PolygonGroupID) : number;
        GetNumPolygonInternalEdges(PolygonID: UE.PolygonID) : number;
        GetNumPolygonTriangles(PolygonID: UE.PolygonID) : number;
        GetNumPolygonVertices(PolygonID: UE.PolygonID) : number;
        GetNumVertexConnectedEdges(VertexID: UE.VertexID) : number;
        GetNumVertexConnectedPolygons(VertexID: UE.VertexID) : number;
        GetNumVertexConnectedTriangles(VertexID: UE.VertexID) : number;
        GetNumVertexInstanceConnectedPolygons(VertexInstanceID: UE.VertexInstanceID) : number;
        GetNumVertexInstanceConnectedTriangles(VertexInstanceID: UE.VertexInstanceID) : number;
        GetNumVertexVertexInstances(VertexID: UE.VertexID) : number;
        GetPolygonAdjacentPolygons(PolygonID: UE.PolygonID, OutPolygonIDs: $Ref<TArray<UE.PolygonID>>) : void;
        GetPolygonGroupPolygons(PolygonGroupID: UE.PolygonGroupID, OutPolygonIDs: $Ref<TArray<UE.PolygonID>>) : void;
        GetPolygonInternalEdges(PolygonID: UE.PolygonID, OutEdgeIDs: $Ref<TArray<UE.EdgeID>>) : void;
        GetPolygonPerimeterEdges(PolygonID: UE.PolygonID, OutEdgeIDs: $Ref<TArray<UE.EdgeID>>) : void;
        GetPolygonPolygonGroup(PolygonID: UE.PolygonID) : UE.PolygonGroupID;
        GetPolygonTriangles(PolygonID: UE.PolygonID, OutTriangleIDs: $Ref<TArray<UE.TriangleID>>) : void;
        GetPolygonVertexInstances(PolygonID: UE.PolygonID, OutVertexInstanceIDs: $Ref<TArray<UE.VertexInstanceID>>) : void;
        GetPolygonVertices(PolygonID: UE.PolygonID, OutVertexIDs: $Ref<TArray<UE.VertexID>>) : void;
        GetTriangleAdjacentTriangles(TriangleID: UE.TriangleID, OutTriangleIDs: $Ref<TArray<UE.TriangleID>>) : void;
        GetTriangleEdges(TriangleID: UE.TriangleID, OutEdgeIDs: $Ref<TArray<UE.EdgeID>>) : void;
        GetTrianglePolygon(TriangleID: UE.TriangleID) : UE.PolygonID;
        GetTrianglePolygonGroup(TriangleID: UE.TriangleID) : UE.PolygonGroupID;
        GetTriangleVertexInstance(TriangleID: UE.TriangleID, Index: number) : UE.VertexInstanceID;
        GetTriangleVertexInstances(TriangleID: UE.TriangleID, OutVertexInstanceIDs: $Ref<TArray<UE.VertexInstanceID>>) : void;
        GetTriangleVertices(TriangleID: UE.TriangleID, OutVertexIDs: $Ref<TArray<UE.VertexID>>) : void;
        GetVertexAdjacentVertices(VertexID: UE.VertexID, OutAdjacentVertexIDs: $Ref<TArray<UE.VertexID>>) : void;
        GetVertexConnectedEdges(VertexID: UE.VertexID, OutEdgeIDs: $Ref<TArray<UE.EdgeID>>) : void;
        GetVertexConnectedPolygons(VertexID: UE.VertexID, OutConnectedPolygonIDs: $Ref<TArray<UE.PolygonID>>) : void;
        GetVertexConnectedTriangles(VertexID: UE.VertexID, OutConnectedTriangleIDs: $Ref<TArray<UE.TriangleID>>) : void;
        GetVertexInstanceConnectedPolygons(VertexInstanceID: UE.VertexInstanceID, OutConnectedPolygonIDs: $Ref<TArray<UE.PolygonID>>) : void;
        GetVertexInstanceConnectedTriangles(VertexInstanceID: UE.VertexInstanceID, OutConnectedTriangleIDs: $Ref<TArray<UE.TriangleID>>) : void;
        GetVertexInstanceForPolygonVertex(PolygonID: UE.PolygonID, VertexID: UE.VertexID) : UE.VertexInstanceID;
        GetVertexInstanceForTriangleVertex(TriangleID: UE.TriangleID, VertexID: UE.VertexID) : UE.VertexInstanceID;
        GetVertexInstancePairEdge(VertexInstanceID0: UE.VertexInstanceID, VertexInstanceID1: UE.VertexInstanceID) : UE.EdgeID;
        GetVertexInstanceVertex(VertexInstanceID: UE.VertexInstanceID) : UE.VertexID;
        GetVertexPairEdge(VertexID0: UE.VertexID, VertexID1: UE.VertexID) : UE.EdgeID;
        GetVertexPosition(VertexID: UE.VertexID) : UE.Vector;
        GetVertexVertexInstances(VertexID: UE.VertexID, OutVertexInstanceIDs: $Ref<TArray<UE.VertexInstanceID>>) : void;
        IsEdgeInternal(EdgeID: UE.EdgeID) : boolean;
        IsEdgeInternalToPolygon(EdgeID: UE.EdgeID, PolygonID: UE.PolygonID) : boolean;
        IsEdgeValid(EdgeID: UE.EdgeID) : boolean;
        IsEmpty() : boolean;
        IsPolygonGroupValid(PolygonGroupID: UE.PolygonGroupID) : boolean;
        IsPolygonValid(PolygonID: UE.PolygonID) : boolean;
        IsTrianglePartOfNgon(TriangleID: UE.TriangleID) : boolean;
        IsTriangleValid(TriangleID: UE.TriangleID) : boolean;
        IsVertexInstanceValid(VertexInstanceID: UE.VertexInstanceID) : boolean;
        IsVertexOrphaned(VertexID: UE.VertexID) : boolean;
        IsVertexValid(VertexID: UE.VertexID) : boolean;
        ReserveNewEdges(NumberOfNewEdges: number) : void;
        ReserveNewPolygonGroups(NumberOfNewPolygonGroups: number) : void;
        ReserveNewPolygons(NumberOfNewPolygons: number) : void;
        ReserveNewTriangles(NumberOfNewTriangles: number) : void;
        ReserveNewVertexInstances(NumberOfNewVertexInstances: number) : void;
        ReserveNewVertices(NumberOfNewVertices: number) : void;
        ReversePolygonFacing(PolygonID: UE.PolygonID) : void;
        SetPolygonPolygonGroup(PolygonID: UE.PolygonID, PolygonGroupID: UE.PolygonGroupID) : void;
        SetPolygonVertexInstance(PolygonID: UE.PolygonID, PerimeterIndex: number, VertexInstanceID: UE.VertexInstanceID) : void;
        SetVertexPosition(VertexID: UE.VertexID, Position: UE.Vector) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshDescriptionBase;
        static Load(InName: string): MeshDescriptionBase;
    }
    
    class StaticMeshDescription extends UE.MeshDescriptionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CreateCube(Center: UE.Vector, HalfExtents: UE.Vector, PolygonGroup: UE.PolygonGroupID, PolygonID_PlusX: $Ref<UE.PolygonID>, PolygonID_MinusX: $Ref<UE.PolygonID>, PolygonID_PlusY: $Ref<UE.PolygonID>, PolygonID_MinusY: $Ref<UE.PolygonID>, PolygonID_PlusZ: $Ref<UE.PolygonID>, PolygonID_MinusZ: $Ref<UE.PolygonID>) : void;
        GetVertexInstanceUV(VertexInstanceID: UE.VertexInstanceID, UVIndex?: number /* = 0 */) : UE.Vector2D;
        SetPolygonGroupMaterialSlotName(PolygonGroupID: UE.PolygonGroupID, SlotName: string) : void;
        SetVertexInstanceUV(VertexInstanceID: UE.VertexInstanceID, UV: UE.Vector2D, UVIndex?: number /* = 0 */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshDescription;
        static Load(InName: string): StaticMeshDescription;
    }
    
    class StaticMesh extends UE.StreamableRenderAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceModels: TArray<UE.StaticMeshSourceModel>;
        SectionInfoMap: UE.MeshSectionInfoMap;
        OriginalSectionInfoMap: UE.MeshSectionInfoMap;
        LODGroup: string;
        NumStreamedLODs: UE.PerPlatformInt;
        ImportVersion: number;
        MaterialRemapIndexPerImportVersion: TArray<UE.MaterialRemapIndex>;
        LightmapUVVersion: number;
        bAutoComputeLODScreenSize: boolean;
        Materials: TArray<UE.MaterialInterface>;
        MinLOD: UE.PerPlatformInt;
        LpvBiasMultiplier: number;
        StaticMaterials: TArray<UE.StaticMaterial>;
        LightmapUVDensity: number;
        LightMapResolution: number;
        LightMapCoordinateIndex: number;
        DistanceFieldSelfShadowBias: number;
        BodySetup: UE.BodySetup;
        LODForCollision: number;
        bGenerateMeshDistanceField: boolean;
        bStripComplexCollisionForConsole: boolean;
        bHasNavigationData: boolean;
        bSupportUniformlyDistributedSampling: boolean;
        bIsBuiltAtRuntime: boolean;
        bAllowCPUAccess: boolean;
        bSupportGpuUniformlyDistributedSampling: boolean;
        AssetImportData: UE.AssetImportData;
        SourceFilePath: string;
        SourceFileTimestamp: string;
        ThumbnailInfo: UE.ThumbnailInfo;
        EditorCameraPosition: UE.AssetEditorOrbitCameraPosition;
        bCustomizedCollision: boolean;
        LODForOccluderMesh: number;
        Sockets: TArray<UE.StaticMeshSocket>;
        PositiveBoundsExtension: UE.Vector;
        NegativeBoundsExtension: UE.Vector;
        ExtendedBounds: UE.BoxSphereBounds;
        ElementToIgnoreForTexFactor: number;
        AssetUserData: TArray<UE.AssetUserData>;
        EditableMesh: UE.Object;
        ComplexCollisionMesh: UE.StaticMesh;
        NavCollision: UE.NavCollisionBase;
        AddMaterial(Material: $Nullable<UE.MaterialInterface>) : string;
        AddSocket(Socket: $Nullable<UE.StaticMeshSocket>) : void;
        BuildFromStaticMeshDescriptions(StaticMeshDescriptions: TArray<UE.StaticMeshDescription>) : void;
        FindSocket(InSocketName: string) : UE.StaticMeshSocket;
        GetBoundingBox() : UE.Box;
        GetBounds() : UE.BoxSphereBounds;
        GetMaterial(MaterialIndex: number) : UE.MaterialInterface;
        GetMaterialIndex(MaterialSlotName: string) : number;
        GetMinimumLODForPlatform(PlatformName: string) : number;
        GetMinimumLODForPlatforms(PlatformMinimumLODs: $Ref<TMap<string, number>>) : void;
        GetNumLODs() : number;
        GetNumSections(InLOD: number) : number;
        RemoveSocket(Socket: $Nullable<UE.StaticMeshSocket>) : void;
        SetMaterial(MaterialIndex: number, NewMaterial: $Nullable<UE.MaterialInterface>) : void;
        SetNumSourceModels(Num: number) : void;
        static CreateStaticMeshDescription(Outer?: UE.Object /* = None */) : UE.StaticMeshDescription;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMesh;
        static Load(InName: string): StaticMesh;
    }
    
    class Interface extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Interface;
        static Load(InName: string): Interface;
    }
    
    class BlendableInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlendableInterface;
        static Load(InName: string): BlendableInterface;
    }
    
    class CameraComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FieldOfView: number;
        OrthoWidth: number;
        OrthoNearClipPlane: number;
        OrthoFarClipPlane: number;
        AspectRatio: number;
        bConstrainAspectRatio: boolean;
        bUseFieldOfViewForLOD: boolean;
        bCameraMeshHiddenInGame: boolean;
        bLockToHmd: boolean;
        bUsePawnControlRotation: boolean;
        ProjectionMode: UE.ECameraProjectionMode;
        CameraMesh: UE.StaticMesh;
        PostProcessBlendWeight: number;
        PostProcessSettings: UE.PostProcessSettings;
        bUseControllerViewRotation: boolean;
        AddOrUpdateBlendable(InBlendableObject: BlendableInterface, InWeight?: number /* = 1.000000 */) : void;
        GetCameraView(DeltaTime: number, DesiredView: $Ref<UE.MinimalViewInfo>) : void;
        GetFilmbackText() : string;
        OnCameraMeshHiddenChanged() : void;
        RemoveBlendable(InBlendableObject: BlendableInterface) : void;
        SetAspectRatio(InAspectRatio: number) : void;
        SetConstraintAspectRatio(bInConstrainAspectRatio: boolean) : void;
        SetFieldOfView(InFieldOfView: number) : void;
        SetOrthoFarClipPlane(InOrthoFarClipPlane: number) : void;
        SetOrthoNearClipPlane(InOrthoNearClipPlane: number) : void;
        SetOrthoWidth(InOrthoWidth: number) : void;
        SetPostProcessBlendWeight(InPostProcessBlendWeight: number) : void;
        SetProjectionMode(InProjectionMode: UE.ECameraProjectionMode) : void;
        SetUseFieldOfViewForLOD(bInUseFieldOfViewForLOD: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraComponent;
        static Load(InName: string): CameraComponent;
    }
    
    class CameraActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AutoActivateForPlayer: UE.EAutoReceiveInput;
        CameraComponent: UE.CameraComponent;
        SceneComponent: UE.SceneComponent;
        bConstrainAspectRatio: boolean;
        AspectRatio: number;
        FOVAngle: number;
        PostProcessBlendWeight: number;
        PostProcessSettings: UE.PostProcessSettings;
        GetAutoActivatePlayerIndex() : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraActor;
        static Load(InName: string): CameraActor;
    }
    
    class PlayerCameraManager extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PCOwner: UE.PlayerController;
        TransformComponent: UE.SceneComponent;
        DefaultFOV: number;
        DefaultOrthoWidth: number;
        DefaultAspectRatio: number;
        CameraCache: UE.CameraCacheEntry;
        LastFrameCameraCache: UE.CameraCacheEntry;
        ViewTarget: UE.TViewTarget;
        PendingViewTarget: UE.TViewTarget;
        CameraCachePrivate: UE.CameraCacheEntry;
        LastFrameCameraCachePrivate: UE.CameraCacheEntry;
        ModifierList: TArray<UE.CameraModifier>;
        DefaultModifiers: TArray<UE.Class>;
        FreeCamDistance: number;
        FreeCamOffset: UE.Vector;
        ViewTargetOffset: UE.Vector;
        CameraLensEffects: TArray<UE.EmitterCameraLensEffectBase>;
        CachedCameraShakeMod: UE.CameraModifier_CameraShake;
        AnimInstPool: FixSizeArray<UE.CameraAnimInst>;
        PostProcessBlendCache: TArray<UE.PostProcessSettings>;
        ActiveAnims: TArray<UE.CameraAnimInst>;
        FreeAnims: TArray<UE.CameraAnimInst>;
        AnimCameraActor: UE.CameraActor;
        bIsOrthographic: boolean;
        bDefaultConstrainAspectRatio: boolean;
        bClientSimulatingViewTarget: boolean;
        bUseClientSideCameraUpdates: boolean;
        bGameCameraCutThisFrame: boolean;
        ViewPitchMin: number;
        ViewPitchMax: number;
        ViewYawMin: number;
        ViewYawMax: number;
        ViewRollMin: number;
        ViewRollMax: number;
        ServerUpdateCameraTimeout: number;
        AddCameraLensEffect(LensEffectEmitterClass: $Nullable<UE.Class>) : UE.EmitterCameraLensEffectBase;
        AddNewCameraModifier(ModifierClass: $Nullable<UE.Class>) : UE.CameraModifier;
        BlueprintUpdateCamera(CameraTarget: $Nullable<UE.Actor>, NewCameraLocation: $Ref<UE.Vector>, NewCameraRotation: $Ref<UE.Rotator>, NewCameraFOV: $Ref<number>) : boolean;
        ClearCameraLensEffects() : void;
        FindCameraModifierByClass(ModifierClass: $Nullable<UE.Class>) : UE.CameraModifier;
        GetCameraLocation() : UE.Vector;
        GetCameraRotation() : UE.Rotator;
        GetFOVAngle() : number;
        GetOwningPlayerController() : UE.PlayerController;
        OnPhotographyMultiPartCaptureEnd() : void;
        OnPhotographyMultiPartCaptureStart() : void;
        OnPhotographySessionEnd() : void;
        OnPhotographySessionStart() : void;
        PhotographyCameraModify(NewCameraLocation: UE.Vector, PreviousCameraLocation: UE.Vector, OriginalCameraLocation: UE.Vector, ResultCameraLocation: $Ref<UE.Vector>) : void;
        PlayCameraAnim(Anim: $Nullable<UE.CameraAnim>, Rate?: number /* = 1.000000 */, Scale?: number /* = 1.000000 */, BlendInTime?: number /* = 0.000000 */, BlendOutTime?: number /* = 0.000000 */, bLoop?: boolean /* = false */, bRandomStartTime?: boolean /* = false */, Duration?: number /* = 0.000000 */, PlaySpace?: UE.ECameraAnimPlaySpace /* = CameraLocal */, UserPlaySpaceRot?: UE.Rotator /* =  */) : UE.CameraAnimInst;
        PlayCameraShake(ShakeClass: $Nullable<UE.Class>, Scale?: number /* = 1.000000 */, PlaySpace?: UE.ECameraAnimPlaySpace /* = CameraLocal */, UserPlaySpaceRot?: UE.Rotator /* =  */) : UE.CameraShake;
        RemoveCameraLensEffect(Emitter: $Nullable<UE.EmitterCameraLensEffectBase>) : void;
        RemoveCameraModifier(ModifierToRemove: $Nullable<UE.CameraModifier>) : boolean;
        SetGameCameraCutThisFrame() : void;
        SetManualCameraFade(InFadeAmount: number, Color: UE.LinearColor, bInFadeAudio: boolean) : void;
        StartCameraFade(FromAlpha: number, ToAlpha: number, Duration: number, Color: UE.LinearColor, bShouldFadeAudio?: boolean /* = false */, bHoldWhenFinished?: boolean /* = false */) : void;
        StopAllCameraAnims(bImmediate?: boolean /* = false */) : void;
        StopAllCameraShakes(bImmediately?: boolean /* = true */) : void;
        StopAllInstancesOfCameraAnim(Anim: $Nullable<UE.CameraAnim>, bImmediate?: boolean /* = false */) : void;
        StopAllInstancesOfCameraShake(Shake: $Nullable<UE.Class>, bImmediately?: boolean /* = true */) : void;
        StopCameraAnimInst(AnimInst: $Nullable<UE.CameraAnimInst>, bImmediate?: boolean /* = false */) : void;
        StopCameraFade() : void;
        StopCameraShake(ShakeInstance: $Nullable<UE.CameraShake>, bImmediately?: boolean /* = true */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlayerCameraManager;
        static Load(InName: string): PlayerCameraManager;
    }
    
    class DrawFrustumComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FrustumColor: UE.Color;
        FrustumAngle: number;
        FrustumAspectRatio: number;
        FrustumStartDist: number;
        FrustumEndDist: number;
        Texture: UE.Texture;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DrawFrustumComponent;
        static Load(InName: string): DrawFrustumComponent;
    }
    
    class DebugCameraController extends UE.PlayerController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bShowSelectedInfo: boolean;
        bIsFrozenRendering: boolean;
        bIsOrbitingSelectedActor: boolean;
        bOrbitPivotUseCenter: boolean;
        bEnableBufferVisualization: boolean;
        bEnableBufferVisualizationFullMode: boolean;
        bIsBufferVisualizationInputSetup: boolean;
        bLastDisplayEnabled: boolean;
        DrawFrustum: UE.DrawFrustumComponent;
        SelectedActor: UE.Actor;
        SelectedComponent: UE.PrimitiveComponent;
        SelectedHitPoint: UE.HitResult;
        OriginalControllerRef: UE.PlayerController;
        OriginalPlayer: UE.Player;
        SpeedScale: number;
        InitialMaxSpeed: number;
        InitialAccel: number;
        InitialDecel: number;
        GetSelectedActor() : UE.Actor;
        ReceiveOnActivate(OriginalPC: $Nullable<UE.PlayerController>) : void;
        ReceiveOnActorSelected(NewSelectedActor: $Nullable<UE.Actor>, SelectHitLocation: UE.Vector, SelectHitNormal: UE.Vector, Hit: UE.HitResult) : void;
        ReceiveOnDeactivate(RestoredPC: $Nullable<UE.PlayerController>) : void;
        SetPawnMovementSpeedScale(NewSpeedScale: number) : void;
        ShowDebugSelectedInfo() : void;
        ToggleDisplay() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DebugCameraController;
        static Load(InName: string): DebugCameraController;
    }
    
    class CheatManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DebugCameraControllerRef: UE.DebugCameraController;
        DebugCameraControllerClass: UE.Class;
        BugIt(ScreenShotDescription?: string /* = "" */) : void;
        BugItGo(X: number, Y: number, Z: number, Pitch: number, Yaw: number, Roll: number) : void;
        BugItStringCreator(ViewLocation: UE.Vector, ViewRotation: UE.Rotator, GoString: $Ref<string>, LocString: $Ref<string>) : void;
        ChangeSize(F: number) : void;
        CheatScript(ScriptName: string) : void;
        DamageTarget(DamageAmount: number) : void;
        DebugCapsuleSweep() : void;
        DebugCapsuleSweepCapture() : void;
        DebugCapsuleSweepChannel(Channel: UE.ECollisionChannel) : void;
        DebugCapsuleSweepClear() : void;
        DebugCapsuleSweepComplex(bTraceComplex: boolean) : void;
        DebugCapsuleSweepPawn() : void;
        DebugCapsuleSweepSize(HalfHeight: number, Radius: number) : void;
        DestroyAll(aClass: $Nullable<UE.Class>) : void;
        DestroyAllPawnsExceptTarget() : void;
        DestroyPawns(aClass: $Nullable<UE.Class>) : void;
        DestroyServerStatReplicator() : void;
        DestroyTarget() : void;
        DisableDebugCamera() : void;
        DumpChatState() : void;
        DumpOnlineSessionState() : void;
        DumpPartyState() : void;
        DumpVoiceMutingState() : void;
        EnableDebugCamera() : void;
        FlushLog() : void;
        Fly() : void;
        FreezeFrame(Delay: number) : void;
        Ghost() : void;
        God() : void;
        InvertMouse() : void;
        LogLoc() : void;
        OnlyLoadLevel(PackageName: string) : void;
        PlayersOnly() : void;
        ReceiveEndPlay() : void;
        ReceiveInitCheatManager() : void;
        ServerToggleAILogging() : void;
        SetMouseSensitivityToDefault() : void;
        SetWorldOrigin() : void;
        Slomo(NewTimeDilation: number) : void;
        SpawnServerStatReplicator() : void;
        StreamLevelIn(PackageName: string) : void;
        StreamLevelOut(PackageName: string) : void;
        Summon(ClassName: string) : void;
        Teleport() : void;
        TestCollisionDistance() : void;
        ToggleAILogging() : void;
        ToggleDebugCamera() : void;
        ToggleServerStatReplicatorClientOverwrite() : void;
        ToggleServerStatReplicatorUpdateStatNet() : void;
        UpdateSafeArea() : void;
        ViewActor(ActorName: string) : void;
        ViewClass(DesiredClass: $Nullable<UE.Class>) : void;
        ViewPlayer(S: string) : void;
        ViewSelf() : void;
        Walk() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CheatManager;
        static Load(InName: string): CheatManager;
    }
    
    class KeyBind {
        constructor();
        constructor(Key: UE.Key, Command: string, Control: boolean, Shift: boolean, Alt: boolean, Cmd: boolean, bIgnoreCtrl: boolean, bIgnoreShift: boolean, bIgnoreAlt: boolean, bIgnoreCmd: boolean, bDisabled: boolean);
        Key: UE.Key;
        Command: string;
        Control: boolean;
        Shift: boolean;
        Alt: boolean;
        Cmd: boolean;
        bIgnoreCtrl: boolean;
        bIgnoreShift: boolean;
        bIgnoreAlt: boolean;
        bIgnoreCmd: boolean;
        bDisabled: boolean;
        static StaticClass(): Class;
    }
    
    class PlayerInput extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DebugExecBindings: TArray<UE.KeyBind>;
        InvertedAxis: TArray<string>;
        ClearSmoothing() : void;
        InvertAxis(AxisName: string) : void;
        InvertAxisKey(AxisKey: UE.Key) : void;
        SetBind(BindName: string, Command: string) : void;
        SetMouseSensitivity(Sensitivity: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlayerInput;
        static Load(InName: string): PlayerInput;
    }
    
    class RuntimeFloatCurve {
        constructor();
        constructor(EditorCurveData: UE.RichCurve, ExternalCurve: UE.CurveFloat);
        EditorCurveData: UE.RichCurve;
        ExternalCurve: UE.CurveFloat;
        static StaticClass(): Class;
    }
    
    class ForceFeedbackChannelDetails {
        constructor();
        constructor(bAffectsLeftLarge: boolean, bAffectsLeftSmall: boolean, bAffectsRightLarge: boolean, bAffectsRightSmall: boolean, Curve: UE.RuntimeFloatCurve);
        bAffectsLeftLarge: boolean;
        bAffectsLeftSmall: boolean;
        bAffectsRightLarge: boolean;
        bAffectsRightSmall: boolean;
        Curve: UE.RuntimeFloatCurve;
        static StaticClass(): Class;
    }
    
    class ForceFeedbackEffect extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChannelDetails: TArray<UE.ForceFeedbackChannelDetails>;
        Duration: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ForceFeedbackEffect;
        static Load(InName: string): ForceFeedbackEffect;
    }
    
    class ActiveForceFeedbackEffect {
        constructor();
        constructor(ForceFeedbackEffect: UE.ForceFeedbackEffect);
        ForceFeedbackEffect: UE.ForceFeedbackEffect;
        static StaticClass(): Class;
    }
    
    class ChildConnection extends UE.NetConnection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Parent: UE.NetConnection;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChildConnection;
        static Load(InName: string): ChildConnection;
    }
    
    class LayerActorStats {
        constructor();
        constructor(Type: UE.Class, Total: number);
        Type: UE.Class;
        Total: number;
        static StaticClass(): Class;
    }
    
    class Layer extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LayerName: string;
        bIsVisible: boolean;
        ActorStats: TArray<UE.LayerActorStats>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Layer;
        static Load(InName: string): Layer;
    }
    
    class ModelComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ModelBodySetup: UE.BodySetup;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ModelComponent;
        static Load(InName: string): ModelComponent;
    }
    
    class LevelActorContainer extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Actors: TArray<UE.Actor>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelActorContainer;
        static Load(InName: string): LevelActorContainer;
    }
    
    class LevelScriptBlueprint extends UE.Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FriendlyName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelScriptBlueprint;
        static Load(InName: string): LevelScriptBlueprint;
    }
    
    class LevelScriptActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bInputEnabled: boolean;
        LevelReset() : void;
        RemoteEvent(EventName: string) : boolean;
        SetCinematicMode(bCinematicMode: boolean, bHidePlayer?: boolean /* = true */, bAffectsHUD?: boolean /* = true */, bAffectsMovement?: boolean /* = false */, bAffectsTurning?: boolean /* = false */) : void;
        WorldOriginLocationChanged(OldOriginLocation: UE.IntVector, NewOriginLocation: UE.IntVector) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelScriptActor;
        static Load(InName: string): LevelScriptActor;
    }
    
    class NavigationObjectBase extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CapsuleComponent: UE.CapsuleComponent;
        GoodSprite: UE.BillboardComponent;
        BadSprite: UE.BillboardComponent;
        bIsPIEPlayerStart: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationObjectBase;
        static Load(InName: string): NavigationObjectBase;
    }
    
    class NavigationDataChunk extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NavigationDataName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationDataChunk;
        static Load(InName: string): NavigationDataChunk;
    }
    
    enum ELightingBuildQuality { Quality_Preview, Quality_Medium, Quality_High, Quality_Production, Quality_MAX}
    class MapBuildDataRegistry extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LevelLightingQuality: UE.ELightingBuildQuality;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MapBuildDataRegistry;
        static Load(InName: string): MapBuildDataRegistry;
    }
    
    enum ETextureSizingType { TextureSizingType_UseSingleTextureSize, TextureSizingType_UseAutomaticBiasedSizes, TextureSizingType_UseManualOverrideTextureSize, TextureSizingType_UseSimplygonAutomaticSizing, TextureSizingType_MAX}
    enum EMaterialMergeType { MaterialMergeType_Default, MaterialMergeType_Simplygon, MaterialMergeType_MAX}
    class MaterialProxySettings {
        constructor();
        constructor(TextureSize: UE.IntPoint, GutterSpace: number, MetallicConstant: number, RoughnessConstant: number, SpecularConstant: number, OpacityConstant: number, OpacityMaskConstant: number, AmbientOcclusionConstant: number, TextureSizingType: UE.ETextureSizingType, MaterialMergeType: UE.EMaterialMergeType, BlendMode: UE.EBlendMode, bAllowTwoSidedMaterial: boolean, bNormalMap: boolean, bMetallicMap: boolean, bRoughnessMap: boolean, bSpecularMap: boolean, bEmissiveMap: boolean, bOpacityMap: boolean, bOpacityMaskMap: boolean, bAmbientOcclusionMap: boolean, DiffuseTextureSize: UE.IntPoint, NormalTextureSize: UE.IntPoint, MetallicTextureSize: UE.IntPoint, RoughnessTextureSize: UE.IntPoint, SpecularTextureSize: UE.IntPoint, EmissiveTextureSize: UE.IntPoint, OpacityTextureSize: UE.IntPoint, OpacityMaskTextureSize: UE.IntPoint, AmbientOcclusionTextureSize: UE.IntPoint);
        TextureSize: UE.IntPoint;
        GutterSpace: number;
        MetallicConstant: number;
        RoughnessConstant: number;
        SpecularConstant: number;
        OpacityConstant: number;
        OpacityMaskConstant: number;
        AmbientOcclusionConstant: number;
        TextureSizingType: UE.ETextureSizingType;
        MaterialMergeType: UE.EMaterialMergeType;
        BlendMode: UE.EBlendMode;
        bAllowTwoSidedMaterial: boolean;
        bNormalMap: boolean;
        bMetallicMap: boolean;
        bRoughnessMap: boolean;
        bSpecularMap: boolean;
        bEmissiveMap: boolean;
        bOpacityMap: boolean;
        bOpacityMaskMap: boolean;
        bAmbientOcclusionMap: boolean;
        DiffuseTextureSize: UE.IntPoint;
        NormalTextureSize: UE.IntPoint;
        MetallicTextureSize: UE.IntPoint;
        RoughnessTextureSize: UE.IntPoint;
        SpecularTextureSize: UE.IntPoint;
        EmissiveTextureSize: UE.IntPoint;
        OpacityTextureSize: UE.IntPoint;
        OpacityMaskTextureSize: UE.IntPoint;
        AmbientOcclusionTextureSize: UE.IntPoint;
        static StaticClass(): Class;
    }
    
    class LevelSimplificationDetails {
        constructor();
        constructor(bCreatePackagePerAsset: boolean, DetailsPercentage: number, StaticMeshMaterialSettings: UE.MaterialProxySettings, bOverrideLandscapeExportLOD: boolean, LandscapeExportLOD: number, LandscapeMaterialSettings: UE.MaterialProxySettings, bBakeFoliageToLandscape: boolean, bBakeGrassToLandscape: boolean, bGenerateMeshNormalMap: boolean, bGenerateMeshMetallicMap: boolean, bGenerateMeshRoughnessMap: boolean, bGenerateMeshSpecularMap: boolean, bGenerateLandscapeNormalMap: boolean, bGenerateLandscapeMetallicMap: boolean, bGenerateLandscapeRoughnessMap: boolean, bGenerateLandscapeSpecularMap: boolean);
        bCreatePackagePerAsset: boolean;
        DetailsPercentage: number;
        StaticMeshMaterialSettings: UE.MaterialProxySettings;
        bOverrideLandscapeExportLOD: boolean;
        LandscapeExportLOD: number;
        LandscapeMaterialSettings: UE.MaterialProxySettings;
        bBakeFoliageToLandscape: boolean;
        bBakeGrassToLandscape: boolean;
        bGenerateMeshNormalMap: boolean;
        bGenerateMeshMetallicMap: boolean;
        bGenerateMeshRoughnessMap: boolean;
        bGenerateMeshSpecularMap: boolean;
        bGenerateLandscapeNormalMap: boolean;
        bGenerateLandscapeMetallicMap: boolean;
        bGenerateLandscapeRoughnessMap: boolean;
        bGenerateLandscapeSpecularMap: boolean;
        static StaticClass(): Class;
    }
    
    enum EVisibilityAggressiveness { VIS_LeastAggressive, VIS_ModeratelyAggressive, VIS_MostAggressive, VIS_Max, VIS_MAX}
    class NavAgentSelector {
        constructor();
        constructor(bSupportsAgent0: boolean, bSupportsAgent1: boolean, bSupportsAgent2: boolean, bSupportsAgent3: boolean, bSupportsAgent4: boolean, bSupportsAgent5: boolean, bSupportsAgent6: boolean, bSupportsAgent7: boolean, bSupportsAgent8: boolean, bSupportsAgent9: boolean, bSupportsAgent10: boolean, bSupportsAgent11: boolean, bSupportsAgent12: boolean, bSupportsAgent13: boolean, bSupportsAgent14: boolean, bSupportsAgent15: boolean);
        bSupportsAgent0: boolean;
        bSupportsAgent1: boolean;
        bSupportsAgent2: boolean;
        bSupportsAgent3: boolean;
        bSupportsAgent4: boolean;
        bSupportsAgent5: boolean;
        bSupportsAgent6: boolean;
        bSupportsAgent7: boolean;
        bSupportsAgent8: boolean;
        bSupportsAgent9: boolean;
        bSupportsAgent10: boolean;
        bSupportsAgent11: boolean;
        bSupportsAgent12: boolean;
        bSupportsAgent13: boolean;
        bSupportsAgent14: boolean;
        bSupportsAgent15: boolean;
        static StaticClass(): Class;
    }
    
    class NavigationSystemConfig extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NavigationSystemClass: UE.SoftClassPath;
        SupportedAgentsMask: UE.NavAgentSelector;
        DefaultAgentName: string;
        bIsOverriden: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationSystemConfig;
        static Load(InName: string): NavigationSystemConfig;
    }
    
    enum EVolumeLightingMethod { VLM_VolumetricLightmap, VLM_SparseVolumeLightingSamples, VLM_MAX}
    class LightmassWorldInfoSettings {
        constructor();
        constructor(StaticLightingLevelScale: number, NumIndirectLightingBounces: number, NumSkyLightingBounces: number, IndirectLightingQuality: number, IndirectLightingSmoothness: number, EnvironmentColor: UE.Color, EnvironmentIntensity: number, EmissiveBoost: number, DiffuseBoost: number, VolumeLightingMethod: UE.EVolumeLightingMethod, bUseAmbientOcclusion: boolean, bGenerateAmbientOcclusionMaterialMask: boolean, bVisualizeMaterialDiffuse: boolean, bVisualizeAmbientOcclusion: boolean, bCompressLightmaps: boolean, VolumetricLightmapDetailCellSize: number, VolumetricLightmapMaximumBrickMemoryMb: number, VolumetricLightmapSphericalHarmonicSmoothing: number, VolumeLightSamplePlacementScale: number, DirectIlluminationOcclusionFraction: number, IndirectIlluminationOcclusionFraction: number, OcclusionExponent: number, FullyOccludedSamplesFraction: number, MaxOcclusionDistance: number);
        StaticLightingLevelScale: number;
        NumIndirectLightingBounces: number;
        NumSkyLightingBounces: number;
        IndirectLightingQuality: number;
        IndirectLightingSmoothness: number;
        EnvironmentColor: UE.Color;
        EnvironmentIntensity: number;
        EmissiveBoost: number;
        DiffuseBoost: number;
        VolumeLightingMethod: UE.EVolumeLightingMethod;
        bUseAmbientOcclusion: boolean;
        bGenerateAmbientOcclusionMaterialMask: boolean;
        bVisualizeMaterialDiffuse: boolean;
        bVisualizeAmbientOcclusion: boolean;
        bCompressLightmaps: boolean;
        VolumetricLightmapDetailCellSize: number;
        VolumetricLightmapMaximumBrickMemoryMb: number;
        VolumetricLightmapSphericalHarmonicSmoothing: number;
        VolumeLightSamplePlacementScale: number;
        DirectIlluminationOcclusionFraction: number;
        IndirectIlluminationOcclusionFraction: number;
        OcclusionExponent: number;
        FullyOccludedSamplesFraction: number;
        MaxOcclusionDistance: number;
        static StaticClass(): Class;
    }
    
    enum ReverbPreset { REVERB_Default, REVERB_Bathroom, REVERB_StoneRoom, REVERB_Auditorium, REVERB_ConcertHall, REVERB_Cave, REVERB_Hallway, REVERB_StoneCorridor, REVERB_Alley, REVERB_Forest, REVERB_City, REVERB_Mountains, REVERB_Quarry, REVERB_Plain, REVERB_ParkingLot, REVERB_SewerPipe, REVERB_Underwater, REVERB_SmallRoom, REVERB_MediumRoom, REVERB_LargeRoom, REVERB_MediumHall, REVERB_LargeHall, REVERB_Plate, REVERB_MAX}
    class ReverbEffect extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Density: number;
        Diffusion: number;
        Gain: number;
        GainHF: number;
        DecayTime: number;
        DecayHFRatio: number;
        ReflectionsGain: number;
        ReflectionsDelay: number;
        LateGain: number;
        LateDelay: number;
        AirAbsorptionGainHF: number;
        RoomRolloffFactor: number;
        bChanged: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReverbEffect;
        static Load(InName: string): ReverbEffect;
    }
    
    class SoundEffectPreset extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundEffectPreset;
        static Load(InName: string): SoundEffectPreset;
    }
    
    class SoundEffectSubmixPreset extends UE.SoundEffectPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundEffectSubmixPreset;
        static Load(InName: string): SoundEffectSubmixPreset;
    }
    
    class ReverbSettings {
        constructor();
        constructor(bApplyReverb: boolean, ReverbType: UE.ReverbPreset, ReverbEffect: UE.ReverbEffect, ReverbPluginEffect: UE.SoundEffectSubmixPreset, Volume: number, FadeTime: number);
        bApplyReverb: boolean;
        ReverbType: UE.ReverbPreset;
        ReverbEffect: UE.ReverbEffect;
        ReverbPluginEffect: UE.SoundEffectSubmixPreset;
        Volume: number;
        FadeTime: number;
        static StaticClass(): Class;
    }
    
    class InteriorSettings {
        constructor();
        constructor(bIsWorldSettings: boolean, ExteriorVolume: number, ExteriorTime: number, ExteriorLPF: number, ExteriorLPFTime: number, InteriorVolume: number, InteriorTime: number, InteriorLPF: number, InteriorLPFTime: number);
        bIsWorldSettings: boolean;
        ExteriorVolume: number;
        ExteriorTime: number;
        ExteriorLPF: number;
        ExteriorLPFTime: number;
        InteriorVolume: number;
        InteriorTime: number;
        InteriorLPF: number;
        InteriorLPFTime: number;
        static StaticClass(): Class;
    }
    
    class AudioEQEffect {
        constructor();
        constructor(FrequencyCenter0: number, Gain0: number, Bandwidth0: number, FrequencyCenter1: number, Gain1: number, Bandwidth1: number, FrequencyCenter2: number, Gain2: number, Bandwidth2: number, FrequencyCenter3: number, Gain3: number, Bandwidth3: number);
        FrequencyCenter0: number;
        Gain0: number;
        Bandwidth0: number;
        FrequencyCenter1: number;
        Gain1: number;
        Bandwidth1: number;
        FrequencyCenter2: number;
        Gain2: number;
        Bandwidth2: number;
        FrequencyCenter3: number;
        Gain3: number;
        Bandwidth3: number;
        static StaticClass(): Class;
    }
    
    enum EAudioOutputTarget { Speaker, Controller, ControllerFallbackToSpeaker, EAudioOutputTarget_MAX}
    enum ESoundWaveLoadingBehavior { Inherited, RetainOnLoad, PrimeOnLoad, LoadOnDemand, ForceInline, Uninitialized, ESoundWaveLoadingBehavior_MAX}
    class SoundClassProperties {
        constructor();
        constructor(Volume: number, Pitch: number, LowPassFilterFrequency: number, StereoBleed: number, LFEBleed: number, VoiceCenterChannelVolume: number, RadioFilterVolume: number, RadioFilterVolumeThreshold: number, bApplyEffects: boolean, bAlwaysPlay: boolean, bIsUISound: boolean, bIsMusic: boolean, bReverb: boolean, Default2DReverbSendAmount: number, bCenterChannelOnly: boolean, bApplyAmbientVolumes: boolean, OutputTarget: UE.EAudioOutputTarget, LoadingBehavior: UE.ESoundWaveLoadingBehavior);
        Volume: number;
        Pitch: number;
        LowPassFilterFrequency: number;
        StereoBleed: number;
        LFEBleed: number;
        VoiceCenterChannelVolume: number;
        RadioFilterVolume: number;
        RadioFilterVolumeThreshold: number;
        bApplyEffects: boolean;
        bAlwaysPlay: boolean;
        bIsUISound: boolean;
        bIsMusic: boolean;
        bReverb: boolean;
        Default2DReverbSendAmount: number;
        bCenterChannelOnly: boolean;
        bApplyAmbientVolumes: boolean;
        OutputTarget: UE.EAudioOutputTarget;
        LoadingBehavior: UE.ESoundWaveLoadingBehavior;
        static StaticClass(): Class;
    }
    
    class PassiveSoundMixModifier {
        constructor();
        constructor(SoundMix: UE.SoundMix, MinVolumeThreshold: number, MaxVolumeThreshold: number);
        SoundMix: UE.SoundMix;
        MinVolumeThreshold: number;
        MaxVolumeThreshold: number;
        static StaticClass(): Class;
    }
    
    class SoundModulationPluginSourceSettingsBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundModulationPluginSourceSettingsBase;
        static Load(InName: string): SoundModulationPluginSourceSettingsBase;
    }
    
    class SoundModulation {
        constructor();
        constructor(Settings: TArray<UE.SoundModulationPluginSourceSettingsBase>);
        Settings: TArray<UE.SoundModulationPluginSourceSettingsBase>;
        static StaticClass(): Class;
    }
    
    class SoundClass extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Properties: UE.SoundClassProperties;
        ChildClasses: TArray<UE.SoundClass>;
        PassiveSoundMixModifiers: TArray<UE.PassiveSoundMixModifier>;
        Modulation: UE.SoundModulation;
        ParentClass: UE.SoundClass;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundClass;
        static Load(InName: string): SoundClass;
    }
    
    class SoundClassAdjuster {
        constructor();
        constructor(SoundClassObject: UE.SoundClass, VolumeAdjuster: number, PitchAdjuster: number, LowPassFilterFrequency: number, bApplyToChildren: boolean, VoiceCenterChannelVolumeAdjuster: number);
        SoundClassObject: UE.SoundClass;
        VolumeAdjuster: number;
        PitchAdjuster: number;
        LowPassFilterFrequency: number;
        bApplyToChildren: boolean;
        VoiceCenterChannelVolumeAdjuster: number;
        static StaticClass(): Class;
    }
    
    class SoundMix extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bApplyEQ: boolean;
        EQPriority: number;
        EQSettings: UE.AudioEQEffect;
        SoundClassEffects: TArray<UE.SoundClassAdjuster>;
        InitialDelay: number;
        FadeInTime: number;
        Duration: number;
        FadeOutTime: number;
        bChanged: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundMix;
        static Load(InName: string): SoundMix;
    }
    
    enum EProxyNormalComputationMethod { AngleWeighted, AreaWeighted, EqualWeighted, EProxyNormalComputationMethod_MAX}
    enum ELandscapeCullingPrecision { High, Medium, Low, ELandscapeCullingPrecision_MAX}
    class MeshProxySettings {
        constructor();
        constructor(ScreenSize: number, VoxelSize: number, MaterialSettings: UE.MaterialProxySettings, TextureWidth: number, TextureHeight: number, bExportNormalMap: boolean, bExportMetallicMap: boolean, bExportRoughnessMap: boolean, bExportSpecularMap: boolean, bBakeVertexData: boolean, MergeDistance: number, UnresolvedGeometryColor: UE.Color, MaxRayCastDist: number, HardAngleThreshold: number, LightMapResolution: number, NormalCalculationMethod: UE.EProxyNormalComputationMethod, LandscapeCullingPrecision: UE.ELandscapeCullingPrecision, bCalculateCorrectLODModel: boolean, bOverrideVoxelSize: boolean, bOverrideTransferDistance: boolean, bUseHardAngleThreshold: boolean, bComputeLightMapResolution: boolean, bRecalculateNormals: boolean, bUseLandscapeCulling: boolean, bAllowAdjacency: boolean, bAllowDistanceField: boolean, bReuseMeshLightmapUVs: boolean, bCreateCollision: boolean, bAllowVertexColors: boolean, bGenerateLightmapUVs: boolean);
        ScreenSize: number;
        VoxelSize: number;
        MaterialSettings: UE.MaterialProxySettings;
        TextureWidth: number;
        TextureHeight: number;
        bExportNormalMap: boolean;
        bExportMetallicMap: boolean;
        bExportRoughnessMap: boolean;
        bExportSpecularMap: boolean;
        bBakeVertexData: boolean;
        MergeDistance: number;
        UnresolvedGeometryColor: UE.Color;
        MaxRayCastDist: number;
        HardAngleThreshold: number;
        LightMapResolution: number;
        NormalCalculationMethod: UE.EProxyNormalComputationMethod;
        LandscapeCullingPrecision: UE.ELandscapeCullingPrecision;
        bCalculateCorrectLODModel: boolean;
        bOverrideVoxelSize: boolean;
        bOverrideTransferDistance: boolean;
        bUseHardAngleThreshold: boolean;
        bComputeLightMapResolution: boolean;
        bRecalculateNormals: boolean;
        bUseLandscapeCulling: boolean;
        bAllowAdjacency: boolean;
        bAllowDistanceField: boolean;
        bReuseMeshLightmapUVs: boolean;
        bCreateCollision: boolean;
        bAllowVertexColors: boolean;
        bGenerateLightmapUVs: boolean;
        static StaticClass(): Class;
    }
    
    enum EUVOutput { DoNotOutputChannel, OutputChannel, EUVOutput_MAX}
    enum EMeshLODSelectionType { AllLODs, SpecificLOD, CalculateLOD, LowestDetailLOD, EMeshLODSelectionType_MAX}
    class MeshMergingSettings {
        constructor();
        constructor(TargetLightMapResolution: number, OutputUVs: FixSizeArray<UE.EUVOutput>, MaterialSettings: UE.MaterialProxySettings, GutterSize: number, SpecificLOD: number, LODSelectionType: UE.EMeshLODSelectionType, bGenerateLightMapUV: boolean, bComputedLightMapResolution: boolean, bPivotPointAtZero: boolean, bMergePhysicsData: boolean, bMergeMaterials: boolean, bCreateMergedMaterial: boolean, bBakeVertexDataToMesh: boolean, bUseVertexDataForBakingMaterial: boolean, bUseTextureBinning: boolean, bReuseMeshLightmapUVs: boolean, bMergeEquivalentMaterials: boolean, bUseLandscapeCulling: boolean, bIncludeImposters: boolean, bAllowDistanceField: boolean, bImportVertexColors: boolean, bCalculateCorrectLODModel: boolean, bExportNormalMap: boolean, bExportMetallicMap: boolean, bExportRoughnessMap: boolean, bExportSpecularMap: boolean, MergedMaterialAtlasResolution: number, ExportSpecificLOD: number);
        TargetLightMapResolution: number;
        OutputUVs: FixSizeArray<UE.EUVOutput>;
        MaterialSettings: UE.MaterialProxySettings;
        GutterSize: number;
        SpecificLOD: number;
        LODSelectionType: UE.EMeshLODSelectionType;
        bGenerateLightMapUV: boolean;
        bComputedLightMapResolution: boolean;
        bPivotPointAtZero: boolean;
        bMergePhysicsData: boolean;
        bMergeMaterials: boolean;
        bCreateMergedMaterial: boolean;
        bBakeVertexDataToMesh: boolean;
        bUseVertexDataForBakingMaterial: boolean;
        bUseTextureBinning: boolean;
        bReuseMeshLightmapUVs: boolean;
        bMergeEquivalentMaterials: boolean;
        bUseLandscapeCulling: boolean;
        bIncludeImposters: boolean;
        bAllowDistanceField: boolean;
        bImportVertexColors: boolean;
        bCalculateCorrectLODModel: boolean;
        bExportNormalMap: boolean;
        bExportMetallicMap: boolean;
        bExportRoughnessMap: boolean;
        bExportSpecularMap: boolean;
        MergedMaterialAtlasResolution: number;
        ExportSpecificLOD: number;
        static StaticClass(): Class;
    }
    
    class HierarchicalSimplification {
        constructor();
        constructor(TransitionScreenSize: number, OverrideDrawDistance: number, bUseOverrideDrawDistance: boolean, bAllowSpecificExclusion: boolean, bSimplifyMesh: boolean, bOnlyGenerateClustersForVolumes: boolean, bReusePreviousLevelClusters: boolean, ProxySetting: UE.MeshProxySettings, MergeSetting: UE.MeshMergingSettings, DesiredBoundRadius: number, DesiredFillingPercentage: number, MinNumberOfActorsToBuild: number);
        TransitionScreenSize: number;
        OverrideDrawDistance: number;
        bUseOverrideDrawDistance: boolean;
        bAllowSpecificExclusion: boolean;
        bSimplifyMesh: boolean;
        bOnlyGenerateClustersForVolumes: boolean;
        bReusePreviousLevelClusters: boolean;
        ProxySetting: UE.MeshProxySettings;
        MergeSetting: UE.MeshMergingSettings;
        DesiredBoundRadius: number;
        DesiredFillingPercentage: number;
        MinNumberOfActorsToBuild: number;
        static StaticClass(): Class;
    }
    
    class BookmarkBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BookmarkBase;
        static Load(InName: string): BookmarkBase;
    }
    
    class BookMark extends UE.BookmarkBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Location: UE.Vector;
        Rotation: UE.Rotator;
        HiddenLevels: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BookMark;
        static Load(InName: string): BookMark;
    }
    
    class BroadphaseSettings {
        constructor();
        constructor(bUseMBPOnClient: boolean, bUseMBPOnServer: boolean, bUseMBPOuterBounds: boolean, MBPBounds: UE.Box, MBPOuterBounds: UE.Box, MBPNumSubdivs: number);
        bUseMBPOnClient: boolean;
        bUseMBPOnServer: boolean;
        bUseMBPOuterBounds: boolean;
        MBPBounds: UE.Box;
        MBPOuterBounds: UE.Box;
        MBPNumSubdivs: number;
        static StaticClass(): Class;
    }
    
    class NetViewer {
        constructor();
        constructor(Connection: UE.NetConnection, InViewer: UE.Actor, ViewTarget: UE.Actor, ViewLocation: UE.Vector, ViewDir: UE.Vector);
        Connection: UE.NetConnection;
        InViewer: UE.Actor;
        ViewTarget: UE.Actor;
        ViewLocation: UE.Vector;
        ViewDir: UE.Vector;
        static StaticClass(): Class;
    }
    
    class WorldSettings extends UE.Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VisibilityCellSize: number;
        VisibilityAggressiveness: UE.EVisibilityAggressiveness;
        bPrecomputeVisibility: boolean;
        bPlaceCellsOnlyAlongCameraTracks: boolean;
        bEnableWorldBoundsChecks: boolean;
        bEnableNavigationSystem: boolean;
        bEnableAISystem: boolean;
        bEnableWorldComposition: boolean;
        bUseClientSideLevelStreamingVolumes: boolean;
        bEnableWorldOriginRebasing: boolean;
        bWorldGravitySet: boolean;
        bGlobalGravitySet: boolean;
        bMinimizeBSPSections: boolean;
        bForceNoPrecomputedLighting: boolean;
        bHighPriorityLoading: boolean;
        bHighPriorityLoadingLocal: boolean;
        bOverrideDefaultBroadphaseSettings: boolean;
        NavigationSystemConfig: UE.NavigationSystemConfig;
        NavigationSystemConfigOverride: UE.NavigationSystemConfig;
        WorldToMeters: number;
        KillZ: number;
        KillZDamageType: UE.Class;
        WorldGravityZ: number;
        GlobalGravityZ: number;
        DefaultPhysicsVolumeClass: UE.Class;
        PhysicsCollisionHandlerClass: UE.Class;
        DefaultGameMode: UE.Class;
        GameNetworkManagerClass: UE.Class;
        PackedLightAndShadowMapTextureSize: number;
        DefaultColorScale: UE.Vector;
        DefaultMaxDistanceFieldOcclusionDistance: number;
        GlobalDistanceFieldViewDistance: number;
        DynamicIndirectShadowsSelfShadowingIntensity: number;
        LightmassSettings: UE.LightmassWorldInfoSettings;
        DefaultReverbSettings: UE.ReverbSettings;
        DefaultAmbientZoneSettings: UE.InteriorSettings;
        MonoCullingDistance: number;
        DefaultBaseSoundMix: UE.SoundMix;
        bEnableHierarchicalLODSystem: boolean;
        HLODSetupAsset: TSoftClassPtr<UE.HierarchicalLODSetup>;
        OverrideBaseMaterial: TSoftObjectPtr<UE.MaterialInterface>;
        HierarchicalLODSetup: TArray<UE.HierarchicalSimplification>;
        NumHLODLevels: number;
        bGenerateSingleClusterForLevel: boolean;
        BookMarks: FixSizeArray<UE.BookMark>;
        TimeDilation: number;
        MatineeTimeDilation: number;
        DemoPlayTimeDilation: number;
        MinGlobalTimeDilation: number;
        MaxGlobalTimeDilation: number;
        MinUndilatedFrameTime: number;
        MaxUndilatedFrameTime: number;
        BroadphaseSettings: UE.BroadphaseSettings;
        Pauser: UE.PlayerState;
        ReplicationViewers: TArray<UE.NetViewer>;
        AssetUserData: TArray<UE.AssetUserData>;
        PauserPlayerState: UE.PlayerState;
        MaxNumberOfBookmarks: number;
        DefaultBookmarkClass: UE.Class;
        BookmarkArray: TArray<UE.BookmarkBase>;
        LastBookmarkClass: UE.Class;
        OnRep_WorldGravityZ() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WorldSettings;
        static Load(InName: string): WorldSettings;
    }
    
    class ReplicatedStaticActorDestructionInfo {
        constructor();
        constructor(ObjClass: UE.Class);
        ObjClass: UE.Class;
        static StaticClass(): Class;
    }
    
    class Level extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OwningWorld: UE.World;
        Model: UE.Model;
        ModelComponents: TArray<UE.ModelComponent>;
        ActorCluster: UE.LevelActorContainer;
        LevelScriptBlueprint: UE.LevelScriptBlueprint;
        TextureStreamingResourceGuids: TArray<UE.Guid>;
        NumTextureStreamingUnbuiltComponents: number;
        NumTextureStreamingDirtyResources: number;
        LevelScriptActor: UE.LevelScriptActor;
        NavListStart: UE.NavigationObjectBase;
        NavListEnd: UE.NavigationObjectBase;
        NavDataChunks: TArray<UE.NavigationDataChunk>;
        LightmapTotalSize: number;
        ShadowmapTotalSize: number;
        StaticNavigableGeometry: TArray<UE.Vector>;
        StreamingTextureGuids: TArray<UE.Guid>;
        LevelBuildDataId: UE.Guid;
        MapBuildData: UE.MapBuildDataRegistry;
        LightBuildLevelOffset: UE.IntVector;
        bIsLightingScenario: boolean;
        bTextureStreamingRotationChanged: boolean;
        bStaticComponentsRegisteredInStreamingManager: boolean;
        bIsVisible: boolean;
        bLocked: boolean;
        LevelSimplification: FixSizeArray<UE.LevelSimplificationDetails>;
        LevelColor: UE.LinearColor;
        bLevelOkayForPlacementWhileCheckedIn: boolean;
        WorldSettings: UE.WorldSettings;
        AssetUserData: TArray<UE.AssetUserData>;
        DestroyedReplicatedStaticActors: TArray<UE.ReplicatedStaticActorDestructionInfo>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Level;
        static Load(InName: string): Level;
    }
    
    class LineBatchComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LineBatchComponent;
        static Load(InName: string): LineBatchComponent;
    }
    
    class GameNetworkManager extends UE.Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BadPacketLossThreshold: number;
        SeverePacketLossThreshold: number;
        BadPingThreshold: number;
        SeverePingThreshold: number;
        AdjustedNetSpeed: number;
        LastNetSpeedUpdateTime: number;
        TotalNetBandwidth: number;
        MinDynamicBandwidth: number;
        MaxDynamicBandwidth: number;
        bIsStandbyCheckingEnabled: boolean;
        bHasStandbyCheatTriggered: boolean;
        StandbyRxCheatTime: number;
        StandbyTxCheatTime: number;
        PercentMissingForRxStandby: number;
        PercentMissingForTxStandby: number;
        PercentForBadPing: number;
        JoinInProgressStandbyWaitTime: number;
        MoveRepSize: number;
        MAXPOSITIONERRORSQUARED: number;
        MAXNEARZEROVELOCITYSQUARED: number;
        CLIENTADJUSTUPDATECOST: number;
        MAXCLIENTUPDATEINTERVAL: number;
        MaxClientForcedUpdateDuration: number;
        ServerForcedUpdateHitchThreshold: number;
        ServerForcedUpdateHitchCooldown: number;
        MaxMoveDeltaTime: number;
        MaxClientSmoothingDeltaTime: number;
        ClientNetSendMoveDeltaTime: number;
        ClientNetSendMoveDeltaTimeThrottled: number;
        ClientNetSendMoveDeltaTimeStationary: number;
        ClientNetSendMoveThrottleAtNetSpeed: number;
        ClientNetSendMoveThrottleOverPlayerCount: number;
        ClientAuthorativePosition: boolean;
        ClientErrorUpdateRateLimit: number;
        ClientNetCamUpdateDeltaTime: number;
        ClientNetCamUpdatePositionLimit: number;
        bMovementTimeDiscrepancyDetection: boolean;
        bMovementTimeDiscrepancyResolution: boolean;
        MovementTimeDiscrepancyMaxTimeMargin: number;
        MovementTimeDiscrepancyMinTimeMargin: number;
        MovementTimeDiscrepancyResolutionRate: number;
        MovementTimeDiscrepancyDriftAllowance: number;
        bMovementTimeDiscrepancyForceCorrectionsDuringResolution: boolean;
        bUseDistanceBasedRelevancy: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameNetworkManager;
        static Load(InName: string): GameNetworkManager;
    }
    
    enum EVirtualizationMode { Disabled, PlayWhenSilent, Restart, EVirtualizationMode_MAX}
    enum EMaxConcurrentResolutionRule { PreventNew, StopOldest, StopFarthestThenPreventNew, StopFarthestThenOldest, StopLowestPriority, StopQuietest, StopLowestPriorityThenPreventNew, EMaxConcurrentResolutionRule_MAX}
    class SoundConcurrencySettings {
        constructor();
        constructor(MaxCount: number, bLimitToOwner: boolean, ResolutionRule: UE.EMaxConcurrentResolutionRule, VolumeScale: number, VolumeScaleAttackTime: number, bVolumeScaleCanRelease: boolean, VolumeScaleReleaseTime: number, VoiceStealReleaseTime: number);
        MaxCount: number;
        bLimitToOwner: boolean;
        ResolutionRule: UE.EMaxConcurrentResolutionRule;
        VolumeScale: number;
        VolumeScaleAttackTime: number;
        bVolumeScaleCanRelease: boolean;
        VolumeScaleReleaseTime: number;
        VoiceStealReleaseTime: number;
        static StaticClass(): Class;
    }
    
    class SoundConcurrency extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Concurrency: UE.SoundConcurrencySettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundConcurrency;
        static Load(InName: string): SoundConcurrency;
    }
    
    enum EAttenuationDistanceModel { Linear, Logarithmic, Inverse, LogReverse, NaturalSound, Custom, EAttenuationDistanceModel_MAX}
    enum EAttenuationShape { Sphere, Capsule, Box, Cone, EAttenuationShape_MAX}
    class BaseAttenuationSettings {
        constructor();
        constructor(DistanceAlgorithm: UE.EAttenuationDistanceModel, AttenuationShape: UE.EAttenuationShape, dBAttenuationAtMax: number, AttenuationShapeExtents: UE.Vector, ConeOffset: number, FalloffDistance: number, CustomAttenuationCurve: UE.RuntimeFloatCurve);
        DistanceAlgorithm: UE.EAttenuationDistanceModel;
        AttenuationShape: UE.EAttenuationShape;
        dBAttenuationAtMax: number;
        AttenuationShapeExtents: UE.Vector;
        ConeOffset: number;
        FalloffDistance: number;
        CustomAttenuationCurve: UE.RuntimeFloatCurve;
        static StaticClass(): Class;
    }
    
    enum ESoundSpatializationAlgorithm { SPATIALIZATION_Default, SPATIALIZATION_HRTF, SPATIALIZATION_MAX}
    enum EAirAbsorptionMethod { Linear, CustomCurve, EAirAbsorptionMethod_MAX}
    enum EReverbSendMethod { Linear, CustomCurve, Manual, EReverbSendMethod_MAX}
    enum ESoundDistanceCalc { SOUNDDISTANCE_Normal, SOUNDDISTANCE_InfiniteXYPlane, SOUNDDISTANCE_InfiniteXZPlane, SOUNDDISTANCE_InfiniteYZPlane, SOUNDDISTANCE_MAX}
    class SpatializationPluginSourceSettingsBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpatializationPluginSourceSettingsBase;
        static Load(InName: string): SpatializationPluginSourceSettingsBase;
    }
    
    class OcclusionPluginSourceSettingsBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OcclusionPluginSourceSettingsBase;
        static Load(InName: string): OcclusionPluginSourceSettingsBase;
    }
    
    class ReverbPluginSourceSettingsBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReverbPluginSourceSettingsBase;
        static Load(InName: string): ReverbPluginSourceSettingsBase;
    }
    
    class SoundAttenuationPluginSettings {
        constructor();
        constructor(SpatializationPluginSettingsArray: TArray<UE.SpatializationPluginSourceSettingsBase>, OcclusionPluginSettingsArray: TArray<UE.OcclusionPluginSourceSettingsBase>, ReverbPluginSettingsArray: TArray<UE.ReverbPluginSourceSettingsBase>);
        SpatializationPluginSettingsArray: TArray<UE.SpatializationPluginSourceSettingsBase>;
        OcclusionPluginSettingsArray: TArray<UE.OcclusionPluginSourceSettingsBase>;
        ReverbPluginSettingsArray: TArray<UE.ReverbPluginSourceSettingsBase>;
        static StaticClass(): Class;
    }
    
    class SoundAttenuationSettings extends UE.BaseAttenuationSettings {
        constructor();
        constructor(bAttenuate: boolean, bSpatialize: boolean, bAttenuateWithLPF: boolean, bEnableListenerFocus: boolean, bEnableFocusInterpolation: boolean, bEnableOcclusion: boolean, bUseComplexCollisionForOcclusion: boolean, bEnableReverbSend: boolean, bApplyNormalizationToStereoSounds: boolean, bEnableLogFrequencyScaling: boolean, SpatializationAlgorithm: UE.ESoundSpatializationAlgorithm, BinauralRadius: number, AbsorptionMethod: UE.EAirAbsorptionMethod, OcclusionTraceChannel: UE.ECollisionChannel, ReverbSendMethod: UE.EReverbSendMethod, DistanceType: UE.ESoundDistanceCalc, OmniRadius: number, StereoSpread: number, SpatializationPluginSettings: UE.SpatializationPluginSourceSettingsBase, RadiusMin: number, RadiusMax: number, LPFRadiusMin: number, LPFRadiusMax: number, CustomLowpassAirAbsorptionCurve: UE.RuntimeFloatCurve, CustomHighpassAirAbsorptionCurve: UE.RuntimeFloatCurve, LPFFrequencyAtMin: number, LPFFrequencyAtMax: number, HPFFrequencyAtMin: number, HPFFrequencyAtMax: number, FocusAzimuth: number, NonFocusAzimuth: number, FocusDistanceScale: number, NonFocusDistanceScale: number, FocusPriorityScale: number, NonFocusPriorityScale: number, FocusVolumeAttenuation: number, NonFocusVolumeAttenuation: number, FocusAttackInterpSpeed: number, FocusReleaseInterpSpeed: number, OcclusionLowPassFilterFrequency: number, OcclusionVolumeAttenuation: number, OcclusionInterpolationTime: number, OcclusionPluginSettings: UE.OcclusionPluginSourceSettingsBase, ReverbPluginSettings: UE.ReverbPluginSourceSettingsBase, ReverbWetLevelMin: number, ReverbWetLevelMax: number, ReverbDistanceMin: number, ReverbDistanceMax: number, ManualReverbSendLevel: number, CustomReverbSendCurve: UE.RuntimeFloatCurve, PluginSettings: UE.SoundAttenuationPluginSettings);
        bAttenuate: boolean;
        bSpatialize: boolean;
        bAttenuateWithLPF: boolean;
        bEnableListenerFocus: boolean;
        bEnableFocusInterpolation: boolean;
        bEnableOcclusion: boolean;
        bUseComplexCollisionForOcclusion: boolean;
        bEnableReverbSend: boolean;
        bApplyNormalizationToStereoSounds: boolean;
        bEnableLogFrequencyScaling: boolean;
        SpatializationAlgorithm: UE.ESoundSpatializationAlgorithm;
        BinauralRadius: number;
        AbsorptionMethod: UE.EAirAbsorptionMethod;
        OcclusionTraceChannel: UE.ECollisionChannel;
        ReverbSendMethod: UE.EReverbSendMethod;
        DistanceType: UE.ESoundDistanceCalc;
        OmniRadius: number;
        StereoSpread: number;
        SpatializationPluginSettings: UE.SpatializationPluginSourceSettingsBase;
        RadiusMin: number;
        RadiusMax: number;
        LPFRadiusMin: number;
        LPFRadiusMax: number;
        CustomLowpassAirAbsorptionCurve: UE.RuntimeFloatCurve;
        CustomHighpassAirAbsorptionCurve: UE.RuntimeFloatCurve;
        LPFFrequencyAtMin: number;
        LPFFrequencyAtMax: number;
        HPFFrequencyAtMin: number;
        HPFFrequencyAtMax: number;
        FocusAzimuth: number;
        NonFocusAzimuth: number;
        FocusDistanceScale: number;
        NonFocusDistanceScale: number;
        FocusPriorityScale: number;
        NonFocusPriorityScale: number;
        FocusVolumeAttenuation: number;
        NonFocusVolumeAttenuation: number;
        FocusAttackInterpSpeed: number;
        FocusReleaseInterpSpeed: number;
        OcclusionLowPassFilterFrequency: number;
        OcclusionVolumeAttenuation: number;
        OcclusionInterpolationTime: number;
        OcclusionPluginSettings: UE.OcclusionPluginSourceSettingsBase;
        ReverbPluginSettings: UE.ReverbPluginSourceSettingsBase;
        ReverbWetLevelMin: number;
        ReverbWetLevelMax: number;
        ReverbDistanceMin: number;
        ReverbDistanceMax: number;
        ManualReverbSendLevel: number;
        CustomReverbSendCurve: UE.RuntimeFloatCurve;
        PluginSettings: UE.SoundAttenuationPluginSettings;
        static StaticClass(): Class;
    }
    
    class SoundAttenuation extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Attenuation: UE.SoundAttenuationSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundAttenuation;
        static Load(InName: string): SoundAttenuation;
    }
    
    enum ESubmixChannelFormat { Device, Stereo, Quad, FiveDotOne, SevenDotOne, Ambisonics, Count, ESubmixChannelFormat_MAX}
    class AmbisonicsSubmixSettingsBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AmbisonicsSubmixSettingsBase;
        static Load(InName: string): AmbisonicsSubmixSettingsBase;
    }
    
    enum ESoundwaveSampleRateSettings { Max, High, Medium, Low, Min, MatchDevice, ESoundwaveSampleRateSettings_MAX}
    enum ESoundGroup { SOUNDGROUP_Default, SOUNDGROUP_Effects, SOUNDGROUP_UI, SOUNDGROUP_Music, SOUNDGROUP_Voice, SOUNDGROUP_GameSoundGroup1, SOUNDGROUP_GameSoundGroup2, SOUNDGROUP_GameSoundGroup3, SOUNDGROUP_GameSoundGroup4, SOUNDGROUP_GameSoundGroup5, SOUNDGROUP_GameSoundGroup6, SOUNDGROUP_GameSoundGroup7, SOUNDGROUP_GameSoundGroup8, SOUNDGROUP_GameSoundGroup9, SOUNDGROUP_GameSoundGroup10, SOUNDGROUP_GameSoundGroup11, SOUNDGROUP_GameSoundGroup12, SOUNDGROUP_GameSoundGroup13, SOUNDGROUP_GameSoundGroup14, SOUNDGROUP_GameSoundGroup15, SOUNDGROUP_GameSoundGroup16, SOUNDGROUP_GameSoundGroup17, SOUNDGROUP_GameSoundGroup18, SOUNDGROUP_GameSoundGroup19, SOUNDGROUP_GameSoundGroup20, SOUNDGROUP_MAX}
    enum ESoundWaveFFTSize { VerySmall_64, Small_256, Medium_512, Large_1024, VeryLarge_2048, ESoundWaveFFTSize_MAX}
    class SoundWaveSpectralDataEntry {
        constructor();
        constructor(Magnitude: number, NormalizedMagnitude: number);
        Magnitude: number;
        NormalizedMagnitude: number;
        static StaticClass(): Class;
    }
    
    class SoundWaveSpectralTimeData {
        constructor();
        constructor(Data: TArray<UE.SoundWaveSpectralDataEntry>, TimeSec: number);
        Data: TArray<UE.SoundWaveSpectralDataEntry>;
        TimeSec: number;
        static StaticClass(): Class;
    }
    
    class SoundWaveEnvelopeTimeData {
        constructor();
        constructor(Amplitude: number, TimeSec: number);
        Amplitude: number;
        TimeSec: number;
        static StaticClass(): Class;
    }
    
    class SubtitleCue {
        constructor();
        constructor(Text: string, Time: number);
        Text: string;
        Time: number;
        static StaticClass(): Class;
    }
    
    class CurveTable extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssetImportData: UE.AssetImportData;
        ImportPath: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveTable;
        static Load(InName: string): CurveTable;
    }
    
    class SoundWave extends UE.SoundBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CompressionQuality: number;
        StreamingPriority: number;
        SampleRateQuality: UE.ESoundwaveSampleRateSettings;
        SoundGroup: UE.ESoundGroup;
        bLooping: boolean;
        bStreaming: boolean;
        bSeekableStreaming: boolean;
        LoadingBehavior: UE.ESoundWaveLoadingBehavior;
        bMature: boolean;
        bManualWordWrap: boolean;
        bSingleLine: boolean;
        bVirtualizeWhenSilent: boolean;
        bIsAmbisonics: boolean;
        OverrideSoundToUseForAnalysis: UE.SoundWave;
        TreatFileAsLoopingForAnalysis: boolean;
        bEnableBakedFFTAnalysis: boolean;
        bEnableAmplitudeEnvelopeAnalysis: boolean;
        FFTSize: UE.ESoundWaveFFTSize;
        FFTAnalysisFrameSize: number;
        FFTAnalysisAttackTime: number;
        FFTAnalysisReleaseTime: number;
        EnvelopeFollowerFrameSize: number;
        EnvelopeFollowerAttackTime: number;
        EnvelopeFollowerReleaseTime: number;
        FrequenciesToAnalyze: TArray<number>;
        CookedSpectralTimeData: TArray<UE.SoundWaveSpectralTimeData>;
        CookedEnvelopeTimeData: TArray<UE.SoundWaveEnvelopeTimeData>;
        InitialChunkSize: number;
        SpokenText: string;
        SubtitlePriority: number;
        Volume: number;
        Pitch: number;
        NumChannels: number;
        ChannelOffsets: TArray<number>;
        ChannelSizes: TArray<number>;
        SampleRate: number;
        Subtitles: TArray<UE.SubtitleCue>;
        Comment: string;
        SourceFilePath: string;
        SourceFileTimestamp: string;
        AssetImportData: UE.AssetImportData;
        Curves: UE.CurveTable;
        InternalCurves: UE.CurveTable;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundWave;
        static Load(InName: string): SoundWave;
    }
    
    enum EAudioRecordingExportType { SoundWave, WavFile, EAudioRecordingExportType_MAX}
    class SoundSubmix extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChildSubmixes: TArray<UE.SoundSubmix>;
        ParentSubmix: UE.SoundSubmix;
        ChannelFormat: UE.ESubmixChannelFormat;
        bMuteWhenBackgrounded: boolean;
        SubmixEffectChain: TArray<UE.SoundEffectSubmixPreset>;
        AmbisonicsPluginSettings: UE.AmbisonicsSubmixSettingsBase;
        EnvelopeFollowerAttackTime: number;
        EnvelopeFollowerReleaseTime: number;
        OutputVolume: number;
        OnSubmixRecordedFileDone: $MulticastDelegate<(ResultingSoundWave: $Nullable<UE.SoundWave>) => void>;
        AddEnvelopeFollowerDelegate(WorldContextObject: $Nullable<UE.Object>, OnSubmixEnvelopeBP: $Delegate<(Envelope: TArray<number>) => void>) : void;
        SetSubmixOutputVolume(WorldContextObject: $Nullable<UE.Object>, InOutputVolume: number) : void;
        StartEnvelopeFollowing(WorldContextObject: $Nullable<UE.Object>) : void;
        StartRecordingOutput(WorldContextObject: $Nullable<UE.Object>, ExpectedDuration: number) : void;
        StopEnvelopeFollowing(WorldContextObject: $Nullable<UE.Object>) : void;
        StopRecordingOutput(WorldContextObject: $Nullable<UE.Object>, ExportType: UE.EAudioRecordingExportType, Name: string, Path: string, ExistingSoundWaveToOverwrite?: UE.SoundWave /* = None */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSubmix;
        static Load(InName: string): SoundSubmix;
    }
    
    enum ESendLevelControlMethod { Linear, CustomCurve, Manual, ESendLevelControlMethod_MAX}
    class SoundSubmixSendInfo {
        constructor();
        constructor(SendLevelControlMethod: UE.ESendLevelControlMethod, SoundSubmix: UE.SoundSubmix, SendLevel: number, MinSendLevel: number, MaxSendLevel: number, MinSendDistance: number, MaxSendDistance: number, CustomSendLevelCurve: UE.RuntimeFloatCurve);
        SendLevelControlMethod: UE.ESendLevelControlMethod;
        SoundSubmix: UE.SoundSubmix;
        SendLevel: number;
        MinSendLevel: number;
        MaxSendLevel: number;
        MinSendDistance: number;
        MaxSendDistance: number;
        CustomSendLevelCurve: UE.RuntimeFloatCurve;
        static StaticClass(): Class;
    }
    
    class SoundEffectSourcePreset extends UE.SoundEffectPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundEffectSourcePreset;
        static Load(InName: string): SoundEffectSourcePreset;
    }
    
    class SourceEffectChainEntry {
        constructor();
        constructor(Preset: UE.SoundEffectSourcePreset, bBypass: boolean);
        Preset: UE.SoundEffectSourcePreset;
        bBypass: boolean;
        static StaticClass(): Class;
    }
    
    class SoundEffectSourcePresetChain extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Chain: TArray<UE.SourceEffectChainEntry>;
        bPlayEffectChainTails: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundEffectSourcePresetChain;
        static Load(InName: string): SoundEffectSourcePresetChain;
    }
    
    enum ESourceBusSendLevelControlMethod { Linear, CustomCurve, Manual, ESourceBusSendLevelControlMethod_MAX}
    enum ESourceBusChannels { Mono, Stereo, ESourceBusChannels_MAX}
    class SoundSourceBus extends UE.SoundWave {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceBusChannels: UE.ESourceBusChannels;
        SourceBusDuration: number;
        bAutoDeactivateWhenSilent: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSourceBus;
        static Load(InName: string): SoundSourceBus;
    }
    
    class SoundSourceBusSendInfo {
        constructor();
        constructor(SourceBusSendLevelControlMethod: UE.ESourceBusSendLevelControlMethod, SoundSourceBus: UE.SoundSourceBus, SendLevel: number, MinSendLevel: number, MaxSendLevel: number, MinSendDistance: number, MaxSendDistance: number, CustomSendLevelCurve: UE.RuntimeFloatCurve);
        SourceBusSendLevelControlMethod: UE.ESourceBusSendLevelControlMethod;
        SoundSourceBus: UE.SoundSourceBus;
        SendLevel: number;
        MinSendLevel: number;
        MaxSendLevel: number;
        MinSendDistance: number;
        MaxSendDistance: number;
        CustomSendLevelCurve: UE.RuntimeFloatCurve;
        static StaticClass(): Class;
    }
    
    class SoundBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundClassObject: UE.SoundClass;
        bDebug: boolean;
        bOverrideConcurrency: boolean;
        bOutputToBusOnly: boolean;
        bHasDelayNode: boolean;
        bHasConcatenatorNode: boolean;
        bHasVirtualizeWhenSilent: boolean;
        bBypassVolumeScaleForPriority: boolean;
        VirtualizationMode: UE.EVirtualizationMode;
        MaxConcurrentResolutionRule: UE.EMaxConcurrentResolutionRule;
        SoundConcurrencySettings: UE.SoundConcurrency;
        ConcurrencySet: TSet<UE.SoundConcurrency>;
        ConcurrencyOverrides: UE.SoundConcurrencySettings;
        MaxConcurrentPlayCount: number;
        Duration: number;
        MaxDistance: number;
        TotalSamples: number;
        Priority: number;
        AttenuationSettings: UE.SoundAttenuation;
        Modulation: UE.SoundModulation;
        SoundSubmixObject: UE.SoundSubmix;
        SoundSubmixSends: TArray<UE.SoundSubmixSendInfo>;
        SourceEffectChain: UE.SoundEffectSourcePresetChain;
        BusSends: TArray<UE.SoundSourceBusSendInfo>;
        PreEffectBusSends: TArray<UE.SoundSourceBusSendInfo>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundBase;
        static Load(InName: string): SoundBase;
    }
    
    class PhysicsCollisionHandler extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImpactThreshold: number;
        ImpactReFireDelay: number;
        DefaultImpactSound: UE.SoundBase;
        LastImpactSoundTime: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsCollisionHandler;
        static Load(InName: string): PhysicsCollisionHandler;
    }
    
    enum EStreamingVolumeUsage { SVB_Loading, SVB_LoadingAndVisibility, SVB_VisibilityBlockingOnLoad, SVB_BlockingOnLoad, SVB_LoadingNotVisible, SVB_MAX}
    class LevelStreamingVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StreamingLevelNames: TArray<string>;
        bEditorPreVisOnly: boolean;
        bDisabled: boolean;
        StreamingUsage: UE.EStreamingVolumeUsage;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelStreamingVolume;
        static Load(InName: string): LevelStreamingVolume;
    }
    
    class LevelStreaming extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PackageName: string;
        WorldAsset: TSoftObjectPtr<UE.World>;
        PackageNameToLoad: string;
        LODPackageNames: TArray<string>;
        LevelTransform: UE.Transform;
        LevelLODIndex: number;
        StreamingPriority: number;
        bShouldBeVisibleInEditor: boolean;
        bShouldBeVisible: boolean;
        bShouldBeLoaded: boolean;
        bLocked: boolean;
        bIsStatic: boolean;
        bShouldBlockOnLoad: boolean;
        bShouldBlockOnUnload: boolean;
        bDisableDistanceStreaming: boolean;
        bDrawOnLevelStatusMap: boolean;
        DrawColor: UE.Color;
        LevelColor: UE.LinearColor;
        EditorStreamingVolumes: TArray<UE.LevelStreamingVolume>;
        MinTimeBetweenVolumeUnloadRequests: number;
        Keywords: TArray<string>;
        OnLevelLoaded: $MulticastDelegate<() => void>;
        OnLevelUnloaded: $MulticastDelegate<() => void>;
        OnLevelShown: $MulticastDelegate<() => void>;
        OnLevelHidden: $MulticastDelegate<() => void>;
        LoadedLevel: UE.Level;
        PendingUnloadLevel: UE.Level;
        FolderPath: string;
        CreateInstance(UniqueInstanceName: string) : UE.LevelStreaming;
        GetLevelScriptActor() : UE.LevelScriptActor;
        GetLoadedLevel() : UE.Level;
        GetWorldAssetPackageFName() : string;
        IsLevelLoaded() : boolean;
        IsLevelVisible() : boolean;
        IsStreamingStatePending() : boolean;
        SetLevelLODIndex(LODIndex: number) : void;
        SetPriority(NewPriority: number) : void;
        SetShouldBeLoaded(bInShouldBeLoaded: boolean) : void;
        SetShouldBeVisible(bInShouldBeVisible: boolean) : void;
        ShouldBeLoaded() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelStreaming;
        static Load(InName: string): LevelStreaming;
    }
    
    class LevelStreamingWrapper {
        constructor();
        constructor(StreamingLevel: UE.LevelStreaming);
        StreamingLevel: UE.LevelStreaming;
        static StaticClass(): Class;
    }
    
    class StreamingLevelsToConsider {
        constructor();
        constructor(StreamingLevels: TArray<UE.LevelStreamingWrapper>);
        StreamingLevels: TArray<UE.LevelStreamingWrapper>;
        static StaticClass(): Class;
    }
    
    class RollbackNetStartupActorInfo {
        constructor();
        constructor(Archetype: UE.Object, Level: UE.Level, ObjReferences: TArray<UE.Object>);
        Archetype: UE.Object;
        Level: UE.Level;
        ObjReferences: TArray<UE.Object>;
        static StaticClass(): Class;
    }
    
    class MulticastRecordOptions {
        constructor();
        constructor(FuncPathName: string, bServerSkip: boolean, bClientSkip: boolean);
        FuncPathName: string;
        bServerSkip: boolean;
        bClientSkip: boolean;
        static StaticClass(): Class;
    }
    
    class DemoNetDriver extends UE.NetDriver {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RollbackNetStartupActors: TMap<string, UE.RollbackNetStartupActorInfo>;
        CheckpointSaveMaxMSPerFrame: number;
        MulticastRecordOptions: TArray<UE.MulticastRecordOptions>;
        bIsLocalReplay: boolean;
        SpectatorControllers: TArray<UE.PlayerController>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DemoNetDriver;
        static Load(InName: string): DemoNetDriver;
    }
    
    class ParticleEventManager extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleEventManager;
        static Load(InName: string): ParticleEventManager;
    }
    
    class NavigationSystemBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationSystemBase;
        static Load(InName: string): NavigationSystemBase;
    }
    
    class GameSession extends UE.Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxSpectators: number;
        MaxPlayers: number;
        MaxPartySize: number;
        MaxSplitscreensPerConnection: number;
        bRequiresPushToTalk: boolean;
        SessionName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameSession;
        static Load(InName: string): GameSession;
    }
    
    class GameStateBase extends UE.Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GameModeClass: UE.Class;
        AuthorityGameMode: UE.GameModeBase;
        SpectatorClass: UE.Class;
        PlayerArray: TArray<UE.PlayerState>;
        bReplicatedHasBegunPlay: boolean;
        ReplicatedWorldTimeSeconds: number;
        ServerWorldTimeSecondsDelta: number;
        ServerWorldTimeSecondsUpdateFrequency: number;
        GetPlayerRespawnDelay(Controller: $Nullable<UE.Controller>) : number;
        GetPlayerStartTime(Controller: $Nullable<UE.Controller>) : number;
        GetServerWorldTimeSeconds() : number;
        HasBegunPlay() : boolean;
        HasMatchStarted() : boolean;
        OnRep_GameModeClass() : void;
        OnRep_ReplicatedHasBegunPlay() : void;
        OnRep_ReplicatedWorldTimeSeconds() : void;
        OnRep_SpectatorClass() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameStateBase;
        static Load(InName: string): GameStateBase;
    }
    
    class ServerStatReplicator extends UE.Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUpdateStatNet: boolean;
        bOverwriteClientStats: boolean;
        Channels: number;
        InRate: number;
        OutRate: number;
        OutSaturation: number;
        MaxPacketOverhead: number;
        InRateClientMax: number;
        InRateClientMin: number;
        InRateClientAvg: number;
        InPacketsClientMax: number;
        InPacketsClientMin: number;
        InPacketsClientAvg: number;
        OutRateClientMax: number;
        OutRateClientMin: number;
        OutRateClientAvg: number;
        OutPacketsClientMax: number;
        OutPacketsClientMin: number;
        OutPacketsClientAvg: number;
        NetNumClients: number;
        InPackets: number;
        OutPackets: number;
        InBunches: number;
        OutBunches: number;
        OutLoss: number;
        InLoss: number;
        VoiceBytesSent: number;
        VoiceBytesRecv: number;
        VoicePacketsSent: number;
        VoicePacketsRecv: number;
        PercentInVoice: number;
        PercentOutVoice: number;
        NumActorChannels: number;
        NumConsideredActors: number;
        PrioritizedActors: number;
        NumRelevantActors: number;
        NumRelevantDeletedActors: number;
        NumReplicatedActorAttempts: number;
        NumReplicatedActors: number;
        NumActors: number;
        NumNetActors: number;
        NumDormantActors: number;
        NumInitiallyDormantActors: number;
        NumNetGUIDsAckd: number;
        NumNetGUIDsPending: number;
        NumNetGUIDsUnAckd: number;
        ObjPathBytes: number;
        NetGUIDOutRate: number;
        NetGUIDInRate: number;
        NetSaturated: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ServerStatReplicator;
        static Load(InName: string): ServerStatReplicator;
    }
    
    class GameModeBase extends UE.Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OptionsString: string;
        GameSessionClass: UE.Class;
        GameStateClass: UE.Class;
        PlayerControllerClass: UE.Class;
        PlayerStateClass: UE.Class;
        HUDClass: UE.Class;
        DefaultPawnClass: UE.Class;
        SpectatorClass: UE.Class;
        ReplaySpectatorPlayerControllerClass: UE.Class;
        ServerStatReplicatorClass: UE.Class;
        GameSession: UE.GameSession;
        GameState: UE.GameStateBase;
        ServerStatReplicator: UE.ServerStatReplicator;
        DefaultPlayerName: string;
        bUseSeamlessTravel: boolean;
        bStartPlayersAsSpectators: boolean;
        bPauseable: boolean;
        CanSpectate(Viewer: $Nullable<UE.PlayerController>, ViewTarget: $Nullable<UE.PlayerState>) : boolean;
        ChangeName(Controller: $Nullable<UE.Controller>, NewName: string, bNameChange: boolean) : void;
        ChoosePlayerStart(Player: $Nullable<UE.Controller>) : UE.Actor;
        FindPlayerStart(Player: $Nullable<UE.Controller>, IncomingName: string) : UE.Actor;
        GetDefaultPawnClassForController(InController: $Nullable<UE.Controller>) : UE.Class;
        GetNumPlayers() : number;
        GetNumSpectators() : number;
        HandleStartingNewPlayer(NewPlayer: $Nullable<UE.PlayerController>) : void;
        HasMatchStarted() : boolean;
        InitializeHUDForPlayer(NewPlayer: $Nullable<UE.PlayerController>) : void;
        InitStartSpot(StartSpot: $Nullable<UE.Actor>, NewPlayer: $Nullable<UE.Controller>) : void;
        K2_FindPlayerStart(Player: $Nullable<UE.Controller>, IncomingName?: string /* = "" */) : UE.Actor;
        K2_OnChangeName(Other: $Nullable<UE.Controller>, NewName: string, bNameChange: boolean) : void;
        K2_OnLogout(ExitingController: $Nullable<UE.Controller>) : void;
        K2_OnRestartPlayer(NewPlayer: $Nullable<UE.Controller>) : void;
        K2_OnSwapPlayerControllers(OldPC: $Nullable<UE.PlayerController>, NewPC: $Nullable<UE.PlayerController>) : void;
        K2_PostLogin(NewPlayer: $Nullable<UE.PlayerController>) : void;
        MustSpectate(NewPlayerController: $Nullable<UE.PlayerController>) : boolean;
        PlayerCanRestart(Player: $Nullable<UE.PlayerController>) : boolean;
        ResetLevel() : void;
        RestartPlayer(NewPlayer: $Nullable<UE.Controller>) : void;
        RestartPlayerAtPlayerStart(NewPlayer: $Nullable<UE.Controller>, StartSpot: $Nullable<UE.Actor>) : void;
        RestartPlayerAtTransform(NewPlayer: $Nullable<UE.Controller>, SpawnTransform: UE.Transform) : void;
        ReturnToMainMenuHost() : void;
        ShouldReset(ActorToReset: $Nullable<UE.Actor>) : boolean;
        SpawnDefaultPawnAtTransform(NewPlayer: $Nullable<UE.Controller>, SpawnTransform: UE.Transform) : UE.Pawn;
        SpawnDefaultPawnFor(NewPlayer: $Nullable<UE.Controller>, StartSpot: $Nullable<UE.Actor>) : UE.Pawn;
        StartPlay() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameModeBase;
        static Load(InName: string): GameModeBase;
    }
    
    class AISystemBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AISystemClassName: UE.SoftClassPath;
        AISystemModuleName: string;
        bInstantiateAISystemOnClient: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISystemBase;
        static Load(InName: string): AISystemBase;
    }
    
    class AvoidanceManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultTimeToLive: number;
        LockTimeAfterAvoid: number;
        LockTimeAfterClean: number;
        DeltaTimeToPredict: number;
        ArtificialRadiusExpansion: number;
        TestHeightDifference: number;
        HeightCheckMargin: number;
        GetAvoidanceVelocityForComponent(MovementComp: $Nullable<UE.MovementComponent>) : UE.Vector;
        GetNewAvoidanceUID() : number;
        GetObjectCount() : number;
        RegisterMovementComponent(MovementComp: $Nullable<UE.MovementComponent>, AvoidanceWeight?: number /* = 0.500000 */) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AvoidanceManager;
        static Load(InName: string): AvoidanceManager;
    }
    
    class LevelCollection {
        constructor();
        constructor(GameState: UE.GameStateBase, NetDriver: UE.NetDriver, DemoNetDriver: UE.DemoNetDriver, PersistentLevel: UE.Level, Levels: TSet<UE.Level>);
        GameState: UE.GameStateBase;
        NetDriver: UE.NetDriver;
        DemoNetDriver: UE.DemoNetDriver;
        PersistentLevel: UE.Level;
        Levels: TSet<UE.Level>;
        static StaticClass(): Class;
    }
    
    class ScriptViewportClient extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScriptViewportClient;
        static Load(InName: string): ScriptViewportClient;
    }
    
    class Console extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConsoleTargetPlayer: UE.LocalPlayer;
        DefaultTexture_Black: UE.Texture2D;
        DefaultTexture_White: UE.Texture2D;
        HistoryBuffer: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Console;
        static Load(InName: string): Console;
    }
    
    class DebugDisplayProperty {
        constructor();
        constructor(Obj: UE.Object, WithinClass: UE.Class);
        Obj: UE.Object;
        WithinClass: UE.Class;
        static StaticClass(): Class;
    }
    
    class GameViewportClient extends UE.ScriptViewportClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ViewportConsole: UE.Console;
        DebugProperties: TArray<UE.DebugDisplayProperty>;
        World: UE.World;
        GameInstance: UE.GameInstance;
        SetConsoleTarget(PlayerIndex: number) : void;
        ShowTitleSafeArea() : void;
        SSSwapControllers() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameViewportClient;
        static Load(InName: string): GameViewportClient;
    }
    
    enum EAspectRatioAxisConstraint { AspectRatio_MaintainYFOV, AspectRatio_MaintainXFOV, AspectRatio_MajorAxisFOV, AspectRatio_MAX}
    class LocalPlayer extends UE.Player {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ViewportClient: UE.GameViewportClient;
        AspectRatioAxisConstraint: UE.EAspectRatioAxisConstraint;
        PendingLevelPlayerControllerClass: UE.Class;
        bSentSplitJoin: boolean;
        ControllerId: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalPlayer;
        static Load(InName: string): LocalPlayer;
    }
    
    class OnlineSession extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineSession;
        static Load(InName: string): OnlineSession;
    }
    
    enum ETravelFailure { NoLevel, LoadMapFailure, InvalidURL, PackageMissing, PackageVersion, NoDownload, TravelFailure, CheatCommands, PendingNetGameCreateFailure, CloudSaveFailure, ServerTravelFailure, ClientTravelFailure, ETravelFailure_MAX}
    enum ENetworkFailure { NetDriverAlreadyExists, NetDriverCreateFailure, NetDriverListenFailure, ConnectionLost, ConnectionTimeout, FailureReceived, OutdatedClient, OutdatedServer, PendingConnectionFailure, NetGuidMismatch, NetChecksumMismatch, ENetworkFailure_MAX}
    class GameInstance extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LocalPlayers: TArray<UE.LocalPlayer>;
        OnlineSession: UE.OnlineSession;
        ReferencedObjects: TArray<UE.Object>;
        DebugCreatePlayer(ControllerId: number) : void;
        DebugRemovePlayer(ControllerId: number) : void;
        HandleNetworkError(FailureType: UE.ENetworkFailure, bIsServer: boolean) : void;
        HandleTravelError(FailureType: UE.ETravelFailure) : void;
        ReceiveInit() : void;
        ReceiveShutdown() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameInstance;
        static Load(InName: string): GameInstance;
    }
    
    class MaterialParameterCollectionInstance extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Collection: UE.MaterialParameterCollection;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialParameterCollectionInstance;
        static Load(InName: string): MaterialParameterCollectionInstance;
    }
    
    class LevelViewportInfo {
        constructor();
        constructor(CamPosition: UE.Vector, CamRotation: UE.Rotator, CamOrthoZoom: number, CamUpdated: boolean);
        CamPosition: UE.Vector;
        CamRotation: UE.Rotator;
        CamOrthoZoom: number;
        CamUpdated: boolean;
        static StaticClass(): Class;
    }
    
    class WorldComposition extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TilesStreaming: TArray<UE.LevelStreaming>;
        TilesStreamingTimeThreshold: number;
        bLoadAllTilesDuringCinematic: boolean;
        bRebaseOriginIn3DSpace: boolean;
        bLockTilesLocation: boolean;
        RebaseOriginDistance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WorldComposition;
        static Load(InName: string): WorldComposition;
    }
    
    class PSCPoolElem {
        constructor();
        constructor(PSC: UE.ParticleSystemComponent);
        PSC: UE.ParticleSystemComponent;
        static StaticClass(): Class;
    }
    
    class PSCPool {
        constructor();
        constructor(FreeElements: TArray<UE.PSCPoolElem>, InUseComponents_Auto: TArray<UE.ParticleSystemComponent>, InUseComponents_Manual: TArray<UE.ParticleSystemComponent>);
        FreeElements: TArray<UE.PSCPoolElem>;
        InUseComponents_Auto: TArray<UE.ParticleSystemComponent>;
        InUseComponents_Manual: TArray<UE.ParticleSystemComponent>;
        static StaticClass(): Class;
    }
    
    class WorldPSCPool {
        constructor();
        constructor(WorldParticleSystemPools: TMap<UE.ParticleSystem, UE.PSCPool>);
        WorldParticleSystemPools: TMap<UE.ParticleSystem, UE.PSCPool>;
        static StaticClass(): Class;
    }
    
    enum ESpawnActorCollisionHandlingMethod { Undefined, AlwaysSpawn, AdjustIfPossibleButAlwaysSpawn, AdjustIfPossibleButDontSpawnIfColliding, DontSpawnIfColliding, ESpawnActorCollisionHandlingMethod_MAX}
    class World extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Layers: TArray<UE.Layer>;
        ActiveGroupActors: TArray<UE.Actor>;
        ThumbnailInfo: UE.ThumbnailInfo;
        PersistentLevel: UE.Level;
        NetDriver: UE.NetDriver;
        LineBatcher: UE.LineBatchComponent;
        PersistentLineBatcher: UE.LineBatchComponent;
        ForegroundLineBatcher: UE.LineBatchComponent;
        NetworkManager: UE.GameNetworkManager;
        PhysicsCollisionHandler: UE.PhysicsCollisionHandler;
        ExtraReferencedObjects: TArray<UE.Object>;
        PerModuleDataObjects: TArray<UE.Object>;
        LevelSequenceActors: TArray<UE.Actor>;
        StreamingLevels: TArray<UE.LevelStreaming>;
        StreamingLevelsToConsider: UE.StreamingLevelsToConsider;
        StreamingLevelsPrefix: string;
        CurrentLevelPendingVisibility: UE.Level;
        CurrentLevelPendingInvisibility: UE.Level;
        DemoNetDriver: UE.DemoNetDriver;
        MyParticleEventManager: UE.ParticleEventManager;
        DefaultPhysicsVolume: UE.PhysicsVolume;
        bAreConstraintsDirty: boolean;
        NavigationSystem: UE.NavigationSystemBase;
        AuthorityGameMode: UE.GameModeBase;
        GameState: UE.GameStateBase;
        AISystem: UE.AISystemBase;
        AvoidanceManager: UE.AvoidanceManager;
        Levels: TArray<UE.Level>;
        LevelCollections: TArray<UE.LevelCollection>;
        CurrentLevel: UE.Level;
        OwningGameInstance: UE.GameInstance;
        ParameterCollectionInstances: TArray<UE.MaterialParameterCollectionInstance>;
        CanvasForRenderingToTarget: UE.Canvas;
        CanvasForDrawMaterialToRenderTarget: UE.Canvas;
        EditorViews: TArray<UE.LevelViewportInfo>;
        ComponentsThatNeedEndOfFrameUpdate: TArray<UE.ActorComponent>;
        ComponentsThatNeedEndOfFrameUpdate_OnGameThread: TArray<UE.ActorComponent>;
        SelectedLevels: TArray<UE.Level>;
        WorldComposition: UE.WorldComposition;
        PSCPool: UE.WorldPSCPool;
        HandleTimelineScrubbed() : void;
        K2_GetWorldSettings() : UE.WorldSettings;
        SpawnActor(Class: $Nullable<UE.Class>, Transform: UE.Transform, SpawnCollisionHandlingOverride: UE.ESpawnActorCollisionHandlingMethod, Owner: $Nullable<UE.Actor>, Instigator: $Nullable<UE.Pawn>) : UE.Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): World;
        static Load(InName: string): World;
    }
    
    class Package extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Package;
        static Load(InName: string): Package;
    }
    
    class ChannelDefinition {
        constructor();
        constructor(ChannelName: string, ClassName: string, ChannelClass: UE.Class, StaticChannelIndex: number, bTickOnCreate: boolean, bServerOpen: boolean, bClientOpen: boolean, bInitialServer: boolean, bInitialClient: boolean);
        ChannelName: string;
        ClassName: string;
        ChannelClass: UE.Class;
        StaticChannelIndex: number;
        bTickOnCreate: boolean;
        bServerOpen: boolean;
        bClientOpen: boolean;
        bInitialServer: boolean;
        bInitialClient: boolean;
        static StaticClass(): Class;
    }
    
    class Channel extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Connection: UE.NetConnection;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Channel;
        static Load(InName: string): Channel;
    }
    
    class ReplicationDriver extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReplicationDriver;
        static Load(InName: string): ReplicationDriver;
    }
    
    class NetDriver extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NetConnectionClassName: string;
        ReplicationDriverClassName: string;
        MaxDownloadSize: number;
        bClampListenServerTickRate: boolean;
        NetServerMaxTickRate: number;
        MaxNetTickRate: number;
        MaxInternetClientRate: number;
        MaxClientRate: number;
        ServerTravelPause: number;
        SpawnPrioritySeconds: number;
        RelevantTimeout: number;
        KeepAliveTime: number;
        InitialConnectTimeout: number;
        ConnectionTimeout: number;
        TimeoutMultiplierForUnoptimizedBuilds: number;
        bNoTimeouts: boolean;
        bNeverApplyNetworkEmulationSettings: boolean;
        ServerConnection: UE.NetConnection;
        ClientConnections: TArray<UE.NetConnection>;
        RecentlyDisconnectedTrackingTime: number;
        World: UE.World;
        WorldPackage: UE.Package;
        NetConnectionClass: UE.Class;
        ReplicationDriverClass: UE.Class;
        RoleProperty: UE.Property;
        RemoteRoleProperty: UE.Property;
        NetDriverName: string;
        ChannelDefinitions: TArray<UE.ChannelDefinition>;
        ChannelDefinitionMap: TMap<string, UE.ChannelDefinition>;
        ActorChannelPool: TArray<UE.Channel>;
        Time: number;
        ReplicationDriver: UE.ReplicationDriver;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NetDriver;
        static Load(InName: string): NetDriver;
    }
    
    class PackageMap extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PackageMap;
        static Load(InName: string): PackageMap;
    }
    
    class NetConnection extends UE.Player {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Children: TArray<UE.ChildConnection>;
        Driver: UE.NetDriver;
        PackageMapClass: UE.Class;
        PackageMap: UE.PackageMap;
        OpenChannels: TArray<UE.Channel>;
        SentTemporaries: TArray<UE.Actor>;
        ViewTarget: UE.Actor;
        OwningActor: UE.Actor;
        MaxPacket: number;
        InternalAck: boolean;
        PlayerId: UE.UniqueNetIdRepl;
        LastReceiveTime: number;
        ChannelsToTick: TArray<UE.Channel>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NetConnection;
        static Load(InName: string): NetConnection;
    }
    
    enum EMouseCursor { None, Default, TextEditBeam, ResizeLeftRight, ResizeUpDown, ResizeSouthEast, ResizeSouthWest, CardinalCross, Crosshairs, Hand, GrabHand, GrabHandClosed, SlashedCircle, EyeDropper, EMouseCursor_MAX}
    class CachedKeyToActionInfo {
        constructor();
        constructor(PlayerInput: UE.PlayerInput);
        PlayerInput: UE.PlayerInput;
        static StaticClass(): Class;
    }
    
    enum EControllerAnalogStick { CAS_LeftStick, CAS_RightStick, CAS_MAX}
    class InputComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CachedKeyToActionInfo: TArray<UE.CachedKeyToActionInfo>;
        GetControllerAnalogKeyState(Key: UE.Key) : number;
        GetControllerAnalogStickState(WhichStick: UE.EControllerAnalogStick, StickX: $Ref<number>, StickY: $Ref<number>) : void;
        GetControllerKeyTimeDown(Key: UE.Key) : number;
        GetControllerMouseDelta(DeltaX: $Ref<number>, DeltaY: $Ref<number>) : void;
        GetControllerVectorKeyState(Key: UE.Key) : UE.Vector;
        GetTouchState(FingerIndex: number, LocationX: $Ref<number>, LocationY: $Ref<number>, bIsCurrentlyPressed: $Ref<boolean>) : void;
        IsControllerKeyDown(Key: UE.Key) : boolean;
        WasControllerKeyJustPressed(Key: UE.Key) : boolean;
        WasControllerKeyJustReleased(Key: UE.Key) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputComponent;
        static Load(InName: string): InputComponent;
    }
    
    class TouchInputControl {
        constructor();
        constructor(Image1: UE.Texture2D, Image2: UE.Texture2D, Center: UE.Vector2D, VisualSize: UE.Vector2D, ThumbSize: UE.Vector2D, InteractionSize: UE.Vector2D, InputScale: UE.Vector2D, MainInputKey: UE.Key, AltInputKey: UE.Key);
        Image1: UE.Texture2D;
        Image2: UE.Texture2D;
        Center: UE.Vector2D;
        VisualSize: UE.Vector2D;
        ThumbSize: UE.Vector2D;
        InteractionSize: UE.Vector2D;
        InputScale: UE.Vector2D;
        MainInputKey: UE.Key;
        AltInputKey: UE.Key;
        static StaticClass(): Class;
    }
    
    class TouchInterface extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Controls: TArray<UE.TouchInputControl>;
        ActiveOpacity: number;
        InactiveOpacity: number;
        TimeUntilDeactive: number;
        TimeUntilReset: number;
        ActivationDelay: number;
        bPreventRecenter: boolean;
        StartupDelay: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TouchInterface;
        static Load(InName: string): TouchInterface;
    }
    
    class SphereComponent extends UE.ShapeComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SphereRadius: number;
        GetScaledSphereRadius() : number;
        GetShapeScale() : number;
        GetUnscaledSphereRadius() : number;
        SetSphereRadius(InSphereRadius: number, bUpdateOverlaps?: boolean /* = true */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SphereComponent;
        static Load(InName: string): SphereComponent;
    }
    
    class StaticMeshComponentLODInfo {
        constructor();
        static StaticClass(): Class;
    }
    
    class StreamingTextureBuildInfo {
        constructor();
        constructor(PackedRelativeBox: number, TextureLevelIndex: number, TexelFactor: number);
        PackedRelativeBox: number;
        TextureLevelIndex: number;
        TexelFactor: number;
        static StaticClass(): Class;
    }
    
    class LightmassPrimitiveSettings {
        constructor();
        constructor(bUseTwoSidedLighting: boolean, bShadowIndirectOnly: boolean, bUseEmissiveForStaticLighting: boolean, bUseVertexNormalForHemisphereGather: boolean, EmissiveLightFalloffExponent: number, EmissiveLightExplicitInfluenceRadius: number, EmissiveBoost: number, DiffuseBoost: number, FullyOccludedSamplesFraction: number);
        bUseTwoSidedLighting: boolean;
        bShadowIndirectOnly: boolean;
        bUseEmissiveForStaticLighting: boolean;
        bUseVertexNormalForHemisphereGather: boolean;
        EmissiveLightFalloffExponent: number;
        EmissiveLightExplicitInfluenceRadius: number;
        EmissiveBoost: number;
        DiffuseBoost: number;
        FullyOccludedSamplesFraction: number;
        static StaticClass(): Class;
    }
    
    class StaticMeshComponent extends UE.MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ForcedLodModel: number;
        PreviousLODLevel: number;
        MinLOD: number;
        SubDivisionStepSize: number;
        StaticMesh: UE.StaticMesh;
        WireframeColorOverride: UE.Color;
        bEvaluateWorldPositionOffset: boolean;
        SelectedEditorSection: number;
        SelectedEditorMaterial: number;
        SectionIndexPreview: number;
        MaterialIndexPreview: number;
        StaticMeshImportVersion: number;
        bOverrideWireframeColor: boolean;
        bOverrideMinLOD: boolean;
        bOverrideNavigationExport: boolean;
        bForceNavigationObstacle: boolean;
        bDisallowMeshPaintPerInstance: boolean;
        bIgnoreInstanceForTextureStreaming: boolean;
        bOverrideLightMapRes: boolean;
        bCastDistanceFieldIndirectShadow: boolean;
        bOverrideDistanceFieldSelfShadowBias: boolean;
        bUseSubDivisions: boolean;
        bUseDefaultCollision: boolean;
        bCustomOverrideVertexColorPerLOD: boolean;
        bDisplayVertexColors: boolean;
        bReverseCulling: boolean;
        OverriddenLightMapRes: number;
        DistanceFieldIndirectShadowMinVisibility: number;
        DistanceFieldSelfShadowBias: number;
        StreamingDistanceMultiplier: number;
        IrrelevantLights: TArray<UE.Guid>;
        LODData: TArray<UE.StaticMeshComponentLODInfo>;
        StreamingTextureData: TArray<UE.StreamingTextureBuildInfo>;
        StaticMeshDerivedDataKey: string;
        MaterialStreamingRelativeBoxes: TArray<number>;
        LightmassSettings: UE.LightmassPrimitiveSettings;
        GetLocalBounds(Min: $Ref<UE.Vector>, Max: $Ref<UE.Vector>) : void;
        OnRep_StaticMesh(OldStaticMesh: $Nullable<UE.StaticMesh>) : void;
        SetDistanceFieldSelfShadowBias(NewValue: number) : void;
        SetForcedLodModel(NewForcedLodModel: number) : void;
        SetReverseCulling(ReverseCulling: boolean) : void;
        SetStaticMesh(NewMesh: $Nullable<UE.StaticMesh>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshComponent;
        static Load(InName: string): StaticMeshComponent;
    }
    
    class DefaultPawn extends UE.Pawn {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseTurnRate: number;
        BaseLookUpRate: number;
        MovementComponent: UE.PawnMovementComponent;
        CollisionComponent: UE.SphereComponent;
        MeshComponent: UE.StaticMeshComponent;
        bAddDefaultMovementBindings: boolean;
        LookUpAtRate(Rate: number) : void;
        MoveForward(Val: number) : void;
        MoveRight(Val: number) : void;
        MoveUp_World(Val: number) : void;
        TurnAtRate(Rate: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DefaultPawn;
        static Load(InName: string): DefaultPawn;
    }
    
    class SpectatorPawn extends UE.DefaultPawn {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpectatorPawn;
        static Load(InName: string): SpectatorPawn;
    }
    
    enum EControllerHand { Left, Right, AnyHand, Pad, ExternalCamera, Gun, Special_1, Special_2, Special_3, Special_4, Special_5, Special_6, Special_7, Special_8, Special_9, Special_10, Special_11, ControllerHand_Count, EControllerHand_MAX}
    enum EViewTargetBlendFunction { VTBlend_Linear, VTBlend_Cubic, VTBlend_EaseIn, VTBlend_EaseOut, VTBlend_EaseInOut, VTBlend_MAX}
    class Visual extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Visual;
        static Load(InName: string): Visual;
    }
    
    class PanelWidget extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Slots: TArray<UE.PanelSlot>;
        AddChild(Content: $Nullable<UE.Widget>) : UE.PanelSlot;
        ClearChildren() : void;
        GetAllChildren() : TArray<UE.Widget>;
        GetChildAt(Index: number) : UE.Widget;
        GetChildIndex(Content: $Nullable<UE.Widget>) : number;
        GetChildrenCount() : number;
        HasAnyChildren() : boolean;
        HasChild(Content: $Nullable<UE.Widget>) : boolean;
        RemoveChild(Content: $Nullable<UE.Widget>) : boolean;
        RemoveChildAt(Index: number) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PanelWidget;
        static Load(InName: string): PanelWidget;
    }
    
    class PanelSlot extends UE.Visual {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Parent: UE.PanelWidget;
        Content: UE.Widget;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PanelSlot;
        static Load(InName: string): PanelSlot;
    }
    
    enum ESlateVisibility { Visible, Collapsed, Hidden, HitTestInvisible, SelfHitTestInvisible, ESlateVisibility_MAX}
    class WidgetTransform {
        constructor();
        constructor(Translation: UE.Vector2D, Scale: UE.Vector2D, Shear: UE.Vector2D, Angle: number);
        Translation: UE.Vector2D;
        Scale: UE.Vector2D;
        Shear: UE.Vector2D;
        Angle: number;
        static StaticClass(): Class;
    }
    
    enum ESlateAccessibleBehavior { NotAccessible, Auto, Summary, Custom, ToolTip, ESlateAccessibleBehavior_MAX}
    class SlateAccessibleWidgetData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCanChildrenBeAccessible: boolean;
        AccessibleBehavior: UE.ESlateAccessibleBehavior;
        AccessibleSummaryBehavior: UE.ESlateAccessibleBehavior;
        AccessibleText: string;
        AccessibleTextDelegate: $Delegate<() => string>;
        AccessibleSummaryText: string;
        AccessibleSummaryTextDelegate: $Delegate<() => string>;
        GetText__DelegateSignature() : string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateAccessibleWidgetData;
        static Load(InName: string): SlateAccessibleWidgetData;
    }
    
    enum EWidgetClipping { Inherit, ClipToBounds, ClipToBoundsWithoutIntersecting, ClipToBoundsAlways, OnDemand, EWidgetClipping_MAX}
    enum EUINavigation { Left, Right, Up, Down, Next, Previous, Num, Invalid, EUINavigation_MAX}
    enum EUINavigationRule { Escape, Explicit, Wrap, Stop, Custom, CustomBoundary, Invalid, EUINavigationRule_MAX}
    class WidgetNavigationData {
        constructor();
        constructor(Rule: UE.EUINavigationRule, WidgetToFocus: string, Widget: TWeakObjectPtr<UE.Widget>, CustomDelegate: $Delegate<(Navigation: UE.EUINavigation) => UE.Widget>);
        Rule: UE.EUINavigationRule;
        WidgetToFocus: string;
        Widget: TWeakObjectPtr<UE.Widget>;
        CustomDelegate: $Delegate<(Navigation: UE.EUINavigation) => UE.Widget>;
        static StaticClass(): Class;
    }
    
    class WidgetNavigation extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Up: UE.WidgetNavigationData;
        Down: UE.WidgetNavigationData;
        Left: UE.WidgetNavigationData;
        Right: UE.WidgetNavigationData;
        Next: UE.WidgetNavigationData;
        Previous: UE.WidgetNavigationData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetNavigation;
        static Load(InName: string): WidgetNavigation;
    }
    
    enum EFlowDirectionPreference { Inherit, Culture, LeftToRight, RightToLeft, EFlowDirectionPreference_MAX}
    class PropertyPathSegment {
        constructor();
        constructor(Name: string, ArrayIndex: number, Struct: UE.Struct, Field: UE.Field);
        Name: string;
        ArrayIndex: number;
        Struct: UE.Struct;
        Field: UE.Field;
        static StaticClass(): Class;
    }
    
    class CachedPropertyPath {
        constructor();
        constructor(Segments: TArray<UE.PropertyPathSegment>, CachedFunction: UE.Function);
        Segments: TArray<UE.PropertyPathSegment>;
        CachedFunction: UE.Function;
        static StaticClass(): Class;
    }
    
    class DynamicPropertyPath extends UE.CachedPropertyPath {
        constructor();
        static StaticClass(): Class;
    }
    
    class PropertyBinding extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceObject: TWeakObjectPtr<UE.Object>;
        SourcePath: UE.DynamicPropertyPath;
        DestinationProperty: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyBinding;
        static Load(InName: string): PropertyBinding;
    }
    
    class EventReply {
        constructor();
        static StaticClass(): Class;
    }
    
    class Geometry {
        constructor();
        static StaticClass(): Class;
    }
    
    class InputEvent {
        constructor();
        static StaticClass(): Class;
    }
    
    class PointerEvent extends UE.InputEvent {
        constructor();
        static StaticClass(): Class;
    }
    
    enum ESlateColorStylingMode { UseColor_Specified, UseColor_Specified_Link, UseColor_Foreground, UseColor_Foreground_Subdued, UseColor_MAX}
    class SlateColor {
        constructor();
        constructor(SpecifiedColor: UE.LinearColor, ColorUseRule: UE.ESlateColorStylingMode);
        SpecifiedColor: UE.LinearColor;
        ColorUseRule: UE.ESlateColorStylingMode;
        static StaticClass(): Class;
    }
    
    class Margin {
        constructor();
        constructor(Left: number, Top: number, Right: number, Bottom: number);
        Left: number;
        Top: number;
        Right: number;
        Bottom: number;
        static StaticClass(): Class;
    }
    
    enum ESlateBrushDrawType { NoDrawType, Box, Border, Image, ESlateBrushDrawType_MAX}
    enum ESlateBrushTileType { NoTile, Horizontal, Vertical, Both, ESlateBrushTileType_MAX}
    enum ESlateBrushMirrorType { NoMirror, Horizontal, Vertical, Both, ESlateBrushMirrorType_MAX}
    enum ESlateBrushImageType { NoImage, FullColor, Linear, ESlateBrushImageType_MAX}
    class SlateBrush {
        constructor();
        constructor(ImageSize: UE.Vector2D, Margin: UE.Margin, Tint: UE.LinearColor, TintColor: UE.SlateColor, ResourceObject: UE.Object, ResourceName: string, UVRegion: UE.Box2D, DrawAs: UE.ESlateBrushDrawType, Tiling: UE.ESlateBrushTileType, Mirroring: UE.ESlateBrushMirrorType, ImageType: UE.ESlateBrushImageType, bIsDynamicallyLoaded: boolean, bHasUObject: boolean);
        ImageSize: UE.Vector2D;
        Margin: UE.Margin;
        Tint: UE.LinearColor;
        TintColor: UE.SlateColor;
        ResourceObject: UE.Object;
        ResourceName: string;
        UVRegion: UE.Box2D;
        DrawAs: UE.ESlateBrushDrawType;
        Tiling: UE.ESlateBrushTileType;
        Mirroring: UE.ESlateBrushMirrorType;
        ImageType: UE.ESlateBrushImageType;
        bIsDynamicallyLoaded: boolean;
        bHasUObject: boolean;
        static StaticClass(): Class;
    }
    
    enum ECheckBoxState { Unchecked, Checked, Undetermined, ECheckBoxState_MAX}
    class Widget extends UE.Visual {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Slot: UE.PanelSlot;
        bIsEnabledDelegate: $Delegate<() => boolean>;
        ToolTipText: string;
        ToolTipTextDelegate: $Delegate<() => string>;
        ToolTipWidget: UE.Widget;
        ToolTipWidgetDelegate: $Delegate<() => UE.Widget>;
        VisibilityDelegate: $Delegate<() => UE.ESlateVisibility>;
        RenderTransform: UE.WidgetTransform;
        RenderTransformPivot: UE.Vector2D;
        bIsVariable: boolean;
        bCreatedByConstructionScript: boolean;
        bIsEnabled: boolean;
        bOverride_Cursor: boolean;
        bOverrideAccessibleDefaults: boolean;
        bCanChildrenBeAccessible: boolean;
        AccessibleBehavior: UE.ESlateAccessibleBehavior;
        AccessibleSummaryBehavior: UE.ESlateAccessibleBehavior;
        AccessibleText: string;
        AccessibleTextDelegate: $Delegate<() => string>;
        AccessibleSummaryText: string;
        AccessibleSummaryTextDelegate: $Delegate<() => string>;
        AccessibleWidgetData: UE.SlateAccessibleWidgetData;
        bIsVolatile: boolean;
        bHiddenInDesigner: boolean;
        bExpandedInDesigner: boolean;
        bLockedInDesigner: boolean;
        Cursor: UE.EMouseCursor;
        Clipping: UE.EWidgetClipping;
        Visibility: UE.ESlateVisibility;
        RenderOpacity: number;
        Navigation: UE.WidgetNavigation;
        FlowDirectionPreference: UE.EFlowDirectionPreference;
        NativeBindings: TArray<UE.PropertyBinding>;
        DesignerFlags: number;
        DisplayLabel: string;
        CategoryName: string;
        ForceLayoutPrepass() : void;
        ForceVolatile(bForce: boolean) : void;
        GenerateWidgetForObject__DelegateSignature(Item: $Nullable<UE.Object>) : UE.Widget;
        GenerateWidgetForString__DelegateSignature(Item: string) : UE.Widget;
        GetBool__DelegateSignature() : boolean;
        GetCachedGeometry() : UE.Geometry;
        GetCheckBoxState__DelegateSignature() : UE.ECheckBoxState;
        GetClipping() : UE.EWidgetClipping;
        GetDesiredSize() : UE.Vector2D;
        GetFloat__DelegateSignature() : number;
        GetGameInstance() : UE.GameInstance;
        GetInt32__DelegateSignature() : number;
        GetIsEnabled() : boolean;
        GetLinearColor__DelegateSignature() : UE.LinearColor;
        GetMouseCursor__DelegateSignature() : UE.EMouseCursor;
        GetOwningLocalPlayer() : UE.LocalPlayer;
        GetOwningPlayer() : UE.PlayerController;
        GetPaintSpaceGeometry() : UE.Geometry;
        GetParent() : UE.PanelWidget;
        GetRenderOpacity() : number;
        GetRenderTransformAngle() : number;
        GetSlateBrush__DelegateSignature() : UE.SlateBrush;
        GetSlateColor__DelegateSignature() : UE.SlateColor;
        GetSlateVisibility__DelegateSignature() : UE.ESlateVisibility;
        GetText__DelegateSignature() : string;
        GetTickSpaceGeometry() : UE.Geometry;
        GetVisibility() : UE.ESlateVisibility;
        GetWidget__DelegateSignature() : UE.Widget;
        HasAnyUserFocus() : boolean;
        HasFocusedDescendants() : boolean;
        HasKeyboardFocus() : boolean;
        HasMouseCapture() : boolean;
        HasMouseCaptureByUser(UserIndex: number, PointerIndex?: number /* = -1 */) : boolean;
        HasUserFocus(PlayerController: $Nullable<UE.PlayerController>) : boolean;
        HasUserFocusedDescendants(PlayerController: $Nullable<UE.PlayerController>) : boolean;
        InvalidateLayoutAndVolatility() : void;
        IsHovered() : boolean;
        IsVisible() : boolean;
        OnPointerEvent__DelegateSignature(MyGeometry: UE.Geometry, MouseEvent: UE.PointerEvent) : UE.EventReply;
        OnReply__DelegateSignature() : UE.EventReply;
        RemoveFromParent() : void;
        ResetCursor() : void;
        SetAllNavigationRules(Rule: UE.EUINavigationRule, WidgetToFocus: string) : void;
        SetClipping(InClipping: UE.EWidgetClipping) : void;
        SetCursor(InCursor: UE.EMouseCursor) : void;
        SetFocus() : void;
        SetIsEnabled(bInIsEnabled: boolean) : void;
        SetKeyboardFocus() : void;
        SetNavigationRule(Direction: UE.EUINavigation, Rule: UE.EUINavigationRule, WidgetToFocus: string) : void;
        SetNavigationRuleBase(Direction: UE.EUINavigation, Rule: UE.EUINavigationRule) : void;
        SetNavigationRuleCustom(Direction: UE.EUINavigation, InCustomDelegate: $Delegate<(Navigation: UE.EUINavigation) => UE.Widget>) : void;
        SetNavigationRuleCustomBoundary(Direction: UE.EUINavigation, InCustomDelegate: $Delegate<(Navigation: UE.EUINavigation) => UE.Widget>) : void;
        SetNavigationRuleExplicit(Direction: UE.EUINavigation, InWidget: $Nullable<UE.Widget>) : void;
        SetRenderOpacity(InOpacity: number) : void;
        SetRenderScale(Scale: UE.Vector2D) : void;
        SetRenderShear(Shear: UE.Vector2D) : void;
        SetRenderTransform(InTransform: UE.WidgetTransform) : void;
        SetRenderTransformAngle(Angle: number) : void;
        SetRenderTransformPivot(Pivot: UE.Vector2D) : void;
        SetRenderTranslation(Translation: UE.Vector2D) : void;
        SetToolTip(Widget: $Nullable<UE.Widget>) : void;
        SetToolTipText(InToolTipText: string) : void;
        SetUserFocus(PlayerController: $Nullable<UE.PlayerController>) : void;
        SetVisibility(InVisibility: UE.ESlateVisibility) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Widget;
        static Load(InName: string): Widget;
    }
    
    class MovieSceneSignedObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Signature: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSignedObject;
        static Load(InName: string): MovieSceneSignedObject;
    }
    
    class MovieSceneTrackIdentifier {
        constructor();
        constructor(Value: number);
        Value: number;
        static StaticClass(): Class;
    }
    
    enum EEvaluationMethod { Static, Swept, EEvaluationMethod_MAX}
    class MovieSceneSegment {
        constructor();
        static StaticClass(): Class;
    }
    
    class MovieSceneEvaluationTrackSegments {
        constructor();
        constructor(SegmentIdentifierToIndex: TArray<number>, SortedSegments: TArray<UE.MovieSceneSegment>);
        SegmentIdentifierToIndex: TArray<number>;
        SortedSegments: TArray<UE.MovieSceneSegment>;
        static StaticClass(): Class;
    }
    
    class MovieSceneTrackEvalOptions {
        constructor();
        constructor(bCanEvaluateNearestSection: boolean, bEvalNearestSection: boolean, bEvaluateInPreroll: boolean, bEvaluateInPostroll: boolean, bEvaluateNearestSection: boolean);
        bCanEvaluateNearestSection: boolean;
        bEvalNearestSection: boolean;
        bEvaluateInPreroll: boolean;
        bEvaluateInPostroll: boolean;
        bEvaluateNearestSection: boolean;
        static StaticClass(): Class;
    }
    
    class MovieSceneTrackDisplayOptions {
        constructor();
        constructor(bShowVerticalFrames: boolean);
        bShowVerticalFrames: boolean;
        static StaticClass(): Class;
    }
    
    class MovieSceneTrack extends UE.MovieSceneSignedObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EvalOptions: UE.MovieSceneTrackEvalOptions;
        DisplayOptions: UE.MovieSceneTrackDisplayOptions;
        bIsEvalDisabled: boolean;
        TrackTint: UE.Color;
        SortingOrder: number;
        bSupportsDefaultSections: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneTrack;
        static Load(InName: string): MovieSceneTrack;
    }
    
    class SectionEvaluationDataTree {
        constructor();
        static StaticClass(): Class;
    }
    
    class MovieSceneEvalTemplatePtr {
        constructor();
        static StaticClass(): Class;
    }
    
    class MovieSceneTrackImplementationPtr {
        constructor();
        static StaticClass(): Class;
    }
    
    class MovieSceneEvaluationTrack {
        constructor();
        constructor(ObjectBindingID: UE.Guid, EvaluationPriority: number, EvaluationMethod: UE.EEvaluationMethod, Segments: UE.MovieSceneEvaluationTrackSegments, SourceTrack: UE.MovieSceneTrack, EvaluationTree: UE.SectionEvaluationDataTree, ChildTemplates: TArray<UE.MovieSceneEvalTemplatePtr>, TrackTemplate: UE.MovieSceneTrackImplementationPtr, EvaluationGroup: string, bEvaluateInPreroll: boolean, bEvaluateInPostroll: boolean, bTearDownPriority: boolean);
        ObjectBindingID: UE.Guid;
        EvaluationPriority: number;
        EvaluationMethod: UE.EEvaluationMethod;
        Segments: UE.MovieSceneEvaluationTrackSegments;
        SourceTrack: UE.MovieSceneTrack;
        EvaluationTree: UE.SectionEvaluationDataTree;
        ChildTemplates: TArray<UE.MovieSceneEvalTemplatePtr>;
        TrackTemplate: UE.MovieSceneTrackImplementationPtr;
        EvaluationGroup: string;
        bEvaluateInPreroll: boolean;
        bEvaluateInPostroll: boolean;
        bTearDownPriority: boolean;
        static StaticClass(): Class;
    }
    
    class MovieSceneFrameRange {
        constructor();
        static StaticClass(): Class;
    }
    
    class MovieSceneEvaluationGroupLUTIndex {
        constructor();
        constructor(LUTOffset: number, NumInitPtrs: number, NumEvalPtrs: number);
        LUTOffset: number;
        NumInitPtrs: number;
        NumEvalPtrs: number;
        static StaticClass(): Class;
    }
    
    class MovieSceneSequenceID {
        constructor();
        constructor(Value: number);
        Value: number;
        static StaticClass(): Class;
    }
    
    class MovieSceneEvaluationFieldTrackPtr {
        constructor();
        constructor(SequenceID: UE.MovieSceneSequenceID, TrackIdentifier: UE.MovieSceneTrackIdentifier);
        SequenceID: UE.MovieSceneSequenceID;
        TrackIdentifier: UE.MovieSceneTrackIdentifier;
        static StaticClass(): Class;
    }
    
    class MovieSceneSegmentIdentifier {
        constructor();
        constructor(IdentifierIndex: number);
        IdentifierIndex: number;
        static StaticClass(): Class;
    }
    
    class MovieSceneEvaluationFieldSegmentPtr extends UE.MovieSceneEvaluationFieldTrackPtr {
        constructor();
        constructor(SegmentID: UE.MovieSceneSegmentIdentifier);
        SegmentID: UE.MovieSceneSegmentIdentifier;
        static StaticClass(): Class;
    }
    
    class MovieSceneEvaluationGroup {
        constructor();
        constructor(LUTIndices: TArray<UE.MovieSceneEvaluationGroupLUTIndex>, SegmentPtrLUT: TArray<UE.MovieSceneEvaluationFieldSegmentPtr>);
        LUTIndices: TArray<UE.MovieSceneEvaluationGroupLUTIndex>;
        SegmentPtrLUT: TArray<UE.MovieSceneEvaluationFieldSegmentPtr>;
        static StaticClass(): Class;
    }
    
    class MovieSceneEvaluationKey {
        constructor();
        constructor(SequenceID: UE.MovieSceneSequenceID, TrackIdentifier: UE.MovieSceneTrackIdentifier, SectionIndex: number);
        SequenceID: UE.MovieSceneSequenceID;
        TrackIdentifier: UE.MovieSceneTrackIdentifier;
        SectionIndex: number;
        static StaticClass(): Class;
    }
    
    class MovieSceneOrderedEvaluationKey {
        constructor();
        constructor(Key: UE.MovieSceneEvaluationKey, SetupIndex: number, TearDownIndex: number);
        Key: UE.MovieSceneEvaluationKey;
        SetupIndex: number;
        TearDownIndex: number;
        static StaticClass(): Class;
    }
    
    class MovieSceneEvaluationMetaData {
        constructor();
        constructor(ActiveSequences: TArray<UE.MovieSceneSequenceID>, ActiveEntities: TArray<UE.MovieSceneOrderedEvaluationKey>, SubTemplateSerialNumbers: TMap<UE.MovieSceneSequenceID, number>);
        ActiveSequences: TArray<UE.MovieSceneSequenceID>;
        ActiveEntities: TArray<UE.MovieSceneOrderedEvaluationKey>;
        SubTemplateSerialNumbers: TMap<UE.MovieSceneSequenceID, number>;
        static StaticClass(): Class;
    }
    
    class MovieSceneEvaluationField {
        constructor();
        constructor(Signature: UE.Guid, Ranges: TArray<UE.MovieSceneFrameRange>, Groups: TArray<UE.MovieSceneEvaluationGroup>, MetaData: TArray<UE.MovieSceneEvaluationMetaData>);
        Signature: UE.Guid;
        Ranges: TArray<UE.MovieSceneFrameRange>;
        Groups: TArray<UE.MovieSceneEvaluationGroup>;
        MetaData: TArray<UE.MovieSceneEvaluationMetaData>;
        static StaticClass(): Class;
    }
    
    class FrameNumber {
        constructor();
        constructor(Value: number);
        Value: number;
        static StaticClass(): Class;
    }
    
    class FrameTime {
        constructor();
        constructor(FrameNumber: UE.FrameNumber, SubFrame: number);
        FrameNumber: UE.FrameNumber;
        SubFrame: number;
        static StaticClass(): Class;
    }
    
    class MovieSceneSequenceTransform {
        constructor();
        constructor(TimeScale: number, Offset: UE.FrameTime);
        TimeScale: number;
        Offset: UE.FrameTime;
        static StaticClass(): Class;
    }
    
    class FrameRate {
        constructor();
        constructor(Numerator: number, Denominator: number);
        Numerator: number;
        Denominator: number;
        static StaticClass(): Class;
    }
    
    class MovieSceneSequenceInstanceDataPtr {
        constructor();
        static StaticClass(): Class;
    }
    
    class MovieSceneSubSequenceData {
        constructor();
        constructor(Sequence: UE.SoftObjectPath, RootToSequenceTransform: UE.MovieSceneSequenceTransform, TickResolution: UE.FrameRate, DeterministicSequenceID: UE.MovieSceneSequenceID, PlayRange: UE.MovieSceneFrameRange, PreRollRange: UE.MovieSceneFrameRange, PostRollRange: UE.MovieSceneFrameRange, HierarchicalBias: number, InstanceData: UE.MovieSceneSequenceInstanceDataPtr, SectionPath: string, SubSectionSignature: UE.Guid, OuterToInnerTransform: UE.MovieSceneSequenceTransform);
        Sequence: UE.SoftObjectPath;
        RootToSequenceTransform: UE.MovieSceneSequenceTransform;
        TickResolution: UE.FrameRate;
        DeterministicSequenceID: UE.MovieSceneSequenceID;
        PlayRange: UE.MovieSceneFrameRange;
        PreRollRange: UE.MovieSceneFrameRange;
        PostRollRange: UE.MovieSceneFrameRange;
        HierarchicalBias: number;
        InstanceData: UE.MovieSceneSequenceInstanceDataPtr;
        SectionPath: string;
        SubSectionSignature: UE.Guid;
        OuterToInnerTransform: UE.MovieSceneSequenceTransform;
        static StaticClass(): Class;
    }
    
    class MovieSceneSequenceHierarchyNode {
        constructor();
        constructor(ParentID: UE.MovieSceneSequenceID, Children: TArray<UE.MovieSceneSequenceID>);
        ParentID: UE.MovieSceneSequenceID;
        Children: TArray<UE.MovieSceneSequenceID>;
        static StaticClass(): Class;
    }
    
    class MovieSceneSequenceHierarchy {
        constructor();
        constructor(SubSequences: TMap<UE.MovieSceneSequenceID, UE.MovieSceneSubSequenceData>, Hierarchy: TMap<UE.MovieSceneSequenceID, UE.MovieSceneSequenceHierarchyNode>);
        SubSequences: TMap<UE.MovieSceneSequenceID, UE.MovieSceneSubSequenceData>;
        Hierarchy: TMap<UE.MovieSceneSequenceID, UE.MovieSceneSequenceHierarchyNode>;
        static StaticClass(): Class;
    }
    
    class MovieSceneEvaluationTemplateSerialNumber {
        constructor();
        constructor(Value: number);
        Value: number;
        static StaticClass(): Class;
    }
    
    class MovieSceneTemplateGenerationLedger {
        constructor();
        constructor(LastTrackIdentifier: UE.MovieSceneTrackIdentifier, TrackSignatureToTrackIdentifier: TMap<UE.Guid, UE.MovieSceneTrackIdentifier>, SubSectionRanges: TMap<UE.Guid, UE.MovieSceneFrameRange>);
        LastTrackIdentifier: UE.MovieSceneTrackIdentifier;
        TrackSignatureToTrackIdentifier: TMap<UE.Guid, UE.MovieSceneTrackIdentifier>;
        SubSectionRanges: TMap<UE.Guid, UE.MovieSceneFrameRange>;
        static StaticClass(): Class;
    }
    
    class MovieSceneTrackFieldData {
        constructor();
        static StaticClass(): Class;
    }
    
    class MovieSceneSubSectionFieldData {
        constructor();
        static StaticClass(): Class;
    }
    
    class MovieSceneEvaluationTemplate {
        constructor();
        constructor(Tracks: TMap<UE.MovieSceneTrackIdentifier, UE.MovieSceneEvaluationTrack>, EvaluationField: UE.MovieSceneEvaluationField, Hierarchy: UE.MovieSceneSequenceHierarchy, SequenceSignature: UE.Guid, TemplateSerialNumber: UE.MovieSceneEvaluationTemplateSerialNumber, TemplateLedger: UE.MovieSceneTemplateGenerationLedger, TrackFieldData: UE.MovieSceneTrackFieldData, SubSectionFieldData: UE.MovieSceneSubSectionFieldData);
        Tracks: TMap<UE.MovieSceneTrackIdentifier, UE.MovieSceneEvaluationTrack>;
        EvaluationField: UE.MovieSceneEvaluationField;
        Hierarchy: UE.MovieSceneSequenceHierarchy;
        SequenceSignature: UE.Guid;
        TemplateSerialNumber: UE.MovieSceneEvaluationTemplateSerialNumber;
        TemplateLedger: UE.MovieSceneTemplateGenerationLedger;
        TrackFieldData: UE.MovieSceneTrackFieldData;
        SubSectionFieldData: UE.MovieSceneSubSectionFieldData;
        static StaticClass(): Class;
    }
    
    enum EMovieSceneCompletionMode { KeepState, RestoreState, ProjectDefault, EMovieSceneCompletionMode_MAX}
    enum EMovieSceneObjectBindingSpace { Local, Root, EMovieSceneObjectBindingSpace_MAX}
    class MovieSceneObjectBindingID {
        constructor();
        constructor(SequenceID: number, Space: UE.EMovieSceneObjectBindingSpace, Guid: UE.Guid);
        SequenceID: number;
        Space: UE.EMovieSceneObjectBindingSpace;
        Guid: UE.Guid;
        static StaticClass(): Class;
    }
    
    class MovieSceneSequence extends UE.MovieSceneSignedObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PrecompiledEvaluationTemplate: UE.MovieSceneEvaluationTemplate;
        DefaultCompletionMode: UE.EMovieSceneCompletionMode;
        bParentContextsAreSignificant: boolean;
        bPlayableDirectly: boolean;
        FindBindingByTag(InBindingName: string) : UE.MovieSceneObjectBindingID;
        FindBindingsByTag(InBindingName: string) : TArray<UE.MovieSceneObjectBindingID>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSequence;
        static Load(InName: string): MovieSceneSequence;
    }
    
    class Timecode {
        constructor();
        constructor(Hours: number, Minutes: number, Seconds: number, Frames: number, bDropFrameFormat: boolean);
        Hours: number;
        Minutes: number;
        Seconds: number;
        Frames: number;
        bDropFrameFormat: boolean;
        static StaticClass(): Class;
    }
    
    class MovieSceneTimecodeSource {
        constructor();
        constructor(Timecode: UE.Timecode, DeltaFrame: UE.FrameNumber);
        Timecode: UE.Timecode;
        DeltaFrame: UE.FrameNumber;
        static StaticClass(): Class;
    }
    
    enum ESpawnOwnership { InnerSequence, MasterSequence, External, ESpawnOwnership_MAX}
    class MovieSceneSpawnable {
        constructor();
        constructor(SpawnTransform: UE.Transform, Tags: TArray<string>, bContinuouslyRespawn: boolean, Guid: UE.Guid, Name: string, ObjectTemplate: UE.Object, ChildPossessables: TArray<UE.Guid>, Ownership: UE.ESpawnOwnership, GeneratedClass: UE.Class, LevelName: string);
        SpawnTransform: UE.Transform;
        Tags: TArray<string>;
        bContinuouslyRespawn: boolean;
        Guid: UE.Guid;
        Name: string;
        ObjectTemplate: UE.Object;
        ChildPossessables: TArray<UE.Guid>;
        Ownership: UE.ESpawnOwnership;
        GeneratedClass: UE.Class;
        LevelName: string;
        static StaticClass(): Class;
    }
    
    class MovieScenePossessable {
        constructor();
        constructor(Tags: TArray<string>, Guid: UE.Guid, Name: string, PossessedObjectClass: UE.Class, ParentGuid: UE.Guid);
        Tags: TArray<string>;
        Guid: UE.Guid;
        Name: string;
        PossessedObjectClass: UE.Class;
        ParentGuid: UE.Guid;
        static StaticClass(): Class;
    }
    
    class MovieSceneBinding {
        constructor();
        constructor(ObjectGuid: UE.Guid, BindingName: string, Tracks: TArray<UE.MovieSceneTrack>, SortingOrder: number);
        ObjectGuid: UE.Guid;
        BindingName: string;
        Tracks: TArray<UE.MovieSceneTrack>;
        SortingOrder: number;
        static StaticClass(): Class;
    }
    
    class MovieSceneObjectBindingIDs {
        constructor();
        constructor(IDs: TArray<UE.MovieSceneObjectBindingID>);
        IDs: TArray<UE.MovieSceneObjectBindingID>;
        static StaticClass(): Class;
    }
    
    enum EMovieSceneEvaluationType { FrameLocked, WithSubFrames, EMovieSceneEvaluationType_MAX}
    enum EUpdateClockSource { Tick, Platform, Audio, Timecode, EUpdateClockSource_MAX}
    class MovieSceneMarkedFrame {
        constructor();
        constructor(FrameNumber: UE.FrameNumber, Label: string, Color: UE.LinearColor);
        FrameNumber: UE.FrameNumber;
        Label: string;
        Color: UE.LinearColor;
        static StaticClass(): Class;
    }
    
    class MovieSceneTrackLabels {
        constructor();
        constructor(Strings: TArray<string>);
        Strings: TArray<string>;
        static StaticClass(): Class;
    }
    
    class MovieSceneExpansionState {
        constructor();
        constructor(bExpanded: boolean);
        bExpanded: boolean;
        static StaticClass(): Class;
    }
    
    class FloatRangeBound {
        constructor();
        constructor(Type: UE.ERangeBoundTypes, Value: number);
        Type: UE.ERangeBoundTypes;
        Value: number;
        static StaticClass(): Class;
    }
    
    class FloatRange {
        constructor();
        constructor(LowerBound: UE.FloatRangeBound, UpperBound: UE.FloatRangeBound);
        LowerBound: UE.FloatRangeBound;
        UpperBound: UE.FloatRangeBound;
        static StaticClass(): Class;
    }
    
    class MovieSceneEditorData {
        constructor();
        constructor(ExpansionStates: TMap<string, UE.MovieSceneExpansionState>, PinnedNodes: TArray<string>, ViewStart: number, ViewEnd: number, WorkStart: number, WorkEnd: number, MarkedFrames: TSet<UE.FrameNumber>, WorkingRange: UE.FloatRange, ViewRange: UE.FloatRange);
        ExpansionStates: TMap<string, UE.MovieSceneExpansionState>;
        PinnedNodes: TArray<string>;
        ViewStart: number;
        ViewEnd: number;
        WorkStart: number;
        WorkEnd: number;
        MarkedFrames: TSet<UE.FrameNumber>;
        WorkingRange: UE.FloatRange;
        ViewRange: UE.FloatRange;
        static StaticClass(): Class;
    }
    
    class MovieSceneFolder extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FolderName: string;
        ChildFolders: TArray<UE.MovieSceneFolder>;
        ChildMasterTracks: TArray<UE.MovieSceneTrack>;
        ChildObjectBindingStrings: TArray<string>;
        FolderColor: UE.Color;
        SortingOrder: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneFolder;
        static Load(InName: string): MovieSceneFolder;
    }
    
    class MovieSceneSectionEvalOptions {
        constructor();
        constructor(bCanEditCompletionMode: boolean, CompletionMode: UE.EMovieSceneCompletionMode);
        bCanEditCompletionMode: boolean;
        CompletionMode: UE.EMovieSceneCompletionMode;
        static StaticClass(): Class;
    }
    
    class MovieSceneEasingFunction extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnEvaluate(Interp: number) : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEasingFunction;
        static Load(InName: string): MovieSceneEasingFunction;
    }
    
    class MovieSceneEasingSettings {
        constructor();
        constructor(AutoEaseInDuration: number, AutoEaseOutDuration: number, EaseIn: MovieSceneEasingFunction, bManualEaseIn: boolean, ManualEaseInDuration: number, EaseOut: MovieSceneEasingFunction, bManualEaseOut: boolean, ManualEaseOutDuration: number, AutoEaseInTime: number, AutoEaseOutTime: number, ManualEaseInTime: number, ManualEaseOutTime: number);
        AutoEaseInDuration: number;
        AutoEaseOutDuration: number;
        EaseIn: MovieSceneEasingFunction;
        bManualEaseIn: boolean;
        ManualEaseInDuration: number;
        EaseOut: MovieSceneEasingFunction;
        bManualEaseOut: boolean;
        ManualEaseOutDuration: number;
        AutoEaseInTime: number;
        AutoEaseOutTime: number;
        ManualEaseInTime: number;
        ManualEaseOutTime: number;
        static StaticClass(): Class;
    }
    
    enum EMovieSceneBlendType { Invalid, Absolute, Additive, Relative, EMovieSceneBlendType_MAX}
    class OptionalMovieSceneBlendType {
        constructor();
        constructor(BlendType: UE.EMovieSceneBlendType, bIsValid: boolean);
        BlendType: UE.EMovieSceneBlendType;
        bIsValid: boolean;
        static StaticClass(): Class;
    }
    
    class MovieSceneSection extends UE.MovieSceneSignedObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EvalOptions: UE.MovieSceneSectionEvalOptions;
        Easing: UE.MovieSceneEasingSettings;
        SectionRange: UE.MovieSceneFrameRange;
        TimecodeSource: UE.MovieSceneTimecodeSource;
        PreRollFrames: UE.FrameNumber;
        PostRollFrames: UE.FrameNumber;
        RowIndex: number;
        OverlapPriority: number;
        bIsActive: boolean;
        bIsLocked: boolean;
        StartTime: number;
        EndTime: number;
        PreRollTime: number;
        PostRollTime: number;
        bIsInfinite: boolean;
        bSupportsInfiniteRange: boolean;
        BlendType: UE.OptionalMovieSceneBlendType;
        GetBlendType() : UE.OptionalMovieSceneBlendType;
        GetCompletionMode() : UE.EMovieSceneCompletionMode;
        GetOverlapPriority() : number;
        GetPostRollFrames() : number;
        GetPreRollFrames() : number;
        GetRowIndex() : number;
        IsActive() : boolean;
        IsLocked() : boolean;
        SetBlendType(InBlendType: UE.EMovieSceneBlendType) : void;
        SetCompletionMode(InCompletionMode: UE.EMovieSceneCompletionMode) : void;
        SetIsActive(bInIsActive: boolean) : void;
        SetIsLocked(bInIsLocked: boolean) : void;
        SetOverlapPriority(NewPriority: number) : void;
        SetPostRollFrames(InPostRollFrames: number) : void;
        SetPreRollFrames(InPreRollFrames: number) : void;
        SetRowIndex(NewRowIndex: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSection;
        static Load(InName: string): MovieSceneSection;
    }
    
    class MovieSceneSectionGroup {
        constructor();
        constructor(Sections: TArray<TWeakObjectPtr<UE.MovieSceneSection>>);
        Sections: TArray<TWeakObjectPtr<UE.MovieSceneSection>>;
        static StaticClass(): Class;
    }
    
    class MovieScene extends UE.MovieSceneSignedObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TimecodeSource: UE.MovieSceneTimecodeSource;
        Spawnables: TArray<UE.MovieSceneSpawnable>;
        Possessables: TArray<UE.MovieScenePossessable>;
        ObjectBindings: TArray<UE.MovieSceneBinding>;
        BindingGroups: TMap<string, UE.MovieSceneObjectBindingIDs>;
        MasterTracks: TArray<UE.MovieSceneTrack>;
        CameraCutTrack: UE.MovieSceneTrack;
        SelectionRange: UE.MovieSceneFrameRange;
        PlaybackRange: UE.MovieSceneFrameRange;
        TickResolution: UE.FrameRate;
        DisplayRate: UE.FrameRate;
        EvaluationType: UE.EMovieSceneEvaluationType;
        ClockSource: UE.EUpdateClockSource;
        MarkedFrames: TArray<UE.MovieSceneMarkedFrame>;
        bReadOnly: boolean;
        bPlaybackRangeLocked: boolean;
        ObjectsToDisplayNames: TMap<string, string>;
        ObjectsToLabels: TMap<string, UE.MovieSceneTrackLabels>;
        EditorData: UE.MovieSceneEditorData;
        RootFolders: TArray<UE.MovieSceneFolder>;
        SoloNodes: TArray<string>;
        MuteNodes: TArray<string>;
        SectionGroups: TArray<UE.MovieSceneSectionGroup>;
        InTime: number;
        OutTime: number;
        StartTime: number;
        EndTime: number;
        bForceFixedFrameIntervalPlayback: boolean;
        FixedFrameInterval: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene;
        static Load(InName: string): MovieScene;
    }
    
    class WidgetAnimationBinding {
        constructor();
        constructor(WidgetName: string, SlotWidgetName: string, AnimationGuid: UE.Guid, bIsRootWidget: boolean);
        WidgetName: string;
        SlotWidgetName: string;
        AnimationGuid: UE.Guid;
        bIsRootWidget: boolean;
        static StaticClass(): Class;
    }
    
    class WidgetAnimation extends UE.MovieSceneSequence {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnAnimationStarted: $MulticastDelegate<() => void>;
        OnAnimationFinished: $MulticastDelegate<() => void>;
        MovieScene: UE.MovieScene;
        AnimationBindings: TArray<UE.WidgetAnimationBinding>;
        bLegacyFinishOnStop: boolean;
        DisplayLabel: string;
        BindToAnimationFinished(Widget: $Nullable<UE.UserWidget>, Delegate: $Delegate<() => void>) : void;
        BindToAnimationStarted(Widget: $Nullable<UE.UserWidget>, Delegate: $Delegate<() => void>) : void;
        GetEndTime() : number;
        GetStartTime() : number;
        UnbindAllFromAnimationFinished(Widget: $Nullable<UE.UserWidget>) : void;
        UnbindAllFromAnimationStarted(Widget: $Nullable<UE.UserWidget>) : void;
        UnbindFromAnimationFinished(Widget: $Nullable<UE.UserWidget>, Delegate: $Delegate<() => void>) : void;
        UnbindFromAnimationStarted(Widget: $Nullable<UE.UserWidget>, Delegate: $Delegate<() => void>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetAnimation;
        static Load(InName: string): WidgetAnimation;
    }
    
    class UMGSequencePlayer extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Animation: UE.WidgetAnimation;
        GetUserTag() : string;
        SetUserTag(InUserTag: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UMGSequencePlayer;
        static Load(InName: string): UMGSequencePlayer;
    }
    
    class NamedSlotBinding {
        constructor();
        constructor(Name: string, Content: UE.Widget);
        Name: string;
        Content: UE.Widget;
        static StaticClass(): Class;
    }
    
    class WidgetTree extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RootWidget: UE.Widget;
        AllWidgets: TArray<UE.Widget>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetTree;
        static Load(InName: string): WidgetTree;
    }
    
    enum EDesignPreviewSizeMode { FillScreen, Custom, CustomOnScreen, Desired, DesiredOnScreen, EDesignPreviewSizeMode_MAX}
    enum EWidgetTickFrequency { Never, Auto, EWidgetTickFrequency_MAX}
    enum EWidgetAnimationEvent { Started, Finished, EWidgetAnimationEvent_MAX}
    class AnimationEventBinding {
        constructor();
        constructor(Animation: UE.WidgetAnimation, Delegate: $Delegate<() => void>, AnimationEvent: UE.EWidgetAnimationEvent, UserTag: string);
        Animation: UE.WidgetAnimation;
        Delegate: $Delegate<() => void>;
        AnimationEvent: UE.EWidgetAnimationEvent;
        UserTag: string;
        static StaticClass(): Class;
    }
    
    enum EInputEvent { IE_Pressed, IE_Released, IE_Repeat, IE_DoubleClick, IE_Axis, IE_MAX}
    class Anchors {
        constructor();
        constructor(Minimum: UE.Vector2D, Maximum: UE.Vector2D);
        Minimum: UE.Vector2D;
        Maximum: UE.Vector2D;
        static StaticClass(): Class;
    }
    
    enum EUMGSequencePlayMode { Forward, Reverse, PingPong, EUMGSequencePlayMode_MAX}
    class FocusEvent {
        constructor();
        static StaticClass(): Class;
    }
    
    class KeyEvent extends UE.InputEvent {
        constructor();
        static StaticClass(): Class;
    }
    
    class PaintContext {
        constructor();
        static StaticClass(): Class;
    }
    
    class MotionEvent extends UE.InputEvent {
        constructor();
        static StaticClass(): Class;
    }
    
    class CharacterEvent extends UE.InputEvent {
        constructor();
        static StaticClass(): Class;
    }
    
    enum EDragPivot { MouseDown, TopLeft, TopCenter, TopRight, CenterLeft, CenterCenter, CenterRight, BottomLeft, BottomCenter, BottomRight, EDragPivot_MAX}
    class DragDropOperation extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Tag: string;
        Payload: UE.Object;
        DefaultDragVisual: UE.Widget;
        Pivot: UE.EDragPivot;
        Offset: UE.Vector2D;
        OnDrop: $MulticastDelegate<(Operation: $Nullable<UE.DragDropOperation>) => void>;
        OnDragCancelled: $MulticastDelegate<(Operation: $Nullable<UE.DragDropOperation>) => void>;
        OnDragged: $MulticastDelegate<(Operation: $Nullable<UE.DragDropOperation>) => void>;
        DragCancelled(PointerEvent: UE.PointerEvent) : void;
        Dragged(PointerEvent: UE.PointerEvent) : void;
        Drop(PointerEvent: UE.PointerEvent) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DragDropOperation;
        static Load(InName: string): DragDropOperation;
    }
    
    class AnalogInputEvent extends UE.KeyEvent {
        constructor();
        static StaticClass(): Class;
    }
    
    class UserWidget extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ColorAndOpacity: UE.LinearColor;
        ColorAndOpacityDelegate: $Delegate<() => UE.LinearColor>;
        ForegroundColor: UE.SlateColor;
        ForegroundColorDelegate: $Delegate<() => UE.SlateColor>;
        Padding: UE.Margin;
        ActiveSequencePlayers: TArray<UE.UMGSequencePlayer>;
        StoppedSequencePlayers: TArray<UE.UMGSequencePlayer>;
        NamedSlotBindings: TArray<UE.NamedSlotBinding>;
        WidgetTree: UE.WidgetTree;
        DesignTimeSize: UE.Vector2D;
        DesignSizeMode: UE.EDesignPreviewSizeMode;
        PaletteCategory: string;
        PreviewBackground: UE.Texture2D;
        Priority: number;
        bSupportsKeyboardFocus: boolean;
        bIsFocusable: boolean;
        bStopAction: boolean;
        bHasScriptImplementedTick: boolean;
        bHasScriptImplementedPaint: boolean;
        bCookedWidgetTree: boolean;
        TickFrequency: UE.EWidgetTickFrequency;
        InputComponent: UE.InputComponent;
        AnimationCallbacks: TArray<UE.AnimationEventBinding>;
        AddToPlayerScreen(ZOrder?: number /* = 0 */) : boolean;
        AddToViewport(ZOrder?: number /* = 0 */) : void;
        BindToAnimationEvent(Animation: $Nullable<UE.WidgetAnimation>, Delegate: $Delegate<() => void>, AnimationEvent: UE.EWidgetAnimationEvent, UserTag?: string /* = "None" */) : void;
        BindToAnimationFinished(Animation: $Nullable<UE.WidgetAnimation>, Delegate: $Delegate<() => void>) : void;
        BindToAnimationStarted(Animation: $Nullable<UE.WidgetAnimation>, Delegate: $Delegate<() => void>) : void;
        CancelLatentActions() : void;
        Construct() : void;
        Destruct() : void;
        GetAlignmentInViewport() : UE.Vector2D;
        GetAnchorsInViewport() : UE.Anchors;
        GetAnimationCurrentTime(InAnimation: $Nullable<UE.WidgetAnimation>) : number;
        GetIsVisible() : boolean;
        GetOwningPlayerPawn() : UE.Pawn;
        IsAnimationPlaying(InAnimation: $Nullable<UE.WidgetAnimation>) : boolean;
        IsAnimationPlayingForward(InAnimation: $Nullable<UE.WidgetAnimation>) : boolean;
        IsAnyAnimationPlaying() : boolean;
        IsInteractable() : boolean;
        IsInViewport() : boolean;
        IsListeningForInputAction(ActionName: string) : boolean;
        IsPlayingAnimation() : boolean;
        ListenForInputAction(ActionName: string, EventType: UE.EInputEvent, bConsume: boolean, Callback: $Delegate<() => void>) : void;
        OnAddedToFocusPath(InFocusEvent: UE.FocusEvent) : void;
        OnAnalogValueChanged(MyGeometry: UE.Geometry, InAnalogInputEvent: UE.AnalogInputEvent) : UE.EventReply;
        OnAnimationFinished(Animation: $Nullable<UE.WidgetAnimation>) : void;
        OnAnimationStarted(Animation: $Nullable<UE.WidgetAnimation>) : void;
        OnDragCancelled(PointerEvent: UE.PointerEvent, Operation: $Nullable<UE.DragDropOperation>) : void;
        OnDragDetected(MyGeometry: UE.Geometry, PointerEvent: UE.PointerEvent, Operation: $Ref<UE.DragDropOperation>) : void;
        OnDragEnter(MyGeometry: UE.Geometry, PointerEvent: UE.PointerEvent, Operation: $Nullable<UE.DragDropOperation>) : void;
        OnDragLeave(PointerEvent: UE.PointerEvent, Operation: $Nullable<UE.DragDropOperation>) : void;
        OnDragOver(MyGeometry: UE.Geometry, PointerEvent: UE.PointerEvent, Operation: $Nullable<UE.DragDropOperation>) : boolean;
        OnDrop(MyGeometry: UE.Geometry, PointerEvent: UE.PointerEvent, Operation: $Nullable<UE.DragDropOperation>) : boolean;
        OnFocusLost(InFocusEvent: UE.FocusEvent) : void;
        OnFocusReceived(MyGeometry: UE.Geometry, InFocusEvent: UE.FocusEvent) : UE.EventReply;
        OnInitialized() : void;
        OnKeyChar(MyGeometry: UE.Geometry, InCharacterEvent: UE.CharacterEvent) : UE.EventReply;
        OnKeyDown(MyGeometry: UE.Geometry, InKeyEvent: UE.KeyEvent) : UE.EventReply;
        OnKeyUp(MyGeometry: UE.Geometry, InKeyEvent: UE.KeyEvent) : UE.EventReply;
        OnMotionDetected(MyGeometry: UE.Geometry, InMotionEvent: UE.MotionEvent) : UE.EventReply;
        OnMouseButtonDoubleClick(InMyGeometry: UE.Geometry, InMouseEvent: UE.PointerEvent) : UE.EventReply;
        OnMouseButtonDown(MyGeometry: UE.Geometry, MouseEvent: UE.PointerEvent) : UE.EventReply;
        OnMouseButtonUp(MyGeometry: UE.Geometry, MouseEvent: UE.PointerEvent) : UE.EventReply;
        OnMouseCaptureLost() : void;
        OnMouseEnter(MyGeometry: UE.Geometry, MouseEvent: UE.PointerEvent) : void;
        OnMouseLeave(MouseEvent: UE.PointerEvent) : void;
        OnMouseMove(MyGeometry: UE.Geometry, MouseEvent: UE.PointerEvent) : UE.EventReply;
        OnMouseWheel(MyGeometry: UE.Geometry, MouseEvent: UE.PointerEvent) : UE.EventReply;
        OnPaint(Context: $Ref<UE.PaintContext>) : void;
        OnPreviewKeyDown(MyGeometry: UE.Geometry, InKeyEvent: UE.KeyEvent) : UE.EventReply;
        OnPreviewMouseButtonDown(MyGeometry: UE.Geometry, MouseEvent: UE.PointerEvent) : UE.EventReply;
        OnRemovedFromFocusPath(InFocusEvent: UE.FocusEvent) : void;
        OnTouchEnded(MyGeometry: UE.Geometry, InTouchEvent: UE.PointerEvent) : UE.EventReply;
        OnTouchForceChanged(MyGeometry: UE.Geometry, InTouchEvent: UE.PointerEvent) : UE.EventReply;
        OnTouchGesture(MyGeometry: UE.Geometry, GestureEvent: UE.PointerEvent) : UE.EventReply;
        OnTouchMoved(MyGeometry: UE.Geometry, InTouchEvent: UE.PointerEvent) : UE.EventReply;
        OnTouchStarted(MyGeometry: UE.Geometry, InTouchEvent: UE.PointerEvent) : UE.EventReply;
        PauseAnimation(InAnimation: $Nullable<UE.WidgetAnimation>) : number;
        PlayAnimation(InAnimation: $Nullable<UE.WidgetAnimation>, StartAtTime?: number /* = 0.000000 */, NumLoopsToPlay?: number /* = 1 */, PlayMode?: UE.EUMGSequencePlayMode /* = Forward */, PlaybackSpeed?: number /* = 1.000000 */, bRestoreState?: boolean /* = false */) : UE.UMGSequencePlayer;
        PlayAnimationForward(InAnimation: $Nullable<UE.WidgetAnimation>, PlaybackSpeed?: number /* = 1.000000 */, bRestoreState?: boolean /* = false */) : UE.UMGSequencePlayer;
        PlayAnimationReverse(InAnimation: $Nullable<UE.WidgetAnimation>, PlaybackSpeed?: number /* = 1.000000 */, bRestoreState?: boolean /* = false */) : UE.UMGSequencePlayer;
        PlayAnimationTimeRange(InAnimation: $Nullable<UE.WidgetAnimation>, StartAtTime?: number /* = 0.000000 */, EndAtTime?: number /* = 0.000000 */, NumLoopsToPlay?: number /* = 1 */, PlayMode?: UE.EUMGSequencePlayMode /* = Forward */, PlaybackSpeed?: number /* = 1.000000 */, bRestoreState?: boolean /* = false */) : UE.UMGSequencePlayer;
        PlaySound(SoundToPlay: $Nullable<UE.SoundBase>) : void;
        PreConstruct(IsDesignTime: boolean) : void;
        RegisterInputComponent() : void;
        RemoveFromViewport() : void;
        ReverseAnimation(InAnimation: $Nullable<UE.WidgetAnimation>) : void;
        SetAlignmentInViewport(Alignment: UE.Vector2D) : void;
        SetAnchorsInViewport(Anchors: UE.Anchors) : void;
        SetColorAndOpacity(InColorAndOpacity: UE.LinearColor) : void;
        SetDesiredSizeInViewport(Size: UE.Vector2D) : void;
        SetForegroundColor(InForegroundColor: UE.SlateColor) : void;
        SetInputActionBlocking(bShouldBlock: boolean) : void;
        SetInputActionPriority(NewPriority: number) : void;
        SetNumLoopsToPlay(InAnimation: $Nullable<UE.WidgetAnimation>, NumLoopsToPlay: number) : void;
        SetOwningPlayer(LocalPlayerController: $Nullable<UE.PlayerController>) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetPlaybackSpeed(InAnimation: $Nullable<UE.WidgetAnimation>, PlaybackSpeed?: number /* = 1.000000 */) : void;
        SetPositionInViewport(Position: UE.Vector2D, bRemoveDPIScale?: boolean /* = true */) : void;
        StopAllAnimations() : void;
        StopAnimation(InAnimation: $Nullable<UE.WidgetAnimation>) : void;
        StopAnimationsAndLatentActions() : void;
        StopListeningForAllInputActions() : void;
        StopListeningForInputAction(ActionName: string, EventType: UE.EInputEvent) : void;
        Tick(MyGeometry: UE.Geometry, InDeltaTime: number) : void;
        UnbindAllFromAnimationFinished(Animation: $Nullable<UE.WidgetAnimation>) : void;
        UnbindAllFromAnimationStarted(Animation: $Nullable<UE.WidgetAnimation>) : void;
        UnbindFromAnimationFinished(Animation: $Nullable<UE.WidgetAnimation>, Delegate: $Delegate<() => void>) : void;
        UnbindFromAnimationStarted(Animation: $Nullable<UE.WidgetAnimation>, Delegate: $Delegate<() => void>) : void;
        UnregisterInputComponent() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserWidget;
        static Load(InName: string): UserWidget;
    }
    
    class ViewTargetTransitionParams {
        constructor();
        constructor(BlendTime: number, BlendFunction: UE.EViewTargetBlendFunction, BlendExp: number, bLockOutgoing: boolean);
        BlendTime: number;
        BlendFunction: UE.EViewTargetBlendFunction;
        BlendExp: number;
        bLockOutgoing: boolean;
        static StaticClass(): Class;
    }
    
    class UpdateLevelVisibilityLevelInfo {
        constructor();
        constructor(PackageName: string, FileName: string, bIsVisible: boolean);
        PackageName: string;
        FileName: string;
        bIsVisible: boolean;
        static StaticClass(): Class;
    }
    
    class HapticFeedbackEffect_Base extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffect_Base;
        static Load(InName: string): HapticFeedbackEffect_Base;
    }
    
    enum EDynamicForceFeedbackAction { Start, Update, Stop, EDynamicForceFeedbackAction_MAX}
    class LatentActionInfo {
        constructor();
        constructor(Linkage: number, UUID: number, ExecutionFunction: string, CallbackTarget: UE.Object);
        Linkage: number;
        UUID: number;
        ExecutionFunction: string;
        CallbackTarget: UE.Object;
        static StaticClass(): Class;
    }
    
    enum EObjectTypeQuery { ObjectTypeQuery1, ObjectTypeQuery2, ObjectTypeQuery3, ObjectTypeQuery4, ObjectTypeQuery5, ObjectTypeQuery6, ObjectTypeQuery7, ObjectTypeQuery8, ObjectTypeQuery9, ObjectTypeQuery10, ObjectTypeQuery11, ObjectTypeQuery12, ObjectTypeQuery13, ObjectTypeQuery14, ObjectTypeQuery15, ObjectTypeQuery16, ObjectTypeQuery17, ObjectTypeQuery18, ObjectTypeQuery19, ObjectTypeQuery20, ObjectTypeQuery21, ObjectTypeQuery22, ObjectTypeQuery23, ObjectTypeQuery24, ObjectTypeQuery25, ObjectTypeQuery26, ObjectTypeQuery27, ObjectTypeQuery28, ObjectTypeQuery29, ObjectTypeQuery30, ObjectTypeQuery31, ObjectTypeQuery32, ObjectTypeQuery_MAX, EObjectTypeQuery_MAX, WorldStatic = 0, WorldDynamic = 1, Pawn = 2, PhysicsBody = 3, Vehicle = 4, Destructible = 5}
    enum ETraceTypeQuery { TraceTypeQuery1, TraceTypeQuery2, TraceTypeQuery3, TraceTypeQuery4, TraceTypeQuery5, TraceTypeQuery6, TraceTypeQuery7, TraceTypeQuery8, TraceTypeQuery9, TraceTypeQuery10, TraceTypeQuery11, TraceTypeQuery12, TraceTypeQuery13, TraceTypeQuery14, TraceTypeQuery15, TraceTypeQuery16, TraceTypeQuery17, TraceTypeQuery18, TraceTypeQuery19, TraceTypeQuery20, TraceTypeQuery21, TraceTypeQuery22, TraceTypeQuery23, TraceTypeQuery24, TraceTypeQuery25, TraceTypeQuery26, TraceTypeQuery27, TraceTypeQuery28, TraceTypeQuery29, TraceTypeQuery30, TraceTypeQuery31, TraceTypeQuery32, TraceTypeQuery_MAX, ETraceTypeQuery_MAX, Visibility = 0, Camera = 1}
    class UpdateLevelStreamingLevelStatus {
        constructor();
        constructor(PackageName: string, LODIndex: number, bNewShouldBeLoaded: boolean, bNewShouldBeVisible: boolean, bNewShouldBlockOnLoad: boolean);
        PackageName: string;
        LODIndex: number;
        bNewShouldBeLoaded: boolean;
        bNewShouldBeVisible: boolean;
        bNewShouldBlockOnLoad: boolean;
        static StaticClass(): Class;
    }
    
    enum ETravelType { TRAVEL_Absolute, TRAVEL_Partial, TRAVEL_Relative, TRAVEL_MAX}
    class ForceFeedbackParameters {
        constructor();
        constructor(Tag: string, bLooping: boolean, bIgnoreTimeDilation: boolean, bPlayWhilePaused: boolean);
        Tag: string;
        bLooping: boolean;
        bIgnoreTimeDilation: boolean;
        bPlayWhilePaused: boolean;
        static StaticClass(): Class;
    }
    
    class PlayerController extends UE.Controller {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Player: UE.Player;
        AcknowledgedPawn: UE.Pawn;
        ControllingDirTrackInst: UE.InterpTrackInstDirector;
        MyHUD: UE.HUD;
        PlayerCameraManager: UE.PlayerCameraManager;
        PlayerCameraManagerClass: UE.Class;
        bAutoManageActiveCameraTarget: boolean;
        TargetViewRotation: UE.Rotator;
        SmoothTargetViewRotationSpeed: number;
        HiddenActors: TArray<UE.Actor>;
        HiddenPrimitiveComponents: TArray<TWeakObjectPtr<UE.PrimitiveComponent>>;
        LastSpectatorStateSynchTime: number;
        LastSpectatorSyncLocation: UE.Vector;
        LastSpectatorSyncRotation: UE.Rotator;
        ClientCap: number;
        CheatManager: UE.CheatManager;
        CheatClass: UE.Class;
        PlayerInput: UE.PlayerInput;
        ActiveForceFeedbackEffects: TArray<UE.ActiveForceFeedbackEffect>;
        bPlayerIsWaiting: boolean;
        NetPlayerIndex: number;
        PendingSwapConnection: UE.NetConnection;
        NetConnection: UE.NetConnection;
        InputYawScale: number;
        InputPitchScale: number;
        InputRollScale: number;
        bShowMouseCursor: boolean;
        bEnableClickEvents: boolean;
        bEnableTouchEvents: boolean;
        bEnableMouseOverEvents: boolean;
        bEnableTouchOverEvents: boolean;
        bForceFeedbackEnabled: boolean;
        ForceFeedbackScale: number;
        ClickEventKeys: TArray<UE.Key>;
        DefaultMouseCursor: UE.EMouseCursor;
        CurrentMouseCursor: UE.EMouseCursor;
        DefaultClickTraceChannel: UE.ECollisionChannel;
        CurrentClickTraceChannel: UE.ECollisionChannel;
        HitResultTraceDistance: number;
        SeamlessTravelCount: number;
        LastCompletedSeamlessTravelCount: number;
        InactiveStateInputComponent: UE.InputComponent;
        bShouldPerformFullTickWhenPaused: boolean;
        CurrentTouchInterface: UE.TouchInterface;
        SpectatorPawn: UE.SpectatorPawn;
        bIsLocalPlayerController: boolean;
        SpawnLocation: UE.Vector;
        ActivateTouchInterface(NewTouchInterface: $Nullable<UE.TouchInterface>) : void;
        AddPitchInput(Val: number) : void;
        AddRollInput(Val: number) : void;
        AddYawInput(Val: number) : void;
        Camera(NewMode: string) : void;
        CanRestartPlayer() : boolean;
        ClearAudioListenerAttenuationOverride() : void;
        ClearAudioListenerOverride() : void;
        ClientAddTextureStreamingLoc(InLoc: UE.Vector, Duration: number, bOverrideLocation: boolean) : void;
        ClientCancelPendingMapChange() : void;
        ClientCapBandwidth(Cap: number) : void;
        ClientClearCameraLensEffects() : void;
        ClientCommitMapChange() : void;
        ClientEnableNetworkVoice(bEnable: boolean) : void;
        ClientEndOnlineSession() : void;
        ClientFlushLevelStreaming() : void;
        ClientForceGarbageCollection() : void;
        ClientGameEnded(EndGameFocus: $Nullable<UE.Actor>, bIsWinner: boolean) : void;
        ClientGotoState(NewState: string) : void;
        ClientIgnoreLookInput(bIgnore: boolean) : void;
        ClientIgnoreMoveInput(bIgnore: boolean) : void;
        ClientMessage(S: string, Type: string, MsgLifeTime: number) : void;
        ClientMutePlayer(PlayerId: UE.UniqueNetIdRepl) : void;
        ClientPlayCameraAnim(AnimToPlay: $Nullable<UE.CameraAnim>, Scale?: number /* = 1.000000 */, Rate?: number /* = 1.000000 */, BlendInTime?: number /* = 0.000000 */, BlendOutTime?: number /* = 0.000000 */, bLoop?: boolean /* = false */, bRandomStartTime?: boolean /* = false */, Space?: UE.ECameraAnimPlaySpace /* = CameraLocal */, CustomPlaySpace?: UE.Rotator /* =  */) : void;
        ClientPlayCameraShake(Shake: $Nullable<UE.Class>, Scale?: number /* = 1.000000 */, PlaySpace?: UE.ECameraAnimPlaySpace /* = CameraLocal */, UserPlaySpaceRot?: UE.Rotator /* =  */) : void;
        ClientPlayForceFeedback_Internal(ForceFeedbackEffect: $Nullable<UE.ForceFeedbackEffect>, Params: UE.ForceFeedbackParameters) : void;
        ClientPlaySound(Sound: $Nullable<UE.SoundBase>, VolumeMultiplier: number, PitchMultiplier: number) : void;
        ClientPlaySoundAtLocation(Sound: $Nullable<UE.SoundBase>, Location: UE.Vector, VolumeMultiplier: number, PitchMultiplier: number) : void;
        ClientPrepareMapChange(LevelName: string, bFirst: boolean, bLast: boolean) : void;
        ClientPrestreamTextures(ForcedActor: $Nullable<UE.Actor>, ForceDuration: number, bEnableStreaming: boolean, CinematicTextureGroups: number) : void;
        ClientReceiveLocalizedMessage(Message: $Nullable<UE.Class>, Switch: number, RelatedPlayerState_1: $Nullable<UE.PlayerState>, RelatedPlayerState_2: $Nullable<UE.PlayerState>, OptionalObject: $Nullable<UE.Object>) : void;
        ClientRepObjRef(Object: $Nullable<UE.Object>) : void;
        ClientReset() : void;
        ClientRestart(NewPawn: $Nullable<UE.Pawn>) : void;
        ClientRetryClientRestart(NewPawn: $Nullable<UE.Pawn>) : void;
        ClientReturnToMainMenu(ReturnReason: string) : void;
        ClientReturnToMainMenuWithTextReason(ReturnReason: string) : void;
        ClientSetBlockOnAsyncLoading() : void;
        ClientSetCameraFade(bEnableFading: boolean, FadeColor: UE.Color, FadeAlpha: UE.Vector2D, FadeTime: number, bFadeAudio: boolean) : void;
        ClientSetCameraMode(NewCamMode: string) : void;
        ClientSetCinematicMode(bInCinematicMode: boolean, bAffectsMovement: boolean, bAffectsTurning: boolean, bAffectsHUD: boolean) : void;
        ClientSetForceMipLevelsToBeResident(Material: $Nullable<UE.MaterialInterface>, ForceDuration: number, CinematicTextureGroups: number) : void;
        ClientSetHUD(NewHUDClass: $Nullable<UE.Class>) : void;
        ClientSetSpectatorWaiting(bWaiting: boolean) : void;
        ClientSetViewTarget(A: $Nullable<UE.Actor>, TransitionParams: UE.ViewTargetTransitionParams) : void;
        ClientSpawnCameraLensEffect(LensEffectEmitterClass: $Nullable<UE.Class>) : void;
        ClientStartOnlineSession() : void;
        ClientStopCameraAnim(AnimToStop: $Nullable<UE.CameraAnim>) : void;
        ClientStopCameraShake(Shake: $Nullable<UE.Class>, bImmediately?: boolean /* = true */) : void;
        ClientStopForceFeedback(ForceFeedbackEffect: $Nullable<UE.ForceFeedbackEffect>, Tag: string) : void;
        ClientTeamMessage(SenderPlayerState: $Nullable<UE.PlayerState>, S: string, Type: string, MsgLifeTime: number) : void;
        ClientTravel(URL: string, TravelType: UE.ETravelType, bSeamless: boolean, MapPackageGuid: UE.Guid) : void;
        ClientTravelInternal(URL: string, TravelType: UE.ETravelType, bSeamless: boolean, MapPackageGuid: UE.Guid) : void;
        ClientUnmutePlayer(PlayerId: UE.UniqueNetIdRepl) : void;
        ClientUpdateLevelStreamingStatus(PackageName: string, bNewShouldBeLoaded: boolean, bNewShouldBeVisible: boolean, bNewShouldBlockOnLoad: boolean, LODIndex: number) : void;
        ClientUpdateMultipleLevelsStreamingStatus(LevelStatuses: TArray<UE.UpdateLevelStreamingLevelStatus>) : void;
        ClientVoiceHandshakeComplete() : void;
        ClientWasKicked(KickReason: string) : void;
        ConsoleKey(Key: UE.Key) : void;
        DeprojectMousePositionToWorld(WorldLocation: $Ref<UE.Vector>, WorldDirection: $Ref<UE.Vector>) : boolean;
        DeprojectScreenPositionToWorld(ScreenX: number, ScreenY: number, WorldLocation: $Ref<UE.Vector>, WorldDirection: $Ref<UE.Vector>) : boolean;
        EnableCheats() : void;
        FOV(NewFOV: number) : void;
        GetFocalLocation() : UE.Vector;
        GetHitResultUnderCursor(TraceChannel: UE.ECollisionChannel, bTraceComplex: boolean, HitResult: $Ref<UE.HitResult>) : boolean;
        GetHitResultUnderCursorByChannel(TraceChannel: UE.ETraceTypeQuery, bTraceComplex: boolean, HitResult: $Ref<UE.HitResult>) : boolean;
        GetHitResultUnderCursorForObjects(ObjectTypes: TArray<UE.EObjectTypeQuery>, bTraceComplex: boolean, HitResult: $Ref<UE.HitResult>) : boolean;
        GetHitResultUnderFinger(FingerIndex: UE.ETouchIndex, TraceChannel: UE.ECollisionChannel, bTraceComplex: boolean, HitResult: $Ref<UE.HitResult>) : boolean;
        GetHitResultUnderFingerByChannel(FingerIndex: UE.ETouchIndex, TraceChannel: UE.ETraceTypeQuery, bTraceComplex: boolean, HitResult: $Ref<UE.HitResult>) : boolean;
        GetHitResultUnderFingerForObjects(FingerIndex: UE.ETouchIndex, ObjectTypes: TArray<UE.EObjectTypeQuery>, bTraceComplex: boolean, HitResult: $Ref<UE.HitResult>) : boolean;
        GetHUD() : UE.HUD;
        GetInputAnalogKeyState(Key: UE.Key) : number;
        GetInputAnalogStickState(WhichStick: UE.EControllerAnalogStick, StickX: $Ref<number>, StickY: $Ref<number>) : void;
        GetInputKeyTimeDown(Key: UE.Key) : number;
        GetInputMotionState(Tilt: $Ref<UE.Vector>, RotationRate: $Ref<UE.Vector>, Gravity: $Ref<UE.Vector>, Acceleration: $Ref<UE.Vector>) : void;
        GetInputMouseDelta(DeltaX: $Ref<number>, DeltaY: $Ref<number>) : void;
        GetInputTouchState(FingerIndex: UE.ETouchIndex, LocationX: $Ref<number>, LocationY: $Ref<number>, bIsCurrentlyPressed: $Ref<boolean>) : void;
        GetInputVectorKeyState(Key: UE.Key) : UE.Vector;
        GetMousePosition(LocationX: $Ref<number>, LocationY: $Ref<number>) : boolean;
        GetSpectatorPawn() : UE.SpectatorPawn;
        GetViewportSize(SizeX: $Ref<number>, SizeY: $Ref<number>) : void;
        IsInputKeyDown(Key: UE.Key) : boolean;
        K2_ClientPlayForceFeedback(ForceFeedbackEffect: $Nullable<UE.ForceFeedbackEffect>, Tag: string, bLooping: boolean, bIgnoreTimeDilation: boolean, bPlayWhilePaused: boolean) : void;
        LocalTravel(URL: string) : void;
        OnServerStartedVisualLogger(bIsLogging: boolean) : void;
        Pause() : void;
        PlayDynamicForceFeedback(Intensity: number, Duration: number, bAffectsLeftLarge: boolean, bAffectsLeftSmall: boolean, bAffectsRightLarge: boolean, bAffectsRightSmall: boolean, Action: UE.EDynamicForceFeedbackAction, LatentInfo: UE.LatentActionInfo) : void;
        PlayHapticEffect(HapticEffect: $Nullable<UE.HapticFeedbackEffect_Base>, Hand: UE.EControllerHand, Scale?: number /* = 1.000000 */, bLoop?: boolean /* = false */) : void;
        ProjectWorldLocationToScreen(WorldLocation: UE.Vector, ScreenLocation: $Ref<UE.Vector2D>, bPlayerViewportRelative?: boolean /* = false */) : boolean;
        ResetControllerLightColor() : void;
        RestartLevel() : void;
        SendToConsole(Command: string) : void;
        ServerAcknowledgePossession(P: $Nullable<UE.Pawn>) : void;
        ServerCamera(NewMode: string) : void;
        ServerChangeName(S: string) : void;
        ServerCheckClientPossession() : void;
        ServerCheckClientPossessionReliable() : void;
        ServerExec(Msg: string) : void;
        ServerExecRPC(Msg: string) : void;
        ServerMutePlayer(PlayerId: UE.UniqueNetIdRepl) : void;
        ServerNotifyLoadedWorld(WorldPackageName: string) : void;
        ServerPause() : void;
        ServerRestartPlayer() : void;
        ServerSetSpectatorLocation(NewLoc: UE.Vector, NewRot: UE.Rotator) : void;
        ServerSetSpectatorWaiting(bWaiting: boolean) : void;
        ServerShortTimeout() : void;
        ServerToggleAILogging() : void;
        ServerUnmutePlayer(PlayerId: UE.UniqueNetIdRepl) : void;
        ServerUpdateCamera(CamLoc: UE.Vector_NetQuantize, CamPitchAndYaw: number) : void;
        ServerUpdateLevelVisibility(LevelVisibility: UE.UpdateLevelVisibilityLevelInfo) : void;
        ServerUpdateMultipleLevelsVisibility(LevelVisibilities: TArray<UE.UpdateLevelVisibilityLevelInfo>) : void;
        ServerVerifyViewTarget() : void;
        ServerViewNextPlayer() : void;
        ServerViewPrevPlayer() : void;
        ServerViewSelf(TransitionParams: UE.ViewTargetTransitionParams) : void;
        SetAudioListenerAttenuationOverride(AttachToComponent: $Nullable<UE.SceneComponent>, AttenuationLocationOVerride: UE.Vector) : void;
        SetAudioListenerOverride(AttachToComponent: $Nullable<UE.SceneComponent>, Location: UE.Vector, Rotation: UE.Rotator) : void;
        SetCinematicMode(bInCinematicMode: boolean, bHidePlayer: boolean, bAffectsHUD: boolean, bAffectsMovement: boolean, bAffectsTurning: boolean) : void;
        SetControllerLightColor(Color: UE.Color) : void;
        SetDisableHaptics(bNewDisabled: boolean) : void;
        SetHapticsByValue(Frequency: number, Amplitude: number, Hand: UE.EControllerHand) : void;
        SetMouseCursorWidget(Cursor: UE.EMouseCursor, CursorWidget: $Nullable<UE.UserWidget>) : void;
        SetMouseLocation(X: number, Y: number) : void;
        SetName(S: string) : void;
        SetViewTargetWithBlend(NewViewTarget: $Nullable<UE.Actor>, BlendTime?: number /* = 0.000000 */, BlendFunc?: UE.EViewTargetBlendFunction /* = VTBlend_Linear */, BlendExp?: number /* = 0.000000 */, bLockOutgoing?: boolean /* = false */) : void;
        SetVirtualJoystickVisibility(bVisible: boolean) : void;
        StartFire(FireModeNum?: number /* = 0 */) : void;
        StopHapticEffect(Hand: UE.EControllerHand) : void;
        SwitchLevel(URL: string) : void;
        TestServerLevelVisibilityChange(PackageName: string, FileName: string) : void;
        ToggleSpeaking(bInSpeaking: boolean) : void;
        WasInputKeyJustPressed(Key: UE.Key) : boolean;
        WasInputKeyJustReleased(Key: UE.Key) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlayerController;
        static Load(InName: string): PlayerController;
    }
    
    class Controller extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlayerState: UE.PlayerState;
        OnInstigatedAnyDamage: $MulticastDelegate<(Damage: number, DamageType: $Nullable<UE.DamageType>, DamagedActor: $Nullable<UE.Actor>, DamageCauser: $Nullable<UE.Actor>) => void>;
        StateName: string;
        Pawn: UE.Pawn;
        Character: UE.Character;
        TransformComponent: UE.SceneComponent;
        ControlRotation: UE.Rotator;
        bAttachToPawn: boolean;
        CastToPlayerController() : UE.PlayerController;
        ClientSetLocation(NewLocation: UE.Vector, NewRotation: UE.Rotator) : void;
        ClientSetRotation(NewRotation: UE.Rotator, bResetCamera: boolean) : void;
        GetControlRotation() : UE.Rotator;
        GetDesiredRotation() : UE.Rotator;
        GetViewTarget() : UE.Actor;
        IsLocalController() : boolean;
        IsLocalPlayerController() : boolean;
        IsLookInputIgnored() : boolean;
        IsMoveInputIgnored() : boolean;
        IsPlayerController() : boolean;
        K2_GetPawn() : UE.Pawn;
        LineOfSightTo(Other: $Nullable<UE.Actor>, ViewPoint?: UE.Vector /* =  */, bAlternateChecks?: boolean /* = false */) : boolean;
        OnRep_Pawn() : void;
        OnRep_PlayerState() : void;
        Possess(InPawn: $Nullable<UE.Pawn>) : void;
        ReceiveInstigatedAnyDamage(Damage: number, DamageType: $Nullable<UE.DamageType>, DamagedActor: $Nullable<UE.Actor>, DamageCauser: $Nullable<UE.Actor>) : void;
        ReceivePossess(PossessedPawn: $Nullable<UE.Pawn>) : void;
        ReceiveUnPossess(UnpossessedPawn: $Nullable<UE.Pawn>) : void;
        ResetIgnoreInputFlags() : void;
        ResetIgnoreLookInput() : void;
        ResetIgnoreMoveInput() : void;
        SetControlRotation(NewRotation: UE.Rotator) : void;
        SetIgnoreLookInput(bNewLookInput: boolean) : void;
        SetIgnoreMoveInput(bNewMoveInput: boolean) : void;
        SetInitialLocationAndRotation(NewLocation: UE.Vector, NewRotation: UE.Rotator) : void;
        StopMovement() : void;
        UnPossess() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Controller;
        static Load(InName: string): Controller;
    }
    
    class Pawn extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseControllerRotationPitch: boolean;
        bUseControllerRotationYaw: boolean;
        bUseControllerRotationRoll: boolean;
        bCanAffectNavigationGeneration: boolean;
        BaseEyeHeight: number;
        AutoPossessPlayer: UE.EAutoReceiveInput;
        AutoPossessAI: UE.EAutoPossessAI;
        RemoteViewPitch: number;
        AIControllerClass: UE.Class;
        PlayerState: UE.PlayerState;
        LastHitBy: UE.Controller;
        Controller: UE.Controller;
        ControlInputVector: UE.Vector;
        LastControlInputVector: UE.Vector;
        AddControllerPitchInput(Val: number) : void;
        AddControllerRollInput(Val: number) : void;
        AddControllerYawInput(Val: number) : void;
        AddMovementInput(WorldDirection: UE.Vector, ScaleValue?: number /* = 1.000000 */, bForce?: boolean /* = false */) : void;
        ConsumeMovementInputVector() : UE.Vector;
        DetachFromControllerPendingDestroy() : void;
        GetBaseAimRotation() : UE.Rotator;
        GetController() : UE.Controller;
        GetControlRotation() : UE.Rotator;
        GetLastMovementInputVector() : UE.Vector;
        GetMovementComponent() : UE.PawnMovementComponent;
        GetNavAgentLocation() : UE.Vector;
        GetPendingMovementInputVector() : UE.Vector;
        IsBotControlled() : boolean;
        IsControlled() : boolean;
        IsLocallyControlled() : boolean;
        IsMoveInputIgnored() : boolean;
        IsPawnControlled() : boolean;
        IsPlayerControlled() : boolean;
        K2_GetMovementInputVector() : UE.Vector;
        LaunchPawn(LaunchVelocity: UE.Vector, bXYOverride: boolean, bZOverride: boolean) : void;
        OnRep_Controller() : void;
        OnRep_PlayerState() : void;
        PawnMakeNoise(Loudness: number, NoiseLocation: UE.Vector, bUseNoiseMakerLocation?: boolean /* = true */, NoiseMaker?: UE.Actor /* = None */) : void;
        ReceivePossessed(NewController: $Nullable<UE.Controller>) : void;
        ReceiveUnpossessed(OldController: $Nullable<UE.Controller>) : void;
        SetCanAffectNavigationGeneration(bNewValue: boolean, bForceUpdate?: boolean /* = false */) : void;
        SpawnDefaultController() : void;
        static GetMovementBaseActor(Pawn: $Nullable<UE.Pawn>) : UE.Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Pawn;
        static Load(InName: string): Pawn;
    }
    
    enum ERadialImpulseFalloff { RIF_Constant, RIF_Linear, RIF_MAX}
    class PrimitiveComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MinDrawDistance: number;
        LDMaxDrawDistance: number;
        CachedMaxDrawDistance: number;
        DepthPriorityGroup: UE.ESceneDepthPriorityGroup;
        ViewOwnerDepthPriorityGroup: UE.ESceneDepthPriorityGroup;
        IndirectLightingCacheQuality: UE.EIndirectLightingCacheQuality;
        LightmapType: UE.ELightmapType;
        ExcludeForSpecificHLODLevels: TArray<number>;
        bEnableAutoLODGeneration: boolean;
        bUseMaxLODAsImposter: boolean;
        bBatchImpostersAsInstances: boolean;
        bNeverDistanceCull: boolean;
        bAlwaysCreatePhysicsState: boolean;
        bGenerateOverlapEvents: boolean;
        bMultiBodyOverlap: boolean;
        bTraceComplexOnMove: boolean;
        bReturnMaterialOnMove: boolean;
        bUseViewOwnerDepthPriorityGroup: boolean;
        bAllowCullDistanceVolume: boolean;
        bHasMotionBlurVelocityMeshes: boolean;
        bVisibleInReflectionCaptures: boolean;
        bVisibleInRayTracing: boolean;
        bRenderInMainPass: boolean;
        bRenderInDepthPass: boolean;
        bReceivesDecals: boolean;
        bOwnerNoSee: boolean;
        bOnlyOwnerSee: boolean;
        bTreatAsBackgroundForOcclusion: boolean;
        bUseAsOccluder: boolean;
        bSelectable: boolean;
        bForceMipStreaming: boolean;
        bHasPerInstanceHitProxies: boolean;
        CastShadow: boolean;
        bAffectDynamicIndirectLighting: boolean;
        bAffectDistanceFieldLighting: boolean;
        bCastDynamicShadow: boolean;
        bCastStaticShadow: boolean;
        bCastVolumetricTranslucentShadow: boolean;
        bSelfShadowOnly: boolean;
        bCastFarShadow: boolean;
        bCastInsetShadow: boolean;
        bCastCinematicShadow: boolean;
        bCastHiddenShadow: boolean;
        bCastShadowAsTwoSided: boolean;
        bLightAsIfStatic: boolean;
        bLightAttachmentsAsGroup: boolean;
        bExcludeFromLightAttachmentGroup: boolean;
        bReceiveMobileCSMShadows: boolean;
        bSingleSampleShadowFromStationaryLights: boolean;
        bIgnoreRadialImpulse: boolean;
        bIgnoreRadialForce: boolean;
        bApplyImpulseOnDamage: boolean;
        bReplicatePhysicsToAutonomousProxy: boolean;
        AlwaysLoadOnClient: boolean;
        AlwaysLoadOnServer: boolean;
        bUseEditorCompositing: boolean;
        bRenderCustomDepth: boolean;
        bHasCustomNavigableGeometry: UE.EHasCustomNavigableGeometry;
        CanBeCharacterBase: UE.ECanBeCharacterBase;
        CanCharacterStepUpOn: UE.ECanBeCharacterBase;
        LightingChannels: UE.LightingChannels;
        CustomDepthStencilWriteMask: UE.ERendererStencilMask;
        CustomDepthStencilValue: number;
        CustomPrimitiveData: UE.CustomPrimitiveData;
        TranslucencySortPriority: number;
        VisibilityId: number;
        RuntimeVirtualTextures: TArray<UE.RuntimeVirtualTexture>;
        VirtualTextureLodBias: number;
        VirtualTextureCullMips: number;
        VirtualTextureMinCoverage: number;
        VirtualTextureRenderPassType: UE.ERuntimeVirtualTextureMainPassType;
        LpvBiasMultiplier: number;
        BoundsScale: number;
        MoveIgnoreActors: TArray<UE.Actor>;
        MoveIgnoreComponents: TArray<UE.PrimitiveComponent>;
        BodyInstance: UE.BodyInstance;
        OnComponentHit: $MulticastDelegate<(HitComponent: $Nullable<UE.PrimitiveComponent>, OtherActor: $Nullable<UE.Actor>, OtherComp: $Nullable<UE.PrimitiveComponent>, NormalImpulse: UE.Vector, Hit: UE.HitResult) => void>;
        OnComponentBeginOverlap: $MulticastDelegate<(OverlappedComponent: $Nullable<UE.PrimitiveComponent>, OtherActor: $Nullable<UE.Actor>, OtherComp: $Nullable<UE.PrimitiveComponent>, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: UE.HitResult) => void>;
        OnComponentEndOverlap: $MulticastDelegate<(OverlappedComponent: $Nullable<UE.PrimitiveComponent>, OtherActor: $Nullable<UE.Actor>, OtherComp: $Nullable<UE.PrimitiveComponent>, OtherBodyIndex: number) => void>;
        OnComponentWake: $MulticastDelegate<(WakingComponent: $Nullable<UE.PrimitiveComponent>, BoneName: string) => void>;
        OnComponentSleep: $MulticastDelegate<(SleepingComponent: $Nullable<UE.PrimitiveComponent>, BoneName: string) => void>;
        OnBeginCursorOver: $MulticastDelegate<(TouchedComponent: $Nullable<UE.PrimitiveComponent>) => void>;
        OnEndCursorOver: $MulticastDelegate<(TouchedComponent: $Nullable<UE.PrimitiveComponent>) => void>;
        OnClicked: $MulticastDelegate<(TouchedComponent: $Nullable<UE.PrimitiveComponent>, ButtonPressed: UE.Key) => void>;
        OnReleased: $MulticastDelegate<(TouchedComponent: $Nullable<UE.PrimitiveComponent>, ButtonReleased: UE.Key) => void>;
        OnInputTouchBegin: $MulticastDelegate<(FingerIndex: UE.ETouchIndex, TouchedComponent: $Nullable<UE.PrimitiveComponent>) => void>;
        OnInputTouchEnd: $MulticastDelegate<(FingerIndex: UE.ETouchIndex, TouchedComponent: $Nullable<UE.PrimitiveComponent>) => void>;
        OnInputTouchEnter: $MulticastDelegate<(FingerIndex: UE.ETouchIndex, TouchedComponent: $Nullable<UE.PrimitiveComponent>) => void>;
        OnInputTouchLeave: $MulticastDelegate<(FingerIndex: UE.ETouchIndex, TouchedComponent: $Nullable<UE.PrimitiveComponent>) => void>;
        LODParentPrimitive: UE.PrimitiveComponent;
        AddAngularImpulse(Impulse: UE.Vector, BoneName?: string /* = "None" */, bVelChange?: boolean /* = false */) : void;
        AddAngularImpulseInDegrees(Impulse: UE.Vector, BoneName?: string /* = "None" */, bVelChange?: boolean /* = false */) : void;
        AddAngularImpulseInRadians(Impulse: UE.Vector, BoneName?: string /* = "None" */, bVelChange?: boolean /* = false */) : void;
        AddForce(Force: UE.Vector, BoneName?: string /* = "None" */, bAccelChange?: boolean /* = false */) : void;
        AddForceAtLocation(Force: UE.Vector, Location: UE.Vector, BoneName?: string /* = "None" */) : void;
        AddForceAtLocationLocal(Force: UE.Vector, Location: UE.Vector, BoneName?: string /* = "None" */) : void;
        AddImpulse(Impulse: UE.Vector, BoneName?: string /* = "None" */, bVelChange?: boolean /* = false */) : void;
        AddImpulseAtLocation(Impulse: UE.Vector, Location: UE.Vector, BoneName?: string /* = "None" */) : void;
        AddRadialForce(Origin: UE.Vector, Radius: number, Strength: number, Falloff: UE.ERadialImpulseFalloff, bAccelChange?: boolean /* = false */) : void;
        AddRadialImpulse(Origin: UE.Vector, Radius: number, Strength: number, Falloff: UE.ERadialImpulseFalloff, bVelChange?: boolean /* = false */) : void;
        AddTorque(Torque: UE.Vector, BoneName?: string /* = "None" */, bAccelChange?: boolean /* = false */) : void;
        AddTorqueInDegrees(Torque: UE.Vector, BoneName?: string /* = "None" */, bAccelChange?: boolean /* = false */) : void;
        AddTorqueInRadians(Torque: UE.Vector, BoneName?: string /* = "None" */, bAccelChange?: boolean /* = false */) : void;
        CanCharacterStepUp(Pawn: $Nullable<UE.Pawn>) : boolean;
        ClearMoveIgnoreActors() : void;
        ClearMoveIgnoreComponents() : void;
        CopyArrayOfMoveIgnoreActors() : TArray<UE.Actor>;
        CopyArrayOfMoveIgnoreComponents() : TArray<UE.PrimitiveComponent>;
        CreateAndSetMaterialInstanceDynamic(ElementIndex: number) : UE.MaterialInstanceDynamic;
        CreateAndSetMaterialInstanceDynamicFromMaterial(ElementIndex: number, Parent: $Nullable<UE.MaterialInterface>) : UE.MaterialInstanceDynamic;
        CreateDynamicMaterialInstance(ElementIndex: number, SourceMaterial?: UE.MaterialInterface /* = None */, OptionalName?: string /* = "None" */) : UE.MaterialInstanceDynamic;
        GetAngularDamping() : number;
        GetCenterOfMass(BoneName?: string /* = "None" */) : UE.Vector;
        GetClosestPointOnCollision(Point: UE.Vector, OutPointOnBody: $Ref<UE.Vector>, BoneName?: string /* = "None" */) : number;
        GetCollisionEnabled() : UE.ECollisionEnabled;
        GetCollisionObjectType() : UE.ECollisionChannel;
        GetCollisionProfileName() : string;
        GetCollisionResponseToChannel(Channel: UE.ECollisionChannel) : UE.ECollisionResponse;
        GetGenerateOverlapEvents() : boolean;
        GetInertiaTensor(BoneName?: string /* = "None" */) : UE.Vector;
        GetLinearDamping() : number;
        GetMass() : number;
        GetMassScale(BoneName?: string /* = "None" */) : number;
        GetMaterial(ElementIndex: number) : UE.MaterialInterface;
        GetMaterialFromCollisionFaceIndex(FaceIndex: number, SectionIndex: $Ref<number>) : UE.MaterialInterface;
        GetNumMaterials() : number;
        GetOverlappingActors(OverlappingActors: $Ref<TArray<UE.Actor>>, ClassFilter?: UE.Class /* = None */) : void;
        GetOverlappingComponents(OutOverlappingComponents: $Ref<TArray<UE.PrimitiveComponent>>) : void;
        GetPhysicsAngularVelocity(BoneName?: string /* = "None" */) : UE.Vector;
        GetPhysicsAngularVelocityInDegrees(BoneName?: string /* = "None" */) : UE.Vector;
        GetPhysicsAngularVelocityInRadians(BoneName?: string /* = "None" */) : UE.Vector;
        GetPhysicsLinearVelocity(BoneName?: string /* = "None" */) : UE.Vector;
        GetPhysicsLinearVelocityAtPoint(Point: UE.Vector, BoneName?: string /* = "None" */) : UE.Vector;
        GetWalkableSlopeOverride() : UE.WalkableSlopeOverride;
        IgnoreActorWhenMoving(Actor: $Nullable<UE.Actor>, bShouldIgnore: boolean) : void;
        IgnoreComponentWhenMoving(Component: $Nullable<UE.PrimitiveComponent>, bShouldIgnore: boolean) : void;
        IsAnyRigidBodyAwake() : boolean;
        IsGravityEnabled() : boolean;
        IsOverlappingActor(Other: $Nullable<UE.Actor>) : boolean;
        IsOverlappingComponent(OtherComp: $Nullable<UE.PrimitiveComponent>) : boolean;
        K2_BoxOverlapComponent(InBoxCentre: UE.Vector, InBox: UE.Box, bTraceComplex: boolean, bShowTrace: boolean, bPersistentShowTrace: boolean, HitLocation: $Ref<UE.Vector>, HitNormal: $Ref<UE.Vector>, BoneName: $Ref<string>, OutHit: $Ref<UE.HitResult>) : boolean;
        K2_IsCollisionEnabled() : boolean;
        K2_IsPhysicsCollisionEnabled() : boolean;
        K2_IsQueryCollisionEnabled() : boolean;
        K2_LineTraceComponent(TraceStart: UE.Vector, TraceEnd: UE.Vector, bTraceComplex: boolean, bShowTrace: boolean, bPersistentShowTrace: boolean, HitLocation: $Ref<UE.Vector>, HitNormal: $Ref<UE.Vector>, BoneName: $Ref<string>, OutHit: $Ref<UE.HitResult>) : boolean;
        K2_SphereOverlapComponent(InSphereCentre: UE.Vector, InSphereRadius: number, bTraceComplex: boolean, bShowTrace: boolean, bPersistentShowTrace: boolean, HitLocation: $Ref<UE.Vector>, HitNormal: $Ref<UE.Vector>, BoneName: $Ref<string>, OutHit: $Ref<UE.HitResult>) : boolean;
        K2_SphereTraceComponent(TraceStart: UE.Vector, TraceEnd: UE.Vector, SphereRadius: number, bTraceComplex: boolean, bShowTrace: boolean, bPersistentShowTrace: boolean, HitLocation: $Ref<UE.Vector>, HitNormal: $Ref<UE.Vector>, BoneName: $Ref<string>, OutHit: $Ref<UE.HitResult>) : boolean;
        PutRigidBodyToSleep(BoneName?: string /* = "None" */) : void;
        ScaleByMomentOfInertia(InputVector: UE.Vector, BoneName?: string /* = "None" */) : UE.Vector;
        SetAllMassScale(InMassScale?: number /* = 1.000000 */) : void;
        SetAllPhysicsAngularVelocityInDegrees(NewAngVel: UE.Vector, bAddToCurrent?: boolean /* = false */) : void;
        SetAllPhysicsAngularVelocityInRadians(NewAngVel: UE.Vector, bAddToCurrent?: boolean /* = false */) : void;
        SetAllPhysicsLinearVelocity(NewVel: UE.Vector, bAddToCurrent?: boolean /* = false */) : void;
        SetAllUseCCD(InUseCCD: boolean) : void;
        SetAngularDamping(InDamping: number) : void;
        SetBoundsScale(NewBoundsScale?: number /* = 1.000000 */) : void;
        SetCastInsetShadow(bInCastInsetShadow: boolean) : void;
        SetCastShadow(NewCastShadow: boolean) : void;
        SetCenterOfMass(CenterOfMassOffset: UE.Vector, BoneName?: string /* = "None" */) : void;
        SetCollisionEnabled(NewType: UE.ECollisionEnabled) : void;
        SetCollisionObjectType(Channel: UE.ECollisionChannel) : void;
        SetCollisionProfileName(InCollisionProfileName: string) : void;
        SetCollisionResponseToAllChannels(NewResponse: UE.ECollisionResponse) : void;
        SetCollisionResponseToChannel(Channel: UE.ECollisionChannel, NewResponse: UE.ECollisionResponse) : void;
        SetConstraintMode(ConstraintMode: UE.EDOFMode) : void;
        SetCullDistance(NewCullDistance: number) : void;
        SetCustomDepthStencilValue(Value: number) : void;
        SetCustomDepthStencilWriteMask(WriteMaskBit: UE.ERendererStencilMask) : void;
        SetCustomPrimitiveDataFloat(DataIndex: number, Value: number) : void;
        SetCustomPrimitiveDataVector2(DataIndex: number, Value: UE.Vector2D) : void;
        SetCustomPrimitiveDataVector3(DataIndex: number, Value: UE.Vector) : void;
        SetCustomPrimitiveDataVector4(DataIndex: number, Value: UE.Vector4) : void;
        SetEnableGravity(bGravityEnabled: boolean) : void;
        SetExcludeFromLightAttachmentGroup(bInExcludeFromLightAttachmentGroup: boolean) : void;
        SetGenerateOverlapEvents(bInGenerateOverlapEvents: boolean) : void;
        SetLightAttachmentsAsGroup(bInLightAttachmentsAsGroup: boolean) : void;
        SetLinearDamping(InDamping: number) : void;
        SetMassOverrideInKg(BoneName?: string /* = "None" */, MassInKg?: number /* = 1.000000 */, bOverrideMass?: boolean /* = true */) : void;
        SetMassScale(BoneName?: string /* = "None" */, InMassScale?: number /* = 1.000000 */) : void;
        SetMaterial(ElementIndex: number, Material: $Nullable<UE.MaterialInterface>) : void;
        SetMaterialByName(MaterialSlotName: string, Material: $Nullable<UE.MaterialInterface>) : void;
        SetNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision: boolean) : void;
        SetOnlyOwnerSee(bNewOnlyOwnerSee: boolean) : void;
        SetOwnerNoSee(bNewOwnerNoSee: boolean) : void;
        SetPhysicsAngularVelocity(NewAngVel: UE.Vector, bAddToCurrent?: boolean /* = false */, BoneName?: string /* = "None" */) : void;
        SetPhysicsAngularVelocityInDegrees(NewAngVel: UE.Vector, bAddToCurrent?: boolean /* = false */, BoneName?: string /* = "None" */) : void;
        SetPhysicsAngularVelocityInRadians(NewAngVel: UE.Vector, bAddToCurrent?: boolean /* = false */, BoneName?: string /* = "None" */) : void;
        SetPhysicsLinearVelocity(NewVel: UE.Vector, bAddToCurrent?: boolean /* = false */, BoneName?: string /* = "None" */) : void;
        SetPhysicsMaxAngularVelocity(NewMaxAngVel: number, bAddToCurrent?: boolean /* = false */, BoneName?: string /* = "None" */) : void;
        SetPhysicsMaxAngularVelocityInDegrees(NewMaxAngVel: number, bAddToCurrent?: boolean /* = false */, BoneName?: string /* = "None" */) : void;
        SetPhysicsMaxAngularVelocityInRadians(NewMaxAngVel: number, bAddToCurrent?: boolean /* = false */, BoneName?: string /* = "None" */) : void;
        SetPhysMaterialOverride(NewPhysMaterial: $Nullable<UE.PhysicalMaterial>) : void;
        SetReceivesDecals(bNewReceivesDecals: boolean) : void;
        SetRenderCustomDepth(bValue: boolean) : void;
        SetRenderInMainPass(bValue: boolean) : void;
        SetSimulatePhysics(bSimulate: boolean) : void;
        SetSingleSampleShadowFromStationaryLights(bNewSingleSampleShadowFromStationaryLights: boolean) : void;
        SetTranslucentSortPriority(NewTranslucentSortPriority: number) : void;
        SetUseCCD(InUseCCD: boolean, BoneName?: string /* = "None" */) : void;
        SetWalkableSlopeOverride(NewOverride: UE.WalkableSlopeOverride) : void;
        WakeAllRigidBodies() : void;
        WakeRigidBody(BoneName?: string /* = "None" */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PrimitiveComponent;
        static Load(InName: string): PrimitiveComponent;
    }
    
    class BrushComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Brush: UE.Model;
        BrushBodySetup: UE.BodySetup;
        PrePivot: UE.Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BrushComponent;
        static Load(InName: string): BrushComponent;
    }
    
    class BuilderPoly {
        constructor();
        constructor(VertexIndices: TArray<number>, Direction: number, ItemName: string, PolyFlags: number);
        VertexIndices: TArray<number>;
        Direction: number;
        ItemName: string;
        PolyFlags: number;
        static StaticClass(): Class;
    }
    
    class BrushBuilder extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BitmapFilename: string;
        ToolTip: string;
        NotifyBadParams: boolean;
        Vertices: TArray<UE.Vector>;
        Polys: TArray<UE.BuilderPoly>;
        Layer: string;
        MergeCoplanars: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BrushBuilder;
        static Load(InName: string): BrushBuilder;
    }
    
    class GeomSelection {
        constructor();
        constructor(Type: number, Index: number, SelectionIndex: number);
        Type: number;
        Index: number;
        SelectionIndex: number;
        static StaticClass(): Class;
    }
    
    class Brush extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BrushType: UE.EBrushType;
        BrushColor: UE.Color;
        PolyFlags: number;
        bColored: boolean;
        bSolidWhenSelected: boolean;
        bPlaceableFromClassBrowser: boolean;
        bNotForClientOrServer: boolean;
        Brush: UE.Model;
        BrushComponent: UE.BrushComponent;
        BrushBuilder: UE.BrushBuilder;
        bInManipulation: boolean;
        SavedSelections: TArray<UE.GeomSelection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Brush;
        static Load(InName: string): Brush;
    }
    
    class Volume extends UE.Brush {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Volume;
        static Load(InName: string): Volume;
    }
    
    class PhysicsVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TerminalVelocity: number;
        Priority: number;
        FluidFriction: number;
        bWaterVolume: boolean;
        bPhysicsOnContact: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsVolume;
        static Load(InName: string): PhysicsVolume;
    }
    
    enum EComponentMobility { Static, Stationary, Movable, EComponentMobility_MAX}
    enum EDetachmentRule { KeepRelative, KeepWorld, EDetachmentRule_MAX}
    enum ERelativeTransformSpace { RTS_World, RTS_Actor, RTS_Component, RTS_ParentBoneSpace, RTS_MAX}
    class SceneComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysicsVolume: TWeakObjectPtr<UE.PhysicsVolume>;
        AttachParent: UE.SceneComponent;
        AttachSocketName: string;
        AttachChildren: TArray<UE.SceneComponent>;
        ClientAttachedChildren: TArray<UE.SceneComponent>;
        RelativeLocation: UE.Vector;
        RelativeRotation: UE.Rotator;
        RelativeScale3D: UE.Vector;
        ComponentVelocity: UE.Vector;
        bComponentToWorldUpdated: boolean;
        bAbsoluteLocation: boolean;
        bAbsoluteRotation: boolean;
        bAbsoluteScale: boolean;
        bVisible: boolean;
        bHiddenInGame: boolean;
        bShouldBeAttached: boolean;
        bShouldSnapLocationWhenAttached: boolean;
        bShouldSnapRotationWhenAttached: boolean;
        bShouldUpdatePhysicsVolume: boolean;
        bBoundsChangeTriggersStreamingDataRebuild: boolean;
        bUseAttachParentBound: boolean;
        bVisualizeComponent: boolean;
        Mobility: UE.EComponentMobility;
        DetailMode: UE.EDetailMode;
        PhysicsVolumeChangedDelegate: $MulticastDelegate<(NewVolume: $Nullable<UE.PhysicsVolume>) => void>;
        DetachFromParent(bMaintainWorldPosition?: boolean /* = false */, bCallModify?: boolean /* = true */) : void;
        DoesSocketExist(InSocketName: string) : boolean;
        GetAllSocketNames() : TArray<string>;
        GetAttachParent() : UE.SceneComponent;
        GetAttachSocketName() : string;
        GetChildComponent(ChildIndex: number) : UE.SceneComponent;
        GetChildrenComponents(bIncludeAllDescendants: boolean, Children: $Ref<TArray<UE.SceneComponent>>) : void;
        GetComponentVelocity() : UE.Vector;
        GetForwardVector() : UE.Vector;
        GetNumChildrenComponents() : number;
        GetParentComponents(Parents: $Ref<TArray<UE.SceneComponent>>) : void;
        GetPhysicsVolume() : UE.PhysicsVolume;
        GetRelativeTransform() : UE.Transform;
        GetRightVector() : UE.Vector;
        GetShouldUpdatePhysicsVolume() : boolean;
        GetSocketLocation(InSocketName: string) : UE.Vector;
        GetSocketQuaternion(InSocketName: string) : UE.Quat;
        GetSocketRotation(InSocketName: string) : UE.Rotator;
        GetSocketTransform(InSocketName: string, TransformSpace?: UE.ERelativeTransformSpace /* = RTS_World */) : UE.Transform;
        GetUpVector() : UE.Vector;
        IsAnySimulatingPhysics() : boolean;
        IsSimulatingPhysics(BoneName?: string /* = "None" */) : boolean;
        IsVisible() : boolean;
        K2_AddLocalOffset(DeltaLocation: UE.Vector, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_AddLocalRotation(DeltaRotation: UE.Rotator, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_AddLocalTransform(DeltaTransform: UE.Transform, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_AddRelativeLocation(DeltaLocation: UE.Vector, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_AddRelativeRotation(DeltaRotation: UE.Rotator, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_AddWorldOffset(DeltaLocation: UE.Vector, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_AddWorldRotation(DeltaRotation: UE.Rotator, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_AddWorldTransform(DeltaTransform: UE.Transform, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_AttachTo(InParent: $Nullable<UE.SceneComponent>, InSocketName?: string /* = "None" */, AttachType?: UE.EAttachLocation /* = KeepRelativeOffset */, bWeldSimulatedBodies?: boolean /* = true */) : boolean;
        K2_AttachToComponent(Parent: $Nullable<UE.SceneComponent>, SocketName: string, LocationRule: UE.EAttachmentRule, RotationRule: UE.EAttachmentRule, ScaleRule: UE.EAttachmentRule, bWeldSimulatedBodies: boolean) : boolean;
        K2_DetachFromComponent(LocationRule?: UE.EDetachmentRule /* = KeepRelative */, RotationRule?: UE.EDetachmentRule /* = KeepRelative */, ScaleRule?: UE.EDetachmentRule /* = KeepRelative */, bCallModify?: boolean /* = true */) : void;
        K2_GetComponentLocation() : UE.Vector;
        K2_GetComponentRotation() : UE.Rotator;
        K2_GetComponentScale() : UE.Vector;
        K2_GetComponentToWorld() : UE.Transform;
        K2_SetRelativeLocation(NewLocation: UE.Vector, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_SetRelativeLocationAndRotation(NewLocation: UE.Vector, NewRotation: UE.Rotator, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_SetRelativeRotation(NewRotation: UE.Rotator, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_SetRelativeTransform(NewTransform: UE.Transform, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_SetWorldLocation(NewLocation: UE.Vector, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_SetWorldLocationAndRotation(NewLocation: UE.Vector, NewRotation: UE.Rotator, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_SetWorldRotation(NewRotation: UE.Rotator, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_SetWorldTransform(NewTransform: UE.Transform, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        OnRep_AttachChildren() : void;
        OnRep_AttachParent() : void;
        OnRep_AttachSocketName() : void;
        OnRep_Transform() : void;
        OnRep_Visibility(OldValue: boolean) : void;
        ResetRelativeTransform() : void;
        SetAbsolute(bNewAbsoluteLocation?: boolean /* = false */, bNewAbsoluteRotation?: boolean /* = false */, bNewAbsoluteScale?: boolean /* = false */) : void;
        SetHiddenInGame(NewHidden: boolean, bPropagateToChildren?: boolean /* = false */) : void;
        SetMobility(NewMobility: UE.EComponentMobility) : void;
        SetRelativeScale3D(NewScale3D: UE.Vector) : void;
        SetShouldUpdatePhysicsVolume(bInShouldUpdatePhysicsVolume: boolean) : void;
        SetupAttachment(p0: $Nullable<SceneComponent>, p1: string) : void;
        SetVisibility(bNewVisibility: boolean, bPropagateToChildren?: boolean /* = false */) : void;
        SetWorldScale3D(NewScale: UE.Vector) : void;
        SnapTo(InParent: $Nullable<UE.SceneComponent>, InSocketName?: string /* = "None" */) : boolean;
        ToggleVisibility(bPropagateToChildren?: boolean /* = false */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneComponent;
        static Load(InName: string): SceneComponent;
    }
    
    class RepAttachment {
        constructor();
        constructor(AttachParent: UE.Actor, LocationOffset: UE.Vector_NetQuantize100, RelativeScale3D: UE.Vector_NetQuantize100, RotationOffset: UE.Rotator, AttachSocket: string, AttachComponent: UE.SceneComponent);
        AttachParent: UE.Actor;
        LocationOffset: UE.Vector_NetQuantize100;
        RelativeScale3D: UE.Vector_NetQuantize100;
        RotationOffset: UE.Rotator;
        AttachSocket: string;
        AttachComponent: UE.SceneComponent;
        static StaticClass(): Class;
    }
    
    enum ENetDormancy { DORM_Never, DORM_Awake, DORM_DormantAll, DORM_DormantPartial, DORM_Initial, DORM_MAX}
    class InterpFilter extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Caption: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpFilter;
        static Load(InName: string): InterpFilter;
    }
    
    class InterpGroupDirector extends UE.InterpGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpGroupDirector;
        static Load(InName: string): InterpGroupDirector;
    }
    
    class InterpData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InterpLength: number;
        PathBuildTime: number;
        InterpGroups: TArray<UE.InterpGroup>;
        CurveEdSetup: UE.InterpCurveEdSetup;
        InterpFilters: TArray<UE.InterpFilter>;
        SelectedFilter: UE.InterpFilter;
        DefaultFilters: TArray<UE.InterpFilter>;
        EdSectionStart: number;
        EdSectionEnd: number;
        bShouldBakeAndPrune: boolean;
        CachedDirectorGroup: UE.InterpGroupDirector;
        AllEventNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpData;
        static Load(InName: string): InterpData;
    }
    
    class InterpGroupActorInfo {
        constructor();
        constructor(ObjectName: string, Actors: TArray<UE.Actor>);
        ObjectName: string;
        Actors: TArray<UE.Actor>;
        static StaticClass(): Class;
    }
    
    class CameraCutInfo {
        constructor();
        constructor(Location: UE.Vector, TimeStamp: number);
        Location: UE.Vector;
        TimeStamp: number;
        static StaticClass(): Class;
    }
    
    class MatineeActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MatineeData: UE.InterpData;
        MatineeControllerName: string;
        PlayRate: number;
        bPlayOnLevelLoad: boolean;
        bForceStartPos: boolean;
        ForceStartPosition: number;
        bLooping: boolean;
        bRewindOnPlay: boolean;
        bNoResetOnRewind: boolean;
        bRewindIfAlreadyPlaying: boolean;
        bDisableRadioFilter: boolean;
        bClientSideOnly: boolean;
        bSkipUpdateIfNotVisible: boolean;
        bIsSkippable: boolean;
        PreferredSplitScreenNum: number;
        bDisableMovementInput: boolean;
        bDisableLookAtInput: boolean;
        bHidePlayer: boolean;
        bHideHud: boolean;
        GroupActorInfos: TArray<UE.InterpGroupActorInfo>;
        bShouldShowGore: boolean;
        GroupInst: TArray<UE.InterpGroupInst>;
        CameraCuts: TArray<UE.CameraCutInfo>;
        SpriteComponent: UE.BillboardComponent;
        bIsBeingEdited: boolean;
        bIsScrubbing: boolean;
        bIsPlaying: boolean;
        bReversePlayback: boolean;
        bPaused: boolean;
        bPendingStop: boolean;
        InterpPosition: number;
        ReplicationForceIsPlaying: number;
        OnPlay: $MulticastDelegate<() => void>;
        OnStop: $MulticastDelegate<() => void>;
        OnPause: $MulticastDelegate<() => void>;
        ChangePlaybackDirection() : void;
        EnableGroupByName(GroupName: string, bEnable: boolean) : void;
        Pause() : void;
        Play() : void;
        Reverse() : void;
        SetLoopingState(bNewLooping: boolean) : void;
        SetPosition(NewPosition: number, bJump?: boolean /* = false */) : void;
        Stop() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MatineeActor;
        static Load(InName: string): MatineeActor;
    }
    
    class ChildActorComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChildActorClass: UE.Class;
        ChildActor: UE.Actor;
        ChildActorTemplate: UE.Actor;
        SetChildActorClass(InClass: $Nullable<UE.Class>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChildActorComponent;
        static Load(InName: string): ChildActorComponent;
    }
    
    class Actor extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PrimaryActorTick: UE.ActorTickFunction;
        bHidden: boolean;
        bNetTemporary: boolean;
        bNetStartup: boolean;
        bOnlyRelevantToOwner: boolean;
        bAlwaysRelevant: boolean;
        bReplicateMovement: boolean;
        bTearOff: boolean;
        bExchangedRoles: boolean;
        bNetLoadOnClient: boolean;
        bNetUseOwnerRelevancy: boolean;
        bRelevantForNetworkReplays: boolean;
        bRelevantForLevelBounds: boolean;
        bReplayRewindable: boolean;
        bAllowTickBeforeBeginPlay: boolean;
        bAutoDestroyWhenFinished: boolean;
        bBlockInput: boolean;
        bCanBeDamaged: boolean;
        bCollideWhenPlacing: boolean;
        bFindCameraComponentWhenViewTarget: boolean;
        bGenerateOverlapEventsDuringLevelStreaming: boolean;
        bIgnoresOriginShifting: boolean;
        bEnableAutoLODGeneration: boolean;
        bIsEditorOnlyActor: boolean;
        bActorSeamlessTraveled: boolean;
        bReplicates: boolean;
        bCanBeInCluster: boolean;
        bAllowReceiveTickEventOnDedicatedServer: boolean;
        bActorEnableCollision: boolean;
        bActorIsBeingDestroyed: boolean;
        UpdateOverlapsMethodDuringLevelStreaming: UE.EActorUpdateOverlapsMethod;
        DefaultUpdateOverlapsMethodDuringLevelStreaming: UE.EActorUpdateOverlapsMethod;
        RemoteRole: UE.ENetRole;
        ReplicatedMovement: UE.RepMovement;
        InitialLifeSpan: number;
        CustomTimeDilation: number;
        AttachmentReplication: UE.RepAttachment;
        Owner: UE.Actor;
        NetDriverName: string;
        Role: UE.ENetRole;
        NetDormancy: UE.ENetDormancy;
        SpawnCollisionHandlingMethod: UE.ESpawnActorCollisionHandlingMethod;
        AutoReceiveInput: UE.EAutoReceiveInput;
        InputPriority: number;
        InputComponent: UE.InputComponent;
        NetCullDistanceSquared: number;
        NetTag: number;
        NetUpdateFrequency: number;
        MinNetUpdateFrequency: number;
        NetPriority: number;
        Instigator: UE.Pawn;
        Children: TArray<UE.Actor>;
        RootComponent: UE.SceneComponent;
        PivotOffset: UE.Vector;
        ControllingMatineeActors: TArray<UE.MatineeActor>;
        Layers: TArray<string>;
        ParentComponentActor: TWeakObjectPtr<UE.Actor>;
        ParentComponent: TWeakObjectPtr<UE.ChildActorComponent>;
        GroupActor: UE.Actor;
        SpriteScale: number;
        HiddenEditorViews: bigint;
        ActorLabel: string;
        FolderPath: string;
        bHiddenEd: boolean;
        bIsEditorPreviewActor: boolean;
        bHiddenEdLayer: boolean;
        bHiddenEdLevel: boolean;
        bLockLocation: boolean;
        bActorLabelEditable: boolean;
        bEditable: boolean;
        bListedInSceneOutliner: boolean;
        bOptimizeBPComponentData: boolean;
        bHiddenEdTemporary: boolean;
        Tags: TArray<string>;
        OnTakeAnyDamage: $MulticastDelegate<(DamagedActor: $Nullable<UE.Actor>, Damage: number, DamageType: $Nullable<UE.DamageType>, InstigatedBy: $Nullable<UE.Controller>, DamageCauser: $Nullable<UE.Actor>) => void>;
        OnTakePointDamage: $MulticastDelegate<(DamagedActor: $Nullable<UE.Actor>, Damage: number, InstigatedBy: $Nullable<UE.Controller>, HitLocation: UE.Vector, FHitComponent: $Nullable<UE.PrimitiveComponent>, BoneName: string, ShotFromDirection: UE.Vector, DamageType: $Nullable<UE.DamageType>, DamageCauser: $Nullable<UE.Actor>) => void>;
        OnTakeRadialDamage: $MulticastDelegate<(DamagedActor: $Nullable<UE.Actor>, Damage: number, DamageType: $Nullable<UE.DamageType>, Origin: UE.Vector, HitInfo: UE.HitResult, InstigatedBy: $Nullable<UE.Controller>, DamageCauser: $Nullable<UE.Actor>) => void>;
        OnActorBeginOverlap: $MulticastDelegate<(OverlappedActor: $Nullable<UE.Actor>, OtherActor: $Nullable<UE.Actor>) => void>;
        OnActorEndOverlap: $MulticastDelegate<(OverlappedActor: $Nullable<UE.Actor>, OtherActor: $Nullable<UE.Actor>) => void>;
        OnBeginCursorOver: $MulticastDelegate<(TouchedActor: $Nullable<UE.Actor>) => void>;
        OnEndCursorOver: $MulticastDelegate<(TouchedActor: $Nullable<UE.Actor>) => void>;
        OnClicked: $MulticastDelegate<(TouchedActor: $Nullable<UE.Actor>, ButtonPressed: UE.Key) => void>;
        OnReleased: $MulticastDelegate<(TouchedActor: $Nullable<UE.Actor>, ButtonReleased: UE.Key) => void>;
        OnInputTouchBegin: $MulticastDelegate<(FingerIndex: UE.ETouchIndex, TouchedActor: $Nullable<UE.Actor>) => void>;
        OnInputTouchEnd: $MulticastDelegate<(FingerIndex: UE.ETouchIndex, TouchedActor: $Nullable<UE.Actor>) => void>;
        OnInputTouchEnter: $MulticastDelegate<(FingerIndex: UE.ETouchIndex, TouchedActor: $Nullable<UE.Actor>) => void>;
        OnInputTouchLeave: $MulticastDelegate<(FingerIndex: UE.ETouchIndex, TouchedActor: $Nullable<UE.Actor>) => void>;
        OnActorHit: $MulticastDelegate<(SelfActor: $Nullable<UE.Actor>, OtherActor: $Nullable<UE.Actor>, NormalImpulse: UE.Vector, Hit: UE.HitResult) => void>;
        OnDestroyed: $MulticastDelegate<(DestroyedActor: $Nullable<UE.Actor>) => void>;
        OnEndPlay: $MulticastDelegate<(Actor: $Nullable<UE.Actor>, EndPlayReason: UE.EEndPlayReason) => void>;
        InstanceComponents: TArray<UE.ActorComponent>;
        BlueprintCreatedComponents: TArray<UE.ActorComponent>;
        ActorHasTag(Tag: string) : boolean;
        AddComponent(TemplateName: string, bManualAttachment: boolean, RelativeTransform: UE.Transform, ComponentTemplateContext: $Nullable<UE.Object>) : UE.ActorComponent;
        AddTickPrerequisiteActor(PrerequisiteActor: $Nullable<UE.Actor>) : void;
        AddTickPrerequisiteComponent(PrerequisiteComponent: $Nullable<UE.ActorComponent>) : void;
        DetachRootComponentFromParent(bMaintainWorldPosition?: boolean /* = true */) : void;
        DisableInput(PlayerController: $Nullable<UE.PlayerController>) : void;
        EnableInput(PlayerController: $Nullable<UE.PlayerController>) : void;
        FlushNetDormancy() : void;
        ForceNetUpdate() : void;
        GetActorBounds(bOnlyCollidingComponents: boolean, Origin: $Ref<UE.Vector>, BoxExtent: $Ref<UE.Vector>) : void;
        GetActorEnableCollision() : boolean;
        GetActorEyesViewPoint(OutLocation: $Ref<UE.Vector>, OutRotation: $Ref<UE.Rotator>) : void;
        GetActorForwardVector() : UE.Vector;
        GetActorLabel() : string;
        GetActorRelativeScale3D() : UE.Vector;
        GetActorRightVector() : UE.Vector;
        GetActorScale3D() : UE.Vector;
        GetActorTickInterval() : number;
        GetActorTimeDilation() : number;
        GetActorUpVector() : UE.Vector;
        GetAllChildActors(ChildActors: $Ref<TArray<UE.Actor>>, bIncludeDescendants?: boolean /* = true */) : void;
        GetAttachedActors(OutActors: $Ref<TArray<UE.Actor>>, bResetArray?: boolean /* = true */) : void;
        GetAttachParentActor() : UE.Actor;
        GetAttachParentSocketName() : string;
        GetComponentByClass(ComponentClass: $Nullable<UE.Class>) : UE.ActorComponent;
        GetComponentsByInterface(Interface: $Nullable<UE.Class>) : TArray<UE.ActorComponent>;
        GetComponentsByTag(ComponentClass: $Nullable<UE.Class>, Tag: string) : TArray<UE.ActorComponent>;
        GetDistanceTo(OtherActor: $Nullable<UE.Actor>) : number;
        GetDotProductTo(OtherActor: $Nullable<UE.Actor>) : number;
        GetFolderPath() : string;
        GetGameTimeSinceCreation() : number;
        GetHorizontalDistanceTo(OtherActor: $Nullable<UE.Actor>) : number;
        GetHorizontalDotProductTo(OtherActor: $Nullable<UE.Actor>) : number;
        GetInputAxisKeyValue(InputAxisKey: UE.Key) : number;
        GetInputAxisValue(InputAxisName: string) : number;
        GetInputVectorAxisValue(InputAxisKey: UE.Key) : UE.Vector;
        GetInstigator() : UE.Pawn;
        GetInstigatorController() : UE.Controller;
        GetLifeSpan() : number;
        GetLocalRole() : UE.ENetRole;
        GetOverlappingActors(OverlappingActors: $Ref<TArray<UE.Actor>>, ClassFilter?: UE.Class /* = None */) : void;
        GetOverlappingComponents(OverlappingComponents: $Ref<TArray<UE.PrimitiveComponent>>) : void;
        GetOwner() : UE.Actor;
        GetParentActor() : UE.Actor;
        GetParentComponent() : UE.ChildActorComponent;
        GetRemoteRole() : UE.ENetRole;
        GetSquaredDistanceTo(OtherActor: $Nullable<UE.Actor>) : number;
        GetTickableWhenPaused() : boolean;
        GetTransform() : UE.Transform;
        GetVelocity() : UE.Vector;
        GetVerticalDistanceTo(OtherActor: $Nullable<UE.Actor>) : number;
        HasAuthority() : boolean;
        IsActorBeingDestroyed() : boolean;
        IsActorTickEnabled() : boolean;
        IsChildActor() : boolean;
        IsEditable() : boolean;
        IsHiddenEd() : boolean;
        IsHiddenEdAtStartup() : boolean;
        IsOverlappingActor(Other: $Nullable<UE.Actor>) : boolean;
        IsSelectable() : boolean;
        IsTemporarilyHiddenInEditor(bIncludeParent?: boolean /* = false */) : boolean;
        K2_AddActorLocalOffset(DeltaLocation: UE.Vector, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_AddActorLocalRotation(DeltaRotation: UE.Rotator, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_AddActorLocalTransform(NewTransform: UE.Transform, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_AddActorWorldOffset(DeltaLocation: UE.Vector, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_AddActorWorldRotation(DeltaRotation: UE.Rotator, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_AddActorWorldTransform(DeltaTransform: UE.Transform, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_AttachRootComponentTo(InParent: $Nullable<UE.SceneComponent>, InSocketName?: string /* = "None" */, AttachLocationType?: UE.EAttachLocation /* = KeepRelativeOffset */, bWeldSimulatedBodies?: boolean /* = true */) : void;
        K2_AttachRootComponentToActor(InParentActor: $Nullable<UE.Actor>, InSocketName?: string /* = "None" */, AttachLocationType?: UE.EAttachLocation /* = KeepRelativeOffset */, bWeldSimulatedBodies?: boolean /* = true */) : void;
        K2_AttachToActor(ParentActor: $Nullable<UE.Actor>, SocketName: string, LocationRule: UE.EAttachmentRule, RotationRule: UE.EAttachmentRule, ScaleRule: UE.EAttachmentRule, bWeldSimulatedBodies: boolean) : void;
        K2_AttachToComponent(Parent: $Nullable<UE.SceneComponent>, SocketName: string, LocationRule: UE.EAttachmentRule, RotationRule: UE.EAttachmentRule, ScaleRule: UE.EAttachmentRule, bWeldSimulatedBodies: boolean) : void;
        K2_DestroyActor() : void;
        K2_DestroyComponent(Component: $Nullable<UE.ActorComponent>) : void;
        K2_DetachFromActor(LocationRule?: UE.EDetachmentRule /* = KeepRelative */, RotationRule?: UE.EDetachmentRule /* = KeepRelative */, ScaleRule?: UE.EDetachmentRule /* = KeepRelative */) : void;
        K2_GetActorLocation() : UE.Vector;
        K2_GetActorRotation() : UE.Rotator;
        K2_GetComponentsByClass(ComponentClass: $Nullable<UE.Class>) : TArray<UE.ActorComponent>;
        K2_GetRootComponent() : UE.SceneComponent;
        K2_OnBecomeViewTarget(PC: $Nullable<UE.PlayerController>) : void;
        K2_OnEndViewTarget(PC: $Nullable<UE.PlayerController>) : void;
        K2_OnReset() : void;
        K2_SetActorLocation(NewLocation: UE.Vector, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : boolean;
        K2_SetActorLocationAndRotation(NewLocation: UE.Vector, NewRotation: UE.Rotator, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : boolean;
        K2_SetActorRelativeLocation(NewRelativeLocation: UE.Vector, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_SetActorRelativeRotation(NewRelativeRotation: UE.Rotator, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_SetActorRelativeTransform(NewRelativeTransform: UE.Transform, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : void;
        K2_SetActorRotation(NewRotation: UE.Rotator, bTeleportPhysics: boolean) : boolean;
        K2_SetActorTransform(NewTransform: UE.Transform, bSweep: boolean, SweepHitResult: $Ref<UE.HitResult>, bTeleport: boolean) : boolean;
        K2_TeleportTo(DestLocation: UE.Vector, DestRotation: UE.Rotator) : boolean;
        MakeMIDForMaterial(Parent: $Nullable<UE.MaterialInterface>) : UE.MaterialInstanceDynamic;
        MakeNoise(Loudness?: number /* = 1.000000 */, NoiseInstigator?: UE.Pawn /* = None */, NoiseLocation?: UE.Vector /* =  */, MaxRange?: number /* = 0.000000 */, Tag?: string /* = "None" */) : void;
        OnRep_AttachmentReplication() : void;
        OnRep_Instigator() : void;
        OnRep_Owner() : void;
        OnRep_ReplicatedMovement() : void;
        OnRep_ReplicateMovement() : void;
        PrestreamTextures(Seconds: number, bEnableStreaming: boolean, CinematicTextureGroups?: number /* = 0 */) : void;
        ReceiveActorBeginCursorOver() : void;
        ReceiveActorBeginOverlap(OtherActor: $Nullable<UE.Actor>) : void;
        ReceiveActorEndCursorOver() : void;
        ReceiveActorEndOverlap(OtherActor: $Nullable<UE.Actor>) : void;
        ReceiveActorOnClicked(ButtonPressed: UE.Key) : void;
        ReceiveActorOnInputTouchBegin(FingerIndex: UE.ETouchIndex) : void;
        ReceiveActorOnInputTouchEnd(FingerIndex: UE.ETouchIndex) : void;
        ReceiveActorOnInputTouchEnter(FingerIndex: UE.ETouchIndex) : void;
        ReceiveActorOnInputTouchLeave(FingerIndex: UE.ETouchIndex) : void;
        ReceiveActorOnReleased(ButtonReleased: UE.Key) : void;
        ReceiveAnyDamage(Damage: number, DamageType: $Nullable<UE.DamageType>, InstigatedBy: $Nullable<UE.Controller>, DamageCauser: $Nullable<UE.Actor>) : void;
        ReceiveBeginPlay() : void;
        ReceiveDestroyed() : void;
        ReceiveEndPlay(EndPlayReason: UE.EEndPlayReason) : void;
        ReceiveHit(MyComp: $Nullable<UE.PrimitiveComponent>, Other: $Nullable<UE.Actor>, OtherComp: $Nullable<UE.PrimitiveComponent>, bSelfMoved: boolean, HitLocation: UE.Vector, HitNormal: UE.Vector, NormalImpulse: UE.Vector, Hit: UE.HitResult) : void;
        ReceivePointDamage(Damage: number, DamageType: $Nullable<UE.DamageType>, HitLocation: UE.Vector, HitNormal: UE.Vector, HitComponent: $Nullable<UE.PrimitiveComponent>, BoneName: string, ShotFromDirection: UE.Vector, InstigatedBy: $Nullable<UE.Controller>, DamageCauser: $Nullable<UE.Actor>, HitInfo: UE.HitResult) : void;
        ReceiveRadialDamage(DamageReceived: number, DamageType: $Nullable<UE.DamageType>, Origin: UE.Vector, HitInfo: UE.HitResult, InstigatedBy: $Nullable<UE.Controller>, DamageCauser: $Nullable<UE.Actor>) : void;
        ReceiveTick(DeltaSeconds: number) : void;
        RemoveTickPrerequisiteActor(PrerequisiteActor: $Nullable<UE.Actor>) : void;
        RemoveTickPrerequisiteComponent(PrerequisiteComponent: $Nullable<UE.ActorComponent>) : void;
        SetActorEnableCollision(bNewActorEnableCollision: boolean) : void;
        SetActorHiddenInGame(bNewHidden: boolean) : void;
        SetActorLabel(NewActorLabel: string, bMarkDirty?: boolean /* = true */) : void;
        SetActorRelativeScale3D(NewRelativeScale: UE.Vector) : void;
        SetActorScale3D(NewScale3D: UE.Vector) : void;
        SetActorTickEnabled(bEnabled: boolean) : void;
        SetActorTickInterval(TickInterval: number) : void;
        SetFolderPath(NewFolderPath: string) : void;
        SetIsTemporarilyHiddenInEditor(bIsHidden: boolean) : void;
        SetLifeSpan(InLifespan: number) : void;
        SetNetDormancy(NewDormancy: UE.ENetDormancy) : void;
        SetOwner(NewOwner: $Nullable<UE.Actor>) : void;
        SetReplicateMovement(bInReplicateMovement: boolean) : void;
        SetReplicates(bInReplicates: boolean) : void;
        SetTickableWhenPaused(bTickableWhenPaused: boolean) : void;
        SetTickGroup(NewTickGroup: UE.ETickingGroup) : void;
        SnapRootComponentTo(InParentActor: $Nullable<UE.Actor>, InSocketName: string) : void;
        TearOff() : void;
        UserConstructionScript() : void;
        WasRecentlyRendered(Tolerance?: number /* = 0.200000 */) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Actor;
        static Load(InName: string): Actor;
    }
    
    class NavDataConfig extends UE.NavAgentProperties {
        constructor();
        constructor(Name: string, Color: UE.Color, DefaultQueryExtent: UE.Vector, NavigationDataClass: UE.Class, NavDataClass: TSoftClassPtr<UE.Actor>);
        Name: string;
        Color: UE.Color;
        DefaultQueryExtent: UE.Vector;
        NavigationDataClass: UE.Class;
        NavDataClass: TSoftClassPtr<UE.Actor>;
        static StaticClass(): Class;
    }
    
    enum ERuntimeGenerationType { Static, DynamicModifiersOnly, Dynamic, LegacyGeneration, ERuntimeGenerationType_MAX}
    class SupportedAreaData {
        constructor();
        constructor(AreaClassName: string, AreaID: number, AreaClass: UE.Class);
        AreaClassName: string;
        AreaID: number;
        AreaClass: UE.Class;
        static StaticClass(): Class;
    }
    
    class NavigationData extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenderingComp: UE.PrimitiveComponent;
        NavDataConfig: UE.NavDataConfig;
        bEnableDrawing: boolean;
        bForceRebuildOnLoad: boolean;
        bAutoDestroyWhenNoNavigation: boolean;
        bCanBeMainNavData: boolean;
        bCanSpawnOnRebuild: boolean;
        bRebuildAtRuntime: boolean;
        RuntimeGeneration: UE.ERuntimeGenerationType;
        ObservedPathsTickInterval: number;
        DataVersion: number;
        SupportedAreas: TArray<UE.SupportedAreaData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationData;
        static Load(InName: string): NavigationData;
    }
    
    class AbstractNavData extends UE.NavigationData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AbstractNavData;
        static Load(InName: string): AbstractNavData;
    }
    
    class BlueprintFunctionLibrary extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintFunctionLibrary;
        static Load(InName: string): BlueprintFunctionLibrary;
    }
    
    class AchievementBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetCachedAchievementDescription(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>, AchievementID: string, bFoundID: $Ref<boolean>, Title: $Ref<string>, LockedDescription: $Ref<string>, UnlockedDescription: $Ref<string>, bHidden: $Ref<boolean>) : void;
        static GetCachedAchievementProgress(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>, AchievementID: string, bFoundID: $Ref<boolean>, Progress: $Ref<number>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AchievementBlueprintLibrary;
        static Load(InName: string): AchievementBlueprintLibrary;
    }
    
    class OnlineBlueprintCallProxyBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Activate() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineBlueprintCallProxyBase;
        static Load(InName: string): OnlineBlueprintCallProxyBase;
    }
    
    class AchievementQueryCallbackProxy extends UE.OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;
        static CacheAchievementDescriptions(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>) : UE.AchievementQueryCallbackProxy;
        static CacheAchievements(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>) : UE.AchievementQueryCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AchievementQueryCallbackProxy;
        static Load(InName: string): AchievementQueryCallbackProxy;
    }
    
    class AchievementWriteCallbackProxy extends UE.OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(WrittenAchievementName: string, WrittenProgress: number, WrittenUserTag: number) => void>;
        OnFailure: $MulticastDelegate<(WrittenAchievementName: string, WrittenProgress: number, WrittenUserTag: number) => void>;
        static WriteAchievementProgress(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>, AchievementName: string, Progress?: number /* = 100.000000 */, UserTag?: number /* = 0 */) : UE.AchievementWriteCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AchievementWriteCallbackProxy;
        static Load(InName: string): AchievementWriteCallbackProxy;
    }
    
    class EditorUtilityObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Run() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityObject;
        static Load(InName: string): EditorUtilityObject;
    }
    
    class ActorActionUtility extends UE.EditorUtilityObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetSupportedClass() : UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorActionUtility;
        static Load(InName: string): ActorActionUtility;
    }
    
    class ActorChannel extends UE.Channel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Actor: UE.Actor;
        CreateSubObjects: TArray<UE.Object>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorChannel;
        static Load(InName: string): ActorChannel;
    }
    
    class PointerToUberGraphFrame {
        constructor();
        static StaticClass(): Class;
    }
    
    namespace Game.ActorComp {
        class ActorComp_C extends UE.ActorComponent {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            UberGraphFrame: UE.PointerToUberGraphFrame;
            ExecuteUbergraph_ActorComp(EntryPoint: number) : void;
            ReceiveBeginPlay() : void;
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): ActorComp_C;
            static Load(InName: string): ActorComp_C;
        }
        
    }

    class ActorFactory extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DisplayName: string;
        MenuPriority: number;
        NewActorClassName: string;
        NewActorClass: UE.Class;
        bShowInEditorQuickMenu: boolean;
        bUseSurfaceOrientation: boolean;
        SpawnPositionOffset: UE.Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactory;
        static Load(InName: string): ActorFactory;
    }
    
    class ActorFactoryAmbientSound extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryAmbientSound;
        static Load(InName: string): ActorFactoryAmbientSound;
    }
    
    class ActorFactorySkeletalMesh extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactorySkeletalMesh;
        static Load(InName: string): ActorFactorySkeletalMesh;
    }
    
    class ActorFactoryAnimationAsset extends UE.ActorFactorySkeletalMesh {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryAnimationAsset;
        static Load(InName: string): ActorFactoryAnimationAsset;
    }
    
    class ActorFactoryAtmosphericFog extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryAtmosphericFog;
        static Load(InName: string): ActorFactoryAtmosphericFog;
    }
    
    class ActorFactoryStaticMesh extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryStaticMesh;
        static Load(InName: string): ActorFactoryStaticMesh;
    }
    
    class ActorFactoryBasicShape extends UE.ActorFactoryStaticMesh {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryBasicShape;
        static Load(InName: string): ActorFactoryBasicShape;
    }
    
    class ActorFactoryBlueprint extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryBlueprint;
        static Load(InName: string): ActorFactoryBlueprint;
    }
    
    class ActorFactoryBoxReflectionCapture extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryBoxReflectionCapture;
        static Load(InName: string): ActorFactoryBoxReflectionCapture;
    }
    
    class ActorFactoryVolume extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryVolume;
        static Load(InName: string): ActorFactoryVolume;
    }
    
    class ActorFactoryBoxVolume extends UE.ActorFactoryVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryBoxVolume;
        static Load(InName: string): ActorFactoryBoxVolume;
    }
    
    class ActorFactoryCameraActor extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryCameraActor;
        static Load(InName: string): ActorFactoryCameraActor;
    }
    
    class ActorFactoryCharacter extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryCharacter;
        static Load(InName: string): ActorFactoryCharacter;
    }
    
    class ActorFactoryClass extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryClass;
        static Load(InName: string): ActorFactoryClass;
    }
    
    class ActorFactoryCylinderVolume extends UE.ActorFactoryVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryCylinderVolume;
        static Load(InName: string): ActorFactoryCylinderVolume;
    }
    
    class ActorFactoryDeferredDecal extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryDeferredDecal;
        static Load(InName: string): ActorFactoryDeferredDecal;
    }
    
    class ActorFactoryDirectionalLight extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryDirectionalLight;
        static Load(InName: string): ActorFactoryDirectionalLight;
    }
    
    class ActorFactoryEmitter extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryEmitter;
        static Load(InName: string): ActorFactoryEmitter;
    }
    
    class ActorFactoryEmptyActor extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bVisualizeActor: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryEmptyActor;
        static Load(InName: string): ActorFactoryEmptyActor;
    }
    
    class ActorFactoryExponentialHeightFog extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryExponentialHeightFog;
        static Load(InName: string): ActorFactoryExponentialHeightFog;
    }
    
    class ActorFactoryGeometryCache extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryGeometryCache;
        static Load(InName: string): ActorFactoryGeometryCache;
    }
    
    class ActorFactoryInteractiveFoliage extends UE.ActorFactoryStaticMesh {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryInteractiveFoliage;
        static Load(InName: string): ActorFactoryInteractiveFoliage;
    }
    
    class ActorFactoryLandscape extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryLandscape;
        static Load(InName: string): ActorFactoryLandscape;
    }
    
    class ActorFactoryMatineeActor extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryMatineeActor;
        static Load(InName: string): ActorFactoryMatineeActor;
    }
    
    class ActorFactoryMovieScene extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryMovieScene;
        static Load(InName: string): ActorFactoryMovieScene;
    }
    
    class ActorFactoryNote extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryNote;
        static Load(InName: string): ActorFactoryNote;
    }
    
    class ActorFactoryPawn extends UE.ActorFactoryEmptyActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryPawn;
        static Load(InName: string): ActorFactoryPawn;
    }
    
    class ActorFactoryPhysicsAsset extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryPhysicsAsset;
        static Load(InName: string): ActorFactoryPhysicsAsset;
    }
    
    class ActorFactoryPlanarReflection extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryPlanarReflection;
        static Load(InName: string): ActorFactoryPlanarReflection;
    }
    
    class ActorFactoryPlaneReflectionCapture extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryPlaneReflectionCapture;
        static Load(InName: string): ActorFactoryPlaneReflectionCapture;
    }
    
    class ActorFactoryPlayerStart extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryPlayerStart;
        static Load(InName: string): ActorFactoryPlayerStart;
    }
    
    class ActorFactoryPointLight extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryPointLight;
        static Load(InName: string): ActorFactoryPointLight;
    }
    
    class ActorFactoryProceduralFoliage extends UE.ActorFactoryBoxVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryProceduralFoliage;
        static Load(InName: string): ActorFactoryProceduralFoliage;
    }
    
    class ActorFactoryRectLight extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryRectLight;
        static Load(InName: string): ActorFactoryRectLight;
    }
    
    class ActorFactoryRuntimeVirtualTextureVolume extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryRuntimeVirtualTextureVolume;
        static Load(InName: string): ActorFactoryRuntimeVirtualTextureVolume;
    }
    
    class ActorFactorySkyAtmosphere extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactorySkyAtmosphere;
        static Load(InName: string): ActorFactorySkyAtmosphere;
    }
    
    class ActorFactorySkyLight extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactorySkyLight;
        static Load(InName: string): ActorFactorySkyLight;
    }
    
    class ActorFactorySphereReflectionCapture extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactorySphereReflectionCapture;
        static Load(InName: string): ActorFactorySphereReflectionCapture;
    }
    
    class ActorFactorySphereVolume extends UE.ActorFactoryVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactorySphereVolume;
        static Load(InName: string): ActorFactorySphereVolume;
    }
    
    class ActorFactorySpotLight extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactorySpotLight;
        static Load(InName: string): ActorFactorySpotLight;
    }
    
    class ActorFactoryTargetPoint extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryTargetPoint;
        static Load(InName: string): ActorFactoryTargetPoint;
    }
    
    class ActorFactoryTextRender extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryTextRender;
        static Load(InName: string): ActorFactoryTextRender;
    }
    
    class ActorFactoryTriggerBox extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryTriggerBox;
        static Load(InName: string): ActorFactoryTriggerBox;
    }
    
    class ActorFactoryTriggerCapsule extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryTriggerCapsule;
        static Load(InName: string): ActorFactoryTriggerCapsule;
    }
    
    class ActorFactoryTriggerSphere extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryTriggerSphere;
        static Load(InName: string): ActorFactoryTriggerSphere;
    }
    
    class ActorFactoryVectorFieldVolume extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryVectorFieldVolume;
        static Load(InName: string): ActorFactoryVectorFieldVolume;
    }
    
    class ActorGroupingUtils extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddSelectedToGroup() : void;
        GroupActors(ActorsToGroup: TArray<UE.Actor>) : void;
        GroupSelected() : void;
        LockSelectedGroups() : void;
        RemoveSelectedFromGroup() : void;
        UngroupActors(ActorsToUngroup: TArray<UE.Actor>) : void;
        UngroupSelected() : void;
        UnlockSelectedGroups() : void;
        static Get() : UE.ActorGroupingUtils;
        static IsGroupingActive() : boolean;
        static SetGroupingActive(bInGroupingActive: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorGroupingUtils;
        static Load(InName: string): ActorGroupingUtils;
    }
    
    class SequenceRecordingBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequenceRecordingBase;
        static Load(InName: string): SequenceRecordingBase;
    }
    
    class ActorRecordingSettings {
        constructor();
        constructor(Settings: TArray<UE.Object>);
        Settings: TArray<UE.Object>;
        static StaticClass(): Class;
    }
    
    class LevelSequenceObjectReferenceMap {
        constructor();
        static StaticClass(): Class;
    }
    
    class LevelSequenceBindingReference {
        constructor();
        constructor(PackageName: string, ExternalObjectPath: UE.SoftObjectPath, ObjectPath: string);
        PackageName: string;
        ExternalObjectPath: UE.SoftObjectPath;
        ObjectPath: string;
        static StaticClass(): Class;
    }
    
    class LevelSequenceBindingReferenceArray {
        constructor();
        constructor(References: TArray<UE.LevelSequenceBindingReference>);
        References: TArray<UE.LevelSequenceBindingReference>;
        static StaticClass(): Class;
    }
    
    class LevelSequenceBindingReferences {
        constructor();
        constructor(BindingIdToReferences: TMap<UE.Guid, UE.LevelSequenceBindingReferenceArray>, AnimSequenceInstances: TSet<UE.Guid>);
        BindingIdToReferences: TMap<UE.Guid, UE.LevelSequenceBindingReferenceArray>;
        AnimSequenceInstances: TSet<UE.Guid>;
        static StaticClass(): Class;
    }
    
    class LevelSequenceObject {
        constructor();
        constructor(ObjectOrOwner: TLazyObjectPtr<UE.Object>, ComponentName: string, CachedComponent: TWeakObjectPtr<UE.Object>);
        ObjectOrOwner: TLazyObjectPtr<UE.Object>;
        ComponentName: string;
        CachedComponent: TWeakObjectPtr<UE.Object>;
        static StaticClass(): Class;
    }
    
    class LevelSequence extends UE.MovieSceneSequence {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MovieScene: UE.MovieScene;
        ObjectReferences: UE.LevelSequenceObjectReferenceMap;
        BindingReferences: UE.LevelSequenceBindingReferences;
        PossessedObjects: TMap<string, UE.LevelSequenceObject>;
        DirectorBlueprint: UE.Blueprint;
        DirectorClass: UE.Class;
        MetaDataObjects: TArray<UE.Object>;
        CopyMetaData(InMetaData: $Nullable<UE.Object>) : UE.Object;
        FindMetaDataByClass(InClass: $Nullable<UE.Class>) : UE.Object;
        FindOrAddMetaDataByClass(InClass: $Nullable<UE.Class>) : UE.Object;
        RemoveMetaDataByClass(InClass: $Nullable<UE.Class>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequence;
        static Load(InName: string): LevelSequence;
    }
    
    class AnimationRecordingSettings {
        constructor();
        constructor(bRecordInWorldSpace: boolean, bRemoveRootAnimation: boolean, bAutoSaveAsset: boolean, SampleRate: number, Length: number, InterpMode: UE.ERichCurveInterpMode, TangentMode: UE.ERichCurveTangentMode);
        bRecordInWorldSpace: boolean;
        bRemoveRootAnimation: boolean;
        bAutoSaveAsset: boolean;
        SampleRate: number;
        Length: number;
        InterpMode: UE.ERichCurveInterpMode;
        TangentMode: UE.ERichCurveTangentMode;
        static StaticClass(): Class;
    }
    
    class ActorRecording extends UE.SequenceRecordingBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActorSettings: UE.ActorRecordingSettings;
        bActive: boolean;
        bCreateLevelSequence: boolean;
        TargetLevelSequence: UE.LevelSequence;
        TargetName: string;
        TakeNumber: number;
        bSpecifyTargetAnimation: boolean;
        TargetAnimation: UE.AnimSequence;
        AnimationSettings: UE.AnimationRecordingSettings;
        bRecordToPossessable: boolean;
        ActorToRecord: TSoftObjectPtr<UE.Actor>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorRecording;
        static Load(InName: string): ActorRecording;
    }
    
    enum EActorSequenceObjectReferenceType { ContextActor, ExternalActor, Component, EActorSequenceObjectReferenceType_MAX}
    class ActorSequenceObjectReference {
        constructor();
        constructor(Type: UE.EActorSequenceObjectReferenceType, ActorId: UE.Guid, PathToComponent: string);
        Type: UE.EActorSequenceObjectReferenceType;
        ActorId: UE.Guid;
        PathToComponent: string;
        static StaticClass(): Class;
    }
    
    class ActorSequenceObjectReferences {
        constructor();
        constructor(Array: TArray<UE.ActorSequenceObjectReference>);
        Array: TArray<UE.ActorSequenceObjectReference>;
        static StaticClass(): Class;
    }
    
    class ActorSequenceObjectReferenceMap {
        constructor();
        constructor(BindingIds: TArray<UE.Guid>, References: TArray<UE.ActorSequenceObjectReferences>);
        BindingIds: TArray<UE.Guid>;
        References: TArray<UE.ActorSequenceObjectReferences>;
        static StaticClass(): Class;
    }
    
    class ActorSequence extends UE.MovieSceneSequence {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MovieScene: UE.MovieScene;
        ObjectReferences: UE.ActorSequenceObjectReferenceMap;
        bHasBeenInitialized: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorSequence;
        static Load(InName: string): ActorSequence;
    }
    
    class MovieSceneSequenceLoopCount {
        constructor();
        constructor(Value: number);
        Value: number;
        static StaticClass(): Class;
    }
    
    class MovieSceneSequencePlaybackSettings {
        constructor();
        constructor(bAutoPlay: boolean, LoopCount: UE.MovieSceneSequenceLoopCount, PlayRate: number, StartTime: number, bRandomStartTime: boolean, bRestoreState: boolean, bDisableMovementInput: boolean, bDisableLookAtInput: boolean, bHidePlayer: boolean, bHideHud: boolean, bDisableCameraCuts: boolean, bPauseAtEnd: boolean);
        bAutoPlay: boolean;
        LoopCount: UE.MovieSceneSequenceLoopCount;
        PlayRate: number;
        StartTime: number;
        bRandomStartTime: boolean;
        bRestoreState: boolean;
        bDisableMovementInput: boolean;
        bDisableLookAtInput: boolean;
        bHidePlayer: boolean;
        bHideHud: boolean;
        bDisableCameraCuts: boolean;
        bPauseAtEnd: boolean;
        static StaticClass(): Class;
    }
    
    enum EMovieScenePlayerStatus { Stopped, Playing, Recording, Scrubbing, Jumping, Stepping, Paused, MAX}
    class MovieSceneRootEvaluationTemplateInstance {
        constructor();
        constructor(DirectorInstances: TMap<UE.MovieSceneSequenceID, UE.Object>);
        DirectorInstances: TMap<UE.MovieSceneSequenceID, UE.Object>;
        static StaticClass(): Class;
    }
    
    class MovieSceneSequenceReplProperties {
        constructor();
        constructor(LastKnownPosition: UE.FrameTime, LastKnownStatus: UE.EMovieScenePlayerStatus, LastKnownNumLoops: number);
        LastKnownPosition: UE.FrameTime;
        LastKnownStatus: UE.EMovieScenePlayerStatus;
        LastKnownNumLoops: number;
        static StaticClass(): Class;
    }
    
    class MovieScenePlaybackClient extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScenePlaybackClient;
        static Load(InName: string): MovieScenePlaybackClient;
    }
    
    enum EUpdatePositionMethod { Play, Jump, Scrub, EUpdatePositionMethod_MAX}
    class QualifiedFrameTime {
        constructor();
        constructor(Time: UE.FrameTime, Rate: UE.FrameRate);
        Time: UE.FrameTime;
        Rate: UE.FrameRate;
        static StaticClass(): Class;
    }
    
    class MovieSceneSequencePlayer extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnPlay: $MulticastDelegate<() => void>;
        OnPlayReverse: $MulticastDelegate<() => void>;
        OnStop: $MulticastDelegate<() => void>;
        OnPause: $MulticastDelegate<() => void>;
        OnFinished: $MulticastDelegate<() => void>;
        Status: UE.EMovieScenePlayerStatus;
        bReversePlayback: boolean;
        Sequence: UE.MovieSceneSequence;
        StartTime: UE.FrameNumber;
        DurationFrames: number;
        CurrentNumLoops: number;
        PlaybackSettings: UE.MovieSceneSequencePlaybackSettings;
        RootTemplateInstance: UE.MovieSceneRootEvaluationTemplateInstance;
        NetSyncProps: UE.MovieSceneSequenceReplProperties;
        PlaybackClient: MovieScenePlaybackClient;
        ChangePlaybackDirection() : void;
        GetBoundObjects(ObjectBinding: UE.MovieSceneObjectBindingID) : TArray<UE.Object>;
        GetCurrentTime() : UE.QualifiedFrameTime;
        GetDisableCameraCuts() : boolean;
        GetDuration() : UE.QualifiedFrameTime;
        GetEndTime() : UE.QualifiedFrameTime;
        GetFrameDuration() : number;
        GetFrameRate() : UE.FrameRate;
        GetLength() : number;
        GetObjectBindings(InObject: $Nullable<UE.Object>) : TArray<UE.MovieSceneObjectBindingID>;
        GetPlaybackEnd() : number;
        GetPlaybackPosition() : number;
        GetPlaybackStart() : number;
        GetPlayRate() : number;
        GetStartTime() : UE.QualifiedFrameTime;
        GoToEndAndStop() : void;
        IsPaused() : boolean;
        IsPlaying() : boolean;
        IsReversed() : boolean;
        JumpToFrame(NewPosition: UE.FrameTime) : void;
        JumpToMarkedFrame(InLabel: string) : boolean;
        JumpToPosition(NewPlaybackPosition: number) : void;
        JumpToSeconds(TimeInSeconds: number) : void;
        Pause() : void;
        Play() : void;
        PlayLooping(NumLoops?: number /* = -1 */) : void;
        PlayReverse() : void;
        PlayToFrame(NewPosition: UE.FrameTime) : void;
        PlayToMarkedFrame(InLabel: string) : boolean;
        PlayToSeconds(TimeInSeconds: number) : void;
        RPC_ExplicitServerUpdateEvent(Method: UE.EUpdatePositionMethod, RelevantTime: UE.FrameTime) : void;
        RPC_OnStopEvent(StoppedTime: UE.FrameTime) : void;
        Scrub() : void;
        ScrubToFrame(NewPosition: UE.FrameTime) : void;
        ScrubToMarkedFrame(InLabel: string) : boolean;
        ScrubToSeconds(TimeInSeconds: number) : void;
        SetDisableCameraCuts(bInDisableCameraCuts: boolean) : void;
        SetFrameRange(StartFrame: number, Duration: number) : void;
        SetFrameRate(FrameRate: UE.FrameRate) : void;
        SetPlaybackPosition(NewPlaybackPosition: number) : void;
        SetPlaybackRange(NewStartTime: number, NewEndTime: number) : void;
        SetPlayRate(PlayRate: number) : void;
        SetTimeRange(StartTime: number, Duration: number) : void;
        Stop() : void;
        StopAtCurrentTime() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSequencePlayer;
        static Load(InName: string): MovieSceneSequencePlayer;
    }
    
    class ActorSequencePlayer extends UE.MovieSceneSequencePlayer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorSequencePlayer;
        static Load(InName: string): ActorSequencePlayer;
    }
    
    class ActorSequenceComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlaybackSettings: UE.MovieSceneSequencePlaybackSettings;
        Sequence: UE.ActorSequence;
        SequencePlayer: UE.ActorSequencePlayer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorSequenceComponent;
        static Load(InName: string): ActorSequenceComponent;
    }
    
    class EditorWorldExtensionActorData {
        constructor();
        constructor(Actor: UE.Actor, bValidForPIE: boolean);
        Actor: UE.Actor;
        bValidForPIE: boolean;
        static StaticClass(): Class;
    }
    
    class EditorWorldExtension extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ExtensionActors: TArray<UE.EditorWorldExtensionActorData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorWorldExtension;
        static Load(InName: string): EditorWorldExtension;
    }
    
    class ViewportActionKeyInput {
        constructor();
        constructor(ActionType: string, Event: UE.EInputEvent, bIsInputCaptured: boolean);
        ActionType: string;
        Event: UE.EInputEvent;
        bIsInputCaptured: boolean;
        static StaticClass(): Class;
    }
    
    enum EHitResultGizmoFilterMode { All, NoGizmos, GizmosOnly, EHitResultGizmoFilterMode_MAX}
    enum EViewportInteractionDraggingMode { Nothing, TransformablesWithGizmo, TransformablesAtLaserImpact, AssistingDrag, TransformablesFreely, World, Interactable, Material, EViewportInteractionDraggingMode_MAX}
    class ViewportInteractor extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        KeyToActionMap: TMap<UE.Key, UE.ViewportActionKeyInput>;
        WorldInteraction: UE.ViewportWorldInteraction;
        OtherInteractor: UE.ViewportInteractor;
        CanCarry() : boolean;
        GetDraggingMode() : UE.EViewportInteractionDraggingMode;
        GetHitResultGizmoFilterMode() : UE.EHitResultGizmoFilterMode;
        GetHoverLocation() : UE.Vector;
        GetLaserPointer(LaserPointerStart: $Ref<UE.Vector>, LaserPointerEnd: $Ref<UE.Vector>, bEvenIfBlocked?: boolean /* = false */, LaserLengthOverride?: number /* = 0.000000 */) : boolean;
        GetLastRoomSpaceTransform() : UE.Transform;
        GetLastTransform() : UE.Transform;
        GetOtherInteractor() : UE.ViewportInteractor;
        GetRoomSpaceTransform() : UE.Transform;
        GetTransform() : UE.Transform;
        GetTransformAndForwardVector(OutHandTransform: $Ref<UE.Transform>, OutForwardVector: $Ref<UE.Vector>) : boolean;
        GetWorldInteraction() : UE.ViewportWorldInteraction;
        HandleInputAxis_BP(Action: UE.ViewportActionKeyInput, Key: UE.Key, Delta: number, DeltaTime: number, bOutWasHandled: $Ref<boolean>) : void;
        HandleInputKey_BP(Action: UE.ViewportActionKeyInput, Key: UE.Key, Event: UE.EInputEvent, bOutWasHandled: $Ref<boolean>) : void;
        IsHoveringOverGizmo() : boolean;
        SetCanCarry(bInCanCarry: boolean) : void;
        SetDraggingMode(NewDraggingMode: UE.EViewportInteractionDraggingMode) : void;
        SetHitResultGizmoFilterMode(newFilter: UE.EHitResultGizmoFilterMode) : void;
        Shutdown() : void;
        Tick(DeltaTime: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ViewportInteractor;
        static Load(InName: string): ViewportInteractor;
    }
    
    class GizmoHandle {
        constructor();
        static StaticClass(): Class;
    }
    
    class ViewportDragOperation extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ViewportDragOperation;
        static Load(InName: string): ViewportDragOperation;
    }
    
    class ViewportDragOperationComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DragOperation: UE.ViewportDragOperation;
        DragOperationSubclass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ViewportDragOperationComponent;
        static Load(InName: string): ViewportDragOperationComponent;
    }
    
    class GizmoHandleGroup extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GizmoMaterial: UE.MaterialInterface;
        TranslucentGizmoMaterial: UE.MaterialInterface;
        Handles: TArray<UE.GizmoHandle>;
        OwningTransformGizmoActor: UE.BaseTransformGizmo;
        DragOperationComponent: UE.ViewportDragOperationComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoHandleGroup;
        static Load(InName: string): GizmoHandleGroup;
    }
    
    class BaseTransformGizmo extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SceneComponent: UE.SceneComponent;
        AllHandleGroups: TArray<UE.GizmoHandleGroup>;
        WorldInteraction: UE.ViewportWorldInteraction;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BaseTransformGizmo;
        static Load(InName: string): BaseTransformGizmo;
    }
    
    class MouseCursorInteractor extends UE.ViewportInteractor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MouseCursorInteractor;
        static Load(InName: string): MouseCursorInteractor;
    }
    
    class ViewportInteractionAssetContainer extends UE.DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GizmoHandleSelectedSound: UE.SoundBase;
        GizmoHandleDropSound: UE.SoundBase;
        SelectionChangeSound: UE.SoundBase;
        SelectionDropSound: UE.SoundBase;
        SelectionStartDragSound: UE.SoundBase;
        GridSnapSound: UE.SoundBase;
        ActorSnapSound: UE.SoundBase;
        UndoSound: UE.SoundBase;
        RedoSound: UE.SoundBase;
        GridMesh: UE.StaticMesh;
        TranslationHandleMesh: UE.StaticMesh;
        UniformScaleHandleMesh: UE.StaticMesh;
        ScaleHandleMesh: UE.StaticMesh;
        PlaneTranslationHandleMesh: UE.StaticMesh;
        RotationHandleMesh: UE.StaticMesh;
        RotationHandleSelectedMesh: UE.StaticMesh;
        StartRotationIndicatorMesh: UE.StaticMesh;
        CurrentRotationIndicatorMesh: UE.StaticMesh;
        FreeRotationHandleMesh: UE.StaticMesh;
        GridMaterial: UE.MaterialInterface;
        TransformGizmoMaterial: UE.MaterialInterface;
        TranslucentTransformGizmoMaterial: UE.MaterialInterface;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ViewportInteractionAssetContainer;
        static Load(InName: string): ViewportInteractionAssetContainer;
    }
    
    class ViewportWorldInteraction extends UE.EditorWorldExtension {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Interactors: TArray<UE.ViewportInteractor>;
        ViewportTransformer: UE.ViewportTransformer;
        TransformGizmoActor: UE.BaseTransformGizmo;
        SnapGridActor: UE.Actor;
        SnapGridMeshComponent: UE.StaticMeshComponent;
        SnapGridMID: UE.MaterialInstanceDynamic;
        DefaultMouseCursorInteractor: UE.MouseCursorInteractor;
        ActorsToExcludeFromHitTest: TArray<TWeakObjectPtr<UE.Actor>>;
        AssetContainer: UE.ViewportInteractionAssetContainer;
        AddActorToExcludeFromHitTests(ActorToExcludeFromHitTests: $Nullable<UE.Actor>) : void;
        AddInteractor(Interactor: $Nullable<UE.ViewportInteractor>) : void;
        GetHeadTransform() : UE.Transform;
        GetInteractors() : TArray<UE.ViewportInteractor>;
        GetRoomSpaceHeadTransform() : UE.Transform;
        GetRoomTransform() : UE.Transform;
        GetTransformGizmoActor() : UE.BaseTransformGizmo;
        GetWorldScaleFactor() : number;
        RemoveInteractor(Interactor: $Nullable<UE.ViewportInteractor>) : void;
        SetHeadTransform(NewHeadTransform: UE.Transform) : void;
        SetRoomTransformForNextFrame(NewRoomTransform: UE.Transform) : void;
        SetWorldToMetersScale(NewWorldToMetersScale: number, bCompensateRoomWorldScale?: boolean /* = false */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ViewportWorldInteraction;
        static Load(InName: string): ViewportWorldInteraction;
    }
    
    class ViewportTransformer extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ViewportWorldInteraction: UE.ViewportWorldInteraction;
        CanAlignToActors() : boolean;
        Init(InitViewportWorldInteraction: $Nullable<UE.ViewportWorldInteraction>) : void;
        OnStartDragging(Interactor: $Nullable<UE.ViewportInteractor>) : void;
        OnStopDragging(Interactor: $Nullable<UE.ViewportInteractor>) : void;
        ShouldCenterTransformGizmoPivot() : boolean;
        Shutdown() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ViewportTransformer;
        static Load(InName: string): ViewportTransformer;
    }
    
    class ActorTransformer extends UE.ViewportTransformer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorTransformer;
        static Load(InName: string): ActorTransformer;
    }
    
    class AdvancedCopyCustomization extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AdvancedCopyCustomization;
        static Load(InName: string): AdvancedCopyCustomization;
    }
    
    enum EPathFollowingResult { Success, Blocked, OffPath, Aborted, Skipped_DEPRECATED, Invalid, EPathFollowingResult_MAX}
    class AIRequestID {
        constructor();
        constructor(RequestID: number);
        RequestID: number;
        static StaticClass(): Class;
    }
    
    class AIAsyncTaskBlueprintProxy extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(MovementResult: UE.EPathFollowingResult) => void>;
        OnFail: $MulticastDelegate<(MovementResult: UE.EPathFollowingResult) => void>;
        OnMoveCompleted(RequestID: UE.AIRequestID, MovementResult: UE.EPathFollowingResult) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIAsyncTaskBlueprintProxy;
        static Load(InName: string): AIAsyncTaskBlueprintProxy;
    }
    
    class BTNode extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NodeName: string;
        TreeAsset: UE.BehaviorTree;
        ParentNode: UE.BTCompositeNode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTNode;
        static Load(InName: string): BTNode;
    }
    
    class BTAuxiliaryNode extends UE.BTNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTAuxiliaryNode;
        static Load(InName: string): BTAuxiliaryNode;
    }
    
    class BTService extends UE.BTAuxiliaryNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Interval: number;
        RandomDeviation: number;
        bCallTickOnSearchStart: boolean;
        bRestartTimerOnEachActivation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTService;
        static Load(InName: string): BTService;
    }
    
    class BTTaskNode extends UE.BTNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Services: TArray<UE.BTService>;
        bIgnoreRestartSelf: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTaskNode;
        static Load(InName: string): BTTaskNode;
    }
    
    enum EBTFlowAbortMode { None, LowerPriority, Self, Both, EBTFlowAbortMode_MAX}
    class BTDecorator extends UE.BTAuxiliaryNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bInverseCondition: boolean;
        FlowAbortMode: UE.EBTFlowAbortMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator;
        static Load(InName: string): BTDecorator;
    }
    
    enum EBTDecoratorLogic { Invalid, Test, And, Or, Not, EBTDecoratorLogic_MAX}
    class BTDecoratorLogic {
        constructor();
        constructor(Operation: UE.EBTDecoratorLogic, Number: number);
        Operation: UE.EBTDecoratorLogic;
        Number: number;
        static StaticClass(): Class;
    }
    
    class BTCompositeChild {
        constructor();
        constructor(ChildComposite: UE.BTCompositeNode, ChildTask: UE.BTTaskNode, Decorators: TArray<UE.BTDecorator>, DecoratorOps: TArray<UE.BTDecoratorLogic>);
        ChildComposite: UE.BTCompositeNode;
        ChildTask: UE.BTTaskNode;
        Decorators: TArray<UE.BTDecorator>;
        DecoratorOps: TArray<UE.BTDecoratorLogic>;
        static StaticClass(): Class;
    }
    
    class BTCompositeNode extends UE.BTNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Children: TArray<UE.BTCompositeChild>;
        Services: TArray<UE.BTService>;
        bApplyDecoratorScope: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTCompositeNode;
        static Load(InName: string): BTCompositeNode;
    }
    
    class BlackboardKeyType extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType;
        static Load(InName: string): BlackboardKeyType;
    }
    
    class BlackboardEntry {
        constructor();
        constructor(EntryName: string, EntryDescription: string, KeyType: UE.BlackboardKeyType, bInstanceSynced: boolean);
        EntryName: string;
        EntryDescription: string;
        KeyType: UE.BlackboardKeyType;
        bInstanceSynced: boolean;
        static StaticClass(): Class;
    }
    
    class BlackboardData extends UE.DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Parent: UE.BlackboardData;
        ParentKeys: TArray<UE.BlackboardEntry>;
        Keys: TArray<UE.BlackboardEntry>;
        bHasSynchronizedKeys: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardData;
        static Load(InName: string): BlackboardData;
    }
    
    class BehaviorTree extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RootNode: UE.BTCompositeNode;
        BTGraph: UE.EdGraph;
        LastEditedDocuments: TArray<UE.EditedDocumentInfo>;
        BlackboardAsset: UE.BlackboardData;
        RootDecorators: TArray<UE.BTDecorator>;
        RootDecoratorOps: TArray<UE.BTDecoratorLogic>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTree;
        static Load(InName: string): BehaviorTree;
    }
    
    enum ENavPathEvent { Cleared, NewPath, UpdatedDueToGoalMoved, UpdatedDueToNavigationChanged, Invalidated, RePathFailed, MetaPathUpdate, Custom, ENavPathEvent_MAX}
    enum ENavigationOptionFlag { Default, Enable, Disable, MAX}
    class NavigationPath extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PathUpdatedNotifier: $MulticastDelegate<(AffectedPath: $Nullable<UE.NavigationPath>, PathEvent: UE.ENavPathEvent) => void>;
        PathPoints: TArray<UE.Vector>;
        RecalculateOnInvalidation: UE.ENavigationOptionFlag;
        EnableDebugDrawing(bShouldDrawDebugData: boolean, PathColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */) : void;
        EnableRecalculationOnInvalidation(DoRecalculation: UE.ENavigationOptionFlag) : void;
        GetDebugString() : string;
        GetPathCost() : number;
        GetPathLength() : number;
        IsPartial() : boolean;
        IsStringPulled() : boolean;
        IsValid() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationPath;
        static Load(InName: string): NavigationPath;
    }
    
    enum EPathFollowingAction { Error, NoMove, DirectMove, PartialPath, PathToGoal, EPathFollowingAction_MAX}
    class PathFollowingComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MovementComp: UE.NavMovementComponent;
        MyNavData: UE.NavigationData;
        GetPathActionType() : UE.EPathFollowingAction;
        GetPathDestination() : UE.Vector;
        OnActorBump(SelfActor: $Nullable<UE.Actor>, OtherActor: $Nullable<UE.Actor>, NormalImpulse: UE.Vector, Hit: UE.HitResult) : void;
        OnNavDataRegistered(NavData: $Nullable<UE.NavigationData>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PathFollowingComponent;
        static Load(InName: string): PathFollowingComponent;
    }
    
    class AISenseConfig extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DebugColor: UE.Color;
        MaxAge: number;
        bStartsEnabled: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseConfig;
        static Load(InName: string): AISenseConfig;
    }
    
    class AIStimulus {
        constructor();
        constructor(Age: number, ExpirationAge: number, Strength: number, StimulusLocation: UE.Vector, ReceiverLocation: UE.Vector, Tag: string, bSuccessfullySensed: boolean);
        Age: number;
        ExpirationAge: number;
        Strength: number;
        StimulusLocation: UE.Vector;
        ReceiverLocation: UE.Vector;
        Tag: string;
        bSuccessfullySensed: boolean;
        static StaticClass(): Class;
    }
    
    class ActorPerceptionBlueprintInfo {
        constructor();
        constructor(Target: UE.Actor, LastSensedStimuli: TArray<UE.AIStimulus>, bIsHostile: boolean);
        Target: UE.Actor;
        LastSensedStimuli: TArray<UE.AIStimulus>;
        bIsHostile: boolean;
        static StaticClass(): Class;
    }
    
    class AIPerceptionComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SensesConfig: TArray<UE.AISenseConfig>;
        DominantSense: UE.Class;
        AIOwner: UE.AIController;
        OnPerceptionUpdated: $MulticastDelegate<(UpdatedActors: TArray<UE.Actor>) => void>;
        OnTargetPerceptionUpdated: $MulticastDelegate<(Actor: $Nullable<UE.Actor>, Stimulus: UE.AIStimulus) => void>;
        GetActorsPerception(Actor: $Nullable<UE.Actor>, Info: $Ref<UE.ActorPerceptionBlueprintInfo>) : boolean;
        GetCurrentlyPerceivedActors(SenseToUse: $Nullable<UE.Class>, OutActors: $Ref<TArray<UE.Actor>>) : void;
        GetKnownPerceivedActors(SenseToUse: $Nullable<UE.Class>, OutActors: $Ref<TArray<UE.Actor>>) : void;
        GetPerceivedActors(SenseToUse: $Nullable<UE.Class>, OutActors: $Ref<TArray<UE.Actor>>) : void;
        GetPerceivedHostileActors(OutActors: $Ref<TArray<UE.Actor>>) : void;
        OnOwnerEndPlay(Actor: $Nullable<UE.Actor>, EndPlayReason: UE.EEndPlayReason) : void;
        RequestStimuliListenerUpdate() : void;
        SetSenseEnabled(SenseClass: $Nullable<UE.Class>, bEnable: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIPerceptionComponent;
        static Load(InName: string): AIPerceptionComponent;
    }
    
    enum EAIRequestPriority { SoftScript, Logic, HardScript, Reaction, Ultimate, MAX}
    enum EPawnActionResult { NotStarted, InProgress, Success, Failed, Aborted, EPawnActionResult_MAX}
    class PawnAction extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChildAction: UE.PawnAction;
        ParentAction: UE.PawnAction;
        OwnerComponent: UE.PawnActionsComponent;
        Instigator: UE.Object;
        BrainComp: UE.BrainComponent;
        bAllowNewSameClassInstance: boolean;
        bReplaceActiveSameClassInstance: boolean;
        bShouldPauseMovement: boolean;
        bAlwaysNotifyOnFinished: boolean;
        Finish(WithResult: UE.EPawnActionResult) : void;
        GetActionPriority() : UE.EAIRequestPriority;
        static CreateActionInstance(WorldContextObject: $Nullable<UE.Object>, ActionClass: $Nullable<UE.Class>) : UE.PawnAction;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnAction;
        static Load(InName: string): PawnAction;
    }
    
    class PawnActionStack {
        constructor();
        constructor(TopAction: UE.PawnAction);
        TopAction: UE.PawnAction;
        static StaticClass(): Class;
    }
    
    class PawnActionEvent {
        constructor();
        constructor(Action: UE.PawnAction);
        Action: UE.PawnAction;
        static StaticClass(): Class;
    }
    
    enum EPawnActionAbortState { NeverStarted, NotBeingAborted, MarkPendingAbort, LatentAbortInProgress, AbortDone, MAX}
    class PawnActionsComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ControlledPawn: UE.Pawn;
        ActionStacks: TArray<UE.PawnActionStack>;
        ActionEvents: TArray<UE.PawnActionEvent>;
        CurrentAction: UE.PawnAction;
        K2_AbortAction(ActionToAbort: $Nullable<UE.PawnAction>) : UE.EPawnActionAbortState;
        K2_ForceAbortAction(ActionToAbort: $Nullable<UE.PawnAction>) : UE.EPawnActionAbortState;
        K2_PushAction(NewAction: $Nullable<UE.PawnAction>, Priority: UE.EAIRequestPriority, Instigator?: UE.Object /* = None */) : boolean;
        static K2_PerformAction(Pawn: $Nullable<UE.Pawn>, Action: $Nullable<UE.PawnAction>, Priority?: UE.EAIRequestPriority /* = HardScript */) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnActionsComponent;
        static Load(InName: string): PawnActionsComponent;
    }
    
    enum ETaskResourceOverlapPolicy { StartOnTop, StartAtEnd, ETaskResourceOverlapPolicy_MAX}
    class GameplayTask extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InstanceName: string;
        ResourceOverlapPolicy: UE.ETaskResourceOverlapPolicy;
        ChildTask: UE.GameplayTask;
        EndTask() : void;
        GenericGameplayTaskDelegate__DelegateSignature() : void;
        ReadyForActivation() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTask;
        static Load(InName: string): GameplayTask;
    }
    
    class GameplayResourceSet {
        constructor();
        static StaticClass(): Class;
    }
    
    class GameplayTaskOwnerInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTaskOwnerInterface;
        static Load(InName: string): GameplayTaskOwnerInterface;
    }
    
    enum EGameplayTaskRunResult { Error, Failed, Success_Paused, Success_Active, Success_Finished, EGameplayTaskRunResult_MAX}
    class GameplayTasksComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsNetDirty: boolean;
        SimulatedTasks: TArray<UE.GameplayTask>;
        TaskPriorityQueue: TArray<UE.GameplayTask>;
        TickingTasks: TArray<UE.GameplayTask>;
        KnownTasks: TArray<UE.GameplayTask>;
        OnClaimedResourcesChange: $MulticastDelegate<(NewlyClaimed: UE.GameplayResourceSet, FreshlyReleased: UE.GameplayResourceSet) => void>;
        OnRep_SimulatedTasks() : void;
        static K2_RunGameplayTask(TaskOwner: GameplayTaskOwnerInterface, Task: $Nullable<UE.GameplayTask>, Priority: number, AdditionalRequiredResources: TArray<UE.Class>, AdditionalClaimedResources: TArray<UE.Class>) : UE.EGameplayTaskRunResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTasksComponent;
        static Load(InName: string): GameplayTasksComponent;
    }
    
    enum EPathFollowingRequestResult { Failed, AlreadyAtGoal, RequestSuccessful, EPathFollowingRequestResult_MAX}
    enum EPathFollowingStatus { Idle, Waiting, Paused, Moving, EPathFollowingStatus_MAX}
    class AIController extends UE.Controller {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bStopAILogicOnUnposses: boolean;
        bLOSflag: boolean;
        bSkipExtraLOSChecks: boolean;
        bAllowStrafe: boolean;
        bWantsPlayerState: boolean;
        bSetControlRotationFromPawnOrientation: boolean;
        PathFollowingComponent: UE.PathFollowingComponent;
        BrainComponent: UE.BrainComponent;
        PerceptionComponent: UE.AIPerceptionComponent;
        ActionsComp: UE.PawnActionsComponent;
        Blackboard: UE.BlackboardComponent;
        CachedGameplayTasksComponent: UE.GameplayTasksComponent;
        DefaultNavigationFilterClass: UE.Class;
        ReceiveMoveCompleted: $MulticastDelegate<(RequestID: UE.AIRequestID, Result: UE.EPathFollowingResult) => void>;
        ClaimTaskResource(ResourceClass: $Nullable<UE.Class>) : void;
        GetAIPerceptionComponent() : UE.AIPerceptionComponent;
        GetFocalPoint() : UE.Vector;
        GetFocalPointOnActor(Actor: $Nullable<UE.Actor>) : UE.Vector;
        GetFocusActor() : UE.Actor;
        GetImmediateMoveDestination() : UE.Vector;
        GetMoveStatus() : UE.EPathFollowingStatus;
        GetPathFollowingComponent() : UE.PathFollowingComponent;
        HasPartialPath() : boolean;
        K2_ClearFocus() : void;
        K2_SetFocalPoint(FP: UE.Vector) : void;
        K2_SetFocus(NewFocus: $Nullable<UE.Actor>) : void;
        MoveToActor(Goal: $Nullable<UE.Actor>, AcceptanceRadius?: number /* = -1.000000 */, bStopOnOverlap?: boolean /* = true */, bUsePathfinding?: boolean /* = true */, bCanStrafe?: boolean /* = true */, FilterClass?: UE.Class /* = None */, bAllowPartialPath?: boolean /* = true */) : UE.EPathFollowingRequestResult;
        MoveToLocation(Dest: UE.Vector, AcceptanceRadius?: number /* = -1.000000 */, bStopOnOverlap?: boolean /* = true */, bUsePathfinding?: boolean /* = true */, bProjectDestinationToNavigation?: boolean /* = false */, bCanStrafe?: boolean /* = true */, FilterClass?: UE.Class /* = None */, bAllowPartialPath?: boolean /* = true */) : UE.EPathFollowingRequestResult;
        OnGameplayTaskResourcesClaimed(NewlyClaimed: UE.GameplayResourceSet, FreshlyReleased: UE.GameplayResourceSet) : void;
        OnUsingBlackBoard(BlackboardComp: $Nullable<UE.BlackboardComponent>, BlackboardAsset: $Nullable<UE.BlackboardData>) : void;
        RunBehaviorTree(BTAsset: $Nullable<UE.BehaviorTree>) : boolean;
        SetMoveBlockDetection(bEnable: boolean) : void;
        SetPathFollowingComponent(NewPFComponent: $Nullable<UE.PathFollowingComponent>) : void;
        UnclaimTaskResource(ResourceClass: $Nullable<UE.Class>) : void;
        UseBlackboard(BlackboardAsset: $Nullable<UE.BlackboardData>, BlackboardComponent: $Ref<UE.BlackboardComponent>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIController;
        static Load(InName: string): AIController;
    }
    
    class BrainComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlackboardComp: UE.BlackboardComponent;
        AIOwner: UE.AIController;
        IsPaused() : boolean;
        IsRunning() : boolean;
        RestartLogic() : void;
        StopLogic(Reason: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BrainComponent;
        static Load(InName: string): BrainComponent;
    }
    
    class BlackboardComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BrainComp: UE.BrainComponent;
        BlackboardAsset: UE.BlackboardData;
        KeyInstances: TArray<UE.BlackboardKeyType>;
        ClearValue(KeyName: string) : void;
        GetLocationFromEntry(KeyName: string, ResultLocation: $Ref<UE.Vector>) : boolean;
        GetRotationFromEntry(KeyName: string, ResultRotation: $Ref<UE.Rotator>) : boolean;
        GetValueAsBool(KeyName: string) : boolean;
        GetValueAsClass(KeyName: string) : UE.Class;
        GetValueAsEnum(KeyName: string) : number;
        GetValueAsFloat(KeyName: string) : number;
        GetValueAsInt(KeyName: string) : number;
        GetValueAsName(KeyName: string) : string;
        GetValueAsObject(KeyName: string) : UE.Object;
        GetValueAsRotator(KeyName: string) : UE.Rotator;
        GetValueAsString(KeyName: string) : string;
        GetValueAsVector(KeyName: string) : UE.Vector;
        IsVectorValueSet(KeyName: string) : boolean;
        SetValueAsBool(KeyName: string, BoolValue: boolean) : void;
        SetValueAsClass(KeyName: string, ClassValue: $Nullable<UE.Class>) : void;
        SetValueAsEnum(KeyName: string, EnumValue: number) : void;
        SetValueAsFloat(KeyName: string, FloatValue: number) : void;
        SetValueAsInt(KeyName: string, IntValue: number) : void;
        SetValueAsName(KeyName: string, NameValue: string) : void;
        SetValueAsObject(KeyName: string, ObjectValue: $Nullable<UE.Object>) : void;
        SetValueAsRotator(KeyName: string, VectorValue: UE.Rotator) : void;
        SetValueAsString(KeyName: string, StringValue: string) : void;
        SetValueAsVector(KeyName: string, VectorValue: UE.Vector) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardComponent;
        static Load(InName: string): BlackboardComponent;
    }
    
    class AIBlueprintHelperLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CreateMoveToProxyObject(WorldContextObject: $Nullable<UE.Object>, Pawn: $Nullable<UE.Pawn>, Destination: UE.Vector, TargetActor?: UE.Actor /* = None */, AcceptanceRadius?: number /* = 5.000000 */, bStopOnOverlap?: boolean /* = false */) : UE.AIAsyncTaskBlueprintProxy;
        static GetAIController(ControlledActor: $Nullable<UE.Actor>) : UE.AIController;
        static GetBlackboard(Target: $Nullable<UE.Actor>) : UE.BlackboardComponent;
        static GetCurrentPath(Controller: $Nullable<UE.Controller>) : UE.NavigationPath;
        static IsValidAIDirection(DirectionVector: UE.Vector) : boolean;
        static IsValidAILocation(Location: UE.Vector) : boolean;
        static IsValidAIRotation(Rotation: UE.Rotator) : boolean;
        static LockAIResourcesWithAnimation(AnimInstance: $Nullable<UE.AnimInstance>, bLockMovement: boolean, LockAILogic: boolean) : void;
        static SendAIMessage(Target: $Nullable<UE.Pawn>, Message: string, MessageSource: $Nullable<UE.Object>, bSuccess?: boolean /* = true */) : void;
        static SimpleMoveToActor(Controller: $Nullable<UE.Controller>, Goal: $Nullable<UE.Actor>) : void;
        static SimpleMoveToLocation(Controller: $Nullable<UE.Controller>, Goal: UE.Vector) : void;
        static SpawnAIFromClass(WorldContextObject: $Nullable<UE.Object>, PawnClass: $Nullable<UE.Class>, BehaviorTree: $Nullable<UE.BehaviorTree>, Location: UE.Vector, Rotation?: UE.Rotator /* =  */, bNoCollisionFail?: boolean /* = false */) : UE.Pawn;
        static UnlockAIResourcesWithAnimation(AnimInstance: $Nullable<UE.AnimInstance>, bUnlockMovement: boolean, UnlockAILogic: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIBlueprintHelperLibrary;
        static Load(InName: string): AIBlueprintHelperLibrary;
    }
    
    class AIDataProvider extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIDataProvider;
        static Load(InName: string): AIDataProvider;
    }
    
    class AIDataProvider_QueryParams extends UE.AIDataProvider {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParamName: string;
        FloatValue: number;
        IntValue: number;
        BoolValue: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIDataProvider_QueryParams;
        static Load(InName: string): AIDataProvider_QueryParams;
    }
    
    class AIDataProvider_Random extends UE.AIDataProvider_QueryParams {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Min: number;
        Max: number;
        bInteger: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIDataProvider_Random;
        static Load(InName: string): AIDataProvider_Random;
    }
    
    class AIGraph extends UE.EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GraphVersion: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIGraph;
        static Load(InName: string): AIGraph;
    }
    
    class GraphNodeClassData {
        constructor();
        constructor(AssetName: string, GeneratedClassPackage: string, ClassName: string, Category: string);
        AssetName: string;
        GeneratedClassPackage: string;
        ClassName: string;
        Category: string;
        static StaticClass(): Class;
    }
    
    class AIGraphNode extends UE.EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ClassData: UE.GraphNodeClassData;
        NodeInstance: UE.Object;
        ParentNode: UE.AIGraphNode;
        SubNodes: TArray<UE.AIGraphNode>;
        CopySubNodeIndex: number;
        bIsReadOnly: boolean;
        bIsSubNode: boolean;
        ErrorMessage: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIGraphNode;
        static Load(InName: string): AIGraphNode;
    }
    
    class EdGraphSchema extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphSchema;
        static Load(InName: string): EdGraphSchema;
    }
    
    class AIGraphSchema extends UE.EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIGraphSchema;
        static Load(InName: string): AIGraphSchema;
    }
    
    class AIHotSpotManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIHotSpotManager;
        static Load(InName: string): AIHotSpotManager;
    }
    
    enum EFilterInterpolationType { BSIT_Average, BSIT_Linear, BSIT_Cubic, BSIT_MAX}
    class InterpolationParameter {
        constructor();
        constructor(InterpolationTime: number, InterpolationType: UE.EFilterInterpolationType);
        InterpolationTime: number;
        InterpolationType: UE.EFilterInterpolationType;
        static StaticClass(): Class;
    }
    
    enum ENotifyTriggerMode { AllAnimations, HighestWeightedAnimation, None, ENotifyTriggerMode_MAX}
    class PerBoneInterpolation {
        constructor();
        constructor(BoneReference: UE.BoneReference, InterpolationSpeedPerSec: number);
        BoneReference: UE.BoneReference;
        InterpolationSpeedPerSec: number;
        static StaticClass(): Class;
    }
    
    class BlendSample {
        constructor();
        constructor(Animation: UE.AnimSequence, SampleValue: UE.Vector, RateScale: number, bSnapToGrid: boolean, bIsValid: boolean);
        Animation: UE.AnimSequence;
        SampleValue: UE.Vector;
        RateScale: number;
        bSnapToGrid: boolean;
        bIsValid: boolean;
        static StaticClass(): Class;
    }
    
    class EditorElement {
        constructor();
        constructor(Indices: FixSizeArray<number>, Weights: FixSizeArray<number>);
        Indices: FixSizeArray<number>;
        Weights: FixSizeArray<number>;
        static StaticClass(): Class;
    }
    
    class BlendParameter {
        constructor();
        constructor(DisplayName: string, Min: number, Max: number, GridNum: number);
        DisplayName: string;
        Min: number;
        Max: number;
        GridNum: number;
        static StaticClass(): Class;
    }
    
    class BlendSpaceBase extends UE.AnimationAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bRotationBlendInMeshSpace: boolean;
        PreviewBasePose: UE.AnimSequence;
        AnimLength: number;
        InterpolationParam: FixSizeArray<UE.InterpolationParameter>;
        TargetWeightInterpolationSpeedPerSec: number;
        NotifyTriggerMode: UE.ENotifyTriggerMode;
        PerBoneBlend: TArray<UE.PerBoneInterpolation>;
        SampleIndexWithMarkers: number;
        SampleData: TArray<UE.BlendSample>;
        GridSamples: TArray<UE.EditorElement>;
        BlendParameters: FixSizeArray<UE.BlendParameter>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlendSpaceBase;
        static Load(InName: string): BlendSpaceBase;
    }
    
    enum EBlendSpaceAxis { BSA_None, BSA_X, BSA_Y, BSA_Max, BSA_MAX}
    class BlendSpace extends UE.BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisToScaleAnimation: UE.EBlendSpaceAxis;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlendSpace;
        static Load(InName: string): BlendSpace;
    }
    
    class AimOffsetBlendSpace extends UE.BlendSpace {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AimOffsetBlendSpace;
        static Load(InName: string): AimOffsetBlendSpace;
    }
    
    class BlendSpace1D extends UE.BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDisplayEditorVertically: boolean;
        bScaleAnimation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlendSpace1D;
        static Load(InName: string): BlendSpace1D;
    }
    
    class AimOffsetBlendSpace1D extends UE.BlendSpace1D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AimOffsetBlendSpace1D;
        static Load(InName: string): AimOffsetBlendSpace1D;
    }
    
    class AutomatedAssetImportData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GroupName: string;
        Filenames: TArray<string>;
        DestinationPath: string;
        FactoryName: string;
        bReplaceExisting: boolean;
        bSkipReadOnly: boolean;
        Factory: UE.Factory;
        LevelToLoad: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomatedAssetImportData;
        static Load(InName: string): AutomatedAssetImportData;
    }
    
    class AssetImportTask extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Filename: string;
        DestinationPath: string;
        DestinationName: string;
        bReplaceExisting: boolean;
        bAutomated: boolean;
        bSave: boolean;
        Factory: UE.Factory;
        Options: UE.Object;
        ImportedObjectPaths: TArray<string>;
        Result: UE.Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetImportTask;
        static Load(InName: string): AssetImportTask;
    }
    
    class Factory extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCreateNew: boolean;
        SupportedClass: UE.Class;
        ContextClass: UE.Class;
        Formats: TArray<string>;
        bEditAfterNew: boolean;
        bEditorImport: boolean;
        bText: boolean;
        ImportPriority: number;
        AutomatedImportData: UE.AutomatedAssetImportData;
        AssetImportTask: UE.AssetImportTask;
        OverwriteYesOrNoToAllState: number;
        ScriptFactoryCanImport(Filename: string) : boolean;
        ScriptFactoryCreateFile(InTask: $Nullable<UE.AssetImportTask>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Factory;
        static Load(InName: string): Factory;
    }
    
    class BlendSpaceFactory1D extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeleton: UE.Skeleton;
        PreviewSkeletalMesh: UE.SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlendSpaceFactory1D;
        static Load(InName: string): BlendSpaceFactory1D;
    }
    
    class AimOffsetBlendSpaceFactory1D extends UE.BlendSpaceFactory1D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AimOffsetBlendSpaceFactory1D;
        static Load(InName: string): AimOffsetBlendSpaceFactory1D;
    }
    
    class BlendSpaceFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeleton: UE.Skeleton;
        PreviewSkeletalMesh: UE.SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlendSpaceFactoryNew;
        static Load(InName: string): BlendSpaceFactoryNew;
    }
    
    class AimOffsetBlendSpaceFactoryNew extends UE.BlendSpaceFactoryNew {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AimOffsetBlendSpaceFactoryNew;
        static Load(InName: string): AimOffsetBlendSpaceFactoryNew;
    }
    
    class AIPerceptionListenerInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIPerceptionListenerInterface;
        static Load(InName: string): AIPerceptionListenerInterface;
    }
    
    class AIPerceptionStimuliSourceComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoRegisterAsSource: boolean;
        RegisterAsSourceForSenses: TArray<UE.Class>;
        RegisterForSense(SenseClass: $Nullable<UE.Class>) : void;
        RegisterWithPerceptionSystem() : void;
        UnregisterFromPerceptionSystem() : void;
        UnregisterFromSense(SenseClass: $Nullable<UE.Class>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIPerceptionStimuliSourceComponent;
        static Load(InName: string): AIPerceptionStimuliSourceComponent;
    }
    
    class BehaviorTreeTemplateInfo {
        constructor();
        constructor(Asset: UE.BehaviorTree, Template: UE.BTCompositeNode);
        Asset: UE.BehaviorTree;
        Template: UE.BTCompositeNode;
        static StaticClass(): Class;
    }
    
    class GameplayTag {
        constructor();
        constructor(TagName: string);
        TagName: string;
        static StaticClass(): Class;
    }
    
    class BehaviorTreeComponent extends UE.BrainComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NodeInstances: TArray<UE.BTNode>;
        AddCooldownTagDuration(CooldownTag: UE.GameplayTag, CooldownDuration: number, bAddToExistingDuration: boolean) : void;
        GetTagCooldownEndTime(CooldownTag: UE.GameplayTag) : number;
        SetDynamicSubtree(InjectTag: UE.GameplayTag, BehaviorAsset: $Nullable<UE.BehaviorTree>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeComponent;
        static Load(InName: string): BehaviorTreeComponent;
    }
    
    class BehaviorTreeManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxDebuggerSteps: number;
        LoadedTemplates: TArray<UE.BehaviorTreeTemplateInfo>;
        ActiveComponents: TArray<UE.BehaviorTreeComponent>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeManager;
        static Load(InName: string): BehaviorTreeManager;
    }
    
    class EnvQueryNode extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VerNum: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryNode;
        static Load(InName: string): EnvQueryNode;
    }
    
    class EnvQueryGenerator extends UE.EnvQueryNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OptionName: string;
        ItemType: UE.Class;
        bAutoSortTests: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator;
        static Load(InName: string): EnvQueryGenerator;
    }
    
    enum EEnvTestPurpose { Filter, Score, FilterAndScore, EEnvTestPurpose_MAX}
    enum EEnvTestFilterOperator { AllPass, AnyPass, EEnvTestFilterOperator_MAX}
    enum EEnvTestScoreOperator { AverageScore, MinScore, MaxScore, Multiply, EEnvTestScoreOperator_MAX}
    enum EEnvTestFilterType { Minimum, Maximum, Range, Match, EEnvTestFilterType_MAX}
    class AIDataProviderValue {
        constructor();
        constructor(CachedProperty: UE.Property, DataBinding: UE.AIDataProvider, DataField: string);
        CachedProperty: UE.Property;
        DataBinding: UE.AIDataProvider;
        DataField: string;
        static StaticClass(): Class;
    }
    
    class AIDataProviderTypedValue extends UE.AIDataProviderValue {
        constructor();
        constructor(PropertyType: UE.Class);
        PropertyType: UE.Class;
        static StaticClass(): Class;
    }
    
    class AIDataProviderBoolValue extends UE.AIDataProviderTypedValue {
        constructor();
        constructor(DefaultValue: boolean);
        DefaultValue: boolean;
        static StaticClass(): Class;
    }
    
    class AIDataProviderFloatValue extends UE.AIDataProviderTypedValue {
        constructor();
        constructor(DefaultValue: number);
        DefaultValue: number;
        static StaticClass(): Class;
    }
    
    enum EEnvTestScoreEquation { Linear, Square, InverseLinear, SquareRoot, Constant, EEnvTestScoreEquation_MAX}
    enum EEnvQueryTestClamping { None, SpecifiedValue, FilterThreshold, EEnvQueryTestClamping_MAX}
    enum EEQSNormalizationType { Absolute, RelativeToScores, EEQSNormalizationType_MAX}
    class EnvQueryTest extends UE.EnvQueryNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TestOrder: number;
        TestPurpose: UE.EEnvTestPurpose;
        TestComment: string;
        MultipleContextFilterOp: UE.EEnvTestFilterOperator;
        MultipleContextScoreOp: UE.EEnvTestScoreOperator;
        FilterType: UE.EEnvTestFilterType;
        BoolValue: UE.AIDataProviderBoolValue;
        FloatValueMin: UE.AIDataProviderFloatValue;
        FloatValueMax: UE.AIDataProviderFloatValue;
        ScoringEquation: UE.EEnvTestScoreEquation;
        ClampMinType: UE.EEnvQueryTestClamping;
        ClampMaxType: UE.EEnvQueryTestClamping;
        NormalizationType: UE.EEQSNormalizationType;
        ScoreClampMin: UE.AIDataProviderFloatValue;
        ScoreClampMax: UE.AIDataProviderFloatValue;
        ScoringFactor: UE.AIDataProviderFloatValue;
        ReferenceValue: UE.AIDataProviderFloatValue;
        bDefineReferenceValue: boolean;
        bWorkOnFloatValues: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest;
        static Load(InName: string): EnvQueryTest;
    }
    
    class EnvQueryOption extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Generator: UE.EnvQueryGenerator;
        Tests: TArray<UE.EnvQueryTest>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryOption;
        static Load(InName: string): EnvQueryOption;
    }
    
    class EnvQuery extends UE.DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EdGraph: UE.EdGraph;
        QueryName: string;
        Options: TArray<UE.EnvQueryOption>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQuery;
        static Load(InName: string): EnvQuery;
    }
    
    class EnvQueryInstanceCache {
        constructor();
        constructor(Template: UE.EnvQuery);
        Template: UE.EnvQuery;
        static StaticClass(): Class;
    }
    
    class EnvQueryContext extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryContext;
        static Load(InName: string): EnvQueryContext;
    }
    
    enum EEnvQueryStatus { Processing, Success, Failed, Aborted, OwnerLost, MissingParam, EEnvQueryStatus_MAX}
    class EnvQueryInstanceBlueprintWrapper extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        QueryID: number;
        ItemType: UE.Class;
        OptionIndex: number;
        OnQueryFinishedEvent: $MulticastDelegate<(QueryInstance: $Nullable<UE.EnvQueryInstanceBlueprintWrapper>, QueryStatus: UE.EEnvQueryStatus) => void>;
        EQSQueryDoneSignature__DelegateSignature(QueryInstance: $Nullable<UE.EnvQueryInstanceBlueprintWrapper>, QueryStatus: UE.EEnvQueryStatus) : void;
        GetItemScore(ItemIndex: number) : number;
        GetQueryResultsAsActors(ResultActors: $Ref<TArray<UE.Actor>>) : boolean;
        GetQueryResultsAsLocations(ResultLocations: $Ref<TArray<UE.Vector>>) : boolean;
        GetResultsAsActors() : TArray<UE.Actor>;
        GetResultsAsLocations() : TArray<UE.Vector>;
        SetNamedParam(ParamName: string, Value: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryInstanceBlueprintWrapper;
        static Load(InName: string): EnvQueryInstanceBlueprintWrapper;
    }
    
    enum EEnvQueryRunMode { SingleResult, RandomBest5Pct, RandomBest25Pct, AllMatching, EEnvQueryRunMode_MAX}
    class EnvQueryManager extends UE.AISubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InstanceCache: TArray<UE.EnvQueryInstanceCache>;
        LocalContexts: TArray<UE.EnvQueryContext>;
        GCShieldedWrappers: TArray<UE.EnvQueryInstanceBlueprintWrapper>;
        MaxAllowedTestingTime: number;
        bTestQueriesUsingBreadth: boolean;
        QueryCountWarningThreshold: number;
        QueryCountWarningInterval: number;
        static RunEQSQuery(WorldContextObject: $Nullable<UE.Object>, QueryTemplate: $Nullable<UE.EnvQuery>, Querier: $Nullable<UE.Object>, RunMode: UE.EEnvQueryRunMode, WrapperClass: $Nullable<UE.Class>) : UE.EnvQueryInstanceBlueprintWrapper;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryManager;
        static Load(InName: string): EnvQueryManager;
    }
    
    class NavLocalGridManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AddLocalNavigationGridForBox(WorldContextObject: $Nullable<UE.Object>, Location: UE.Vector, Extent?: UE.Vector /* = 1.000000,1.000000,1.000000 */, Rotation?: UE.Rotator /* =  */, Radius2D?: number /* = 5 */, Height?: number /* = 100.000000 */, bRebuildGrids?: boolean /* = true */) : number;
        static AddLocalNavigationGridForCapsule(WorldContextObject: $Nullable<UE.Object>, Location: UE.Vector, CapsuleRadius: number, CapsuleHalfHeight: number, Radius2D?: number /* = 5 */, Height?: number /* = 100.000000 */, bRebuildGrids?: boolean /* = true */) : number;
        static AddLocalNavigationGridForPoint(WorldContextObject: $Nullable<UE.Object>, Location: UE.Vector, Radius2D?: number /* = 5 */, Height?: number /* = 100.000000 */, bRebuildGrids?: boolean /* = true */) : number;
        static AddLocalNavigationGridForPoints(WorldContextObject: $Nullable<UE.Object>, Locations: TArray<UE.Vector>, Radius2D?: number /* = 5 */, Height?: number /* = 100.000000 */, bRebuildGrids?: boolean /* = true */) : number;
        static FindLocalNavigationGridPath(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, PathPoints: $Ref<TArray<UE.Vector>>) : boolean;
        static RemoveLocalNavigationGrid(WorldContextObject: $Nullable<UE.Object>, GridId: number, bRebuildGrids?: boolean /* = true */) : void;
        static SetLocalNavigationGridDensity(WorldContextObject: $Nullable<UE.Object>, CellSize: number) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLocalGridManager;
        static Load(InName: string): NavLocalGridManager;
    }
    
    class AISystem extends UE.AISystemBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PerceptionSystemClassName: UE.SoftClassPath;
        HotSpotManagerClassName: UE.SoftClassPath;
        AcceptanceRadius: number;
        PathfollowingRegularPathPointAcceptanceRadius: number;
        PathfollowingNavLinkAcceptanceRadius: number;
        bFinishMoveOnGoalOverlap: boolean;
        bAcceptPartialPaths: boolean;
        bAllowStrafing: boolean;
        bEnableBTAITasks: boolean;
        bAllowControllersAsEQSQuerier: boolean;
        bEnableDebuggerPlugin: boolean;
        DefaultSightCollisionChannel: UE.ECollisionChannel;
        BehaviorTreeManager: UE.BehaviorTreeManager;
        EnvironmentQueryManager: UE.EnvQueryManager;
        PerceptionSystem: UE.AIPerceptionSystem;
        AllProxyObjects: TArray<UE.AIAsyncTaskBlueprintProxy>;
        HotSpotManager: UE.AIHotSpotManager;
        NavLocalGrids: UE.NavLocalGridManager;
        AIIgnorePlayers() : void;
        AILoggingVerbose() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISystem;
        static Load(InName: string): AISystem;
    }
    
    class AISubsystem extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AISystem: UE.AISystem;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISubsystem;
        static Load(InName: string): AISubsystem;
    }
    
    enum EAISenseNotifyType { OnEveryPerception, OnPerceptionChange, EAISenseNotifyType_MAX}
    class AISense extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultExpirationAge: number;
        NotifyType: UE.EAISenseNotifyType;
        bWantsNewPawnNotification: boolean;
        bAutoRegisterAllPawnsAsSources: boolean;
        PerceptionSystemInstance: UE.AIPerceptionSystem;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISense;
        static Load(InName: string): AISense;
    }
    
    class AISenseEvent extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseEvent;
        static Load(InName: string): AISenseEvent;
    }
    
    class AIPerceptionSystem extends UE.AISubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Senses: TArray<UE.AISense>;
        PerceptionAgingRate: number;
        OnPerceptionStimuliSourceEndPlay(Actor: $Nullable<UE.Actor>, EndPlayReason: UE.EEndPlayReason) : void;
        ReportEvent(PerceptionEvent: $Nullable<UE.AISenseEvent>) : void;
        static GetSenseClassForStimulus(WorldContextObject: $Nullable<UE.Object>, Stimulus: UE.AIStimulus) : UE.Class;
        static RegisterPerceptionStimuliSource(WorldContextObject: $Nullable<UE.Object>, Sense: $Nullable<UE.Class>, Target: $Nullable<UE.Actor>) : boolean;
        static ReportPerceptionEvent(WorldContextObject: $Nullable<UE.Object>, PerceptionEvent: $Nullable<UE.AISenseEvent>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIPerceptionSystem;
        static Load(InName: string): AIPerceptionSystem;
    }
    
    class GameplayTaskResource extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ManualResourceID: number;
        AutoResourceID: number;
        bManuallySetID: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTaskResource;
        static Load(InName: string): GameplayTaskResource;
    }
    
    class AIResource_Logic extends UE.GameplayTaskResource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIResource_Logic;
        static Load(InName: string): AIResource_Logic;
    }
    
    class AIResource_Movement extends UE.GameplayTaskResource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIResource_Movement;
        static Load(InName: string): AIResource_Movement;
    }
    
    class AIResourceInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIResourceInterface;
        static Load(InName: string): AIResourceInterface;
    }
    
    class AISense_Blueprint extends UE.AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ListenerDataType: UE.Class;
        ListenerContainer: TArray<UE.AIPerceptionComponent>;
        UnprocessedEvents: TArray<UE.AISenseEvent>;
        GetAllListenerActors(ListenerActors: $Ref<TArray<UE.Actor>>) : void;
        GetAllListenerComponents(ListenerComponents: $Ref<TArray<UE.AIPerceptionComponent>>) : void;
        K2_OnNewPawn(NewPawn: $Nullable<UE.Pawn>) : void;
        OnListenerRegistered(ActorListener: $Nullable<UE.Actor>, PerceptionComponent: $Nullable<UE.AIPerceptionComponent>) : void;
        OnListenerUnregistered(ActorListener: $Nullable<UE.Actor>, PerceptionComponent: $Nullable<UE.AIPerceptionComponent>) : void;
        OnListenerUpdated(ActorListener: $Nullable<UE.Actor>, PerceptionComponent: $Nullable<UE.AIPerceptionComponent>) : void;
        OnUpdate(EventsToProcess: TArray<UE.AISenseEvent>) : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISense_Blueprint;
        static Load(InName: string): AISense_Blueprint;
    }
    
    class AIDamageEvent {
        constructor();
        constructor(Amount: number, Location: UE.Vector, HitLocation: UE.Vector, DamagedActor: UE.Actor, Instigator: UE.Actor);
        Amount: number;
        Location: UE.Vector;
        HitLocation: UE.Vector;
        DamagedActor: UE.Actor;
        Instigator: UE.Actor;
        static StaticClass(): Class;
    }
    
    class AISense_Damage extends UE.AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RegisteredEvents: TArray<UE.AIDamageEvent>;
        static ReportDamageEvent(WorldContextObject: $Nullable<UE.Object>, DamagedActor: $Nullable<UE.Actor>, Instigator: $Nullable<UE.Actor>, DamageAmount: number, EventLocation: UE.Vector, HitLocation: UE.Vector) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISense_Damage;
        static Load(InName: string): AISense_Damage;
    }
    
    class AINoiseEvent {
        constructor();
        constructor(NoiseLocation: UE.Vector, Loudness: number, MaxRange: number, Instigator: UE.Actor, Tag: string);
        NoiseLocation: UE.Vector;
        Loudness: number;
        MaxRange: number;
        Instigator: UE.Actor;
        Tag: string;
        static StaticClass(): Class;
    }
    
    class AISense_Hearing extends UE.AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NoiseEvents: TArray<UE.AINoiseEvent>;
        SpeedOfSoundSq: number;
        static ReportNoiseEvent(WorldContextObject: $Nullable<UE.Object>, NoiseLocation: UE.Vector, Loudness?: number /* = 1.000000 */, Instigator?: UE.Actor /* = None */, MaxRange?: number /* = 0.000000 */, Tag?: string /* = "None" */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISense_Hearing;
        static Load(InName: string): AISense_Hearing;
    }
    
    class AIPredictionEvent {
        constructor();
        constructor(Requestor: UE.Actor, PredictedActor: UE.Actor);
        Requestor: UE.Actor;
        PredictedActor: UE.Actor;
        static StaticClass(): Class;
    }
    
    class AISense_Prediction extends UE.AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RegisteredEvents: TArray<UE.AIPredictionEvent>;
        static RequestControllerPredictionEvent(Requestor: $Nullable<UE.AIController>, PredictedActor: $Nullable<UE.Actor>, PredictionTime: number) : void;
        static RequestPawnPredictionEvent(Requestor: $Nullable<UE.Pawn>, PredictedActor: $Nullable<UE.Actor>, PredictionTime: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISense_Prediction;
        static Load(InName: string): AISense_Prediction;
    }
    
    class AISense_Sight extends UE.AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxTracesPerTick: number;
        MinQueriesPerTimeSliceCheck: number;
        MaxTimeSlicePerTick: number;
        HighImportanceQueryDistanceThreshold: number;
        MaxQueryImportance: number;
        SightLimitQueryImportance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISense_Sight;
        static Load(InName: string): AISense_Sight;
    }
    
    class AITeamStimulusEvent {
        constructor();
        constructor(Broadcaster: UE.Actor, Enemy: UE.Actor);
        Broadcaster: UE.Actor;
        Enemy: UE.Actor;
        static StaticClass(): Class;
    }
    
    class AISense_Team extends UE.AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RegisteredEvents: TArray<UE.AITeamStimulusEvent>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISense_Team;
        static Load(InName: string): AISense_Team;
    }
    
    class AITouchEvent {
        constructor();
        constructor(TouchReceiver: UE.Actor, OtherActor: UE.Actor);
        TouchReceiver: UE.Actor;
        OtherActor: UE.Actor;
        static StaticClass(): Class;
    }
    
    class AISense_Touch extends UE.AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RegisteredEvents: TArray<UE.AITouchEvent>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISense_Touch;
        static Load(InName: string): AISense_Touch;
    }
    
    class ScriptStruct extends UE.Struct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScriptStruct;
        static Load(InName: string): ScriptStruct;
    }
    
    enum EUserDefinedStructureStatus { UDSS_UpToDate, UDSS_Dirty, UDSS_Error, UDSS_Duplicate, UDSS_MAX}
    class UserDefinedStruct extends UE.ScriptStruct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PrimaryStruct: TWeakObjectPtr<UE.UserDefinedStruct>;
        ErrorMessage: string;
        EditorData: UE.Object;
        Status: UE.EUserDefinedStructureStatus;
        Guid: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserDefinedStruct;
        static Load(InName: string): UserDefinedStruct;
    }
    
    class AISenseBlueprintListener extends UE.UserDefinedStruct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseBlueprintListener;
        static Load(InName: string): AISenseBlueprintListener;
    }
    
    class AISenseConfig_Blueprint extends UE.AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Implementation: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Blueprint;
        static Load(InName: string): AISenseConfig_Blueprint;
    }
    
    class AISenseConfig_Damage extends UE.AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Implementation: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Damage;
        static Load(InName: string): AISenseConfig_Damage;
    }
    
    class AISenseAffiliationFilter {
        constructor();
        constructor(bDetectEnemies: boolean, bDetectNeutrals: boolean, bDetectFriendlies: boolean);
        bDetectEnemies: boolean;
        bDetectNeutrals: boolean;
        bDetectFriendlies: boolean;
        static StaticClass(): Class;
    }
    
    class AISenseConfig_Hearing extends UE.AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Implementation: UE.Class;
        HearingRange: number;
        LoSHearingRange: number;
        bUseLoSHearing: boolean;
        DetectionByAffiliation: UE.AISenseAffiliationFilter;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Hearing;
        static Load(InName: string): AISenseConfig_Hearing;
    }
    
    class AISenseConfig_Prediction extends UE.AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Prediction;
        static Load(InName: string): AISenseConfig_Prediction;
    }
    
    class AISenseConfig_Sight extends UE.AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Implementation: UE.Class;
        SightRadius: number;
        LoseSightRadius: number;
        PeripheralVisionAngleDegrees: number;
        DetectionByAffiliation: UE.AISenseAffiliationFilter;
        AutoSuccessRangeFromLastSeenLocation: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Sight;
        static Load(InName: string): AISenseConfig_Sight;
    }
    
    class AISenseConfig_Team extends UE.AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Team;
        static Load(InName: string): AISenseConfig_Team;
    }
    
    class AISenseConfig_Touch extends UE.AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Touch;
        static Load(InName: string): AISenseConfig_Touch;
    }
    
    class AISenseEvent_Damage extends UE.AISenseEvent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Event: UE.AIDamageEvent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseEvent_Damage;
        static Load(InName: string): AISenseEvent_Damage;
    }
    
    class AISenseEvent_Hearing extends UE.AISenseEvent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Event: UE.AINoiseEvent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseEvent_Hearing;
        static Load(InName: string): AISenseEvent_Hearing;
    }
    
    class AISightTargetInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISightTargetInterface;
        static Load(InName: string): AISightTargetInterface;
    }
    
    class AITask extends UE.GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OwnerController: UE.AIController;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AITask;
        static Load(InName: string): AITask;
    }
    
    class AITask_LockLogic extends UE.AITask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AITask_LockLogic;
        static Load(InName: string): AITask_LockLogic;
    }
    
    class AIMoveRequest {
        constructor();
        constructor(GoalActor: UE.Actor);
        GoalActor: UE.Actor;
        static StaticClass(): Class;
    }
    
    enum EAIOptionFlag { Default, Enable, Disable, MAX}
    class AITask_MoveTo extends UE.AITask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnRequestFailed: $MulticastDelegate<() => void>;
        OnMoveFinished: $MulticastDelegate<(Result: UE.EPathFollowingResult, AIController: $Nullable<UE.AIController>) => void>;
        MoveRequest: UE.AIMoveRequest;
        static AIMoveTo(Controller: $Nullable<UE.AIController>, GoalLocation: UE.Vector, GoalActor?: UE.Actor /* = None */, AcceptanceRadius?: number /* = -1.000000 */, StopOnOverlap?: UE.EAIOptionFlag /* = Default */, AcceptPartialPath?: UE.EAIOptionFlag /* = Default */, bUsePathfinding?: boolean /* = true */, bLockAILogic?: boolean /* = true */, bUseContinuosGoalTracking?: boolean /* = false */, ProjectGoalOnNavigation?: UE.EAIOptionFlag /* = Default */) : UE.AITask_MoveTo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AITask_MoveTo;
        static Load(InName: string): AITask_MoveTo;
    }
    
    class AITask_RunEQS extends UE.AITask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static RunEQS(Controller: $Nullable<UE.AIController>, QueryTemplate: $Nullable<UE.EnvQuery>) : UE.AITask_RunEQS;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AITask_RunEQS;
        static Load(InName: string): AITask_RunEQS;
    }
    
    class AlembicImportFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportSettings: UE.AbcImportSettings;
        bShowOption: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AlembicImportFactory;
        static Load(InName: string): AlembicImportFactory;
    }
    
    class Commandlet extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HelpDescription: string;
        HelpUsage: string;
        HelpWebLink: string;
        HelpParamNames: TArray<string>;
        HelpParamDescriptions: TArray<string>;
        IsServer: boolean;
        IsClient: boolean;
        IsEditor: boolean;
        LogToConsole: boolean;
        ShowErrorCount: boolean;
        ShowProgress: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Commandlet;
        static Load(InName: string): Commandlet;
    }
    
    class AlembicTestCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AlembicTestCommandlet;
        static Load(InName: string): AlembicTestCommandlet;
    }
    
    class AudioComponentParam {
        constructor();
        constructor(ParamName: string, FloatParam: number, BoolParam: boolean, IntParam: number, SoundWaveParam: UE.SoundWave);
        ParamName: string;
        FloatParam: number;
        BoolParam: boolean;
        IntParam: number;
        SoundWaveParam: UE.SoundWave;
        static StaticClass(): Class;
    }
    
    enum EAudioComponentPlayState { Playing, Stopped, Paused, FadingIn, FadingOut, Count, EAudioComponentPlayState_MAX}
    class SoundWaveSpectralData {
        constructor();
        constructor(FrequencyHz: number, Magnitude: number, NormalizedMagnitude: number);
        FrequencyHz: number;
        Magnitude: number;
        NormalizedMagnitude: number;
        static StaticClass(): Class;
    }
    
    class SoundWaveSpectralDataPerSound {
        constructor();
        constructor(SpectralData: TArray<UE.SoundWaveSpectralData>, PlaybackTime: number, SoundWave: UE.SoundWave);
        SpectralData: TArray<UE.SoundWaveSpectralData>;
        PlaybackTime: number;
        SoundWave: UE.SoundWave;
        static StaticClass(): Class;
    }
    
    class SoundWaveEnvelopeDataPerSound {
        constructor();
        constructor(Envelope: number, PlaybackTime: number, SoundWave: UE.SoundWave);
        Envelope: number;
        PlaybackTime: number;
        SoundWave: UE.SoundWave;
        static StaticClass(): Class;
    }
    
    enum EAudioFaderCurve { Linear, Logarithmic, SCurve, Sin, Count, EAudioFaderCurve_MAX}
    class AudioComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sound: UE.SoundBase;
        InstanceParameters: TArray<UE.AudioComponentParam>;
        SoundClassOverride: UE.SoundClass;
        bAutoDestroy: boolean;
        bStopWhenOwnerDestroyed: boolean;
        bShouldRemainActiveIfDropped: boolean;
        bAllowSpatialization: boolean;
        bOverrideAttenuation: boolean;
        bOverrideSubtitlePriority: boolean;
        bIsUISound: boolean;
        bEnableLowPassFilter: boolean;
        bOverridePriority: boolean;
        bSuppressSubtitles: boolean;
        bAutoManageAttachment: boolean;
        AudioComponentUserID: string;
        PitchModulationMin: number;
        PitchModulationMax: number;
        VolumeModulationMin: number;
        VolumeModulationMax: number;
        VolumeMultiplier: number;
        EnvelopeFollowerAttackTime: number;
        EnvelopeFollowerReleaseTime: number;
        Priority: number;
        SubtitlePriority: number;
        SourceEffectChain: UE.SoundEffectSourcePresetChain;
        VolumeWeightedPriorityScale: number;
        HighFrequencyGainMultiplier: number;
        PitchMultiplier: number;
        LowPassFilterFrequency: number;
        AttenuationSettings: UE.SoundAttenuation;
        AttenuationOverrides: UE.SoundAttenuationSettings;
        ConcurrencySettings: UE.SoundConcurrency;
        ConcurrencySet: TSet<UE.SoundConcurrency>;
        AutoAttachLocationRule: UE.EAttachmentRule;
        AutoAttachRotationRule: UE.EAttachmentRule;
        AutoAttachScaleRule: UE.EAttachmentRule;
        OnAudioFinished: $MulticastDelegate<() => void>;
        OnAudioPlaybackPercent: $MulticastDelegate<(PlayingSoundWave: $Nullable<UE.SoundWave>, PlaybackPercent: number) => void>;
        OnAudioSingleEnvelopeValue: $MulticastDelegate<(PlayingSoundWave: $Nullable<UE.SoundWave>, EnvelopeValue: number) => void>;
        OnAudioMultiEnvelopeValue: $MulticastDelegate<(AverageEnvelopeValue: number, MaxEnvelope: number, NumWaveInstances: number) => void>;
        Modulation: UE.SoundModulation;
        OnQueueSubtitles: $Delegate<(Subtitles: TArray<UE.SubtitleCue>, CueDuration: number) => void>;
        AutoAttachParent: TWeakObjectPtr<UE.SceneComponent>;
        AutoAttachSocketName: string;
        AdjustAttenuation(InAttenuationSettings: UE.SoundAttenuationSettings) : void;
        AdjustVolume(AdjustVolumeDuration: number, AdjustVolumeLevel: number, FadeCurve?: UE.EAudioFaderCurve /* = Linear */) : void;
        BP_GetAttenuationSettingsToApply(OutAttenuationSettings: $Ref<UE.SoundAttenuationSettings>) : boolean;
        FadeIn(FadeInDuration: number, FadeVolumeLevel?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, FadeCurve?: UE.EAudioFaderCurve /* = Linear */) : void;
        FadeOut(FadeOutDuration: number, FadeVolumeLevel: number, FadeCurve?: UE.EAudioFaderCurve /* = Linear */) : void;
        GetCookedEnvelopeData(OutEnvelopeData: $Ref<number>) : boolean;
        GetCookedEnvelopeDataForAllPlayingSounds(OutEnvelopeData: $Ref<TArray<UE.SoundWaveEnvelopeDataPerSound>>) : boolean;
        GetCookedFFTData(FrequenciesToGet: TArray<number>, OutSoundWaveSpectralData: $Ref<TArray<UE.SoundWaveSpectralData>>) : boolean;
        GetCookedFFTDataForAllPlayingSounds(OutSoundWaveSpectralData: $Ref<TArray<UE.SoundWaveSpectralDataPerSound>>) : boolean;
        GetPlayState() : UE.EAudioComponentPlayState;
        HasCookedAmplitudeEnvelopeData() : boolean;
        HasCookedFFTData() : boolean;
        IsPlaying() : boolean;
        Play(StartTime?: number /* = 0.000000 */) : void;
        SetBoolParameter(InName: string, InBool: boolean) : void;
        SetFloatParameter(InName: string, InFloat: number) : void;
        SetIntParameter(InName: string, InInt: number) : void;
        SetLowPassFilterEnabled(InLowPassFilterEnabled: boolean) : void;
        SetLowPassFilterFrequency(InLowPassFilterFrequency: number) : void;
        SetPaused(bPause: boolean) : void;
        SetPitchMultiplier(NewPitchMultiplier: number) : void;
        SetSound(NewSound: $Nullable<UE.SoundBase>) : void;
        SetSourceBusSendPostEffect(SoundSourceBus: $Nullable<UE.SoundSourceBus>, SourceBusSendLevel: number) : void;
        SetSourceBusSendPreEffect(SoundSourceBus: $Nullable<UE.SoundSourceBus>, SourceBusSendLevel: number) : void;
        SetSubmixSend(Submix: $Nullable<UE.SoundSubmix>, SendLevel: number) : void;
        SetUISound(bInUISound: boolean) : void;
        SetVolumeMultiplier(NewVolumeMultiplier: number) : void;
        SetWaveParameter(InName: string, InWave: $Nullable<UE.SoundWave>) : void;
        Stop() : void;
        StopDelayed(DelayTime: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioComponent;
        static Load(InName: string): AudioComponent;
    }
    
    class AmbientSound extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AudioComponent: UE.AudioComponent;
        AdjustVolume(AdjustVolumeDuration: number, AdjustVolumeLevel: number) : void;
        FadeIn(FadeInDuration: number, FadeVolumeLevel?: number /* = 1.000000 */) : void;
        FadeOut(FadeOutDuration: number, FadeVolumeLevel: number) : void;
        Play(StartTime?: number /* = 0.000000 */) : void;
        Stop() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AmbientSound;
        static Load(InName: string): AmbientSound;
    }
    
    class AnalyticsPrivacySettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bSendUsageData: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnalyticsPrivacySettings;
        static Load(InName: string): AnalyticsPrivacySettings;
    }
    
    class AndroidFileMediaSourceFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AndroidFileMediaSourceFactory;
        static Load(InName: string): AndroidFileMediaSourceFactory;
    }
    
    class AndroidMediaSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CacheableVideoSampleBuffers: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AndroidMediaSettings;
        static Load(InName: string): AndroidMediaSettings;
    }
    
    class AndroidPermissionCallbackProxy extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnPermissionsGrantedDynamicDelegate: $MulticastDelegate<(Permissions: TArray<string>, GrantResults: TArray<boolean>) => void>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AndroidPermissionCallbackProxy;
        static Load(InName: string): AndroidPermissionCallbackProxy;
    }
    
    class AndroidPermissionFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AcquirePermissions(permissions: TArray<string>) : UE.AndroidPermissionCallbackProxy;
        static CheckPermission(permission: string) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AndroidPermissionFunctionLibrary;
        static Load(InName: string): AndroidPermissionFunctionLibrary;
    }
    
    enum EAndroidInstallLocation { InternalOnly, PreferExternal, Auto, EAndroidInstallLocation_MAX}
    enum EAndroidScreenOrientation { Portrait, ReversePortrait, SensorPortrait, Landscape, ReverseLandscape, SensorLandscape, Sensor, FullSensor, EAndroidScreenOrientation_MAX}
    enum EAndroidDepthBufferPreference { Default, Bits16, Bits24, Bits32, EAndroidDepthBufferPreference_MAX}
    enum EOculusMobileDevice { GearGo, Quest, EOculusMobileDevice_MAX}
    enum EGoogleVRCaps { Cardboard, Daydream33, Daydream63, Daydream66, EGoogleVRCaps_MAX}
    class GooglePlayAchievementMapping {
        constructor();
        constructor(Name: string, AchievementID: string);
        Name: string;
        AchievementID: string;
        static StaticClass(): Class;
    }
    
    class GooglePlayLeaderboardMapping {
        constructor();
        constructor(Name: string, LeaderboardID: string);
        Name: string;
        LeaderboardID: string;
        static StaticClass(): Class;
    }
    
    enum EAndroidAudio { Default, OGG, ADPCM, EAndroidAudio_MAX}
    class PlatformRuntimeAudioCompressionOverrides {
        constructor();
        constructor(bOverrideCompressionTimes: boolean, DurationThreshold: number, MaxNumRandomBranches: number, SoundCueQualityIndex: number);
        bOverrideCompressionTimes: boolean;
        DurationThreshold: number;
        MaxNumRandomBranches: number;
        SoundCueQualityIndex: number;
        static StaticClass(): Class;
    }
    
    enum EAndroidGraphicsDebugger { None, Mali, Adreno, EAndroidGraphicsDebugger_MAX}
    class DirectoryPath {
        constructor();
        constructor(Path: string);
        Path: string;
        static StaticClass(): Class;
    }
    
    class AndroidRuntimeSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PackageName: string;
        StoreVersion: number;
        StoreVersionOffsetArmV7: number;
        StoreVersionOffsetArm64: number;
        StoreVersionOffsetX8664: number;
        ApplicationDisplayName: string;
        VersionDisplayName: string;
        MinSDKVersion: number;
        TargetSDKVersion: number;
        InstallLocation: UE.EAndroidInstallLocation;
        bEnableGradle: boolean;
        bEnableLint: boolean;
        bPackageDataInsideApk: boolean;
        bCreateAllPlatformsInstall: boolean;
        bDisableVerifyOBBOnStartUp: boolean;
        bAllowLargeOBBFiles: boolean;
        bAllowPatchOBBFile: boolean;
        bUseExternalFilesDir: boolean;
        bPublicLogFiles: boolean;
        Orientation: UE.EAndroidScreenOrientation;
        MaxAspectRatio: number;
        bUseDisplayCutout: boolean;
        bRestoreNotificationsOnReboot: boolean;
        bFullScreen: boolean;
        bEnableNewKeyboard: boolean;
        DepthBufferPreference: UE.EAndroidDepthBufferPreference;
        bValidateTextureFormats: boolean;
        ExtraManifestNodeTags: TArray<string>;
        ExtraApplicationNodeTags: TArray<string>;
        ExtraApplicationSettings: string;
        ExtraActivityNodeTags: TArray<string>;
        ExtraActivitySettings: string;
        ExtraPermissions: TArray<string>;
        bAndroidVoiceEnabled: boolean;
        PackageForOculusMobile: TArray<UE.EOculusMobileDevice>;
        bRemoveOSIG: boolean;
        GoogleVRCaps: TArray<UE.EGoogleVRCaps>;
        bGoogleVRSustainedPerformance: boolean;
        KeyStore: string;
        KeyAlias: string;
        KeyStorePassword: string;
        KeyPassword: string;
        bBuildForArmV7: boolean;
        bBuildForArm64: boolean;
        bBuildForX8664: boolean;
        bBuildForES2: boolean;
        bBuildForES31: boolean;
        bSupportsVulkan: boolean;
        bDetectVulkanByDefault: boolean;
        bBuildWithHiddenSymbolVisibility: boolean;
        bSaveSymbols: boolean;
        bEnableGooglePlaySupport: boolean;
        bUseGetAccounts: boolean;
        GamesAppID: string;
        AchievementMap: TArray<UE.GooglePlayAchievementMapping>;
        LeaderboardMap: TArray<UE.GooglePlayLeaderboardMapping>;
        bEnableSnapshots: boolean;
        bSupportAdMob: boolean;
        AdMobAdUnitID: string;
        AdMobAdUnitIDs: TArray<string>;
        GooglePlayLicenseKey: string;
        GCMClientSenderID: string;
        bShowLaunchImage: boolean;
        bAllowIMU: boolean;
        bAllowControllers: boolean;
        bBlockAndroidKeysOnControllers: boolean;
        AndroidAudio: UE.EAndroidAudio;
        AudioSampleRate: number;
        AudioCallbackBufferFrameSize: number;
        AudioNumBuffersToEnqueue: number;
        AudioMaxChannels: number;
        AudioNumSourceWorkers: number;
        SpatializationPlugin: string;
        ReverbPlugin: string;
        OcclusionPlugin: string;
        CompressionOverrides: UE.PlatformRuntimeAudioCompressionOverrides;
        ChunkSizeKB: number;
        bUseAudioStreamCaching: boolean;
        CacheSizeKB: number;
        bResampleForDevice: boolean;
        SoundCueCookQualityIndex: number;
        MaxSampleRate: number;
        HighSampleRate: number;
        MedSampleRate: number;
        LowSampleRate: number;
        MinSampleRate: number;
        CompressionQualityModifier: number;
        AutoStreamingThreshold: number;
        AndroidGraphicsDebugger: UE.EAndroidGraphicsDebugger;
        MaliGraphicsDebuggerPath: UE.DirectoryPath;
        bMultiTargetFormat_ETC1: boolean;
        bMultiTargetFormat_ETC1a: boolean;
        bMultiTargetFormat_ETC2: boolean;
        bMultiTargetFormat_DXT: boolean;
        bMultiTargetFormat_PVRTC: boolean;
        bMultiTargetFormat_ATC: boolean;
        bMultiTargetFormat_ASTC: boolean;
        TextureFormatPriority_ETC1: number;
        TextureFormatPriority_ETC1a: number;
        TextureFormatPriority_ETC2: number;
        TextureFormatPriority_DXT: number;
        TextureFormatPriority_PVRTC: number;
        TextureFormatPriority_ATC: number;
        TextureFormatPriority_ASTC: number;
        SDKAPILevelOverride: string;
        NDKAPILevelOverride: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AndroidRuntimeSettings;
        static Load(InName: string): AndroidRuntimeSettings;
    }
    
    class AndroidSDKSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SDKPath: UE.DirectoryPath;
        NDKPath: UE.DirectoryPath;
        JavaPath: UE.DirectoryPath;
        SDKAPILevel: string;
        NDKAPILevel: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AndroidSDKSettings;
        static Load(InName: string): AndroidSDKSettings;
    }
    
    namespace Game.Blueprints.TypeScript.Animal {
        class Animal_C extends UE.Actor {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            UberGraphFrame: UE.PointerToUberGraphFrame;
            DefaultSceneRoot: UE.SceneComponent;
            Age: number;
            ExecuteUbergraph_Animal(EntryPoint: number) : void;
            ReceiveBeginPlay() : void;
            Speak() : void;
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): Animal_C;
            static Load(InName: string): Animal_C;
        }
        
    }

    class AnimationBlueprintEditorOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bHideUnrelatedNodes: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationBlueprintEditorOptions;
        static Load(InName: string): AnimationBlueprintEditorOptions;
    }
    
    enum ERawCurveTrackTypes { RCT_Float, RCT_Vector, RCT_Transform, RCT_MAX}
    class AnimationBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AddAnimationNotifyEvent(AnimationSequence: $Nullable<UE.AnimSequence>, NotifyTrackName: string, StartTime: number, NotifyClass: $Nullable<UE.Class>) : UE.AnimNotify;
        static AddAnimationNotifyEventObject(AnimationSequence: $Nullable<UE.AnimSequence>, StartTime: number, Notify: $Nullable<UE.AnimNotify>, NotifyTrackName: string) : void;
        static AddAnimationNotifyStateEvent(AnimationSequence: $Nullable<UE.AnimSequence>, NotifyTrackName: string, StartTime: number, Duration: number, NotifyStateClass: $Nullable<UE.Class>) : UE.AnimNotifyState;
        static AddAnimationNotifyStateEventObject(AnimationSequence: $Nullable<UE.AnimSequence>, StartTime: number, Duration: number, NotifyState: $Nullable<UE.AnimNotifyState>, NotifyTrackName: string) : void;
        static AddAnimationNotifyTrack(AnimationSequence: $Nullable<UE.AnimSequence>, NotifyTrackName: string, TrackColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */) : void;
        static AddAnimationSyncMarker(AnimationSequence: $Nullable<UE.AnimSequence>, MarkerName: string, Time: number, NotifyTrackName: string) : void;
        static AddCurve(AnimationSequence: $Nullable<UE.AnimSequence>, CurveName: string, CurveType?: UE.ERawCurveTrackTypes /* = RCT_Float */, bMetaDataCurve?: boolean /* = false */) : void;
        static AddFloatCurveKey(AnimationSequence: $Nullable<UE.AnimSequence>, CurveName: string, Time: number, Value: number) : void;
        static AddFloatCurveKeys(AnimationSequence: $Nullable<UE.AnimSequence>, CurveName: string, Times: TArray<number>, Values: TArray<number>) : void;
        static AddMetaData(AnimationSequence: $Nullable<UE.AnimSequence>, MetaDataClass: $Nullable<UE.Class>, MetaDataInstance: UE.AnimMetaData) : void;
        static AddMetaDataObject(AnimationSequence: $Nullable<UE.AnimSequence>, MetaDataObject: $Nullable<UE.AnimMetaData>) : void;
        static AddTransformationCurveKey(AnimationSequence: $Nullable<UE.AnimSequence>, CurveName: string, Time: number, Transform: UE.Transform) : void;
        static AddTransformationCurveKeys(AnimationSequence: $Nullable<UE.AnimSequence>, CurveName: string, Times: TArray<number>, Transforms: TArray<UE.Transform>) : void;
        static AddVectorCurveKey(AnimationSequence: $Nullable<UE.AnimSequence>, CurveName: string, Time: number, Vector: UE.Vector) : void;
        static AddVectorCurveKeys(AnimationSequence: $Nullable<UE.AnimSequence>, CurveName: string, Times: TArray<number>, Vectors: TArray<UE.Vector>) : void;
        static AddVirtualBone(AnimationSequence: $Nullable<UE.AnimSequence>, SourceBoneName: string, TargetBoneName: string, VirtualBoneName: $Ref<string>) : void;
        static ContainsMetaDataOfClass(AnimationSequence: $Nullable<UE.AnimSequence>, MetaDataClass: $Nullable<UE.Class>) : boolean;
        static CopyAnimNotifiesFromSequence(SrcAnimSequence: $Nullable<UE.AnimSequence>, DestAnimSequence: $Nullable<UE.AnimSequence>) : void;
        static DoesBoneNameExist(AnimationSequence: $Nullable<UE.AnimSequence>, BoneName: string, bExists: $Ref<boolean>) : void;
        static DoesCurveExist(AnimationSequence: $Nullable<UE.AnimSequence>, CurveName: string, CurveType: UE.ERawCurveTrackTypes) : boolean;
        static FinalizeBoneAnimation(AnimationSequence: $Nullable<UE.AnimSequence>) : void;
        static FindBonePathToRoot(AnimationSequence: $Nullable<UE.AnimSequence>, BoneName: string, BonePath: $Ref<TArray<string>>) : void;
        static GetAdditiveAnimationType(AnimationSequence: $Nullable<UE.AnimSequence>, AdditiveAnimationType: $Ref<UE.EAdditiveAnimationType>) : void;
        static GetAdditiveBasePoseType(AnimationSequence: $Nullable<UE.AnimSequence>, AdditiveBasePoseType: $Ref<UE.EAdditiveBasePoseType>) : void;
        static GetAnimationInterpolationType(AnimationSequence: $Nullable<UE.AnimSequence>, InterpolationType: $Ref<UE.EAnimInterpolationType>) : void;
        static GetAnimationNotifyEventNames(AnimationSequence: $Nullable<UE.AnimSequence>, EventNames: $Ref<TArray<string>>) : void;
        static GetAnimationNotifyEvents(AnimationSequence: $Nullable<UE.AnimSequence>, NotifyEvents: $Ref<TArray<UE.AnimNotifyEvent>>) : void;
        static GetAnimationNotifyEventsForTrack(AnimationSequence: $Nullable<UE.AnimSequence>, NotifyTrackName: string, Events: $Ref<TArray<UE.AnimNotifyEvent>>) : void;
        static GetAnimationNotifyTrackNames(AnimationSequence: $Nullable<UE.AnimSequence>, TrackNames: $Ref<TArray<string>>) : void;
        static GetAnimationSyncMarkers(AnimationSequence: $Nullable<UE.AnimSequence>, Markers: $Ref<TArray<UE.AnimSyncMarker>>) : void;
        static GetAnimationSyncMarkersForTrack(AnimationSequence: $Nullable<UE.AnimSequence>, NotifyTrackName: string, Markers: $Ref<TArray<UE.AnimSyncMarker>>) : void;
        static GetAnimationTrackNames(AnimationSequence: $Nullable<UE.AnimSequence>, TrackNames: $Ref<TArray<string>>) : void;
        static GetAnimNotifyEventTriggerTime(NotifyEvent: UE.AnimNotifyEvent) : number;
        static GetBonePoseForFrame(AnimationSequence: $Nullable<UE.AnimSequence>, BoneName: string, Frame: number, bExtractRootMotion: boolean, Pose: $Ref<UE.Transform>) : void;
        static GetBonePoseForTime(AnimationSequence: $Nullable<UE.AnimSequence>, BoneName: string, Time: number, bExtractRootMotion: boolean, Pose: $Ref<UE.Transform>) : void;
        static GetBonePosesForFrame(AnimationSequence: $Nullable<UE.AnimSequence>, BoneNames: TArray<string>, Frame: number, bExtractRootMotion: boolean, Poses: $Ref<TArray<UE.Transform>>, PreviewMesh?: UE.SkeletalMesh /* = None */) : void;
        static GetBonePosesForTime(AnimationSequence: $Nullable<UE.AnimSequence>, BoneNames: TArray<string>, Time: number, bExtractRootMotion: boolean, Poses: $Ref<TArray<UE.Transform>>, PreviewMesh?: UE.SkeletalMesh /* = None */) : void;
        static GetCompressionScheme(AnimationSequence: $Nullable<UE.AnimSequence>, CompressionScheme: $Ref<UE.AnimCompress>) : void;
        static GetFloatKeys(AnimationSequence: $Nullable<UE.AnimSequence>, CurveName: string, Times: $Ref<TArray<number>>, Values: $Ref<TArray<number>>) : void;
        static GetFrameAtTime(AnimationSequence: $Nullable<UE.AnimSequence>, Time: number, Frame: $Ref<number>) : void;
        static GetMetaData(AnimationSequence: $Nullable<UE.AnimSequence>, MetaData: TArray<UE.AnimMetaData>) : void;
        static GetMetaDataOfClass(AnimationSequence: $Nullable<UE.AnimSequence>, MetaDataClass: $Nullable<UE.Class>, MetaDataOfClass: TArray<UE.AnimMetaData>) : void;
        static GetNumFrames(AnimationSequence: $Nullable<UE.AnimSequence>, NumFrames: $Ref<number>) : void;
        static GetRateScale(AnimationSequence: $Nullable<UE.AnimSequence>, RateScale: $Ref<number>) : void;
        static GetRawTrackData(AnimationSequence: $Nullable<UE.AnimSequence>, TrackName: string, PositionKeys: $Ref<TArray<UE.Vector>>, RotationKeys: $Ref<TArray<UE.Quat>>, ScalingKeys: $Ref<TArray<UE.Vector>>) : void;
        static GetRawTrackPositionData(AnimationSequence: $Nullable<UE.AnimSequence>, TrackName: string, PositionData: $Ref<TArray<UE.Vector>>) : void;
        static GetRawTrackRotationData(AnimationSequence: $Nullable<UE.AnimSequence>, TrackName: string, RotationData: $Ref<TArray<UE.Quat>>) : void;
        static GetRawTrackScaleData(AnimationSequence: $Nullable<UE.AnimSequence>, TrackName: string, ScaleData: $Ref<TArray<UE.Vector>>) : void;
        static GetRootMotionLockType(AnimationSequence: $Nullable<UE.AnimSequence>, LockType: $Ref<UE.ERootMotionRootLock>) : void;
        static GetSequenceLength(AnimationSequence: $Nullable<UE.AnimSequence>, Length: $Ref<number>) : void;
        static GetTimeAtFrame(AnimationSequence: $Nullable<UE.AnimSequence>, Frame: number, Time: $Ref<number>) : void;
        static GetTransformationKeys(AnimationSequence: $Nullable<UE.AnimSequence>, CurveName: string, Times: $Ref<TArray<number>>, Values: $Ref<TArray<UE.Transform>>) : void;
        static GetUniqueMarkerNames(AnimationSequence: $Nullable<UE.AnimSequence>, MarkerNames: $Ref<TArray<string>>) : void;
        static GetVectorKeys(AnimationSequence: $Nullable<UE.AnimSequence>, CurveName: string, Times: $Ref<TArray<number>>, Values: $Ref<TArray<UE.Vector>>) : void;
        static IsRootMotionEnabled(AnimationSequence: $Nullable<UE.AnimSequence>) : boolean;
        static IsRootMotionLockForced(AnimationSequence: $Nullable<UE.AnimSequence>) : boolean;
        static IsValidAnimationSyncMarkerName(AnimationSequence: $Nullable<UE.AnimSequence>, MarkerName: string) : boolean;
        static IsValidAnimNotifyTrackName(AnimationSequence: $Nullable<UE.AnimSequence>, NotifyTrackName: string) : boolean;
        static IsValidRawAnimationTrackName(AnimationSequence: $Nullable<UE.AnimSequence>, TrackName: string) : boolean;
        static IsValidTime(AnimationSequence: $Nullable<UE.AnimSequence>, Time: number, IsValid: $Ref<boolean>) : void;
        static RemoveAllAnimationNotifyTracks(AnimationSequence: $Nullable<UE.AnimSequence>) : void;
        static RemoveAllAnimationSyncMarkers(AnimationSequence: $Nullable<UE.AnimSequence>) : void;
        static RemoveAllBoneAnimation(AnimationSequence: $Nullable<UE.AnimSequence>) : void;
        static RemoveAllCurveData(AnimationSequence: $Nullable<UE.AnimSequence>) : void;
        static RemoveAllMetaData(AnimationSequence: $Nullable<UE.AnimSequence>) : void;
        static RemoveAllVirtualBones(AnimationSequence: $Nullable<UE.AnimSequence>) : void;
        static RemoveAnimationNotifyEventsByName(AnimationSequence: $Nullable<UE.AnimSequence>, NotifyName: string) : number;
        static RemoveAnimationNotifyEventsByTrack(AnimationSequence: $Nullable<UE.AnimSequence>, NotifyTrackName: string) : number;
        static RemoveAnimationNotifyTrack(AnimationSequence: $Nullable<UE.AnimSequence>, NotifyTrackName: string) : void;
        static RemoveAnimationSyncMarkersByName(AnimationSequence: $Nullable<UE.AnimSequence>, MarkerName: string) : number;
        static RemoveAnimationSyncMarkersByTrack(AnimationSequence: $Nullable<UE.AnimSequence>, NotifyTrackName: string) : number;
        static RemoveBoneAnimation(AnimationSequence: $Nullable<UE.AnimSequence>, BoneName: string, bIncludeChildren?: boolean /* = true */, bFinalize?: boolean /* = true */) : void;
        static RemoveCurve(AnimationSequence: $Nullable<UE.AnimSequence>, CurveName: string, bRemoveNameFromSkeleton?: boolean /* = false */) : void;
        static RemoveMetaData(AnimationSequence: $Nullable<UE.AnimSequence>, MetaDataObject: $Nullable<UE.AnimMetaData>) : void;
        static RemoveMetaDataOfClass(AnimationSequence: $Nullable<UE.AnimSequence>, MetaDataClass: $Nullable<UE.Class>) : void;
        static RemoveVirtualBone(AnimationSequence: $Nullable<UE.AnimSequence>, VirtualBoneName: string) : void;
        static RemoveVirtualBones(AnimationSequence: $Nullable<UE.AnimSequence>, VirtualBoneNames: TArray<string>) : void;
        static ReplaceAnimNotifies(AnimationSequence: $Nullable<UE.AnimSequenceBase>, OldNotifyClass: $Nullable<UE.Class>, NewNotifyClass: $Nullable<UE.Class>, OnNotifyReplaced: $Delegate<(OldNotify: $Nullable<UE.AnimNotify>, NewNotify: $Nullable<UE.AnimNotify>) => void>) : void;
        static ReplaceAnimNotifyStates(AnimationSequence: $Nullable<UE.AnimSequenceBase>, OldNotifyClass: $Nullable<UE.Class>, NewNotifyClass: $Nullable<UE.Class>, OnNotifyStateReplaced: $Delegate<(OldNotifyState: $Nullable<UE.AnimNotifyState>, NewNotifyState: $Nullable<UE.AnimNotifyState>) => void>) : void;
        static SetAdditiveAnimationType(AnimationSequence: $Nullable<UE.AnimSequence>, AdditiveAnimationType: UE.EAdditiveAnimationType) : void;
        static SetAdditiveBasePoseType(AnimationSequence: $Nullable<UE.AnimSequence>, AdditiveBasePoseType: UE.EAdditiveBasePoseType) : void;
        static SetAnimationInterpolationType(AnimationSequence: $Nullable<UE.AnimSequence>, InterpolationType: UE.EAnimInterpolationType) : void;
        static SetCompressionScheme(AnimationSequence: $Nullable<UE.AnimSequence>, CompressionScheme: $Nullable<UE.AnimCompress>) : void;
        static SetIsRootMotionLockForced(AnimationSequence: $Nullable<UE.AnimSequence>, bForced: boolean) : void;
        static SetRateScale(AnimationSequence: $Nullable<UE.AnimSequence>, RateScale: number) : void;
        static SetRootMotionEnabled(AnimationSequence: $Nullable<UE.AnimSequence>, bEnabled: boolean) : void;
        static SetRootMotionLockType(AnimationSequence: $Nullable<UE.AnimSequence>, RootMotionLockType: UE.ERootMotionRootLock) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationBlueprintLibrary;
        static Load(InName: string): AnimationBlueprintLibrary;
    }
    
    class BlueprintCallableFunctionRedirect {
        constructor();
        constructor(ClassName: string, OldFunctionName: string, NewFunctionName: string, BlueprintParamName: string, ClassParamName: string);
        ClassName: string;
        OldFunctionName: string;
        NewFunctionName: string;
        BlueprintParamName: string;
        ClassParamName: string;
        static StaticClass(): Class;
    }
    
    class EdGraphSchema_K2 extends UE.EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditoronlyBPFunctionRedirects: TArray<UE.BlueprintCallableFunctionRedirect>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphSchema_K2;
        static Load(InName: string): EdGraphSchema_K2;
    }
    
    class AnimationConduitGraphSchema extends UE.EdGraphSchema_K2 {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationConduitGraphSchema;
        static Load(InName: string): AnimationConduitGraphSchema;
    }
    
    class AnimationGraph extends UE.EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlendOptions: UE.AnimGraphBlendOptions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationGraph;
        static Load(InName: string): AnimationGraph;
    }
    
    class K2Node extends UE.EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node;
        static Load(InName: string): K2Node;
    }
    
    class OptionalPinFromProperty {
        constructor();
        constructor(PropertyName: string, PropertyFriendlyName: string, PropertyTooltip: string, CategoryName: string, bShowPin: boolean, bCanToggleVisibility: boolean, bPropertyIsCustomized: boolean, bHasOverridePin: boolean, bIsMarkedForAdvancedDisplay: boolean, bIsOverrideEnabled: boolean, bIsSetValuePinVisible: boolean, bIsOverridePinVisible: boolean);
        PropertyName: string;
        PropertyFriendlyName: string;
        PropertyTooltip: string;
        CategoryName: string;
        bShowPin: boolean;
        bCanToggleVisibility: boolean;
        bPropertyIsCustomized: boolean;
        bHasOverridePin: boolean;
        bIsMarkedForAdvancedDisplay: boolean;
        bIsOverrideEnabled: boolean;
        bIsSetValuePinVisible: boolean;
        bIsOverridePinVisible: boolean;
        static StaticClass(): Class;
    }
    
    enum EBlueprintUsage { NoProperties, DoesNotUseBlueprint, UsesBlueprint, EBlueprintUsage_MAX}
    class AnimGraphNode_Base extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShowPinForProperties: TArray<UE.OptionalPinFromProperty>;
        BlueprintUsage: UE.EBlueprintUsage;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Base;
        static Load(InName: string): AnimGraphNode_Base;
    }
    
    class AnimNode_Base {
        constructor();
        static StaticClass(): Class;
    }
    
    class PoseLinkBase {
        constructor();
        constructor(LinkID: number, SourceLinkID: number);
        LinkID: number;
        SourceLinkID: number;
        static StaticClass(): Class;
    }
    
    class PoseLink extends UE.PoseLinkBase {
        constructor();
        static StaticClass(): Class;
    }
    
    class AnimNode_Root extends UE.AnimNode_Base {
        constructor();
        constructor(Result: UE.PoseLink, Name: string, Group: string);
        Result: UE.PoseLink;
        Name: string;
        Group: string;
        static StaticClass(): Class;
    }
    
    class AnimNode_StateResult extends UE.AnimNode_Root {
        constructor();
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_StateResult extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_StateResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_StateResult;
        static Load(InName: string): AnimGraphNode_StateResult;
    }
    
    class AnimGraphNode_CustomTransitionResult extends UE.AnimGraphNode_StateResult {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CustomTransitionResult;
        static Load(InName: string): AnimGraphNode_CustomTransitionResult;
    }
    
    class AnimationCustomTransitionGraph extends UE.AnimationGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MyResultNode: UE.AnimGraphNode_CustomTransitionResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationCustomTransitionGraph;
        static Load(InName: string): AnimationCustomTransitionGraph;
    }
    
    class AnimationGraphSchema extends UE.EdGraphSchema_K2 {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PN_SequenceName: string;
        NAME_NeverAsPin: string;
        NAME_PinHiddenByDefault: string;
        NAME_PinShownByDefault: string;
        NAME_AlwaysAsPin: string;
        NAME_CustomizeProperty: string;
        NAME_OnEvaluate: string;
        DefaultEvaluationHandlerName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationGraphSchema;
        static Load(InName: string): AnimationGraphSchema;
    }
    
    class AnimationCustomTransitionSchema extends UE.AnimationGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationCustomTransitionSchema;
        static Load(InName: string): AnimationCustomTransitionSchema;
    }
    
    class AnimationDataSourceRegistry extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DataSources: TMap<string, UE.Object>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationDataSourceRegistry;
        static Load(InName: string): AnimationDataSourceRegistry;
    }
    
    class AnimationEditorPreviewActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationEditorPreviewActor;
        static Load(InName: string): AnimationEditorPreviewActor;
    }
    
    class AnimationModifier extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RevisionGuid: UE.Guid;
        AppliedGuid: UE.Guid;
        StoredNativeRevision: number;
        PreviouslyAppliedModifier: UE.AnimationModifier;
        OnApply(AnimationSequence: $Nullable<UE.AnimSequence>) : void;
        OnRevert(AnimationSequence: $Nullable<UE.AnimSequence>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationModifier;
        static Load(InName: string): AnimationModifier;
    }
    
    class AnimationModifiersAssetUserData extends UE.AssetUserData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimationModifierInstances: TArray<UE.AnimationModifier>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationModifiersAssetUserData;
        static Load(InName: string): AnimationModifiersAssetUserData;
    }
    
    class DeveloperSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DeveloperSettings;
        static Load(InName: string): DeveloperSettings;
    }
    
    class AnimationSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CompressCommandletVersion: number;
        KeyEndEffectorsMatchNameArray: TArray<string>;
        DefaultCompressionAlgorithm: UE.Class;
        RotationCompressionFormat: UE.AnimationCompressionFormat;
        TranslationCompressionFormat: UE.AnimationCompressionFormat;
        MaxCurveError: number;
        AlternativeCompressionThreshold: number;
        ForceRecompression: boolean;
        bOnlyCheckForMissingSkeletalMeshes: boolean;
        bForceBelowThreshold: boolean;
        bFirstRecompressUsingCurrentOrDefault: boolean;
        bRaiseMaxErrorToExisting: boolean;
        bTryExhaustiveSearch: boolean;
        bEnableSegmenting: boolean;
        bEnablePerformanceLog: boolean;
        bStripAnimationDataOnDedicatedServer: boolean;
        bTickAnimationOnSkeletalMeshInit: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationSettings;
        static Load(InName: string): AnimationSettings;
    }
    
    class Enum extends UE.Field {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Enum;
        static Load(InName: string): Enum;
    }
    
    class AnimationSharingStateProcessor extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimationStateEnum: TSoftObjectPtr<UE.Enum>;
        GetAnimationStateEnum() : UE.Enum;
        ProcessActorState(OutState: $Ref<number>, InActor: $Nullable<UE.Actor>, CurrentState: number, OnDemandState: number, bShouldProcess: $Ref<boolean>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationSharingStateProcessor;
        static Load(InName: string): AnimationSharingStateProcessor;
    }
    
    class AnimSharingInstance extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RegisteredActors: TArray<UE.Actor>;
        StateProcessor: UE.AnimationSharingStateProcessor;
        UsedAnimationSequences: TArray<UE.AnimSequence>;
        StateEnum: UE.Enum;
        SharingActor: UE.Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSharingInstance;
        static Load(InName: string): AnimSharingInstance;
    }
    
    class AnimationSetup {
        constructor();
        constructor(AnimSequence: UE.AnimSequence, AnimBlueprint: UE.Class, NumRandomizedInstances: UE.PerPlatformInt, Enabled: UE.PerPlatformBool);
        AnimSequence: UE.AnimSequence;
        AnimBlueprint: UE.Class;
        NumRandomizedInstances: UE.PerPlatformInt;
        Enabled: UE.PerPlatformBool;
        static StaticClass(): Class;
    }
    
    class AnimationStateEntry {
        constructor();
        constructor(State: number, AnimationSetups: TArray<UE.AnimationSetup>, bOnDemand: boolean, bAdditive: boolean, BlendTime: number, bReturnToPreviousState: boolean, bSetNextState: boolean, NextState: number, MaximumNumberOfConcurrentInstances: UE.PerPlatformInt, WiggleTimePercentage: number, bRequiresCurves: boolean);
        State: number;
        AnimationSetups: TArray<UE.AnimationSetup>;
        bOnDemand: boolean;
        bAdditive: boolean;
        BlendTime: number;
        bReturnToPreviousState: boolean;
        bSetNextState: boolean;
        NextState: number;
        MaximumNumberOfConcurrentInstances: UE.PerPlatformInt;
        WiggleTimePercentage: number;
        bRequiresCurves: boolean;
        static StaticClass(): Class;
    }
    
    class PerSkeletonAnimationSharingSetup {
        constructor();
        constructor(Skeleton: UE.Skeleton, SkeletalMesh: UE.SkeletalMesh, BlendAnimBlueprint: UE.Class, AdditiveAnimBlueprint: UE.Class, StateProcessorClass: UE.Class, AnimationStates: TArray<UE.AnimationStateEntry>);
        Skeleton: UE.Skeleton;
        SkeletalMesh: UE.SkeletalMesh;
        BlendAnimBlueprint: UE.Class;
        AdditiveAnimBlueprint: UE.Class;
        StateProcessorClass: UE.Class;
        AnimationStates: TArray<UE.AnimationStateEntry>;
        static StaticClass(): Class;
    }
    
    class AnimationSharingScalability {
        constructor();
        constructor(UseBlendTransitions: UE.PerPlatformBool, BlendSignificanceValue: UE.PerPlatformFloat, MaximumNumberConcurrentBlends: UE.PerPlatformInt, TickSignificanceValue: UE.PerPlatformFloat);
        UseBlendTransitions: UE.PerPlatformBool;
        BlendSignificanceValue: UE.PerPlatformFloat;
        MaximumNumberConcurrentBlends: UE.PerPlatformInt;
        TickSignificanceValue: UE.PerPlatformFloat;
        static StaticClass(): Class;
    }
    
    class AnimationSharingSetup extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SkeletonSetups: TArray<UE.PerSkeletonAnimationSharingSetup>;
        ScalabilitySettings: UE.AnimationSharingScalability;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationSharingSetup;
        static Load(InName: string): AnimationSharingSetup;
    }
    
    class AnimationSharingManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Skeletons: TArray<UE.Skeleton>;
        PerSkeletonData: TArray<UE.AnimSharingInstance>;
        RegisterActorWithSkeletonBP(InActor: $Nullable<UE.Actor>, SharingSkeleton: $Nullable<UE.Skeleton>) : void;
        static AnimationSharingEnabled() : boolean;
        static CreateAnimationSharingManager(WorldContextObject: $Nullable<UE.Object>, Setup: $Nullable<UE.AnimationSharingSetup>) : boolean;
        static GetAnimationSharingManager(WorldContextObject: $Nullable<UE.Object>) : UE.AnimationSharingManager;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationSharingManager;
        static Load(InName: string): AnimationSharingManager;
    }
    
    class AnimationSharingSetupFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationSharingSetupFactory;
        static Load(InName: string): AnimationSharingSetupFactory;
    }
    
    class AnimationStateGraph extends UE.AnimationGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MyResultNode: UE.AnimGraphNode_StateResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationStateGraph;
        static Load(InName: string): AnimationStateGraph;
    }
    
    class AnimationStateGraphSchema extends UE.AnimationGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationStateGraphSchema;
        static Load(InName: string): AnimationStateGraphSchema;
    }
    
    class AnimStateEntryNode extends UE.EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimStateEntryNode;
        static Load(InName: string): AnimStateEntryNode;
    }
    
    class AnimGraphNode_StateMachineBase extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditorStateMachineGraph: UE.AnimationStateMachineGraph;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_StateMachineBase;
        static Load(InName: string): AnimGraphNode_StateMachineBase;
    }
    
    class AnimationStateMachineGraph extends UE.EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EntryNode: UE.AnimStateEntryNode;
        OwnerAnimGraphNode: UE.AnimGraphNode_StateMachineBase;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationStateMachineGraph;
        static Load(InName: string): AnimationStateMachineGraph;
    }
    
    class AnimationStateMachineSchema extends UE.EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationStateMachineSchema;
        static Load(InName: string): AnimationStateMachineSchema;
    }
    
    class SkeletalMeshActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bShouldDoAnimNotifies: boolean;
        bWakeOnLevelStart: boolean;
        SkeletalMeshComponent: UE.SkeletalMeshComponent;
        ReplicatedMesh: UE.SkeletalMesh;
        ReplicatedPhysAsset: UE.PhysicsAsset;
        ReplicatedMaterial0: UE.MaterialInterface;
        ReplicatedMaterial1: UE.MaterialInterface;
        OnRep_ReplicatedMaterial0() : void;
        OnRep_ReplicatedMaterial1() : void;
        OnRep_ReplicatedMesh() : void;
        OnRep_ReplicatedPhysAsset() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshActor;
        static Load(InName: string): SkeletalMeshActor;
    }
    
    class AnimationThumbnailSkeletalMeshActor extends UE.SkeletalMeshActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationThumbnailSkeletalMeshActor;
        static Load(InName: string): AnimationThumbnailSkeletalMeshActor;
    }
    
    class AnimNode_TransitionResult extends UE.AnimNode_Base {
        constructor();
        constructor(bCanEnterTransition: boolean);
        bCanEnterTransition: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_TransitionResult extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_TransitionResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_TransitionResult;
        static Load(InName: string): AnimGraphNode_TransitionResult;
    }
    
    class AnimationTransitionGraph extends UE.AnimationGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MyResultNode: UE.AnimGraphNode_TransitionResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationTransitionGraph;
        static Load(InName: string): AnimationTransitionGraph;
    }
    
    class AnimationTransitionSchema extends UE.EdGraphSchema_K2 {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationTransitionSchema;
        static Load(InName: string): AnimationTransitionSchema;
    }
    
    class AnimBlueprintFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlueprintType: UE.EBlueprintType;
        ParentClass: UE.Class;
        TargetSkeleton: UE.Skeleton;
        PreviewSkeletalMesh: UE.SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimBlueprintFactory;
        static Load(InName: string): AnimBlueprintFactory;
    }
    
    class AnimBlueprintPostCompileValidation extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimBlueprintPostCompileValidation;
        static Load(InName: string): AnimBlueprintPostCompileValidation;
    }
    
    class ThumbnailRenderer extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ThumbnailRenderer;
        static Load(InName: string): ThumbnailRenderer;
    }
    
    class DefaultSizedThumbnailRenderer extends UE.ThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultSizeX: number;
        DefaultSizeY: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DefaultSizedThumbnailRenderer;
        static Load(InName: string): DefaultSizedThumbnailRenderer;
    }
    
    class AnimBlueprintThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimBlueprintThumbnailRenderer;
        static Load(InName: string): AnimBlueprintThumbnailRenderer;
    }
    
    class AnimBlueprintFunction {
        constructor();
        constructor(Name: string, Group: string, OutputPoseNodeIndex: number, InputPoseNames: TArray<string>, InputPoseNodeIndices: TArray<number>, OutputPoseNodeProperty: UE.StructProperty, InputPoseNodeProperties: TArray<UE.StructProperty>, InputProperties: TArray<UE.Property>, bImplemented: boolean);
        Name: string;
        Group: string;
        OutputPoseNodeIndex: number;
        InputPoseNames: TArray<string>;
        InputPoseNodeIndices: TArray<number>;
        OutputPoseNodeProperty: UE.StructProperty;
        InputPoseNodeProperties: TArray<UE.StructProperty>;
        InputProperties: TArray<UE.Property>;
        bImplemented: boolean;
        static StaticClass(): Class;
    }
    
    class AnimClassData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BakedStateMachines: TArray<UE.BakedAnimationStateMachine>;
        TargetSkeleton: UE.Skeleton;
        AnimNotifies: TArray<UE.AnimNotifyEvent>;
        OrderedSavedPoseIndicesMap: TMap<string, UE.CachedPoseIndices>;
        AnimBlueprintFunctions: TArray<UE.AnimBlueprintFunction>;
        AnimNodeProperties: TArray<UE.StructProperty>;
        LinkedAnimGraphNodeProperties: TArray<UE.StructProperty>;
        LinkedAnimLayerNodeProperties: TArray<UE.StructProperty>;
        PreUpdateNodeProperties: TArray<UE.StructProperty>;
        DynamicResetNodeProperties: TArray<UE.StructProperty>;
        StateMachineNodeProperties: TArray<UE.StructProperty>;
        InitializationNodeProperties: TArray<UE.StructProperty>;
        GraphNameAssetPlayers: TMap<string, UE.GraphAssetPlayerInformation>;
        SyncGroupNames: TArray<string>;
        EvaluateGraphExposedInputs: TArray<UE.ExposedValueHandler>;
        GraphBlendOptions: TMap<string, UE.AnimGraphBlendOptions>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimClassData;
        static Load(InName: string): AnimClassData;
    }
    
    class AnimClassInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimClassInterface;
        static Load(InName: string): AnimClassInterface;
    }
    
    class AnimComposite extends UE.AnimCompositeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimationTrack: UE.AnimTrack;
        PreviewBasePose: UE.AnimSequence;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimComposite;
        static Load(InName: string): AnimComposite;
    }
    
    class AnimCompositeFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeleton: UE.Skeleton;
        SourceAnimation: UE.AnimSequence;
        PreviewSkeletalMesh: UE.SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompositeFactory;
        static Load(InName: string): AnimCompositeFactory;
    }
    
    class AnimCompress_Automatic extends UE.AnimCompress {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxEndEffectorError: number;
        bRunCurrentDefaultCompressor: boolean;
        bAutoReplaceIfExistingErrorTooGreat: boolean;
        bRaiseMaxErrorToExisting: boolean;
        bTryExhaustiveSearch: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompress_Automatic;
        static Load(InName: string): AnimCompress_Automatic;
    }
    
    class AnimCompress_BitwiseCompressOnly extends UE.AnimCompress {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompress_BitwiseCompressOnly;
        static Load(InName: string): AnimCompress_BitwiseCompressOnly;
    }
    
    class AnimCompress_LeastDestructive extends UE.AnimCompress {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompress_LeastDestructive;
        static Load(InName: string): AnimCompress_LeastDestructive;
    }
    
    class AnimCompress_RemoveLinearKeys extends UE.AnimCompress {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxPosDiff: number;
        MaxAngleDiff: number;
        MaxScaleDiff: number;
        MaxEffectorDiff: number;
        MinEffectorDiff: number;
        EffectorDiffSocket: number;
        ParentKeyScale: number;
        bRetarget: boolean;
        bActuallyFilterLinearKeys: boolean;
        bOptimizeForForwardPlayback: boolean;
        bUseDecompression: boolean;
        bUseMultithreading: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompress_RemoveLinearKeys;
        static Load(InName: string): AnimCompress_RemoveLinearKeys;
    }
    
    class AnimCompress_PerTrackCompression extends UE.AnimCompress_RemoveLinearKeys {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxZeroingThreshold: number;
        MaxPosDiffBitwise: number;
        MaxAngleDiffBitwise: number;
        MaxScaleDiffBitwise: number;
        AllowedRotationFormats: TArray<UE.AnimationCompressionFormat>;
        AllowedTranslationFormats: TArray<UE.AnimationCompressionFormat>;
        AllowedScaleFormats: TArray<UE.AnimationCompressionFormat>;
        bResampleAnimation: boolean;
        ResampledFramerate: number;
        MinKeysForResampling: number;
        bUseAdaptiveError: boolean;
        bUseOverrideForEndEffectors: boolean;
        TrackHeightBias: number;
        ParentingDivisor: number;
        ParentingDivisorExponent: number;
        bUseAdaptiveError2: boolean;
        RotationErrorSourceRatio: number;
        TranslationErrorSourceRatio: number;
        ScaleErrorSourceRatio: number;
        MaxErrorPerTrackRatio: number;
        PerturbationProbeSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompress_PerTrackCompression;
        static Load(InName: string): AnimCompress_PerTrackCompression;
    }
    
    class AnimCompress_RemoveEverySecondKey extends UE.AnimCompress {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MinKeys: number;
        bStartAtSecondKey: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompress_RemoveEverySecondKey;
        static Load(InName: string): AnimCompress_RemoveEverySecondKey;
    }
    
    class AnimCompress_RemoveTrivialKeys extends UE.AnimCompress {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxPosDiff: number;
        MaxAngleDiff: number;
        MaxScaleDiff: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompress_RemoveTrivialKeys;
        static Load(InName: string): AnimCompress_RemoveTrivialKeys;
    }
    
    class AnimCurveCompressionCodec_CompressedRichCurve extends UE.AnimCurveCompressionCodec {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxCurveError: number;
        UseAnimSequenceSampleRate: boolean;
        ErrorSampleRate: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionCodec_CompressedRichCurve;
        static Load(InName: string): AnimCurveCompressionCodec_CompressedRichCurve;
    }
    
    class AnimCurveCompressionCodec_UniformIndexable extends UE.AnimCurveCompressionCodec {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionCodec_UniformIndexable;
        static Load(InName: string): AnimCurveCompressionCodec_UniformIndexable;
    }
    
    class AnimCurveCompressionCodec_UniformlySampled extends UE.AnimCurveCompressionCodec {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UseAnimSequenceSampleRate: boolean;
        SampleRate: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionCodec_UniformlySampled;
        static Load(InName: string): AnimCurveCompressionCodec_UniformlySampled;
    }
    
    class AnimCurveCompressionSettingsFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionSettingsFactory;
        static Load(InName: string): AnimCurveCompressionSettingsFactory;
    }
    
    class AnimCustomInstance extends UE.AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCustomInstance;
        static Load(InName: string): AnimCustomInstance;
    }
    
    enum EAnimGroupRole { CanBeLeader, AlwaysFollower, AlwaysLeader, TransitionLeader, TransitionFollower, EAnimGroupRole_MAX}
    class AnimationGroupReference {
        constructor();
        constructor(GroupName: string, GroupRole: UE.EAnimGroupRole);
        GroupName: string;
        GroupRole: UE.EAnimGroupRole;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_AssetPlayerBase extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SyncGroup: UE.AnimationGroupReference;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_AssetPlayerBase;
        static Load(InName: string): AnimGraphNode_AssetPlayerBase;
    }
    
    class AnimGraphNode_BlendSpaceBase extends UE.AnimGraphNode_AssetPlayerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendSpaceBase;
        static Load(InName: string): AnimGraphNode_BlendSpaceBase;
    }
    
    class AnimNode_AssetPlayerBase extends UE.AnimNode_Base {
        constructor();
        constructor(GroupIndex: number, GroupRole: UE.EAnimGroupRole, bIgnoreForRelevancyTest: boolean, BlendWeight: number, InternalTimeAccumulator: number);
        GroupIndex: number;
        GroupRole: UE.EAnimGroupRole;
        bIgnoreForRelevancyTest: boolean;
        BlendWeight: number;
        InternalTimeAccumulator: number;
        static StaticClass(): Class;
    }
    
    class AnimNode_BlendSpacePlayer extends UE.AnimNode_AssetPlayerBase {
        constructor();
        constructor(X: number, Y: number, Z: number, PlayRate: number, bLoop: boolean, bResetPlayTimeWhenBlendSpaceChanges: boolean, StartPosition: number, BlendSpace: UE.BlendSpaceBase, PreviousBlendSpace: UE.BlendSpaceBase);
        X: number;
        Y: number;
        Z: number;
        PlayRate: number;
        bLoop: boolean;
        bResetPlayTimeWhenBlendSpaceChanges: boolean;
        StartPosition: number;
        BlendSpace: UE.BlendSpaceBase;
        PreviousBlendSpace: UE.BlendSpaceBase;
        static StaticClass(): Class;
    }
    
    class AnimNode_AimOffsetLookAt extends UE.AnimNode_BlendSpacePlayer {
        constructor();
        constructor(BasePose: UE.PoseLink, LODThreshold: number, SourceSocketName: string, PivotSocketName: string, LookAtLocation: UE.Vector, SocketAxis: UE.Vector, Alpha: number);
        BasePose: UE.PoseLink;
        LODThreshold: number;
        SourceSocketName: string;
        PivotSocketName: string;
        LookAtLocation: UE.Vector;
        SocketAxis: UE.Vector;
        Alpha: number;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_AimOffsetLookAt extends UE.AnimGraphNode_BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_AimOffsetLookAt;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_AimOffsetLookAt;
        static Load(InName: string): AnimGraphNode_AimOffsetLookAt;
    }
    
    class AnimGraphNode_SkeletalControlBase extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SkeletalControlBase;
        static Load(InName: string): AnimGraphNode_SkeletalControlBase;
    }
    
    class ComponentSpacePoseLink extends UE.PoseLinkBase {
        constructor();
        static StaticClass(): Class;
    }
    
    enum EAnimAlphaInputType { Float, Bool, Curve, EAnimAlphaInputType_MAX}
    class InputScaleBias {
        constructor();
        constructor(Scale: number, Bias: number);
        Scale: number;
        Bias: number;
        static StaticClass(): Class;
    }
    
    class InputAlphaBoolBlend {
        constructor();
        constructor(BlendInTime: number, BlendOutTime: number, BlendOption: UE.EAlphaBlendOption, bInitialized: boolean, CustomCurve: UE.CurveFloat, AlphaBlend: UE.AlphaBlend);
        BlendInTime: number;
        BlendOutTime: number;
        BlendOption: UE.EAlphaBlendOption;
        bInitialized: boolean;
        CustomCurve: UE.CurveFloat;
        AlphaBlend: UE.AlphaBlend;
        static StaticClass(): Class;
    }
    
    class InputRange {
        constructor();
        constructor(Min: number, Max: number);
        Min: number;
        Max: number;
        static StaticClass(): Class;
    }
    
    class InputScaleBiasClamp {
        constructor();
        constructor(bMapRange: boolean, bClampResult: boolean, bInterpResult: boolean, InRange: UE.InputRange, OutRange: UE.InputRange, Scale: number, Bias: number, ClampMin: number, ClampMax: number, InterpSpeedIncreasing: number, InterpSpeedDecreasing: number);
        bMapRange: boolean;
        bClampResult: boolean;
        bInterpResult: boolean;
        InRange: UE.InputRange;
        OutRange: UE.InputRange;
        Scale: number;
        Bias: number;
        ClampMin: number;
        ClampMax: number;
        InterpSpeedIncreasing: number;
        InterpSpeedDecreasing: number;
        static StaticClass(): Class;
    }
    
    class AnimNode_SkeletalControlBase extends UE.AnimNode_Base {
        constructor();
        constructor(ComponentPose: UE.ComponentSpacePoseLink, LODThreshold: number, ActualAlpha: number, AlphaInputType: UE.EAnimAlphaInputType, bAlphaBoolEnabled: boolean, Alpha: number, AlphaScaleBias: UE.InputScaleBias, AlphaBoolBlend: UE.InputAlphaBoolBlend, AlphaCurveName: string, AlphaScaleBiasClamp: UE.InputScaleBiasClamp);
        ComponentPose: UE.ComponentSpacePoseLink;
        LODThreshold: number;
        ActualAlpha: number;
        AlphaInputType: UE.EAnimAlphaInputType;
        bAlphaBoolEnabled: boolean;
        Alpha: number;
        AlphaScaleBias: UE.InputScaleBias;
        AlphaBoolBlend: UE.InputAlphaBoolBlend;
        AlphaCurveName: string;
        AlphaScaleBiasClamp: UE.InputScaleBiasClamp;
        static StaticClass(): Class;
    }
    
    enum AnimPhysLinearConstraintType { Free, Limited, AnimPhysLinearConstraintType_MAX}
    enum AnimPhysAngularConstraintType { Angular, Cone, AnimPhysAngularConstraintType_MAX}
    enum AnimPhysTwistAxis { AxisX, AxisY, AxisZ, AnimPhysTwistAxis_MAX}
    class AnimPhysConstraintSetup {
        constructor();
        constructor(LinearXLimitType: UE.AnimPhysLinearConstraintType, LinearYLimitType: UE.AnimPhysLinearConstraintType, LinearZLimitType: UE.AnimPhysLinearConstraintType, LinearAxesMin: UE.Vector, LinearAxesMax: UE.Vector, AngularConstraintType: UE.AnimPhysAngularConstraintType, TwistAxis: UE.AnimPhysTwistAxis, AngularTargetAxis: UE.AnimPhysTwistAxis, ConeAngle: number, AngularXAngle: number, AngularYAngle: number, AngularZAngle: number, AngularLimitsMin: UE.Vector, AngularLimitsMax: UE.Vector, AngularTarget: UE.Vector);
        LinearXLimitType: UE.AnimPhysLinearConstraintType;
        LinearYLimitType: UE.AnimPhysLinearConstraintType;
        LinearZLimitType: UE.AnimPhysLinearConstraintType;
        LinearAxesMin: UE.Vector;
        LinearAxesMax: UE.Vector;
        AngularConstraintType: UE.AnimPhysAngularConstraintType;
        TwistAxis: UE.AnimPhysTwistAxis;
        AngularTargetAxis: UE.AnimPhysTwistAxis;
        ConeAngle: number;
        AngularXAngle: number;
        AngularYAngle: number;
        AngularZAngle: number;
        AngularLimitsMin: UE.Vector;
        AngularLimitsMax: UE.Vector;
        AngularTarget: UE.Vector;
        static StaticClass(): Class;
    }
    
    enum ESphericalLimitType { Inner, Outer, ESphericalLimitType_MAX}
    class AnimPhysSphericalLimit {
        constructor();
        constructor(DrivingBone: UE.BoneReference, SphereLocalOffset: UE.Vector, LimitRadius: number, LimitType: UE.ESphericalLimitType);
        DrivingBone: UE.BoneReference;
        SphereLocalOffset: UE.Vector;
        LimitRadius: number;
        LimitType: UE.ESphericalLimitType;
        static StaticClass(): Class;
    }
    
    class AnimPhysPlanarLimit {
        constructor();
        constructor(DrivingBone: UE.BoneReference, PlaneTransform: UE.Transform);
        DrivingBone: UE.BoneReference;
        PlaneTransform: UE.Transform;
        static StaticClass(): Class;
    }
    
    enum AnimPhysCollisionType { CoM, CustomSphere, InnerSphere, OuterSphere, AnimPhysCollisionType_MAX}
    enum AnimPhysSimSpaceType { Component, Actor, World, RootRelative, BoneRelative, AnimPhysSimSpaceType_MAX}
    enum ERotationComponent { EulerX, EulerY, EulerZ, QuaternionAngle, SwingAngle, TwistAngle, ERotationComponent_MAX}
    enum EEasingFuncType { Linear, Sinusoidal, Cubic, QuadraticInOut, CubicInOut, HermiteCubic, QuarticInOut, QuinticInOut, CircularIn, CircularOut, CircularInOut, ExpIn, ExpOut, ExpInOut, CustomCurve, EEasingFuncType_MAX}
    class RotationRetargetingInfo {
        constructor();
        constructor(bEnabled: boolean, Source: UE.Transform, Target: UE.Transform, RotationComponent: UE.ERotationComponent, TwistAxis: UE.Vector, bUseAbsoluteAngle: boolean, SourceMinimum: number, SourceMaximum: number, TargetMinimum: number, TargetMaximum: number, EasingType: UE.EEasingFuncType, CustomCurve: UE.RuntimeFloatCurve, bFlipEasing: boolean, EasingWeight: number, bClamp: boolean);
        bEnabled: boolean;
        Source: UE.Transform;
        Target: UE.Transform;
        RotationComponent: UE.ERotationComponent;
        TwistAxis: UE.Vector;
        bUseAbsoluteAngle: boolean;
        SourceMinimum: number;
        SourceMaximum: number;
        TargetMinimum: number;
        TargetMaximum: number;
        EasingType: UE.EEasingFuncType;
        CustomCurve: UE.RuntimeFloatCurve;
        bFlipEasing: boolean;
        EasingWeight: number;
        bClamp: boolean;
        static StaticClass(): Class;
    }
    
    class AnimNode_AnimDynamics extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(LinearDampingOverride: number, AngularDampingOverride: number, RelativeSpaceBone: UE.BoneReference, BoundBone: UE.BoneReference, ChainEnd: UE.BoneReference, BoxExtents: UE.Vector, LocalJointOffset: UE.Vector, GravityScale: number, GravityOverride: UE.Vector, LinearSpringConstant: number, AngularSpringConstant: number, WindScale: number, ComponentLinearAccScale: UE.Vector, ComponentLinearVelScale: UE.Vector, ComponentAppliedLinearAccClamp: UE.Vector, AngularBiasOverride: number, NumSolverIterationsPreUpdate: number, NumSolverIterationsPostUpdate: number, ConstraintSetup: UE.AnimPhysConstraintSetup, SphericalLimits: TArray<UE.AnimPhysSphericalLimit>, SphereCollisionRadius: number, ExternalForce: UE.Vector, PlanarLimits: TArray<UE.AnimPhysPlanarLimit>, CollisionType: UE.AnimPhysCollisionType, SimulationSpace: UE.AnimPhysSimSpaceType, bUseSphericalLimits: boolean, bUsePlanarLimit: boolean, bDoUpdate: boolean, bDoEval: boolean, bOverrideLinearDamping: boolean, bOverrideAngularBias: boolean, bOverrideAngularDamping: boolean, bEnableWind: boolean, bUseGravityOverride: boolean, bLinearSpring: boolean, bAngularSpring: boolean, bChain: boolean, RetargetingSettings: UE.RotationRetargetingInfo);
        LinearDampingOverride: number;
        AngularDampingOverride: number;
        RelativeSpaceBone: UE.BoneReference;
        BoundBone: UE.BoneReference;
        ChainEnd: UE.BoneReference;
        BoxExtents: UE.Vector;
        LocalJointOffset: UE.Vector;
        GravityScale: number;
        GravityOverride: UE.Vector;
        LinearSpringConstant: number;
        AngularSpringConstant: number;
        WindScale: number;
        ComponentLinearAccScale: UE.Vector;
        ComponentLinearVelScale: UE.Vector;
        ComponentAppliedLinearAccClamp: UE.Vector;
        AngularBiasOverride: number;
        NumSolverIterationsPreUpdate: number;
        NumSolverIterationsPostUpdate: number;
        ConstraintSetup: UE.AnimPhysConstraintSetup;
        SphericalLimits: TArray<UE.AnimPhysSphericalLimit>;
        SphereCollisionRadius: number;
        ExternalForce: UE.Vector;
        PlanarLimits: TArray<UE.AnimPhysPlanarLimit>;
        CollisionType: UE.AnimPhysCollisionType;
        SimulationSpace: UE.AnimPhysSimSpaceType;
        bUseSphericalLimits: boolean;
        bUsePlanarLimit: boolean;
        bDoUpdate: boolean;
        bDoEval: boolean;
        bOverrideLinearDamping: boolean;
        bOverrideAngularBias: boolean;
        bOverrideAngularDamping: boolean;
        bEnableWind: boolean;
        bUseGravityOverride: boolean;
        bLinearSpring: boolean;
        bAngularSpring: boolean;
        bChain: boolean;
        RetargetingSettings: UE.RotationRetargetingInfo;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_AnimDynamics extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_AnimDynamics;
        bPreviewLive: boolean;
        bShowLinearLimits: boolean;
        bShowAngularLimits: boolean;
        bShowPlanarLimit: boolean;
        bShowSphericalLimit: boolean;
        bShowCollisionSpheres: boolean;
        LastPreviewComponent: UE.SkeletalMeshComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_AnimDynamics;
        static Load(InName: string): AnimGraphNode_AnimDynamics;
    }
    
    class AnimNode_ApplyAdditive extends UE.AnimNode_Base {
        constructor();
        constructor(Base: UE.PoseLink, Additive: UE.PoseLink, Alpha: number, AlphaScaleBias: UE.InputScaleBias, LODThreshold: number, AlphaBoolBlend: UE.InputAlphaBoolBlend, AlphaCurveName: string, AlphaScaleBiasClamp: UE.InputScaleBiasClamp, AlphaInputType: UE.EAnimAlphaInputType, bAlphaBoolEnabled: boolean);
        Base: UE.PoseLink;
        Additive: UE.PoseLink;
        Alpha: number;
        AlphaScaleBias: UE.InputScaleBias;
        LODThreshold: number;
        AlphaBoolBlend: UE.InputAlphaBoolBlend;
        AlphaCurveName: string;
        AlphaScaleBiasClamp: UE.InputScaleBiasClamp;
        AlphaInputType: UE.EAnimAlphaInputType;
        bAlphaBoolEnabled: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_ApplyAdditive extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_ApplyAdditive;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ApplyAdditive;
        static Load(InName: string): AnimGraphNode_ApplyAdditive;
    }
    
    class AngularRangeLimit {
        constructor();
        constructor(LimitMin: UE.Vector, LimitMax: UE.Vector, Bone: UE.BoneReference);
        LimitMin: UE.Vector;
        LimitMax: UE.Vector;
        Bone: UE.BoneReference;
        static StaticClass(): Class;
    }
    
    class AnimNode_ApplyLimits extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(AngularRangeLimits: TArray<UE.AngularRangeLimit>, AngularOffsets: TArray<UE.Vector>);
        AngularRangeLimits: TArray<UE.AngularRangeLimit>;
        AngularOffsets: TArray<UE.Vector>;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_ApplyLimits extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_ApplyLimits;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ApplyLimits;
        static Load(InName: string): AnimGraphNode_ApplyLimits;
    }
    
    class AnimNode_ApplyMeshSpaceAdditive extends UE.AnimNode_Base {
        constructor();
        constructor(Base: UE.PoseLink, Additive: UE.PoseLink, Alpha: number, AlphaScaleBias: UE.InputScaleBias, LODThreshold: number);
        Base: UE.PoseLink;
        Additive: UE.PoseLink;
        Alpha: number;
        AlphaScaleBias: UE.InputScaleBias;
        LODThreshold: number;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_ApplyMeshSpaceAdditive extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_ApplyMeshSpaceAdditive;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ApplyMeshSpaceAdditive;
        static Load(InName: string): AnimGraphNode_ApplyMeshSpaceAdditive;
    }
    
    class BlendBoneByChannelEntry {
        constructor();
        constructor(SourceBone: UE.BoneReference, TargetBone: UE.BoneReference, bBlendTranslation: boolean, bBlendRotation: boolean, bBlendScale: boolean);
        SourceBone: UE.BoneReference;
        TargetBone: UE.BoneReference;
        bBlendTranslation: boolean;
        bBlendRotation: boolean;
        bBlendScale: boolean;
        static StaticClass(): Class;
    }
    
    enum EBoneControlSpace { BCS_WorldSpace, BCS_ComponentSpace, BCS_ParentBoneSpace, BCS_BoneSpace, BCS_MAX}
    class AnimNode_BlendBoneByChannel extends UE.AnimNode_Base {
        constructor();
        constructor(A: UE.PoseLink, B: UE.PoseLink, BoneDefinitions: TArray<UE.BlendBoneByChannelEntry>, Alpha: number, AlphaScaleBias: UE.InputScaleBias, TransformsSpace: UE.EBoneControlSpace);
        A: UE.PoseLink;
        B: UE.PoseLink;
        BoneDefinitions: TArray<UE.BlendBoneByChannelEntry>;
        Alpha: number;
        AlphaScaleBias: UE.InputScaleBias;
        TransformsSpace: UE.EBoneControlSpace;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_BlendBoneByChannel extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlendNode: UE.AnimNode_BlendBoneByChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendBoneByChannel;
        static Load(InName: string): AnimGraphNode_BlendBoneByChannel;
    }
    
    class AnimGraphNode_BlendListBase extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendListBase;
        static Load(InName: string): AnimGraphNode_BlendListBase;
    }
    
    enum EBlendListTransitionType { StandardBlend, Inertialization, EBlendListTransitionType_MAX}
    class AnimNode_BlendListBase extends UE.AnimNode_Base {
        constructor();
        constructor(BlendPose: TArray<UE.PoseLink>, BlendTime: TArray<number>, TransitionType: UE.EBlendListTransitionType, BlendType: UE.EAlphaBlendOption, bResetChildOnActivation: boolean, CustomBlendCurve: UE.CurveFloat, BlendProfile: UE.BlendProfile);
        BlendPose: TArray<UE.PoseLink>;
        BlendTime: TArray<number>;
        TransitionType: UE.EBlendListTransitionType;
        BlendType: UE.EAlphaBlendOption;
        bResetChildOnActivation: boolean;
        CustomBlendCurve: UE.CurveFloat;
        BlendProfile: UE.BlendProfile;
        static StaticClass(): Class;
    }
    
    class AnimNode_BlendListByBool extends UE.AnimNode_BlendListBase {
        constructor();
        constructor(bActiveValue: boolean);
        bActiveValue: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_BlendListByBool extends UE.AnimGraphNode_BlendListBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_BlendListByBool;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendListByBool;
        static Load(InName: string): AnimGraphNode_BlendListByBool;
    }
    
    class AnimNode_BlendListByEnum extends UE.AnimNode_BlendListBase {
        constructor();
        constructor(EnumToPoseIndex: TArray<number>, ActiveEnumValue: number);
        EnumToPoseIndex: TArray<number>;
        ActiveEnumValue: number;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_BlendListByEnum extends UE.AnimGraphNode_BlendListBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_BlendListByEnum;
        BoundEnum: UE.Enum;
        VisibleEnumEntries: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendListByEnum;
        static Load(InName: string): AnimGraphNode_BlendListByEnum;
    }
    
    class AnimNode_BlendListByInt extends UE.AnimNode_BlendListBase {
        constructor();
        constructor(ActiveChildIndex: number);
        ActiveChildIndex: number;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_BlendListByInt extends UE.AnimGraphNode_BlendListBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_BlendListByInt;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendListByInt;
        static Load(InName: string): AnimGraphNode_BlendListByInt;
    }
    
    class AnimNode_BlendSpaceEvaluator extends UE.AnimNode_BlendSpacePlayer {
        constructor();
        constructor(NormalizedTime: number);
        NormalizedTime: number;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_BlendSpaceEvaluator extends UE.AnimGraphNode_BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_BlendSpaceEvaluator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendSpaceEvaluator;
        static Load(InName: string): AnimGraphNode_BlendSpaceEvaluator;
    }
    
    class AnimGraphNode_BlendSpacePlayer extends UE.AnimGraphNode_BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_BlendSpacePlayer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendSpacePlayer;
        static Load(InName: string): AnimGraphNode_BlendSpacePlayer;
    }
    
    enum EComponentType { None, TranslationX, TranslationY, TranslationZ, RotationX, RotationY, RotationZ, Scale, ScaleX, ScaleY, ScaleZ, EComponentType_MAX}
    enum EDrivenDestinationMode { Bone, MorphTarget, MaterialParameter, EDrivenDestinationMode_MAX}
    enum EDrivenBoneModificationMode { AddToInput, ReplaceComponent, AddToRefPose, EDrivenBoneModificationMode_MAX}
    class AnimNode_BoneDrivenController extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(SourceBone: UE.BoneReference, DrivingCurve: UE.CurveFloat, Multiplier: number, RangeMin: number, RangeMax: number, RemappedMin: number, RemappedMax: number, ParameterName: string, TargetBone: UE.BoneReference, TargetComponent: UE.EComponentType, DestinationMode: UE.EDrivenDestinationMode, ModificationMode: UE.EDrivenBoneModificationMode, SourceComponent: UE.EComponentType, bUseRange: boolean, bAffectTargetTranslationX: boolean, bAffectTargetTranslationY: boolean, bAffectTargetTranslationZ: boolean, bAffectTargetRotationX: boolean, bAffectTargetRotationY: boolean, bAffectTargetRotationZ: boolean, bAffectTargetScaleX: boolean, bAffectTargetScaleY: boolean, bAffectTargetScaleZ: boolean);
        SourceBone: UE.BoneReference;
        DrivingCurve: UE.CurveFloat;
        Multiplier: number;
        RangeMin: number;
        RangeMax: number;
        RemappedMin: number;
        RemappedMax: number;
        ParameterName: string;
        TargetBone: UE.BoneReference;
        TargetComponent: UE.EComponentType;
        DestinationMode: UE.EDrivenDestinationMode;
        ModificationMode: UE.EDrivenBoneModificationMode;
        SourceComponent: UE.EComponentType;
        bUseRange: boolean;
        bAffectTargetTranslationX: boolean;
        bAffectTargetTranslationY: boolean;
        bAffectTargetTranslationZ: boolean;
        bAffectTargetRotationX: boolean;
        bAffectTargetRotationY: boolean;
        bAffectTargetRotationZ: boolean;
        bAffectTargetScaleX: boolean;
        bAffectTargetScaleY: boolean;
        bAffectTargetScaleZ: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_BoneDrivenController extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_BoneDrivenController;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BoneDrivenController;
        static Load(InName: string): AnimGraphNode_BoneDrivenController;
    }
    
    class SocketReference {
        constructor();
        constructor(SocketName: string);
        SocketName: string;
        static StaticClass(): Class;
    }
    
    class BoneSocketTarget {
        constructor();
        constructor(bUseSocket: boolean, BoneReference: UE.BoneReference, SocketReference: UE.SocketReference);
        bUseSocket: boolean;
        BoneReference: UE.BoneReference;
        SocketReference: UE.SocketReference;
        static StaticClass(): Class;
    }
    
    class AnimNode_CCDIK extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(EffectorLocation: UE.Vector, EffectorLocationSpace: UE.EBoneControlSpace, EffectorTarget: UE.BoneSocketTarget, TipBone: UE.BoneReference, RootBone: UE.BoneReference, Precision: number, MaxIterations: number, bStartFromTail: boolean, bEnableRotationLimit: boolean, RotationLimitPerJoints: TArray<number>);
        EffectorLocation: UE.Vector;
        EffectorLocationSpace: UE.EBoneControlSpace;
        EffectorTarget: UE.BoneSocketTarget;
        TipBone: UE.BoneReference;
        RootBone: UE.BoneReference;
        Precision: number;
        MaxIterations: number;
        bStartFromTail: boolean;
        bEnableRotationLimit: boolean;
        RotationLimitPerJoints: TArray<number>;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_CCDIK extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_CCDIK;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CCDIK;
        static Load(InName: string): AnimGraphNode_CCDIK;
    }
    
    class AnimNode_ConvertComponentToLocalSpace extends UE.AnimNode_Base {
        constructor();
        constructor(ComponentPose: UE.ComponentSpacePoseLink);
        ComponentPose: UE.ComponentSpacePoseLink;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_ComponentToLocalSpace extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_ConvertComponentToLocalSpace;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ComponentToLocalSpace;
        static Load(InName: string): AnimGraphNode_ComponentToLocalSpace;
    }
    
    enum EConstraintOffsetOption { None, Offset_RefPose, EConstraintOffsetOption_MAX}
    enum ETransformConstraintType { Translation, Rotation, Scale, Parent, ETransformConstraintType_MAX}
    class FilterOptionPerAxis {
        constructor();
        constructor(bX: boolean, bY: boolean, bZ: boolean);
        bX: boolean;
        bY: boolean;
        bZ: boolean;
        static StaticClass(): Class;
    }
    
    class Constraint {
        constructor();
        constructor(TargetBone: UE.BoneReference, OffsetOption: UE.EConstraintOffsetOption, TransformType: UE.ETransformConstraintType, PerAxis: UE.FilterOptionPerAxis);
        TargetBone: UE.BoneReference;
        OffsetOption: UE.EConstraintOffsetOption;
        TransformType: UE.ETransformConstraintType;
        PerAxis: UE.FilterOptionPerAxis;
        static StaticClass(): Class;
    }
    
    class AnimNode_Constraint extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(BoneToModify: UE.BoneReference, ConstraintSetup: TArray<UE.Constraint>, ConstraintWeights: TArray<number>);
        BoneToModify: UE.BoneReference;
        ConstraintSetup: TArray<UE.Constraint>;
        ConstraintWeights: TArray<number>;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_Constraint extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_Constraint;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Constraint;
        static Load(InName: string): AnimGraphNode_Constraint;
    }
    
    class AnimNode_CopyBone extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(SourceBone: UE.BoneReference, TargetBone: UE.BoneReference, bCopyTranslation: boolean, bCopyRotation: boolean, bCopyScale: boolean, ControlSpace: UE.EBoneControlSpace);
        SourceBone: UE.BoneReference;
        TargetBone: UE.BoneReference;
        bCopyTranslation: boolean;
        bCopyRotation: boolean;
        bCopyScale: boolean;
        ControlSpace: UE.EBoneControlSpace;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_CopyBone extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_CopyBone;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CopyBone;
        static Load(InName: string): AnimGraphNode_CopyBone;
    }
    
    enum CopyBoneDeltaMode { Accumulate, Copy, CopyBoneDeltaMode_MAX}
    class AnimNode_CopyBoneDelta extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(SourceBone: UE.BoneReference, TargetBone: UE.BoneReference, bCopyTranslation: boolean, bCopyRotation: boolean, bCopyScale: boolean, CopyMode: UE.CopyBoneDeltaMode, TranslationMultiplier: number, RotationMultiplier: number, ScaleMultiplier: number);
        SourceBone: UE.BoneReference;
        TargetBone: UE.BoneReference;
        bCopyTranslation: boolean;
        bCopyRotation: boolean;
        bCopyScale: boolean;
        CopyMode: UE.CopyBoneDeltaMode;
        TranslationMultiplier: number;
        RotationMultiplier: number;
        ScaleMultiplier: number;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_CopyBoneDelta extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_CopyBoneDelta;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CopyBoneDelta;
        static Load(InName: string): AnimGraphNode_CopyBoneDelta;
    }
    
    class AnimNode_CopyPoseFromMesh extends UE.AnimNode_Base {
        constructor();
        constructor(SourceMeshComponent: TWeakObjectPtr<UE.SkeletalMeshComponent>, bUseAttachedParent: boolean, bCopyCurves: boolean);
        SourceMeshComponent: TWeakObjectPtr<UE.SkeletalMeshComponent>;
        bUseAttachedParent: boolean;
        bCopyCurves: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_CopyPoseFromMesh extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_CopyPoseFromMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CopyPoseFromMesh;
        static Load(InName: string): AnimGraphNode_CopyPoseFromMesh;
    }
    
    class NamedCurveValue {
        constructor();
        constructor(Name: string, Value: number);
        Name: string;
        Value: number;
        static StaticClass(): Class;
    }
    
    class CurveSourceInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetBindingName() : string;
        GetCurves(OutValues: $Ref<TArray<UE.NamedCurveValue>>) : void;
        GetCurveValue(CurveName: string) : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveSourceInterface;
        static Load(InName: string): CurveSourceInterface;
    }
    
    class AnimNode_CurveSource extends UE.AnimNode_Base {
        constructor();
        constructor(SourcePose: UE.PoseLink, SourceBinding: string, Alpha: number, CurveSource: CurveSourceInterface);
        SourcePose: UE.PoseLink;
        SourceBinding: string;
        Alpha: number;
        CurveSource: CurveSourceInterface;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_CurveSource extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_CurveSource;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CurveSource;
        static Load(InName: string): AnimGraphNode_CurveSource;
    }
    
    class AnimGraphNode_CustomProperty extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        KnownExposableProperties: TArray<string>;
        ExposedPropertyNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CustomProperty;
        static Load(InName: string): AnimGraphNode_CustomProperty;
    }
    
    enum EBoneRotationSource { BRS_KeepComponentSpaceRotation, BRS_KeepLocalSpaceRotation, BRS_CopyFromTarget, BRS_MAX}
    class AnimNode_Fabrik extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(EffectorTransform: UE.Transform, EffectorTarget: UE.BoneSocketTarget, TipBone: UE.BoneReference, RootBone: UE.BoneReference, Precision: number, MaxIterations: number, EffectorTransformSpace: UE.EBoneControlSpace, EffectorRotationSource: UE.EBoneRotationSource, bEnableDebugDraw: boolean, EffectorTransformBone: UE.BoneReference);
        EffectorTransform: UE.Transform;
        EffectorTarget: UE.BoneSocketTarget;
        TipBone: UE.BoneReference;
        RootBone: UE.BoneReference;
        Precision: number;
        MaxIterations: number;
        EffectorTransformSpace: UE.EBoneControlSpace;
        EffectorRotationSource: UE.EBoneRotationSource;
        bEnableDebugDraw: boolean;
        EffectorTransformBone: UE.BoneReference;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_Fabrik extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_Fabrik;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Fabrik;
        static Load(InName: string): AnimGraphNode_Fabrik;
    }
    
    class AnimNode_HandIKRetargeting extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(RightHandFK: UE.BoneReference, LeftHandFK: UE.BoneReference, RightHandIK: UE.BoneReference, LeftHandIK: UE.BoneReference, IKBonesToMove: TArray<UE.BoneReference>, HandFKWeight: number);
        RightHandFK: UE.BoneReference;
        LeftHandFK: UE.BoneReference;
        RightHandIK: UE.BoneReference;
        LeftHandIK: UE.BoneReference;
        IKBonesToMove: TArray<UE.BoneReference>;
        HandFKWeight: number;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_HandIKRetargeting extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_HandIKRetargeting;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_HandIKRetargeting;
        static Load(InName: string): AnimGraphNode_HandIKRetargeting;
    }
    
    enum ERefPoseType { EIT_LocalSpace, EIT_Additive, EIT_MAX}
    class AnimNode_RefPose extends UE.AnimNode_Base {
        constructor();
        constructor(RefPoseType: UE.ERefPoseType);
        RefPoseType: UE.ERefPoseType;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_RefPoseBase extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_RefPose;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RefPoseBase;
        static Load(InName: string): AnimGraphNode_RefPoseBase;
    }
    
    class AnimGraphNode_IdentityPose extends UE.AnimGraphNode_RefPoseBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_IdentityPose;
        static Load(InName: string): AnimGraphNode_IdentityPose;
    }
    
    class AnimNode_Inertialization extends UE.AnimNode_Base {
        constructor();
        constructor(Source: UE.PoseLink);
        Source: UE.PoseLink;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_Inertialization extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_Inertialization;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Inertialization;
        static Load(InName: string): AnimGraphNode_Inertialization;
    }
    
    class BranchFilter {
        constructor();
        constructor(BoneName: string, BlendDepth: number);
        BoneName: string;
        BlendDepth: number;
        static StaticClass(): Class;
    }
    
    class InputBlendPose {
        constructor();
        constructor(BranchFilters: TArray<UE.BranchFilter>);
        BranchFilters: TArray<UE.BranchFilter>;
        static StaticClass(): Class;
    }
    
    enum ECurveBlendOption { MaxWeight, NormalizeByWeight, BlendByWeight, ECurveBlendOption_MAX}
    class PerBoneBlendWeight {
        constructor();
        constructor(SourceIndex: number, BlendWeight: number);
        SourceIndex: number;
        BlendWeight: number;
        static StaticClass(): Class;
    }
    
    class AnimNode_LayeredBoneBlend extends UE.AnimNode_Base {
        constructor();
        constructor(BasePose: UE.PoseLink, BlendPoses: TArray<UE.PoseLink>, LayerSetup: TArray<UE.InputBlendPose>, BlendWeights: TArray<number>, bMeshSpaceRotationBlend: boolean, bMeshSpaceScaleBlend: boolean, CurveBlendOption: UE.ECurveBlendOption, bBlendRootMotionBasedOnRootBone: boolean, LODThreshold: number, PerBoneBlendWeights: TArray<UE.PerBoneBlendWeight>, SkeletonGuid: UE.Guid, VirtualBoneGuid: UE.Guid);
        BasePose: UE.PoseLink;
        BlendPoses: TArray<UE.PoseLink>;
        LayerSetup: TArray<UE.InputBlendPose>;
        BlendWeights: TArray<number>;
        bMeshSpaceRotationBlend: boolean;
        bMeshSpaceScaleBlend: boolean;
        CurveBlendOption: UE.ECurveBlendOption;
        bBlendRootMotionBasedOnRootBone: boolean;
        LODThreshold: number;
        PerBoneBlendWeights: TArray<UE.PerBoneBlendWeight>;
        SkeletonGuid: UE.Guid;
        VirtualBoneGuid: UE.Guid;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_LayeredBoneBlend extends UE.AnimGraphNode_BlendListBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_LayeredBoneBlend;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LayeredBoneBlend;
        static Load(InName: string): AnimGraphNode_LayeredBoneBlend;
    }
    
    class AnimLegIKDefinition {
        constructor();
        constructor(IKFootBone: UE.BoneReference, FKFootBone: UE.BoneReference, NumBonesInLimb: number, MinRotationAngle: number, FootBoneForwardAxis: UE.EAxis, HingeRotationAxis: UE.EAxis, bEnableRotationLimit: boolean, bEnableKneeTwistCorrection: boolean);
        IKFootBone: UE.BoneReference;
        FKFootBone: UE.BoneReference;
        NumBonesInLimb: number;
        MinRotationAngle: number;
        FootBoneForwardAxis: UE.EAxis;
        HingeRotationAxis: UE.EAxis;
        bEnableRotationLimit: boolean;
        bEnableKneeTwistCorrection: boolean;
        static StaticClass(): Class;
    }
    
    class AnimNode_LegIK extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(ReachPrecision: number, MaxIterations: number, LegsDefinition: TArray<UE.AnimLegIKDefinition>);
        ReachPrecision: number;
        MaxIterations: number;
        LegsDefinition: TArray<UE.AnimLegIKDefinition>;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_LegIK extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_LegIK;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LegIK;
        static Load(InName: string): AnimGraphNode_LegIK;
    }
    
    class AnimGraphNode_LinkedAnimGraphBase extends UE.AnimGraphNode_CustomProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LinkedAnimGraphBase;
        static Load(InName: string): AnimGraphNode_LinkedAnimGraphBase;
    }
    
    class AnimNode_CustomProperty extends UE.AnimNode_Base {
        constructor();
        constructor(SourcePropertyNames: TArray<string>, DestPropertyNames: TArray<string>, TargetInstance: UE.Object, SourceProperties: TArray<UE.Property>, DestProperties: TArray<UE.Property>);
        SourcePropertyNames: TArray<string>;
        DestPropertyNames: TArray<string>;
        TargetInstance: UE.Object;
        SourceProperties: TArray<UE.Property>;
        DestProperties: TArray<UE.Property>;
        static StaticClass(): Class;
    }
    
    class AnimNode_LinkedAnimGraph extends UE.AnimNode_CustomProperty {
        constructor();
        constructor(InputPoses: TArray<UE.PoseLink>, InputPoseNames: TArray<string>, InstanceClass: UE.Class, Tag: string);
        InputPoses: TArray<UE.PoseLink>;
        InputPoseNames: TArray<string>;
        InstanceClass: UE.Class;
        Tag: string;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_LinkedAnimGraph extends UE.AnimGraphNode_LinkedAnimGraphBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_LinkedAnimGraph;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LinkedAnimGraph;
        static Load(InName: string): AnimGraphNode_LinkedAnimGraph;
    }
    
    class AnimNode_LinkedAnimLayer extends UE.AnimNode_LinkedAnimGraph {
        constructor();
        constructor(Interface: UE.Class, Layer: string);
        Interface: UE.Class;
        Layer: string;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_LinkedAnimLayer extends UE.AnimGraphNode_LinkedAnimGraphBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_LinkedAnimLayer;
        InterfaceGuid: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LinkedAnimLayer;
        static Load(InName: string): AnimGraphNode_LinkedAnimLayer;
    }
    
    class AnimNode_LinkedInputPose extends UE.AnimNode_Base {
        constructor();
        constructor(Name: string, Graph: string, InputPose: UE.PoseLink);
        Name: string;
        Graph: string;
        InputPose: UE.PoseLink;
        static StaticClass(): Class;
    }
    
    class AnimBlueprintFunctionPinInfo {
        constructor();
        constructor(Name: string, Type: UE.EdGraphPinType);
        Name: string;
        Type: UE.EdGraphPinType;
        static StaticClass(): Class;
    }
    
    class MemberReference {
        constructor();
        constructor(MemberParent: UE.Object, MemberScope: string, MemberName: string, MemberGuid: UE.Guid, bSelfContext: boolean, bWasDeprecated: boolean);
        MemberParent: UE.Object;
        MemberScope: string;
        MemberName: string;
        MemberGuid: UE.Guid;
        bSelfContext: boolean;
        bWasDeprecated: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_LinkedInputPose extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_LinkedInputPose;
        Inputs: TArray<UE.AnimBlueprintFunctionPinInfo>;
        FunctionReference: UE.MemberReference;
        InputPoseIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LinkedInputPose;
        static Load(InName: string): AnimGraphNode_LinkedInputPose;
    }
    
    class AnimGraphNode_LocalRefPose extends UE.AnimGraphNode_RefPoseBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LocalRefPose;
        static Load(InName: string): AnimGraphNode_LocalRefPose;
    }
    
    class AnimNode_ConvertLocalToComponentSpace extends UE.AnimNode_Base {
        constructor();
        constructor(LocalPose: UE.PoseLink);
        LocalPose: UE.PoseLink;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_LocalToComponentSpace extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_ConvertLocalToComponentSpace;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LocalToComponentSpace;
        static Load(InName: string): AnimGraphNode_LocalToComponentSpace;
    }
    
    class Axis {
        constructor();
        constructor(Axis: UE.Vector, bInLocalSpace: boolean);
        Axis: UE.Vector;
        bInLocalSpace: boolean;
        static StaticClass(): Class;
    }
    
    enum EInterpolationBlend { Linear, Cubic, Sinusoidal, EaseInOutExponent2, EaseInOutExponent3, EaseInOutExponent4, EaseInOutExponent5, MAX}
    enum EAxisOption { X, Y, Z, X_Neg, Y_Neg, Z_Neg, Custom, EAxisOption_MAX}
    class AnimNode_LookAt extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(BoneToModify: UE.BoneReference, LookAtTarget: UE.BoneSocketTarget, LookAtLocation: UE.Vector, LookAt_Axis: UE.Axis, bUseLookUpAxis: boolean, InterpolationType: UE.EInterpolationBlend, LookUp_Axis: UE.Axis, LookAtClamp: number, InterpolationTime: number, InterpolationTriggerThreashold: number, LookAtBone: UE.BoneReference, LookAtSocket: string, LookAtAxis: UE.EAxisOption, CustomLookAtAxis: UE.Vector, LookUpAxis: UE.EAxisOption, CustomLookUpAxis: UE.Vector);
        BoneToModify: UE.BoneReference;
        LookAtTarget: UE.BoneSocketTarget;
        LookAtLocation: UE.Vector;
        LookAt_Axis: UE.Axis;
        bUseLookUpAxis: boolean;
        InterpolationType: UE.EInterpolationBlend;
        LookUp_Axis: UE.Axis;
        LookAtClamp: number;
        InterpolationTime: number;
        InterpolationTriggerThreashold: number;
        LookAtBone: UE.BoneReference;
        LookAtSocket: string;
        LookAtAxis: UE.EAxisOption;
        CustomLookAtAxis: UE.Vector;
        LookUpAxis: UE.EAxisOption;
        CustomLookUpAxis: UE.Vector;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_LookAt extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_LookAt;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LookAt;
        static Load(InName: string): AnimGraphNode_LookAt;
    }
    
    class AnimNode_MakeDynamicAdditive extends UE.AnimNode_Base {
        constructor();
        constructor(Base: UE.PoseLink, Additive: UE.PoseLink, bMeshSpaceAdditive: boolean);
        Base: UE.PoseLink;
        Additive: UE.PoseLink;
        bMeshSpaceAdditive: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_MakeDynamicAdditive extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_MakeDynamicAdditive;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_MakeDynamicAdditive;
        static Load(InName: string): AnimGraphNode_MakeDynamicAdditive;
    }
    
    class AnimNode_MeshSpaceRefPose extends UE.AnimNode_Base {
        constructor();
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_MeshRefPose extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_MeshSpaceRefPose;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_MeshRefPose;
        static Load(InName: string): AnimGraphNode_MeshRefPose;
    }
    
    enum EBoneModificationMode { BMM_Ignore, BMM_Replace, BMM_Additive, BMM_MAX}
    class AnimNode_ModifyBone extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(BoneToModify: UE.BoneReference, Translation: UE.Vector, Rotation: UE.Rotator, Scale: UE.Vector, TranslationMode: UE.EBoneModificationMode, RotationMode: UE.EBoneModificationMode, ScaleMode: UE.EBoneModificationMode, TranslationSpace: UE.EBoneControlSpace, RotationSpace: UE.EBoneControlSpace, ScaleSpace: UE.EBoneControlSpace);
        BoneToModify: UE.BoneReference;
        Translation: UE.Vector;
        Rotation: UE.Rotator;
        Scale: UE.Vector;
        TranslationMode: UE.EBoneModificationMode;
        RotationMode: UE.EBoneModificationMode;
        ScaleMode: UE.EBoneModificationMode;
        TranslationSpace: UE.EBoneControlSpace;
        RotationSpace: UE.EBoneControlSpace;
        ScaleSpace: UE.EBoneControlSpace;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_ModifyBone extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_ModifyBone;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ModifyBone;
        static Load(InName: string): AnimGraphNode_ModifyBone;
    }
    
    enum EModifyCurveApplyMode { Add, Scale, Blend, WeightedMovingAverage, RemapCurve, EModifyCurveApplyMode_MAX}
    class AnimNode_ModifyCurve extends UE.AnimNode_Base {
        constructor();
        constructor(SourcePose: UE.PoseLink, CurveValues: TArray<number>, CurveNames: TArray<string>, Alpha: number, ApplyMode: UE.EModifyCurveApplyMode);
        SourcePose: UE.PoseLink;
        CurveValues: TArray<number>;
        CurveNames: TArray<string>;
        Alpha: number;
        ApplyMode: UE.EModifyCurveApplyMode;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_ModifyCurve extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_ModifyCurve;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ModifyCurve;
        static Load(InName: string): AnimGraphNode_ModifyCurve;
    }
    
    class AnimNode_MultiWayBlend extends UE.AnimNode_Base {
        constructor();
        constructor(Poses: TArray<UE.PoseLink>, DesiredAlphas: TArray<number>, AlphaScaleBias: UE.InputScaleBias, bAdditiveNode: boolean, bNormalizeAlpha: boolean);
        Poses: TArray<UE.PoseLink>;
        DesiredAlphas: TArray<number>;
        AlphaScaleBias: UE.InputScaleBias;
        bAdditiveNode: boolean;
        bNormalizeAlpha: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_MultiWayBlend extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_MultiWayBlend;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_MultiWayBlend;
        static Load(InName: string): AnimGraphNode_MultiWayBlend;
    }
    
    class AnimNode_ObserveBone extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(BoneToObserve: UE.BoneReference, DisplaySpace: UE.EBoneControlSpace, bRelativeToRefPose: boolean, Translation: UE.Vector, Rotation: UE.Rotator, Scale: UE.Vector);
        BoneToObserve: UE.BoneReference;
        DisplaySpace: UE.EBoneControlSpace;
        bRelativeToRefPose: boolean;
        Translation: UE.Vector;
        Rotation: UE.Rotator;
        Scale: UE.Vector;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_ObserveBone extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_ObserveBone;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ObserveBone;
        static Load(InName: string): AnimGraphNode_ObserveBone;
    }
    
    class AnimGraphNode_PoseHandler extends UE.AnimGraphNode_AssetPlayerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_PoseHandler;
        static Load(InName: string): AnimGraphNode_PoseHandler;
    }
    
    class AnimNode_PoseHandler extends UE.AnimNode_AssetPlayerBase {
        constructor();
        constructor(PoseAsset: UE.PoseAsset);
        PoseAsset: UE.PoseAsset;
        static StaticClass(): Class;
    }
    
    class AnimNode_PoseBlendNode extends UE.AnimNode_PoseHandler {
        constructor();
        constructor(SourcePose: UE.PoseLink, BlendOption: UE.EAlphaBlendOption, CustomCurve: UE.CurveFloat);
        SourcePose: UE.PoseLink;
        BlendOption: UE.EAlphaBlendOption;
        CustomCurve: UE.CurveFloat;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_PoseBlendNode extends UE.AnimGraphNode_PoseHandler {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_PoseBlendNode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_PoseBlendNode;
        static Load(InName: string): AnimGraphNode_PoseBlendNode;
    }
    
    class AnimNode_PoseByName extends UE.AnimNode_PoseHandler {
        constructor();
        constructor(PoseName: string, PoseWeight: number);
        PoseName: string;
        PoseWeight: number;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_PoseByName extends UE.AnimGraphNode_AssetPlayerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_PoseByName;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_PoseByName;
        static Load(InName: string): AnimGraphNode_PoseByName;
    }
    
    class PoseDriverTransform {
        constructor();
        constructor(TargetTranslation: UE.Vector, TargetRotation: UE.Rotator);
        TargetTranslation: UE.Vector;
        TargetRotation: UE.Rotator;
        static StaticClass(): Class;
    }
    
    enum ERBFDistanceMethod { Euclidean, Quaternion, SwingAngle, DefaultMethod, ERBFDistanceMethod_MAX}
    enum ERBFFunctionType { Gaussian, Exponential, Linear, Cubic, Quintic, DefaultFunction, ERBFFunctionType_MAX}
    class PoseDriverTarget {
        constructor();
        constructor(BoneTransforms: TArray<UE.PoseDriverTransform>, TargetRotation: UE.Rotator, TargetScale: number, DistanceMethod: UE.ERBFDistanceMethod, FunctionType: UE.ERBFFunctionType, bApplyCustomCurve: boolean, CustomCurve: UE.RichCurve, DrivenName: string, bIsHidden: boolean);
        BoneTransforms: TArray<UE.PoseDriverTransform>;
        TargetRotation: UE.Rotator;
        TargetScale: number;
        DistanceMethod: UE.ERBFDistanceMethod;
        FunctionType: UE.ERBFFunctionType;
        bApplyCustomCurve: boolean;
        CustomCurve: UE.RichCurve;
        DrivenName: string;
        bIsHidden: boolean;
        static StaticClass(): Class;
    }
    
    enum EBoneAxis { BA_X, BA_Y, BA_Z, BA_MAX}
    enum ERBFNormalizeMethod { OnlyNormalizeAboveOne, AlwaysNormalize, NormalizeWithinMedian, ERBFNormalizeMethod_MAX}
    class RBFParams {
        constructor();
        constructor(TargetDimensions: number, Radius: number, Function: UE.ERBFFunctionType, DistanceMethod: UE.ERBFDistanceMethod, TwistAxis: UE.EBoneAxis, WeightThreshold: number, NormalizeMethod: UE.ERBFNormalizeMethod, MedianReference: UE.Vector, MedianMin: number, MedianMax: number);
        TargetDimensions: number;
        Radius: number;
        Function: UE.ERBFFunctionType;
        DistanceMethod: UE.ERBFDistanceMethod;
        TwistAxis: UE.EBoneAxis;
        WeightThreshold: number;
        NormalizeMethod: UE.ERBFNormalizeMethod;
        MedianReference: UE.Vector;
        MedianMin: number;
        MedianMax: number;
        static StaticClass(): Class;
    }
    
    enum EPoseDriverType { SwingAndTwist, SwingOnly, Translation, EPoseDriverType_MAX}
    enum EPoseDriverSource { Rotation, Translation, EPoseDriverSource_MAX}
    enum EPoseDriverOutput { DrivePoses, DriveCurves, EPoseDriverOutput_MAX}
    class AnimNode_PoseDriver extends UE.AnimNode_PoseHandler {
        constructor();
        constructor(SourcePose: UE.PoseLink, SourceBones: TArray<UE.BoneReference>, OnlyDriveBones: TArray<UE.BoneReference>, PoseTargets: TArray<UE.PoseDriverTarget>, EvalSpaceBone: UE.BoneReference, RBFParams: UE.RBFParams, SourceBone: UE.BoneReference, TwistAxis: UE.EBoneAxis, Type: UE.EPoseDriverType, RadialScaling: number, DriveSource: UE.EPoseDriverSource, DriveOutput: UE.EPoseDriverOutput, bOnlyDriveSelectedBones: boolean);
        SourcePose: UE.PoseLink;
        SourceBones: TArray<UE.BoneReference>;
        OnlyDriveBones: TArray<UE.BoneReference>;
        PoseTargets: TArray<UE.PoseDriverTarget>;
        EvalSpaceBone: UE.BoneReference;
        RBFParams: UE.RBFParams;
        SourceBone: UE.BoneReference;
        TwistAxis: UE.EBoneAxis;
        Type: UE.EPoseDriverType;
        RadialScaling: number;
        DriveSource: UE.EPoseDriverSource;
        DriveOutput: UE.EPoseDriverOutput;
        bOnlyDriveSelectedBones: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_PoseDriver extends UE.AnimGraphNode_PoseHandler {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_PoseDriver;
        AxisLength: number;
        ConeSubdivision: number;
        bDrawDebugCones: boolean;
        LastPreviewComponent: UE.SkeletalMeshComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_PoseDriver;
        static Load(InName: string): AnimGraphNode_PoseDriver;
    }
    
    enum ESnapshotSourceMode { NamedSnapshot, SnapshotPin, ESnapshotSourceMode_MAX}
    class AnimNode_PoseSnapshot extends UE.AnimNode_Base {
        constructor();
        constructor(SnapshotName: string, Snapshot: UE.PoseSnapshot, Mode: UE.ESnapshotSourceMode);
        SnapshotName: string;
        Snapshot: UE.PoseSnapshot;
        Mode: UE.ESnapshotSourceMode;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_PoseSnapshot extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_PoseSnapshot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_PoseSnapshot;
        static Load(InName: string): AnimGraphNode_PoseSnapshot;
    }
    
    class RandomPlayerSequenceEntry {
        constructor();
        constructor(Sequence: UE.AnimSequence, ChanceToPlay: number, MinLoopCount: number, MaxLoopCount: number, MinPlayRate: number, MaxPlayRate: number, BlendIn: UE.AlphaBlend);
        Sequence: UE.AnimSequence;
        ChanceToPlay: number;
        MinLoopCount: number;
        MaxLoopCount: number;
        MinPlayRate: number;
        MaxPlayRate: number;
        BlendIn: UE.AlphaBlend;
        static StaticClass(): Class;
    }
    
    class AnimNode_RandomPlayer extends UE.AnimNode_Base {
        constructor();
        constructor(Entries: TArray<UE.RandomPlayerSequenceEntry>, bShuffleMode: boolean);
        Entries: TArray<UE.RandomPlayerSequenceEntry>;
        bShuffleMode: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_RandomPlayer extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_RandomPlayer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RandomPlayer;
        static Load(InName: string): AnimGraphNode_RandomPlayer;
    }
    
    class AnimNode_ResetRoot extends UE.AnimNode_SkeletalControlBase {
        constructor();
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_ResetRoot extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_ResetRoot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ResetRoot;
        static Load(InName: string): AnimGraphNode_ResetRoot;
    }
    
    enum ESimulationSpace { ComponentSpace, WorldSpace, BaseBoneSpace, ESimulationSpace_MAX}
    class AnimNode_RigidBody extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(OverridePhysicsAsset: UE.PhysicsAsset, OverrideWorldGravity: UE.Vector, ExternalForce: UE.Vector, ComponentLinearAccScale: UE.Vector, ComponentLinearVelScale: UE.Vector, ComponentAppliedLinearAccClamp: UE.Vector, CachedBoundsScale: number, BaseBoneRef: UE.BoneReference, OverlapChannel: UE.ECollisionChannel, SimulationSpace: UE.ESimulationSpace, bForceDisableCollisionBetweenConstraintBodies: boolean, bEnableWorldGeometry: boolean, bOverrideWorldGravity: boolean, bTransferBoneVelocities: boolean, bFreezeIncomingPoseOnStart: boolean, bClampLinearTranslationLimitToRefPose: boolean, bComponentSpaceSimulation: boolean);
        OverridePhysicsAsset: UE.PhysicsAsset;
        OverrideWorldGravity: UE.Vector;
        ExternalForce: UE.Vector;
        ComponentLinearAccScale: UE.Vector;
        ComponentLinearVelScale: UE.Vector;
        ComponentAppliedLinearAccClamp: UE.Vector;
        CachedBoundsScale: number;
        BaseBoneRef: UE.BoneReference;
        OverlapChannel: UE.ECollisionChannel;
        SimulationSpace: UE.ESimulationSpace;
        bForceDisableCollisionBetweenConstraintBodies: boolean;
        bEnableWorldGeometry: boolean;
        bOverrideWorldGravity: boolean;
        bTransferBoneVelocities: boolean;
        bFreezeIncomingPoseOnStart: boolean;
        bClampLinearTranslationLimitToRefPose: boolean;
        bComponentSpaceSimulation: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_RigidBody extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_RigidBody;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RigidBody;
        static Load(InName: string): AnimGraphNode_RigidBody;
    }
    
    class AnimNode_RigidBody_Chaos extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(OverridePhysicsAsset: UE.PhysicsAsset, OverrideWorldGravity: UE.Vector, ExternalForce: UE.Vector, ComponentLinearAccScale: UE.Vector, ComponentLinearVelScale: UE.Vector, ComponentAppliedLinearAccClamp: UE.Vector, CachedBoundsScale: number, BaseBoneRef: UE.BoneReference, OverlapChannel: UE.ECollisionChannel, SimulationSpace: UE.ESimulationSpace, bForceDisableCollisionBetweenConstraintBodies: boolean, bEnableWorldGeometry: boolean, bOverrideWorldGravity: boolean, bTransferBoneVelocities: boolean, bFreezeIncomingPoseOnStart: boolean, bClampLinearTranslationLimitToRefPose: boolean, bComponentSpaceSimulation: boolean);
        OverridePhysicsAsset: UE.PhysicsAsset;
        OverrideWorldGravity: UE.Vector;
        ExternalForce: UE.Vector;
        ComponentLinearAccScale: UE.Vector;
        ComponentLinearVelScale: UE.Vector;
        ComponentAppliedLinearAccClamp: UE.Vector;
        CachedBoundsScale: number;
        BaseBoneRef: UE.BoneReference;
        OverlapChannel: UE.ECollisionChannel;
        SimulationSpace: UE.ESimulationSpace;
        bForceDisableCollisionBetweenConstraintBodies: boolean;
        bEnableWorldGeometry: boolean;
        bOverrideWorldGravity: boolean;
        bTransferBoneVelocities: boolean;
        bFreezeIncomingPoseOnStart: boolean;
        bClampLinearTranslationLimitToRefPose: boolean;
        bComponentSpaceSimulation: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_RigidBody_Chaos extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_RigidBody_Chaos;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RigidBody_Chaos;
        static Load(InName: string): AnimGraphNode_RigidBody_Chaos;
    }
    
    class AnimGraphNode_Root extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_Root;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Root;
        static Load(InName: string): AnimGraphNode_Root;
    }
    
    class AnimNode_RotateRootBone extends UE.AnimNode_Base {
        constructor();
        constructor(BasePose: UE.PoseLink, Pitch: number, Yaw: number, PitchScaleBiasClamp: UE.InputScaleBiasClamp, YawScaleBiasClamp: UE.InputScaleBiasClamp, MeshToComponent: UE.Rotator);
        BasePose: UE.PoseLink;
        Pitch: number;
        Yaw: number;
        PitchScaleBiasClamp: UE.InputScaleBiasClamp;
        YawScaleBiasClamp: UE.InputScaleBiasClamp;
        MeshToComponent: UE.Rotator;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_RotateRootBone extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_RotateRootBone;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RotateRootBone;
        static Load(InName: string): AnimGraphNode_RotateRootBone;
    }
    
    class AnimNode_RotationMultiplier extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(TargetBone: UE.BoneReference, SourceBone: UE.BoneReference, Multiplier: number, RotationAxisToRefer: UE.EBoneAxis, bIsAdditive: boolean);
        TargetBone: UE.BoneReference;
        SourceBone: UE.BoneReference;
        Multiplier: number;
        RotationAxisToRefer: UE.EBoneAxis;
        bIsAdditive: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_RotationMultiplier extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_RotationMultiplier;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RotationMultiplier;
        static Load(InName: string): AnimGraphNode_RotationMultiplier;
    }
    
    class AnimNode_RotationOffsetBlendSpace extends UE.AnimNode_BlendSpacePlayer {
        constructor();
        constructor(BasePose: UE.PoseLink, LODThreshold: number, Alpha: number, AlphaScaleBias: UE.InputScaleBias, AlphaBoolBlend: UE.InputAlphaBoolBlend, AlphaCurveName: string, AlphaScaleBiasClamp: UE.InputScaleBiasClamp, AlphaInputType: UE.EAnimAlphaInputType, bAlphaBoolEnabled: boolean);
        BasePose: UE.PoseLink;
        LODThreshold: number;
        Alpha: number;
        AlphaScaleBias: UE.InputScaleBias;
        AlphaBoolBlend: UE.InputAlphaBoolBlend;
        AlphaCurveName: string;
        AlphaScaleBiasClamp: UE.InputScaleBiasClamp;
        AlphaInputType: UE.EAnimAlphaInputType;
        bAlphaBoolEnabled: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_RotationOffsetBlendSpace extends UE.AnimGraphNode_BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_RotationOffsetBlendSpace;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RotationOffsetBlendSpace;
        static Load(InName: string): AnimGraphNode_RotationOffsetBlendSpace;
    }
    
    class AnimNode_SaveCachedPose extends UE.AnimNode_Base {
        constructor();
        constructor(Pose: UE.PoseLink, CachePoseName: string);
        Pose: UE.PoseLink;
        CachePoseName: string;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_SaveCachedPose extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_SaveCachedPose;
        CacheName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SaveCachedPose;
        static Load(InName: string): AnimGraphNode_SaveCachedPose;
    }
    
    enum EScaleChainInitialLength { FixedDefaultLengthValue, Distance, ChainLength, EScaleChainInitialLength_MAX}
    class AnimNode_ScaleChainLength extends UE.AnimNode_Base {
        constructor();
        constructor(InputPose: UE.PoseLink, DefaultChainLength: number, ChainStartBone: UE.BoneReference, ChainEndBone: UE.BoneReference, TargetLocation: UE.Vector, Alpha: number, AlphaScaleBias: UE.InputScaleBias, ChainInitialLength: UE.EScaleChainInitialLength);
        InputPose: UE.PoseLink;
        DefaultChainLength: number;
        ChainStartBone: UE.BoneReference;
        ChainEndBone: UE.BoneReference;
        TargetLocation: UE.Vector;
        Alpha: number;
        AlphaScaleBias: UE.InputScaleBias;
        ChainInitialLength: UE.EScaleChainInitialLength;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_ScaleChainLength extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_ScaleChainLength;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ScaleChainLength;
        static Load(InName: string): AnimGraphNode_ScaleChainLength;
    }
    
    enum ESequenceEvalReinit { NoReset, StartPosition, ExplicitTime, ESequenceEvalReinit_MAX}
    class AnimNode_SequenceEvaluator extends UE.AnimNode_AssetPlayerBase {
        constructor();
        constructor(Sequence: UE.AnimSequenceBase, ExplicitTime: number, bShouldLoop: boolean, bTeleportToExplicitTime: boolean, ReinitializationBehavior: UE.ESequenceEvalReinit, StartPosition: number);
        Sequence: UE.AnimSequenceBase;
        ExplicitTime: number;
        bShouldLoop: boolean;
        bTeleportToExplicitTime: boolean;
        ReinitializationBehavior: UE.ESequenceEvalReinit;
        StartPosition: number;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_SequenceEvaluator extends UE.AnimGraphNode_AssetPlayerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_SequenceEvaluator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SequenceEvaluator;
        static Load(InName: string): AnimGraphNode_SequenceEvaluator;
    }
    
    class AnimNode_SequencePlayer extends UE.AnimNode_AssetPlayerBase {
        constructor();
        constructor(Sequence: UE.AnimSequenceBase, PlayRateBasis: number, PlayRate: number, PlayRateScaleBiasClamp: UE.InputScaleBiasClamp, StartPosition: number, bLoopAnimation: boolean);
        Sequence: UE.AnimSequenceBase;
        PlayRateBasis: number;
        PlayRate: number;
        PlayRateScaleBiasClamp: UE.InputScaleBiasClamp;
        StartPosition: number;
        bLoopAnimation: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_SequencePlayer extends UE.AnimGraphNode_AssetPlayerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_SequencePlayer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SequencePlayer;
        static Load(InName: string): AnimGraphNode_SequencePlayer;
    }
    
    class AnimNode_Slot extends UE.AnimNode_Base {
        constructor();
        constructor(Source: UE.PoseLink, SlotName: string, bAlwaysUpdateSourcePose: boolean);
        Source: UE.PoseLink;
        SlotName: string;
        bAlwaysUpdateSourcePose: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_Slot extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_Slot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Slot;
        static Load(InName: string): AnimGraphNode_Slot;
    }
    
    enum ESplineBoneAxis { None, X, Y, Z, ESplineBoneAxis_MAX}
    class AnimNode_SplineIK extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(StartBone: UE.BoneReference, EndBone: UE.BoneReference, BoneAxis: UE.ESplineBoneAxis, bAutoCalculateSpline: boolean, PointCount: number, ControlPoints: TArray<UE.Transform>, Roll: number, TwistStart: number, TwistEnd: number, TwistBlend: UE.AlphaBlend, Stretch: number, Offset: number);
        StartBone: UE.BoneReference;
        EndBone: UE.BoneReference;
        BoneAxis: UE.ESplineBoneAxis;
        bAutoCalculateSpline: boolean;
        PointCount: number;
        ControlPoints: TArray<UE.Transform>;
        Roll: number;
        TwistStart: number;
        TwistEnd: number;
        TwistBlend: UE.AlphaBlend;
        Stretch: number;
        Offset: number;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_SplineIK extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_SplineIK;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SplineIK;
        static Load(InName: string): AnimGraphNode_SplineIK;
    }
    
    class AnimNode_SpringBone extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(SpringBone: UE.BoneReference, MaxDisplacement: number, SpringStiffness: number, SpringDamping: number, ErrorResetThresh: number, bNoZSpring: boolean, bLimitDisplacement: boolean, bTranslateX: boolean, bTranslateY: boolean, bTranslateZ: boolean, bRotateX: boolean, bRotateY: boolean, bRotateZ: boolean);
        SpringBone: UE.BoneReference;
        MaxDisplacement: number;
        SpringStiffness: number;
        SpringDamping: number;
        ErrorResetThresh: number;
        bNoZSpring: boolean;
        bLimitDisplacement: boolean;
        bTranslateX: boolean;
        bTranslateY: boolean;
        bTranslateZ: boolean;
        bRotateX: boolean;
        bRotateY: boolean;
        bRotateZ: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_SpringBone extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_SpringBone;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SpringBone;
        static Load(InName: string): AnimGraphNode_SpringBone;
    }
    
    class AnimNode_StateMachine extends UE.AnimNode_Base {
        constructor();
        constructor(StateMachineIndexInClass: number, MaxTransitionsPerFrame: number, bSkipFirstUpdateTransition: boolean, bReinitializeOnBecomingRelevant: boolean);
        StateMachineIndexInClass: number;
        MaxTransitionsPerFrame: number;
        bSkipFirstUpdateTransition: boolean;
        bReinitializeOnBecomingRelevant: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_StateMachine extends UE.AnimGraphNode_StateMachineBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_StateMachine;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_StateMachine;
        static Load(InName: string): AnimGraphNode_StateMachine;
    }
    
    enum EMotionRange { VR_WithoutController, VR_WithController, VR_MAX}
    enum EHand { VR_LeftHand, VR_RightHand, VR_MAX}
    enum EHandSkeleton { VR_SteamVRHandSkeleton, VR_UE4HandSkeleton, VR_MAX}
    class SteamVRSkeletonTransform {
        constructor();
        constructor(Root: UE.Transform, Wrist: UE.Transform, Thumb_0: UE.Transform, Thumb_1: UE.Transform, Thumb_2: UE.Transform, Thumb_3: UE.Transform, Index_0: UE.Transform, Index_1: UE.Transform, Index_2: UE.Transform, Index_3: UE.Transform, Index_4: UE.Transform, Middle_0: UE.Transform, Middle_1: UE.Transform, Middle_2: UE.Transform, Middle_3: UE.Transform, Middle_4: UE.Transform, Ring_0: UE.Transform, Ring_1: UE.Transform, Ring_2: UE.Transform, Ring_3: UE.Transform, Ring_4: UE.Transform, Pinky_0: UE.Transform, Pinky_1: UE.Transform, Pinky_2: UE.Transform, Pinky_3: UE.Transform, Pinky_4: UE.Transform, Aux_Thumb: UE.Transform, Aux_Index: UE.Transform, Aux_Middle: UE.Transform, Aux_Ring: UE.Transform, Aux_Pinky: UE.Transform);
        Root: UE.Transform;
        Wrist: UE.Transform;
        Thumb_0: UE.Transform;
        Thumb_1: UE.Transform;
        Thumb_2: UE.Transform;
        Thumb_3: UE.Transform;
        Index_0: UE.Transform;
        Index_1: UE.Transform;
        Index_2: UE.Transform;
        Index_3: UE.Transform;
        Index_4: UE.Transform;
        Middle_0: UE.Transform;
        Middle_1: UE.Transform;
        Middle_2: UE.Transform;
        Middle_3: UE.Transform;
        Middle_4: UE.Transform;
        Ring_0: UE.Transform;
        Ring_1: UE.Transform;
        Ring_2: UE.Transform;
        Ring_3: UE.Transform;
        Ring_4: UE.Transform;
        Pinky_0: UE.Transform;
        Pinky_1: UE.Transform;
        Pinky_2: UE.Transform;
        Pinky_3: UE.Transform;
        Pinky_4: UE.Transform;
        Aux_Thumb: UE.Transform;
        Aux_Index: UE.Transform;
        Aux_Middle: UE.Transform;
        Aux_Ring: UE.Transform;
        Aux_Pinky: UE.Transform;
        static StaticClass(): Class;
    }
    
    class UE4RetargettingRefs {
        constructor();
        constructor(bIsInitialized: boolean, bIsRightHanded: boolean, KnuckleAverageMS_UE4: UE.Vector, WristSideDirectionLS_UE4: UE.Vector, WristForwardLS_UE4: UE.Vector);
        bIsInitialized: boolean;
        bIsRightHanded: boolean;
        KnuckleAverageMS_UE4: UE.Vector;
        WristSideDirectionLS_UE4: UE.Vector;
        WristForwardLS_UE4: UE.Vector;
        static StaticClass(): Class;
    }
    
    class AnimNode_SteamVRInputAnimPose extends UE.AnimNode_Base {
        constructor();
        constructor(MotionRange: UE.EMotionRange, Hand: UE.EHand, HandSkeleton: UE.EHandSkeleton, Mirror: boolean, SteamVRSkeletalTransform: UE.SteamVRSkeletonTransform, UE4RetargettingRefs: UE.UE4RetargettingRefs);
        MotionRange: UE.EMotionRange;
        Hand: UE.EHand;
        HandSkeleton: UE.EHandSkeleton;
        Mirror: boolean;
        SteamVRSkeletalTransform: UE.SteamVRSkeletonTransform;
        UE4RetargettingRefs: UE.UE4RetargettingRefs;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_SteamVRInputAnimPose extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_SteamVRInputAnimPose;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SteamVRInputAnimPose;
        static Load(InName: string): AnimGraphNode_SteamVRInputAnimPose;
    }
    
    class AnimNode_SteamVRSetWristTransform extends UE.AnimNode_Base {
        constructor();
        constructor(ReferencePose: UE.PoseLink, HandSkeleton: UE.EHandSkeleton, TargetPose: UE.PoseLink);
        ReferencePose: UE.PoseLink;
        HandSkeleton: UE.EHandSkeleton;
        TargetPose: UE.PoseLink;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_SteamVRSetWristTransform extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_SteamVRSetWristTransform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SteamVRSetWristTransform;
        static Load(InName: string): AnimGraphNode_SteamVRSetWristTransform;
    }
    
    class RotationLimit {
        constructor();
        constructor(LimitMin: UE.Vector, LimitMax: UE.Vector);
        LimitMin: UE.Vector;
        LimitMax: UE.Vector;
        static StaticClass(): Class;
    }
    
    class AnimNode_Trail extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(TrailBone: UE.BoneReference, ChainLength: number, ChainBoneAxis: UE.EAxis, bInvertChainBoneAxis: boolean, bLimitStretch: boolean, bLimitRotation: boolean, bUsePlanarLimit: boolean, bActorSpaceFakeVel: boolean, bReorientParentToChild: boolean, bEnableDebug: boolean, bShowBaseMotion: boolean, bShowTrailLocation: boolean, bShowLimit: boolean, DebugLifeTime: number, TrailRelaxation: number, MaxDeltaTime: number, RelaxationSpeedScale: number, TrailRelaxationSpeed: UE.RuntimeFloatCurve, RelaxationSpeedScaleInputProcessor: UE.InputScaleBiasClamp, RotationLimits: TArray<UE.RotationLimit>, RotationOffsets: TArray<UE.Vector>, PlanarLimits: TArray<UE.AnimPhysPlanarLimit>, StretchLimit: number, FakeVelocity: UE.Vector, BaseJoint: UE.BoneReference, TrailBoneRotationBlendAlpha: number, LastBoneRotationAnimAlphaBlend: number);
        TrailBone: UE.BoneReference;
        ChainLength: number;
        ChainBoneAxis: UE.EAxis;
        bInvertChainBoneAxis: boolean;
        bLimitStretch: boolean;
        bLimitRotation: boolean;
        bUsePlanarLimit: boolean;
        bActorSpaceFakeVel: boolean;
        bReorientParentToChild: boolean;
        bEnableDebug: boolean;
        bShowBaseMotion: boolean;
        bShowTrailLocation: boolean;
        bShowLimit: boolean;
        DebugLifeTime: number;
        TrailRelaxation: number;
        MaxDeltaTime: number;
        RelaxationSpeedScale: number;
        TrailRelaxationSpeed: UE.RuntimeFloatCurve;
        RelaxationSpeedScaleInputProcessor: UE.InputScaleBiasClamp;
        RotationLimits: TArray<UE.RotationLimit>;
        RotationOffsets: TArray<UE.Vector>;
        PlanarLimits: TArray<UE.AnimPhysPlanarLimit>;
        StretchLimit: number;
        FakeVelocity: UE.Vector;
        BaseJoint: UE.BoneReference;
        TrailBoneRotationBlendAlpha: number;
        LastBoneRotationAnimAlphaBlend: number;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_Trail extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_Trail;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Trail;
        static Load(InName: string): AnimGraphNode_Trail;
    }
    
    enum EEvaluatorDataSource { EDS_SourcePose, EDS_DestinationPose, EDS_MAX}
    enum EEvaluatorMode { EM_Standard, EM_Freeze, EM_DelayedFreeze, EM_MAX}
    class AnimNode_TransitionPoseEvaluator extends UE.AnimNode_Base {
        constructor();
        constructor(FramesToCachePose: number, DataSource: UE.EEvaluatorDataSource, EvaluatorMode: UE.EEvaluatorMode);
        FramesToCachePose: number;
        DataSource: UE.EEvaluatorDataSource;
        EvaluatorMode: UE.EEvaluatorMode;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_TransitionPoseEvaluator extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_TransitionPoseEvaluator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_TransitionPoseEvaluator;
        static Load(InName: string): AnimGraphNode_TransitionPoseEvaluator;
    }
    
    class ReferenceBoneFrame {
        constructor();
        constructor(Bone: UE.BoneReference, Axis: UE.Axis);
        Bone: UE.BoneReference;
        Axis: UE.Axis;
        static StaticClass(): Class;
    }
    
    class AnimCurveParam {
        constructor();
        constructor(Name: string);
        Name: string;
        static StaticClass(): Class;
    }
    
    class AnimNode_TwistCorrectiveNode extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(BaseFrame: UE.ReferenceBoneFrame, TwistFrame: UE.ReferenceBoneFrame, TwistPlaneNormalAxis: UE.Axis, RangeMax: number, RemappedMin: number, RemappedMax: number, Curve: UE.AnimCurveParam);
        BaseFrame: UE.ReferenceBoneFrame;
        TwistFrame: UE.ReferenceBoneFrame;
        TwistPlaneNormalAxis: UE.Axis;
        RangeMax: number;
        RemappedMin: number;
        RemappedMax: number;
        Curve: UE.AnimCurveParam;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_TwistCorrectiveNode extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_TwistCorrectiveNode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_TwistCorrectiveNode;
        static Load(InName: string): AnimGraphNode_TwistCorrectiveNode;
    }
    
    class AnimNode_TwoBoneIK extends UE.AnimNode_SkeletalControlBase {
        constructor();
        constructor(IKBone: UE.BoneReference, StartStretchRatio: number, MaxStretchScale: number, StretchLimits: UE.Vector2D, bNoTwist: boolean, JointTargetSpaceBoneName: string, EffectorSpaceBoneName: string, EffectorLocation: UE.Vector, EffectorTarget: UE.BoneSocketTarget, JointTargetLocation: UE.Vector, JointTarget: UE.BoneSocketTarget, TwistAxis: UE.Axis, EffectorLocationSpace: UE.EBoneControlSpace, JointTargetLocationSpace: UE.EBoneControlSpace, bAllowStretching: boolean, bTakeRotationFromEffectorSpace: boolean, bMaintainEffectorRelRot: boolean, bAllowTwist: boolean);
        IKBone: UE.BoneReference;
        StartStretchRatio: number;
        MaxStretchScale: number;
        StretchLimits: UE.Vector2D;
        bNoTwist: boolean;
        JointTargetSpaceBoneName: string;
        EffectorSpaceBoneName: string;
        EffectorLocation: UE.Vector;
        EffectorTarget: UE.BoneSocketTarget;
        JointTargetLocation: UE.Vector;
        JointTarget: UE.BoneSocketTarget;
        TwistAxis: UE.Axis;
        EffectorLocationSpace: UE.EBoneControlSpace;
        JointTargetLocationSpace: UE.EBoneControlSpace;
        bAllowStretching: boolean;
        bTakeRotationFromEffectorSpace: boolean;
        bMaintainEffectorRelRot: boolean;
        bAllowTwist: boolean;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_TwoBoneIK extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_TwoBoneIK;
        bEnableDebugDraw: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_TwoBoneIK;
        static Load(InName: string): AnimGraphNode_TwoBoneIK;
    }
    
    class AnimNode_TwoWayBlend extends UE.AnimNode_Base {
        constructor();
        constructor(A: UE.PoseLink, B: UE.PoseLink, AlphaInputType: UE.EAnimAlphaInputType, bAlphaBoolEnabled: boolean, bResetChildOnActivation: boolean, Alpha: number, AlphaScaleBias: UE.InputScaleBias, AlphaBoolBlend: UE.InputAlphaBoolBlend, AlphaCurveName: string, AlphaScaleBiasClamp: UE.InputScaleBiasClamp);
        A: UE.PoseLink;
        B: UE.PoseLink;
        AlphaInputType: UE.EAnimAlphaInputType;
        bAlphaBoolEnabled: boolean;
        bResetChildOnActivation: boolean;
        Alpha: number;
        AlphaScaleBias: UE.InputScaleBias;
        AlphaBoolBlend: UE.InputAlphaBoolBlend;
        AlphaCurveName: string;
        AlphaScaleBiasClamp: UE.InputScaleBiasClamp;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_TwoWayBlend extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlendNode: UE.AnimNode_TwoWayBlend;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_TwoWayBlend;
        static Load(InName: string): AnimGraphNode_TwoWayBlend;
    }
    
    class AnimNode_UseCachedPose extends UE.AnimNode_Base {
        constructor();
        constructor(LinkToCachingNode: UE.PoseLink, CachePoseName: string);
        LinkToCachingNode: UE.PoseLink;
        CachePoseName: string;
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_UseCachedPose extends UE.AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_UseCachedPose;
        SaveCachedPoseNode: TWeakObjectPtr<UE.AnimGraphNode_SaveCachedPose>;
        NameOfCache: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_UseCachedPose;
        static Load(InName: string): AnimGraphNode_UseCachedPose;
    }
    
    class AnimNode_WheelHandler extends UE.AnimNode_SkeletalControlBase {
        constructor();
        static StaticClass(): Class;
    }
    
    class AnimGraphNode_WheelHandler extends UE.AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.AnimNode_WheelHandler;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_WheelHandler;
        static Load(InName: string): AnimGraphNode_WheelHandler;
    }
    
    class AnimLayerInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimLayerInterface;
        static Load(InName: string): AnimLayerInterface;
    }
    
    class AnimLayerInterfaceFactory extends UE.AnimBlueprintFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimLayerInterfaceFactory;
        static Load(InName: string): AnimLayerInterfaceFactory;
    }
    
    class AnimMontageFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeleton: UE.Skeleton;
        SourceAnimation: UE.AnimSequence;
        PreviewSkeletalMesh: UE.SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimMontageFactory;
        static Load(InName: string): AnimMontageFactory;
    }
    
    class AnimNotify_PauseClothingSimulation extends UE.AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify_PauseClothingSimulation;
        static Load(InName: string): AnimNotify_PauseClothingSimulation;
    }
    
    class AnimNotify_PlayMontageNotify extends UE.AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NotifyName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify_PlayMontageNotify;
        static Load(InName: string): AnimNotify_PlayMontageNotify;
    }
    
    class AnimNotify_PlayMontageNotifyWindow extends UE.AnimNotifyState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NotifyName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify_PlayMontageNotifyWindow;
        static Load(InName: string): AnimNotify_PlayMontageNotifyWindow;
    }
    
    class AnimNotify_PlayParticleEffect extends UE.AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PSTemplate: UE.ParticleSystem;
        LocationOffset: UE.Vector;
        RotationOffset: UE.Rotator;
        Scale: UE.Vector;
        Attached: boolean;
        SocketName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify_PlayParticleEffect;
        static Load(InName: string): AnimNotify_PlayParticleEffect;
    }
    
    class AnimNotify_PlaySound extends UE.AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sound: UE.SoundBase;
        VolumeMultiplier: number;
        PitchMultiplier: number;
        bFollow: boolean;
        AttachName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify_PlaySound;
        static Load(InName: string): AnimNotify_PlaySound;
    }
    
    class AnimNotify_ResetClothingSimulation extends UE.AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify_ResetClothingSimulation;
        static Load(InName: string): AnimNotify_ResetClothingSimulation;
    }
    
    class AnimNotify_ResetDynamics extends UE.AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify_ResetDynamics;
        static Load(InName: string): AnimNotify_ResetDynamics;
    }
    
    class AnimNotify_ResumeClothingSimulation extends UE.AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify_ResumeClothingSimulation;
        static Load(InName: string): AnimNotify_ResumeClothingSimulation;
    }
    
    class AnimNotifyState_DisableRootMotion extends UE.AnimNotifyState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotifyState_DisableRootMotion;
        static Load(InName: string): AnimNotifyState_DisableRootMotion;
    }
    
    class AnimNotifyState_TimedParticleEffect extends UE.AnimNotifyState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PSTemplate: UE.ParticleSystem;
        SocketName: string;
        LocationOffset: UE.Vector;
        RotationOffset: UE.Rotator;
        bDestroyAtEnd: boolean;
        PreviousPSTemplates: TArray<UE.ParticleSystem>;
        PreviousSocketNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotifyState_TimedParticleEffect;
        static Load(InName: string): AnimNotifyState_TimedParticleEffect;
    }
    
    class AnimNotifyState_Trail extends UE.AnimNotifyState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PSTemplate: UE.ParticleSystem;
        FirstSocketName: string;
        SecondSocketName: string;
        WidthScaleMode: UE.ETrailWidthMode;
        WidthScaleCurve: string;
        bRecycleSpawnedSystems: boolean;
        bRenderGeometry: boolean;
        bRenderSpawnPoints: boolean;
        bRenderTangents: boolean;
        bRenderTessellation: boolean;
        OverridePSTemplate(MeshComp: $Nullable<UE.SkeletalMeshComponent>, Animation: $Nullable<UE.AnimSequenceBase>) : UE.ParticleSystem;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotifyState_Trail;
        static Load(InName: string): AnimNotifyState_Trail;
    }
    
    class AnimPreviewAttacheInstance extends UE.AnimCustomInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimPreviewAttacheInstance;
        static Load(InName: string): AnimPreviewAttacheInstance;
    }
    
    class AnimSingleNodeInstance extends UE.AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurrentAsset: UE.AnimationAsset;
        PostEvaluateAnimEvent: $Delegate<() => void>;
        GetAnimationAsset() : UE.AnimationAsset;
        GetLength() : number;
        PlayAnim(bIsLooping?: boolean /* = false */, InPlayRate?: number /* = 1.000000 */, InStartPosition?: number /* = 0.000000 */) : void;
        SetAnimationAsset(NewAsset: $Nullable<UE.AnimationAsset>, bIsLooping?: boolean /* = true */, InPlayRate?: number /* = 1.000000 */) : void;
        SetBlendSpaceInput(InBlendInput: UE.Vector) : void;
        SetLooping(bIsLooping: boolean) : void;
        SetPlaying(bIsPlaying: boolean) : void;
        SetPlayRate(InPlayRate: number) : void;
        SetPosition(InPosition: number, bFireNotifies?: boolean /* = true */) : void;
        SetPositionWithPreviousTime(InPosition: number, InPreviousTime: number, bFireNotifies?: boolean /* = true */) : void;
        SetPreviewCurveOverride(PoseName: string, Value: number, bRemoveIfZero: boolean) : void;
        SetReverse(bInReverse: boolean) : void;
        StopAnim() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSingleNodeInstance;
        static Load(InName: string): AnimSingleNodeInstance;
    }
    
    enum EMontagePreviewType { EMPT_Normal, EMPT_AllSections, EMPT_MAX}
    class AnimPreviewInstance extends UE.AnimSingleNodeInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MontagePreviewType: UE.EMontagePreviewType;
        MontagePreviewStartSectionIdx: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimPreviewInstance;
        static Load(InName: string): AnimPreviewInstance;
    }
    
    class AssetExportTask extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Object: UE.Object;
        Exporter: UE.Exporter;
        Filename: string;
        bSelected: boolean;
        bReplaceIdentical: boolean;
        bPrompt: boolean;
        bAutomated: boolean;
        bUseFileArchive: boolean;
        bWriteEmptyFiles: boolean;
        IgnoreObjectList: TArray<UE.Object>;
        Options: UE.Object;
        Errors: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetExportTask;
        static Load(InName: string): AssetExportTask;
    }
    
    class Exporter extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SupportedClass: UE.Class;
        ExportRootScope: UE.Object;
        FormatExtension: TArray<string>;
        FormatDescription: TArray<string>;
        PreferredFormatIndex: number;
        TextIndent: number;
        bText: boolean;
        bSelectedOnly: boolean;
        bForceFileOperations: boolean;
        ExportTask: UE.AssetExportTask;
        ScriptRunAssetExportTask(Task: $Nullable<UE.AssetExportTask>) : boolean;
        static RunAssetExportTask(Task: $Nullable<UE.AssetExportTask>) : boolean;
        static RunAssetExportTasks(ExportTasks: TArray<UE.AssetExportTask>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Exporter;
        static Load(InName: string): Exporter;
    }
    
    class ExporterFBX extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ExporterFBX;
        static Load(InName: string): ExporterFBX;
    }
    
    class AnimSequenceExporterFBX extends UE.ExporterFBX {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSequenceExporterFBX;
        static Load(InName: string): AnimSequenceExporterFBX;
    }
    
    class AnimSequenceFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeleton: UE.Skeleton;
        PreviewSkeletalMesh: UE.SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSequenceFactory;
        static Load(InName: string): AnimSequenceFactory;
    }
    
    class AnimSequencerInstance extends UE.AnimCustomInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSequencerInstance;
        static Load(InName: string): AnimSequencerInstance;
    }
    
    class AnimSequenceThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSequenceThumbnailRenderer;
        static Load(InName: string): AnimSequenceThumbnailRenderer;
    }
    
    class AnimSetMeshLinkup {
        constructor();
        constructor(BoneToTrackTable: TArray<number>);
        BoneToTrackTable: TArray<number>;
        static StaticClass(): Class;
    }
    
    class AnimSet extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAnimRotationOnly: boolean;
        TrackBoneNames: TArray<string>;
        Sequences: TArray<UE.AnimSequence>;
        LinkupCache: TArray<UE.AnimSetMeshLinkup>;
        BoneUseAnimTranslation: TArray<number>;
        ForceUseMeshTranslation: TArray<number>;
        UseTranslationBoneNames: TArray<string>;
        ForceMeshTranslationBoneNames: TArray<string>;
        PreviewSkelMeshName: string;
        BestRatioSkelMeshName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSet;
        static Load(InName: string): AnimSet;
    }
    
    class AnimSharingAdditiveInstance extends UE.AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseComponent: TWeakObjectPtr<UE.SkeletalMeshComponent>;
        AdditiveAnimation: TWeakObjectPtr<UE.AnimSequence>;
        Alpha: number;
        bStateBool: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSharingAdditiveInstance;
        static Load(InName: string): AnimSharingAdditiveInstance;
    }
    
    class AnimSharingStateInstance extends UE.AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimationToPlay: UE.AnimSequence;
        PermutationTimeOffset: number;
        PlayRate: number;
        bStateBool: boolean;
        Instance: UE.AnimSharingInstance;
        GetInstancedActors(Actors: $Ref<TArray<UE.Actor>>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSharingStateInstance;
        static Load(InName: string): AnimSharingStateInstance;
    }
    
    class AnimSharingTransitionInstance extends UE.AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FromComponent: TWeakObjectPtr<UE.SkeletalMeshComponent>;
        ToComponent: TWeakObjectPtr<UE.SkeletalMeshComponent>;
        BlendTime: number;
        bBlendBool: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSharingTransitionInstance;
        static Load(InName: string): AnimSharingTransitionInstance;
    }
    
    class AnimStateNodeBase extends UE.EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimStateNodeBase;
        static Load(InName: string): AnimStateNodeBase;
    }
    
    class AnimStateConduitNode extends UE.AnimStateNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoundGraph: UE.EdGraph;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimStateConduitNode;
        static Load(InName: string): AnimStateConduitNode;
    }
    
    class AnimStateMachineTypes extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimStateMachineTypes;
        static Load(InName: string): AnimStateMachineTypes;
    }
    
    enum EAnimStateType { AST_SingleAnimation, AST_BlendGraph, AST_MAX}
    class AnimStateNode extends UE.AnimStateNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoundGraph: UE.EdGraph;
        StateType: UE.EAnimStateType;
        StateEntered: UE.AnimNotifyEvent;
        StateLeft: UE.AnimNotifyEvent;
        StateFullyBlended: UE.AnimNotifyEvent;
        bAlwaysResetOnEntry: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimStateNode;
        static Load(InName: string): AnimStateNode;
    }
    
    enum ETransitionBlendMode { TBM_Linear, TBM_Cubic, TBM_MAX}
    class AnimStateTransitionNode extends UE.AnimStateNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoundGraph: UE.EdGraph;
        CustomTransitionGraph: UE.EdGraph;
        PriorityOrder: number;
        CrossfadeDuration: number;
        CrossfadeMode: UE.ETransitionBlendMode;
        BlendMode: UE.EAlphaBlendOption;
        CustomBlendCurve: UE.CurveFloat;
        BlendProfile: UE.BlendProfile;
        bAutomaticRuleBasedOnSequencePlayerInState: boolean;
        LogicType: UE.ETransitionLogicType;
        TransitionStart: UE.AnimNotifyEvent;
        TransitionEnd: UE.AnimNotifyEvent;
        TransitionInterrupt: UE.AnimNotifyEvent;
        Bidirectional: boolean;
        bSharedRules: boolean;
        bSharedCrossfade: boolean;
        SharedRulesName: string;
        SharedRulesGuid: UE.Guid;
        SharedColor: UE.LinearColor;
        SharedCrossfadeName: string;
        SharedCrossfadeGuid: UE.Guid;
        SharedCrossfadeIdx: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimStateTransitionNode;
        static Load(InName: string): AnimStateTransitionNode;
    }
    
    class RawAnimSequenceTrack {
        constructor();
        constructor(PosKeys: TArray<UE.Vector>, RotKeys: TArray<UE.Quat>, ScaleKeys: TArray<UE.Vector>);
        PosKeys: TArray<UE.Vector>;
        RotKeys: TArray<UE.Quat>;
        ScaleKeys: TArray<UE.Vector>;
        static StaticClass(): Class;
    }
    
    class AnimStreamable extends UE.AnimSequenceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumFrames: number;
        Interpolation: UE.EAnimInterpolationType;
        RetargetSource: string;
        SourceSequence: UE.AnimSequence;
        CompressionScheme: UE.AnimCompress;
        RawDataGuid: UE.Guid;
        RawAnimationData: TArray<UE.RawAnimSequenceTrack>;
        TrackToSkeletonMapTable: TArray<UE.TrackToSkeletonMap>;
        AnimationTrackNames: TArray<string>;
        CurveCompressionSettings: UE.AnimCurveCompressionSettings;
        bEnableRootMotion: boolean;
        RootMotionRootLock: UE.ERootMotionRootLock;
        bForceRootLock: boolean;
        bUseNormalizedRootMotionScale: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimStreamable;
        static Load(InName: string): AnimStreamable;
    }
    
    class AnimStreamableFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeleton: UE.Skeleton;
        SourceAnimation: UE.AnimSequence;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimStreamableFactory;
        static Load(InName: string): AnimStreamableFactory;
    }
    
    namespace Game.Blueprints.TypeScript.Modules.AnotherActor {
        class AnotherActor_C extends UE.Actor {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            UberGraphFrame: UE.PointerToUberGraphFrame;
            DefaultSceneRoot: UE.SceneComponent;
            ExecuteUbergraph_AnotherActor(EntryPoint: number) : void;
            ReceiveBeginPlay() : void;
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): AnotherActor_C;
            static Load(InName: string): AnotherActor_C;
        }
        
    }

    class InputBehavior extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputBehavior;
        static Load(InName: string): InputBehavior;
    }
    
    class AnyButtonInputBehavior extends UE.InputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ButtonNumber: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnyButtonInputBehavior;
        static Load(InName: string): AnyButtonInputBehavior;
    }
    
    class AppleImageInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AppleImageInterface;
        static Load(InName: string): AppleImageInterface;
    }
    
    class AppleImageUtilsImageConversionResult {
        constructor();
        constructor(Error: string, ImageData: TArray<number>);
        Error: string;
        ImageData: TArray<number>;
        static StaticClass(): Class;
    }
    
    enum ETextureRotationDirection { None, Left, Right, Down, ETextureRotationDirection_MAX}
    class AppleImageUtilsBaseAsyncTaskBlueprintProxy extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(ConversionResult: UE.AppleImageUtilsImageConversionResult) => void>;
        OnFailure: $MulticastDelegate<(ConversionResult: UE.AppleImageUtilsImageConversionResult) => void>;
        ConversionResult: UE.AppleImageUtilsImageConversionResult;
        static CreateProxyObjectForConvertToHEIF(SourceImage: $Nullable<UE.Texture>, Quality?: number /* = 85 */, bWantColor?: boolean /* = true */, bUseGpu?: boolean /* = true */, Scale?: number /* = 1.000000 */, Rotate?: UE.ETextureRotationDirection /* = None */) : UE.AppleImageUtilsBaseAsyncTaskBlueprintProxy;
        static CreateProxyObjectForConvertToJPEG(SourceImage: $Nullable<UE.Texture>, Quality?: number /* = 85 */, bWantColor?: boolean /* = true */, bUseGpu?: boolean /* = true */, Scale?: number /* = 1.000000 */, Rotate?: UE.ETextureRotationDirection /* = None */) : UE.AppleImageUtilsBaseAsyncTaskBlueprintProxy;
        static CreateProxyObjectForConvertToPNG(SourceImage: $Nullable<UE.Texture>, bWantColor?: boolean /* = true */, bUseGpu?: boolean /* = true */, Scale?: number /* = 1.000000 */, Rotate?: UE.ETextureRotationDirection /* = None */) : UE.AppleImageUtilsBaseAsyncTaskBlueprintProxy;
        static CreateProxyObjectForConvertToTIFF(SourceImage: $Nullable<UE.Texture>, bWantColor?: boolean /* = true */, bUseGpu?: boolean /* = true */, Scale?: number /* = 1.000000 */, Rotate?: UE.ETextureRotationDirection /* = None */) : UE.AppleImageUtilsBaseAsyncTaskBlueprintProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AppleImageUtilsBaseAsyncTaskBlueprintProxy;
        static Load(InName: string): AppleImageUtilsBaseAsyncTaskBlueprintProxy;
    }
    
    enum ETemperatureSeverityType { Unknown, Good, Bad, Serious, Critical, NumSeverities, ETemperatureSeverityType_MAX}
    class ApplicationLifecycleComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ApplicationWillDeactivateDelegate: $MulticastDelegate<() => void>;
        ApplicationHasReactivatedDelegate: $MulticastDelegate<() => void>;
        ApplicationWillEnterBackgroundDelegate: $MulticastDelegate<() => void>;
        ApplicationHasEnteredForegroundDelegate: $MulticastDelegate<() => void>;
        ApplicationWillTerminateDelegate: $MulticastDelegate<() => void>;
        ApplicationShouldUnloadResourcesDelegate: $MulticastDelegate<() => void>;
        ApplicationReceivedStartupArgumentsDelegate: $MulticastDelegate<(StartupArguments: TArray<string>) => void>;
        OnTemperatureChangeDelegate: $MulticastDelegate<(Severity: UE.ETemperatureSeverityType) => void>;
        OnLowPowerModeDelegate: $MulticastDelegate<(bInLowPowerMode: boolean) => void>;
        ApplicationLifetimeDelegate__DelegateSignature() : void;
        ApplicationStartupArgumentsDelegate__DelegateSignature(StartupArguments: TArray<string>) : void;
        OnLowPowerModeDelegate__DelegateSignature(bInLowPowerMode: boolean) : void;
        OnTemperatureChangeDelegate__DelegateSignature(Severity: UE.ETemperatureSeverityType) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ApplicationLifecycleComponent;
        static Load(InName: string): ApplicationLifecycleComponent;
    }
    
    class BlueprintAsyncActionBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Activate() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintAsyncActionBase;
        static Load(InName: string): BlueprintAsyncActionBase;
    }
    
    class ARBaseAsyncTaskBlueprintProxy extends UE.BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARBaseAsyncTaskBlueprintProxy;
        static Load(InName: string): ARBaseAsyncTaskBlueprintProxy;
    }
    
    class ARLightEstimate extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARLightEstimate;
        static Load(InName: string): ARLightEstimate;
    }
    
    class ARBasicLightEstimate extends UE.ARLightEstimate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AmbientIntensityLumens: number;
        AmbientColorTemperatureKelvin: number;
        AmbientColor: UE.LinearColor;
        GetAmbientColor() : UE.LinearColor;
        GetAmbientColorTemperatureKelvin() : number;
        GetAmbientIntensityLumens() : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARBasicLightEstimate;
        static Load(InName: string): ARBasicLightEstimate;
    }
    
    enum EARWorldAlignment { Gravity, GravityAndHeading, Camera, EARWorldAlignment_MAX}
    enum EARSessionType { None, Orientation, World, Face, Image, ObjectScanning, PoseTracking, EARSessionType_MAX}
    enum EARPlaneDetectionMode { None, HorizontalPlaneDetection, VerticalPlaneDetection, EARPlaneDetectionMode_MAX}
    enum EARLightEstimationMode { None, AmbientLightEstimate, DirectionalLightEstimate, EARLightEstimationMode_MAX}
    enum EARFrameSyncMode { SyncTickWithCameraImage, SyncTickWithoutCameraImage, EARFrameSyncMode_MAX}
    enum EARCandidateImageOrientation { Landscape, Portrait, EARCandidateImageOrientation_MAX}
    class ARCandidateImage extends UE.DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CandidateTexture: UE.Texture2D;
        FriendlyName: string;
        Width: number;
        Height: number;
        Orientation: UE.EARCandidateImageOrientation;
        GetCandidateTexture() : UE.Texture2D;
        GetFriendlyName() : string;
        GetOrientation() : UE.EARCandidateImageOrientation;
        GetPhysicalHeight() : number;
        GetPhysicalWidth() : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARCandidateImage;
        static Load(InName: string): ARCandidateImage;
    }
    
    enum EAREnvironmentCaptureProbeType { None, Manual, Automatic, EAREnvironmentCaptureProbeType_MAX}
    class ARCandidateObject extends UE.DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CandidateObjectData: TArray<number>;
        FriendlyName: string;
        BoundingBox: UE.Box;
        GetBoundingBox() : UE.Box;
        GetCandidateObjectData() : TArray<number>;
        GetFriendlyName() : string;
        SetBoundingBox(InBoundingBox: UE.Box) : void;
        SetCandidateObjectData(InCandidateObject: TArray<number>) : void;
        SetFriendlyName(NewName: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARCandidateObject;
        static Load(InName: string): ARCandidateObject;
    }
    
    class ARVideoFormat {
        constructor();
        constructor(FPS: number, Width: number, Height: number);
        FPS: number;
        Width: number;
        Height: number;
        static StaticClass(): Class;
    }
    
    enum EARFaceTrackingDirection { FaceRelative, FaceMirrored, EARFaceTrackingDirection_MAX}
    enum EARFaceTrackingUpdate { CurvesAndGeo, CurvesOnly, EARFaceTrackingUpdate_MAX}
    enum EARSessionTrackingFeature { None, PoseDetection2D, PersonSegmentation, PersonSegmentationWithDepth, EARSessionTrackingFeature_MAX}
    class ARSessionConfig extends UE.DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bGenerateMeshDataFromTrackedGeometry: boolean;
        bGenerateCollisionForMeshData: boolean;
        bGenerateNavMeshForMeshData: boolean;
        bUseMeshDataForOcclusion: boolean;
        bRenderMeshDataInWireframe: boolean;
        bTrackSceneObjects: boolean;
        bUsePersonSegmentationForOcclusion: boolean;
        WorldAlignment: UE.EARWorldAlignment;
        SessionType: UE.EARSessionType;
        PlaneDetectionMode: UE.EARPlaneDetectionMode;
        bHorizontalPlaneDetection: boolean;
        bVerticalPlaneDetection: boolean;
        bEnableAutoFocus: boolean;
        LightEstimationMode: UE.EARLightEstimationMode;
        FrameSyncMode: UE.EARFrameSyncMode;
        bEnableAutomaticCameraOverlay: boolean;
        bEnableAutomaticCameraTracking: boolean;
        bResetCameraTracking: boolean;
        bResetTrackedObjects: boolean;
        CandidateImages: TArray<UE.ARCandidateImage>;
        MaxNumSimultaneousImagesTracked: number;
        EnvironmentCaptureProbeType: UE.EAREnvironmentCaptureProbeType;
        WorldMapData: TArray<number>;
        CandidateObjects: TArray<UE.ARCandidateObject>;
        DesiredVideoFormat: UE.ARVideoFormat;
        FaceTrackingDirection: UE.EARFaceTrackingDirection;
        FaceTrackingUpdate: UE.EARFaceTrackingUpdate;
        SerializedARCandidateImageDatabase: TArray<number>;
        EnabledSessionTrackingFeature: UE.EARSessionTrackingFeature;
        AddCandidateImage(NewCandidateImage: $Nullable<UE.ARCandidateImage>) : void;
        AddCandidateObject(CandidateObject: $Nullable<UE.ARCandidateObject>) : void;
        GetCandidateImageList() : TArray<UE.ARCandidateImage>;
        GetCandidateObjectList() : TArray<UE.ARCandidateObject>;
        GetDesiredVideoFormat() : UE.ARVideoFormat;
        GetEnabledSessionTrackingFeature() : UE.EARSessionTrackingFeature;
        GetEnvironmentCaptureProbeType() : UE.EAREnvironmentCaptureProbeType;
        GetFaceTrackingDirection() : UE.EARFaceTrackingDirection;
        GetFaceTrackingUpdate() : UE.EARFaceTrackingUpdate;
        GetFrameSyncMode() : UE.EARFrameSyncMode;
        GetLightEstimationMode() : UE.EARLightEstimationMode;
        GetMaxNumSimultaneousImagesTracked() : number;
        GetPlaneDetectionMode() : UE.EARPlaneDetectionMode;
        GetSessionType() : UE.EARSessionType;
        GetWorldAlignment() : UE.EARWorldAlignment;
        GetWorldMapData() : TArray<number>;
        SetCandidateObjectList(InCandidateObjects: TArray<UE.ARCandidateObject>) : void;
        SetDesiredVideoFormat(NewFormat: UE.ARVideoFormat) : void;
        SetEnableAutoFocus(bNewValue: boolean) : void;
        SetFaceTrackingDirection(InDirection: UE.EARFaceTrackingDirection) : void;
        SetFaceTrackingUpdate(InUpdate: UE.EARFaceTrackingUpdate) : void;
        SetResetCameraTracking(bNewValue: boolean) : void;
        SetResetTrackedObjects(bNewValue: boolean) : void;
        SetSessionTrackingFeatureToEnable(InSessionTrackingFeature: UE.EARSessionTrackingFeature) : void;
        SetWorldMapData(WorldMapData: TArray<number>) : void;
        ShouldEnableAutoFocus() : boolean;
        ShouldEnableCameraTracking() : boolean;
        ShouldRenderCameraOverlay() : boolean;
        ShouldResetCameraTracking() : boolean;
        ShouldResetTrackedObjects() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARSessionConfig;
        static Load(InName: string): ARSessionConfig;
    }
    
    enum EARTrackingState { Unknown, Tracking, NotTracking, StoppedTracking, EARTrackingState_MAX}
    class MRMeshComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Material: UE.MaterialInterface;
        bCreateMeshProxySections: boolean;
        bUpdateNavMeshOnMeshUpdate: boolean;
        bNeverCreateCollisionMesh: boolean;
        CachedBodySetup: UE.BodySetup;
        BodySetups: TArray<UE.BodySetup>;
        WireframeMaterial: UE.MaterialInterface;
        Clear() : void;
        ForceNavMeshUpdate() : void;
        IsConnected() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MRMeshComponent;
        static Load(InName: string): MRMeshComponent;
    }
    
    enum EARObjectClassification { NotApplicable, Unknown, Wall, Ceiling, Floor, Table, Seat, Face, Image, World, SceneObject, EARObjectClassification_MAX}
    class ARTrackedGeometry extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UniqueId: UE.Guid;
        LocalToTrackingTransform: UE.Transform;
        LocalToAlignedTrackingTransform: UE.Transform;
        TrackingState: UE.EARTrackingState;
        UnderlyingMesh: UE.MRMeshComponent;
        ObjectClassification: UE.EARObjectClassification;
        LastUpdateFrameNumber: number;
        DebugName: string;
        GetDebugName() : string;
        GetLastUpdateFrameNumber() : number;
        GetLastUpdateTimestamp() : number;
        GetLocalToTrackingTransform() : UE.Transform;
        GetLocalToWorldTransform() : UE.Transform;
        GetObjectClassification() : UE.EARObjectClassification;
        GetTrackingState() : UE.EARTrackingState;
        GetUnderlyingMesh() : UE.MRMeshComponent;
        IsTracked() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTrackedGeometry;
        static Load(InName: string): ARTrackedGeometry;
    }
    
    class ARPin extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TrackedGeometry: UE.ARTrackedGeometry;
        PinnedComponent: UE.SceneComponent;
        LocalToTrackingTransform: UE.Transform;
        LocalToAlignedTrackingTransform: UE.Transform;
        TrackingState: UE.EARTrackingState;
        OnARTrackingStateChanged: $MulticastDelegate<(NewTrackingState: UE.EARTrackingState) => void>;
        OnARTransformUpdated: $MulticastDelegate<(OldToNewTransform: UE.Transform) => void>;
        DebugDraw(World: $Nullable<UE.World>, Color: UE.LinearColor, Scale: number, PersistForSeconds: number) : void;
        GetDebugName() : string;
        GetLocalToTrackingTransform() : UE.Transform;
        GetLocalToWorldTransform() : UE.Transform;
        GetPinnedComponent() : UE.SceneComponent;
        GetTrackedGeometry() : UE.ARTrackedGeometry;
        GetTrackingState() : UE.EARTrackingState;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARPin;
        static Load(InName: string): ARPin;
    }
    
    enum EARLineTraceChannels { None, FeaturePoint, GroundPlane, PlaneUsingExtent, PlaneUsingBoundaryPolygon, EARLineTraceChannels_MAX}
    class ARTraceResult {
        constructor();
        constructor(DistanceFromCamera: number, TraceChannel: UE.EARLineTraceChannels, LocalToTrackingTransform: UE.Transform, TrackedGeometry: UE.ARTrackedGeometry);
        DistanceFromCamera: number;
        TraceChannel: UE.EARLineTraceChannels;
        LocalToTrackingTransform: UE.Transform;
        TrackedGeometry: UE.ARTrackedGeometry;
        static StaticClass(): Class;
    }
    
    enum EARWorldMappingState { NotAvailable, StillMappingNotRelocalizable, StillMappingRelocalizable, Mapped, EARWorldMappingState_MAX}
    enum EARTrackingQualityReason { None, Initializing, Relocalizing, ExcessiveMotion, InsufficientFeatures, EARTrackingQualityReason_MAX}
    enum EARTrackingQuality { NotTracking, OrientationOnly, OrientationAndPosition, EARTrackingQuality_MAX}
    enum EARTextureType { CameraImage, CameraDepth, EnvironmentCapture, EARTextureType_MAX}
    class ARTexture extends UE.Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TextureType: UE.EARTextureType;
        Timestamp: number;
        ExternalTextureGuid: UE.Guid;
        Size: UE.Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTexture;
        static Load(InName: string): ARTexture;
    }
    
    class ARTextureCameraImage extends UE.ARTexture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTextureCameraImage;
        static Load(InName: string): ARTextureCameraImage;
    }
    
    enum EARDepthQuality { Unkown, Low, High, EARDepthQuality_MAX}
    enum EARDepthAccuracy { Unkown, Approximate, Accurate, EARDepthAccuracy_MAX}
    class ARTextureCameraDepth extends UE.ARTexture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DepthQuality: UE.EARDepthQuality;
        DepthAccuracy: UE.EARDepthAccuracy;
        bIsTemporallySmoothed: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTextureCameraDepth;
        static Load(InName: string): ARTextureCameraDepth;
    }
    
    enum EARSessionStatus { NotStarted, Running, NotSupported, FatalError, PermissionNotGranted, UnsupportedConfiguration, Other, EARSessionStatus_MAX}
    class ARSessionStatus {
        constructor();
        constructor(AdditionalInfo: string, Status: UE.EARSessionStatus);
        AdditionalInfo: string;
        Status: UE.EARSessionStatus;
        static StaticClass(): Class;
    }
    
    class ARSkeletonDefinition {
        constructor();
        constructor(NumJoints: number, JointNames: TArray<string>, ParentIndices: TArray<number>);
        NumJoints: number;
        JointNames: TArray<string>;
        ParentIndices: TArray<number>;
        static StaticClass(): Class;
    }
    
    enum EARJointTransformSpace { Model, ParentJoint, EARJointTransformSpace_MAX}
    class ARPose3D {
        constructor();
        constructor(SkeletonDefinition: UE.ARSkeletonDefinition, JointTransforms: TArray<UE.Transform>, IsJointTracked: TArray<boolean>, JointTransformSpace: UE.EARJointTransformSpace);
        SkeletonDefinition: UE.ARSkeletonDefinition;
        JointTransforms: TArray<UE.Transform>;
        IsJointTracked: TArray<boolean>;
        JointTransformSpace: UE.EARJointTransformSpace;
        static StaticClass(): Class;
    }
    
    class ARTrackedPose extends UE.ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetTrackedPoseData() : UE.ARPose3D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTrackedPose;
        static Load(InName: string): ARTrackedPose;
    }
    
    class ARTrackedPoint extends UE.ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTrackedPoint;
        static Load(InName: string): ARTrackedPoint;
    }
    
    enum EARPlaneOrientation { Horizontal, Vertical, Diagonal, EARPlaneOrientation_MAX}
    class ARPlaneGeometry extends UE.ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Orientation: UE.EARPlaneOrientation;
        Center: UE.Vector;
        Extent: UE.Vector;
        SubsumedBy: UE.ARPlaneGeometry;
        GetBoundaryPolygonInLocalSpace() : TArray<UE.Vector>;
        GetCenter() : UE.Vector;
        GetExtent() : UE.Vector;
        GetOrientation() : UE.EARPlaneOrientation;
        GetSubsumedBy() : UE.ARPlaneGeometry;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARPlaneGeometry;
        static Load(InName: string): ARPlaneGeometry;
    }
    
    class ARTrackedImage extends UE.ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DetectedImage: UE.ARCandidateImage;
        EstimatedSize: UE.Vector2D;
        GetDetectedImage() : UE.ARCandidateImage;
        GetEstimateSize() : UE.Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTrackedImage;
        static Load(InName: string): ARTrackedImage;
    }
    
    class AREnvironmentCaptureProbeTexture extends UE.TextureCube {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TextureType: UE.EARTextureType;
        Timestamp: number;
        ExternalTextureGuid: UE.Guid;
        Size: UE.Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AREnvironmentCaptureProbeTexture;
        static Load(InName: string): AREnvironmentCaptureProbeTexture;
    }
    
    class AREnvironmentCaptureProbe extends UE.ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EnvironmentCaptureTexture: UE.AREnvironmentCaptureProbeTexture;
        GetEnvironmentCaptureTexture() : UE.AREnvironmentCaptureProbeTexture;
        GetExtent() : UE.Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AREnvironmentCaptureProbe;
        static Load(InName: string): AREnvironmentCaptureProbe;
    }
    
    class ARPose2D {
        constructor();
        constructor(SkeletonDefinition: UE.ARSkeletonDefinition, JointLocations: TArray<UE.Vector2D>, IsJointTracked: TArray<boolean>);
        SkeletonDefinition: UE.ARSkeletonDefinition;
        JointLocations: TArray<UE.Vector2D>;
        IsJointTracked: TArray<boolean>;
        static StaticClass(): Class;
    }
    
    class ARBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AddManualEnvironmentCaptureProbe(Location: UE.Vector, Extent: UE.Vector) : boolean;
        static AddRuntimeCandidateImage(SessionConfig: $Nullable<UE.ARSessionConfig>, CandidateTexture: $Nullable<UE.Texture2D>, FriendlyName: string, PhysicalWidth: number) : UE.ARCandidateImage;
        static DebugDrawPin(ARPin: $Nullable<UE.ARPin>, WorldContextObject: $Nullable<UE.Object>, Color?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=0.000000,A=0.750000) */, Scale?: number /* = 5.000000 */, PersistForSeconds?: number /* = 0.000000 */) : void;
        static DebugDrawTrackedGeometry(TrackedGeometry: $Nullable<UE.ARTrackedGeometry>, WorldContextObject: $Nullable<UE.Object>, Color?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=0.000000,A=0.750000) */, OutlineThickness?: number /* = 5.000000 */, PersistForSeconds?: number /* = 0.000000 */) : void;
        static GetAllGeometries() : TArray<UE.ARTrackedGeometry>;
        static GetAllPins() : TArray<UE.ARPin>;
        static GetAllTracked2DPoses() : TArray<UE.ARPose2D>;
        static GetAllTrackedEnvironmentCaptureProbes() : TArray<UE.AREnvironmentCaptureProbe>;
        static GetAllTrackedImages() : TArray<UE.ARTrackedImage>;
        static GetAllTrackedPlanes() : TArray<UE.ARPlaneGeometry>;
        static GetAllTrackedPoints() : TArray<UE.ARTrackedPoint>;
        static GetAllTrackedPoses() : TArray<UE.ARTrackedPose>;
        static GetARSessionStatus() : UE.ARSessionStatus;
        static GetCameraDepth() : UE.ARTextureCameraDepth;
        static GetCameraImage() : UE.ARTextureCameraImage;
        static GetCurrentLightEstimate() : UE.ARLightEstimate;
        static GetPersonSegmentationDepthImage() : UE.ARTextureCameraImage;
        static GetPersonSegmentationImage() : UE.ARTextureCameraImage;
        static GetPointCloud() : TArray<UE.Vector>;
        static GetSessionConfig() : UE.ARSessionConfig;
        static GetSupportedVideoFormats(SessionType: UE.EARSessionType) : TArray<UE.ARVideoFormat>;
        static GetTrackingQuality() : UE.EARTrackingQuality;
        static GetTrackingQualityReason() : UE.EARTrackingQualityReason;
        static GetWorldMappingStatus() : UE.EARWorldMappingState;
        static IsARSupported() : boolean;
        static IsSessionTrackingFeatureSupported(SessionType: UE.EARSessionType, SessionTrackingFeature: UE.EARSessionTrackingFeature) : boolean;
        static IsSessionTypeSupported(SessionType: UE.EARSessionType) : boolean;
        static LineTraceTrackedObjects(ScreenCoord: UE.Vector2D, bTestFeaturePoints?: boolean /* = true */, bTestGroundPlane?: boolean /* = true */, bTestPlaneExtents?: boolean /* = true */, bTestPlaneBoundaryPolygon?: boolean /* = true */) : TArray<UE.ARTraceResult>;
        static LineTraceTrackedObjects3D(Start: UE.Vector, End: UE.Vector, bTestFeaturePoints?: boolean /* = true */, bTestGroundPlane?: boolean /* = true */, bTestPlaneExtents?: boolean /* = true */, bTestPlaneBoundaryPolygon?: boolean /* = true */) : TArray<UE.ARTraceResult>;
        static PauseARSession() : void;
        static PinComponent(ComponentToPin: $Nullable<UE.SceneComponent>, PinToWorldTransform: UE.Transform, TrackedGeometry?: UE.ARTrackedGeometry /* = None */, DebugName?: string /* = "None" */) : UE.ARPin;
        static PinComponentToTraceResult(ComponentToPin: $Nullable<UE.SceneComponent>, TraceResult: UE.ARTraceResult, DebugName?: string /* = "None" */) : UE.ARPin;
        static RemovePin(PinToRemove: $Nullable<UE.ARPin>) : void;
        static SetAlignmentTransform(InAlignmentTransform: UE.Transform) : void;
        static StartARSession(SessionConfig: $Nullable<UE.ARSessionConfig>) : void;
        static StopARSession() : void;
        static UnpinComponent(ComponentToUnpin: $Nullable<UE.SceneComponent>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARBlueprintLibrary;
        static Load(InName: string): ARBlueprintLibrary;
    }
    
    class ArchVisCharacter extends UE.Character {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LookUpAxisName: string;
        LookUpAtRateAxisName: string;
        TurnAxisName: string;
        TurnAtRateAxisName: string;
        MoveForwardAxisName: string;
        MoveRightAxisName: string;
        MouseSensitivityScale_Pitch: number;
        MouseSensitivityScale_Yaw: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ArchVisCharacter;
        static Load(InName: string): ArchVisCharacter;
    }
    
    class ArchVisCharMovementComponent extends UE.CharacterMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RotationalAcceleration: UE.Rotator;
        RotationalDeceleration: UE.Rotator;
        MaxRotationalVelocity: UE.Rotator;
        MinPitch: number;
        MaxPitch: number;
        WalkingFriction: number;
        WalkingSpeed: number;
        WalkingAcceleration: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ArchVisCharMovementComponent;
        static Load(InName: string): ArchVisCharMovementComponent;
    }
    
    enum EShapeAddMode { AppendAfter, AppendBefore, InsertAfter, InsertBefore, EShapeAddMode_MAX}
    class SplineGeneratorBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShapeAddMode: UE.EShapeAddMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SplineGeneratorBase;
        static Load(InName: string): SplineGeneratorBase;
    }
    
    class ArcSplineGenerator extends UE.SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumberOfPoints: number;
        Radius: number;
        Degrees: number;
        bReverseDir: boolean;
        bKeepFirstKeyTangent: boolean;
        bBranchRight: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ArcSplineGenerator;
        static Load(InName: string): ArcSplineGenerator;
    }
    
    enum EARFaceBlendShape { EyeBlinkLeft, EyeLookDownLeft, EyeLookInLeft, EyeLookOutLeft, EyeLookUpLeft, EyeSquintLeft, EyeWideLeft, EyeBlinkRight, EyeLookDownRight, EyeLookInRight, EyeLookOutRight, EyeLookUpRight, EyeSquintRight, EyeWideRight, JawForward, JawLeft, JawRight, JawOpen, MouthClose, MouthFunnel, MouthPucker, MouthLeft, MouthRight, MouthSmileLeft, MouthSmileRight, MouthFrownLeft, MouthFrownRight, MouthDimpleLeft, MouthDimpleRight, MouthStretchLeft, MouthStretchRight, MouthRollLower, MouthRollUpper, MouthShrugLower, MouthShrugUpper, MouthPressLeft, MouthPressRight, MouthLowerDownLeft, MouthLowerDownRight, MouthUpperUpLeft, MouthUpperUpRight, BrowDownLeft, BrowDownRight, BrowInnerUp, BrowOuterUpLeft, BrowOuterUpRight, CheekPuff, CheekSquintLeft, CheekSquintRight, NoseSneerLeft, NoseSneerRight, TongueOut, HeadYaw, HeadPitch, HeadRoll, LeftEyeYaw, LeftEyePitch, LeftEyeRoll, RightEyeYaw, RightEyePitch, RightEyeRoll, MAX}
    enum EAREye { LeftEye, RightEye, EAREye_MAX}
    class ARFaceGeometry extends UE.ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LookAtTarget: UE.Vector;
        bIsTracked: boolean;
        BlendShapes: TMap<UE.EARFaceBlendShape, number>;
        GetBlendShapes() : TMap<UE.EARFaceBlendShape, number>;
        GetBlendShapeValue(BlendShape: UE.EARFaceBlendShape) : number;
        GetLocalSpaceEyeTransform(Eye: UE.EAREye) : UE.Transform;
        GetWorldSpaceEyeTransform(Eye: UE.EAREye) : UE.Transform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARFaceGeometry;
        static Load(InName: string): ARFaceGeometry;
    }
    
    class ARGetCandidateObjectAsyncTaskBlueprintProxy extends UE.ARBaseAsyncTaskBlueprintProxy {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(SavedObject: $Nullable<UE.ARCandidateObject>) => void>;
        OnFailed: $MulticastDelegate<(SavedObject: $Nullable<UE.ARCandidateObject>) => void>;
        static ARGetCandidateObject(WorldContextObject: $Nullable<UE.Object>, Location: UE.Vector, Extent: UE.Vector) : UE.ARGetCandidateObjectAsyncTaskBlueprintProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARGetCandidateObjectAsyncTaskBlueprintProxy;
        static Load(InName: string): ARGetCandidateObjectAsyncTaskBlueprintProxy;
    }
    
    class AROriginActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AROriginActor;
        static Load(InName: string): AROriginActor;
    }
    
    class ArrayProperty extends UE.Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ArrayProperty;
        static Load(InName: string): ArrayProperty;
    }
    
    class ARSaveWorldAsyncTaskBlueprintProxy extends UE.ARBaseAsyncTaskBlueprintProxy {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(SavedWorld: TArray<number>) => void>;
        OnFailed: $MulticastDelegate<(SavedWorld: TArray<number>) => void>;
        static ARSaveWorld(WorldContextObject: $Nullable<UE.Object>) : UE.ARSaveWorldAsyncTaskBlueprintProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARSaveWorldAsyncTaskBlueprintProxy;
        static Load(InName: string): ARSaveWorldAsyncTaskBlueprintProxy;
    }
    
    class GameMode extends UE.GameModeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MatchState: string;
        bDelayedStart: boolean;
        NumSpectators: number;
        NumPlayers: number;
        NumBots: number;
        MinRespawnDelay: number;
        NumTravellingPlayers: number;
        EngineMessageClass: UE.Class;
        InactivePlayerArray: TArray<UE.PlayerState>;
        InactivePlayerStateLifeSpan: number;
        MaxInactivePlayers: number;
        bHandleDedicatedServerReplays: boolean;
        AbortMatch() : void;
        EndMatch() : void;
        GetMatchState() : string;
        HasMatchEnded() : boolean;
        IsMatchInProgress() : boolean;
        K2_OnSetMatchState(NewState: string) : void;
        ReadyToEndMatch() : boolean;
        ReadyToStartMatch() : boolean;
        RestartGame() : void;
        Say(Msg: string) : void;
        SetBandwidthLimit(AsyncIOBandwidthLimit: number) : void;
        StartMatch() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameMode;
        static Load(InName: string): GameMode;
    }
    
    class GameState extends UE.GameStateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MatchState: string;
        PreviousMatchState: string;
        ElapsedTime: number;
        OnRep_ElapsedTime() : void;
        OnRep_MatchState() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameState;
        static Load(InName: string): GameState;
    }
    
    class ARSharedWorldGameState extends UE.GameState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PreviewImageData: TArray<number>;
        ARWorldData: TArray<number>;
        PreviewImageBytesTotal: number;
        ARWorldBytesTotal: number;
        PreviewImageBytesDelivered: number;
        ARWorldBytesDelivered: number;
        K2_OnARWorldMapIsReady() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARSharedWorldGameState;
        static Load(InName: string): ARSharedWorldGameState;
    }
    
    class ARSharedWorldGameMode extends UE.GameMode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BufferSizePerChunk: number;
        GetARSharedWorldGameState() : UE.ARSharedWorldGameState;
        SetARSharedWorldData(ARWorldData: TArray<number>) : void;
        SetARWorldSharingIsReady() : void;
        SetPreviewImageData(ImageData: TArray<number>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARSharedWorldGameMode;
        static Load(InName: string): ARSharedWorldGameMode;
    }
    
    class ARSharedWorldPlayerController extends UE.PlayerController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ClientInitSharedWorld(PreviewImageSize: number, ARWorldDataSize: number) : void;
        ClientUpdateARWorldData(Offset: number, Buffer: TArray<number>) : void;
        ClientUpdatePreviewImageData(Offset: number, Buffer: TArray<number>) : void;
        ServerMarkReadyForReceiving() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARSharedWorldPlayerController;
        static Load(InName: string): ARSharedWorldPlayerController;
    }
    
    class LightComponentBase extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightGuid: UE.Guid;
        Brightness: number;
        Intensity: number;
        LightColor: UE.Color;
        bAffectsWorld: boolean;
        CastShadows: boolean;
        CastStaticShadows: boolean;
        CastDynamicShadows: boolean;
        bAffectTranslucentLighting: boolean;
        bTransmission: boolean;
        bCastVolumetricShadow: boolean;
        bCastDeepShadow: boolean;
        bCastRaytracedShadow: boolean;
        bAffectReflection: boolean;
        bAffectGlobalIllumination: boolean;
        IndirectLightingIntensity: number;
        VolumetricScatteringIntensity: number;
        SamplesPerPixel: number;
        StaticEditorTexture: UE.Texture2D;
        StaticEditorTextureScale: number;
        DynamicEditorTexture: UE.Texture2D;
        DynamicEditorTextureScale: number;
        GetLightColor() : UE.LinearColor;
        SetAffectGlobalIllumination(bNewValue: boolean) : void;
        SetAffectReflection(bNewValue: boolean) : void;
        SetCastDeepShadow(bNewValue: boolean) : void;
        SetCastRaytracedShadow(bNewValue: boolean) : void;
        SetCastShadows(bNewValue: boolean) : void;
        SetCastVolumetricShadow(bNewValue: boolean) : void;
        SetSamplesPerPixel(NewValue: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightComponentBase;
        static Load(InName: string): LightComponentBase;
    }
    
    enum ESkyLightSourceType { SLS_CapturedScene, SLS_SpecifiedCubemap, SLS_MAX}
    enum EOcclusionCombineMode { OCM_Minimum, OCM_Multiply, OCM_MAX}
    class SkyLightComponent extends UE.LightComponentBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceType: UE.ESkyLightSourceType;
        Cubemap: UE.TextureCube;
        SourceCubemapAngle: number;
        CubemapResolution: number;
        SkyDistanceThreshold: number;
        bCaptureEmissiveOnly: boolean;
        bLowerHemisphereIsBlack: boolean;
        LowerHemisphereColor: UE.LinearColor;
        OcclusionMaxDistance: number;
        Contrast: number;
        OcclusionExponent: number;
        MinOcclusion: number;
        OcclusionTint: UE.Color;
        OcclusionCombineMode: UE.EOcclusionCombineMode;
        BlendDestinationCubemap: UE.TextureCube;
        RecaptureSky() : void;
        SetCubemap(NewCubemap: $Nullable<UE.TextureCube>) : void;
        SetCubemapBlend(SourceCubemap: $Nullable<UE.TextureCube>, DestinationCubemap: $Nullable<UE.TextureCube>, InBlendFraction: number) : void;
        SetIndirectLightingIntensity(NewIntensity: number) : void;
        SetIntensity(NewIntensity: number) : void;
        SetLightColor(NewLightColor: UE.LinearColor) : void;
        SetLowerHemisphereColor(InLowerHemisphereColor: UE.LinearColor) : void;
        SetMinOcclusion(InMinOcclusion: number) : void;
        SetOcclusionContrast(InOcclusionContrast: number) : void;
        SetOcclusionExponent(InOcclusionExponent: number) : void;
        SetOcclusionTint(InTint: UE.Color) : void;
        SetVolumetricScatteringIntensity(NewIntensity: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkyLightComponent;
        static Load(InName: string): SkyLightComponent;
    }
    
    class SkyLight extends UE.Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightComponent: UE.SkyLightComponent;
        bEnabled: boolean;
        OnRep_bEnabled() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkyLight;
        static Load(InName: string): SkyLight;
    }
    
    class ARSkyLight extends UE.SkyLight {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CaptureProbe: UE.AREnvironmentCaptureProbe;
        SetEnvironmentCaptureProbe(InCaptureProbe: $Nullable<UE.AREnvironmentCaptureProbe>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARSkyLight;
        static Load(InName: string): ARSkyLight;
    }
    
    class ARTraceResultDummy extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTraceResultDummy;
        static Load(InName: string): ARTraceResultDummy;
    }
    
    class ARTraceResultLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetDistanceFromCamera(TraceResult: UE.ARTraceResult) : number;
        static GetLocalToTrackingTransform(TraceResult: UE.ARTraceResult) : UE.Transform;
        static GetLocalToWorldTransform(TraceResult: UE.ARTraceResult) : UE.Transform;
        static GetTraceChannel(TraceResult: UE.ARTraceResult) : UE.EARLineTraceChannels;
        static GetTrackedGeometry(TraceResult: UE.ARTraceResult) : UE.ARTrackedGeometry;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTraceResultLibrary;
        static Load(InName: string): ARTraceResultLibrary;
    }
    
    class ARTrackedObject extends UE.ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DetectedObject: UE.ARCandidateObject;
        GetDetectedObject() : UE.ARCandidateObject;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTrackedObject;
        static Load(InName: string): ARTrackedObject;
    }
    
    class ARTrackableNotifyComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnAddTrackedGeometry: $MulticastDelegate<(TrackedGeometry: $Nullable<UE.ARTrackedGeometry>) => void>;
        OnUpdateTrackedGeometry: $MulticastDelegate<(TrackedGeometry: $Nullable<UE.ARTrackedGeometry>) => void>;
        OnRemoveTrackedGeometry: $MulticastDelegate<(TrackedGeometry: $Nullable<UE.ARTrackedGeometry>) => void>;
        OnAddTrackedPlane: $MulticastDelegate<(TrackedPlane: $Nullable<UE.ARPlaneGeometry>) => void>;
        OnUpdateTrackedPlane: $MulticastDelegate<(TrackedPlane: $Nullable<UE.ARPlaneGeometry>) => void>;
        OnRemoveTrackedPlane: $MulticastDelegate<(TrackedPlane: $Nullable<UE.ARPlaneGeometry>) => void>;
        OnAddTrackedPoint: $MulticastDelegate<(TrackedPoint: $Nullable<UE.ARTrackedPoint>) => void>;
        OnUpdateTrackedPoint: $MulticastDelegate<(TrackedPoint: $Nullable<UE.ARTrackedPoint>) => void>;
        OnRemoveTrackedPoint: $MulticastDelegate<(TrackedPoint: $Nullable<UE.ARTrackedPoint>) => void>;
        OnAddTrackedImage: $MulticastDelegate<(TrackedImage: $Nullable<UE.ARTrackedImage>) => void>;
        OnUpdateTrackedImage: $MulticastDelegate<(TrackedImage: $Nullable<UE.ARTrackedImage>) => void>;
        OnRemoveTrackedImage: $MulticastDelegate<(TrackedImage: $Nullable<UE.ARTrackedImage>) => void>;
        OnAddTrackedFace: $MulticastDelegate<(TrackedFace: $Nullable<UE.ARFaceGeometry>) => void>;
        OnUpdateTrackedFace: $MulticastDelegate<(TrackedFace: $Nullable<UE.ARFaceGeometry>) => void>;
        OnRemoveTrackedFace: $MulticastDelegate<(TrackedFace: $Nullable<UE.ARFaceGeometry>) => void>;
        OnAddTrackedEnvProbe: $MulticastDelegate<(TrackedEnvProbe: $Nullable<UE.AREnvironmentCaptureProbe>) => void>;
        OnUpdateTrackedEnvProbe: $MulticastDelegate<(TrackedEnvProbe: $Nullable<UE.AREnvironmentCaptureProbe>) => void>;
        OnRemoveTrackedEnvProbe: $MulticastDelegate<(TrackedEnvProbe: $Nullable<UE.AREnvironmentCaptureProbe>) => void>;
        OnAddTrackedObject: $MulticastDelegate<(TrackedObject: $Nullable<UE.ARTrackedObject>) => void>;
        OnUpdateTrackedObject: $MulticastDelegate<(TrackedObject: $Nullable<UE.ARTrackedObject>) => void>;
        OnRemoveTrackedObject: $MulticastDelegate<(TrackedObject: $Nullable<UE.ARTrackedObject>) => void>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTrackableNotifyComponent;
        static Load(InName: string): ARTrackableNotifyComponent;
    }
    
    class ARTrackedQRCode extends UE.ARTrackedImage {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        QRCode: string;
        Version: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTrackedQRCode;
        static Load(InName: string): ARTrackedQRCode;
    }
    
    class ARTypesDummyClass extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTypesDummyClass;
        static Load(InName: string): ARTypesDummyClass;
    }
    
    class AssetActionUtility extends UE.EditorUtilityObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetSupportedClass() : UE.Class;
        IsActionForBlueprints() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetActionUtility;
        static Load(InName: string): AssetActionUtility;
    }
    
    class AssetBakeOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetBakeOptions;
        static Load(InName: string): AssetBakeOptions;
    }
    
    class Subsystem extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Subsystem;
        static Load(InName: string): Subsystem;
    }
    
    class DynamicSubsystem extends UE.Subsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DynamicSubsystem;
        static Load(InName: string): DynamicSubsystem;
    }
    
    class EditorSubsystem extends UE.DynamicSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorSubsystem;
        static Load(InName: string): EditorSubsystem;
    }
    
    class AssetEditorSubsystem extends UE.EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CloseAllEditorsForAsset(Asset: $Nullable<UE.Object>) : number;
        OpenEditorForAssets(Assets: TArray<UE.Object>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetEditorSubsystem;
        static Load(InName: string): AssetEditorSubsystem;
    }
    
    class AssetEditorToolkitMenuContext extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetEditorToolkitMenuContext;
        static Load(InName: string): AssetEditorToolkitMenuContext;
    }
    
    class AssetManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ObjectReferenceList: TArray<UE.Object>;
        bIsGlobalAsyncScanEnvironment: boolean;
        bShouldGuessTypeAndName: boolean;
        bShouldUseSynchronousLoad: boolean;
        bIsLoadingFromPakFiles: boolean;
        bShouldAcquireMissingChunksOnLoad: boolean;
        bOnlyCookProductionAssets: boolean;
        bIsBulkScanning: boolean;
        bIsPrimaryAssetDirectoryCurrent: boolean;
        bIsManagementDatabaseCurrent: boolean;
        bUpdateManagementDatabaseAfterScan: boolean;
        bIncludeOnlyOnDiskAssets: boolean;
        NumberOfSpawnedNotifications: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetManager;
        static Load(InName: string): AssetManager;
    }
    
    enum EPrimaryAssetCookRule { Unknown, NeverCook, DevelopmentCook, DevelopmentAlwaysCook, AlwaysCook, EPrimaryAssetCookRule_MAX}
    class PrimaryAssetRules {
        constructor();
        constructor(Priority: number, ChunkId: number, bApplyRecursively: boolean, CookRule: UE.EPrimaryAssetCookRule);
        Priority: number;
        ChunkId: number;
        bApplyRecursively: boolean;
        CookRule: UE.EPrimaryAssetCookRule;
        static StaticClass(): Class;
    }
    
    class PrimaryAssetTypeInfo {
        constructor();
        constructor(PrimaryAssetType: string, AssetBaseClass: TSoftClassPtr<UE.Object>, AssetBaseClassLoaded: UE.Class, bHasBlueprintClasses: boolean, bIsEditorOnly: boolean, Directories: TArray<UE.DirectoryPath>, SpecificAssets: TArray<UE.SoftObjectPath>, Rules: UE.PrimaryAssetRules, AssetScanPaths: TArray<string>, bIsDynamicAsset: boolean, NumberOfAssets: number);
        PrimaryAssetType: string;
        AssetBaseClass: TSoftClassPtr<UE.Object>;
        AssetBaseClassLoaded: UE.Class;
        bHasBlueprintClasses: boolean;
        bIsEditorOnly: boolean;
        Directories: TArray<UE.DirectoryPath>;
        SpecificAssets: TArray<UE.SoftObjectPath>;
        Rules: UE.PrimaryAssetRules;
        AssetScanPaths: TArray<string>;
        bIsDynamicAsset: boolean;
        NumberOfAssets: number;
        static StaticClass(): Class;
    }
    
    class PrimaryAssetType {
        constructor();
        constructor(Name: string);
        Name: string;
        static StaticClass(): Class;
    }
    
    class PrimaryAssetId {
        constructor();
        constructor(PrimaryAssetType: UE.PrimaryAssetType, PrimaryAssetName: string);
        PrimaryAssetType: UE.PrimaryAssetType;
        PrimaryAssetName: string;
        static StaticClass(): Class;
    }
    
    class PrimaryAssetRulesOverride {
        constructor();
        constructor(PrimaryAssetId: UE.PrimaryAssetId, Rules: UE.PrimaryAssetRules);
        PrimaryAssetId: UE.PrimaryAssetId;
        Rules: UE.PrimaryAssetRules;
        static StaticClass(): Class;
    }
    
    class PrimaryAssetRulesCustomOverride {
        constructor();
        constructor(PrimaryAssetType: UE.PrimaryAssetType, FilterDirectory: UE.DirectoryPath, FilterString: string, Rules: UE.PrimaryAssetRules);
        PrimaryAssetType: UE.PrimaryAssetType;
        FilterDirectory: UE.DirectoryPath;
        FilterString: string;
        Rules: UE.PrimaryAssetRules;
        static StaticClass(): Class;
    }
    
    class AssetManagerRedirect {
        constructor();
        constructor(Old: string, New: string);
        Old: string;
        New: string;
        static StaticClass(): Class;
    }
    
    class AssetManagerSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PrimaryAssetTypesToScan: TArray<UE.PrimaryAssetTypeInfo>;
        DirectoriesToExclude: TArray<UE.DirectoryPath>;
        PrimaryAssetRules: TArray<UE.PrimaryAssetRulesOverride>;
        CustomPrimaryAssetRules: TArray<UE.PrimaryAssetRulesCustomOverride>;
        bOnlyCookProductionAssets: boolean;
        bShouldManagerDetermineTypeAndName: boolean;
        bShouldGuessTypeAndNameInEditor: boolean;
        bShouldAcquireMissingChunksOnLoad: boolean;
        PrimaryAssetIdRedirects: TArray<UE.AssetManagerRedirect>;
        PrimaryAssetTypeRedirects: TArray<UE.AssetManagerRedirect>;
        AssetPathRedirects: TArray<UE.AssetManagerRedirect>;
        MetaDataTagsForAssetRegistry: TSet<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetManagerSettings;
        static Load(InName: string): AssetManagerSettings;
    }
    
    class AssetData {
        constructor();
        constructor(ObjectPath: string, PackageName: string, PackagePath: string, AssetName: string, AssetClass: string);
        ObjectPath: string;
        PackageName: string;
        PackagePath: string;
        AssetName: string;
        AssetClass: string;
        static StaticClass(): Class;
    }
    
    class ARFilter {
        constructor();
        constructor(PackageNames: TArray<string>, PackagePaths: TArray<string>, ObjectPaths: TArray<string>, ClassNames: TArray<string>, RecursiveClassesExclusionSet: TSet<string>, bRecursivePaths: boolean, bRecursiveClasses: boolean, bIncludeOnlyOnDiskAssets: boolean);
        PackageNames: TArray<string>;
        PackagePaths: TArray<string>;
        ObjectPaths: TArray<string>;
        ClassNames: TArray<string>;
        RecursiveClassesExclusionSet: TSet<string>;
        bRecursivePaths: boolean;
        bRecursiveClasses: boolean;
        bIncludeOnlyOnDiskAssets: boolean;
        static StaticClass(): Class;
    }
    
    class AssetRegistryDependencyOptions {
        constructor();
        constructor(bIncludeSoftPackageReferences: boolean, bIncludeHardPackageReferences: boolean, bIncludeSearchableNames: boolean, bIncludeSoftManagementReferences: boolean, bIncludeHardManagementReferences: boolean);
        bIncludeSoftPackageReferences: boolean;
        bIncludeHardPackageReferences: boolean;
        bIncludeSearchableNames: boolean;
        bIncludeSoftManagementReferences: boolean;
        bIncludeHardManagementReferences: boolean;
        static StaticClass(): Class;
    }
    
    class AssetRegistry extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetAllAssets(OutAssetData: $Ref<TArray<UE.AssetData>>, bIncludeOnlyOnDiskAssets?: boolean /* = false */) : boolean;
        GetAllCachedPaths(OutPathList: $Ref<TArray<string>>) : void;
        GetAssetByObjectPath(ObjectPath: string, bIncludeOnlyOnDiskAssets?: boolean /* = false */) : UE.AssetData;
        GetAssets(Filter: UE.ARFilter, OutAssetData: $Ref<TArray<UE.AssetData>>) : boolean;
        GetAssetsByClass(ClassName: string, OutAssetData: $Ref<TArray<UE.AssetData>>, bSearchSubClasses?: boolean /* = false */) : boolean;
        GetAssetsByPackageName(PackageName: string, OutAssetData: $Ref<TArray<UE.AssetData>>, bIncludeOnlyOnDiskAssets?: boolean /* = false */) : boolean;
        GetAssetsByPath(PackagePath: string, OutAssetData: $Ref<TArray<UE.AssetData>>, bRecursive?: boolean /* = false */, bIncludeOnlyOnDiskAssets?: boolean /* = false */) : boolean;
        GetSubPaths(InBasePath: string, OutPathList: $Ref<TArray<string>>, bInRecurse: boolean) : void;
        HasAssets(PackagePath: string, bRecursive?: boolean /* = false */) : boolean;
        IsLoadingAssets() : boolean;
        K2_GetDependencies(PackageName: string, DependencyOptions: UE.AssetRegistryDependencyOptions, OutDependencies: $Ref<TArray<string>>) : boolean;
        K2_GetReferencers(PackageName: string, ReferenceOptions: UE.AssetRegistryDependencyOptions, OutReferencers: $Ref<TArray<string>>) : boolean;
        PrioritizeSearchPath(PathToPrioritize: string) : void;
        RunAssetsThroughFilter(AssetDataList: $Ref<TArray<UE.AssetData>>, Filter: UE.ARFilter) : void;
        ScanFilesSynchronous(InFilePaths: TArray<string>, bForceRescan?: boolean /* = false */) : void;
        ScanModifiedAssetFiles(InFilePaths: TArray<string>) : void;
        ScanPathsSynchronous(InPaths: TArray<string>, bForceRescan?: boolean /* = false */) : void;
        SearchAllAssets(bSynchronousSearch: boolean) : void;
        UseFilterToExcludeAssets(AssetDataList: $Ref<TArray<UE.AssetData>>, Filter: UE.ARFilter) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetRegistry;
        static Load(InName: string): AssetRegistry;
    }
    
    class TagAndValue {
        constructor();
        constructor(Tag: string, Value: string);
        Tag: string;
        Value: string;
        static StaticClass(): Class;
    }
    
    class AssetRegistryHelpers extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CreateAssetData(InAsset: $Nullable<UE.Object>, bAllowBlueprintClass?: boolean /* = false */) : UE.AssetData;
        static GetAsset(InAssetData: UE.AssetData) : UE.Object;
        static GetAssetRegistry() : AssetRegistry;
        static GetClass(InAssetData: UE.AssetData) : UE.Class;
        static GetExportTextName(InAssetData: UE.AssetData) : string;
        static GetFullName(InAssetData: UE.AssetData) : string;
        static GetTagValue(InAssetData: UE.AssetData, InTagName: string, OutTagValue: $Ref<string>) : boolean;
        static IsAssetLoaded(InAssetData: UE.AssetData) : boolean;
        static IsRedirector(InAssetData: UE.AssetData) : boolean;
        static IsUAsset(InAssetData: UE.AssetData) : boolean;
        static IsValid(InAssetData: UE.AssetData) : boolean;
        static SetFilterTagsAndValues(InFilter: UE.ARFilter, InTagsAndValues: TArray<UE.TagAndValue>) : UE.ARFilter;
        static ToSoftObjectPath(InAssetData: UE.AssetData) : UE.SoftObjectPath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetRegistryHelpers;
        static Load(InName: string): AssetRegistryHelpers;
    }
    
    class AssetRegistryImpl extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetRegistryImpl;
        static Load(InName: string): AssetRegistryImpl;
    }
    
    class AssetRegUtilCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetRegUtilCommandlet;
        static Load(InName: string): AssetRegUtilCommandlet;
    }
    
    class EngineSubsystem extends UE.DynamicSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EngineSubsystem;
        static Load(InName: string): EngineSubsystem;
    }
    
    enum ECollectionScriptingShareType { Local, Private, Shared, ECollectionScriptingShareType_MAX}
    class AssetTagsSubsystem extends UE.EngineSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddAssetDatasToCollection(Name: string, AssetDatas: TArray<UE.AssetData>) : boolean;
        AddAssetDataToCollection(Name: string, AssetData: UE.AssetData) : boolean;
        AddAssetPtrsToCollection(Name: string, AssetPtrs: TArray<UE.Object>) : boolean;
        AddAssetPtrToCollection(Name: string, AssetPtr: $Nullable<UE.Object>) : boolean;
        AddAssetsToCollection(Name: string, AssetPathNames: TArray<string>) : boolean;
        AddAssetToCollection(Name: string, AssetPathName: string) : boolean;
        CollectionExists(Name: string) : boolean;
        CreateCollection(Name: string, ShareType: UE.ECollectionScriptingShareType) : boolean;
        DestroyCollection(Name: string) : boolean;
        EmptyCollection(Name: string) : boolean;
        GetAssetsInCollection(Name: string) : TArray<UE.AssetData>;
        GetCollections() : TArray<string>;
        GetCollectionsContainingAsset(AssetPathName: string) : TArray<string>;
        GetCollectionsContainingAssetData(AssetData: UE.AssetData) : TArray<string>;
        GetCollectionsContainingAssetPtr(AssetPtr: $Nullable<UE.Object>) : TArray<string>;
        RemoveAssetDataFromCollection(Name: string, AssetData: UE.AssetData) : boolean;
        RemoveAssetDatasFromCollection(Name: string, AssetDatas: TArray<UE.AssetData>) : boolean;
        RemoveAssetFromCollection(Name: string, AssetPathName: string) : boolean;
        RemoveAssetPtrFromCollection(Name: string, AssetPtr: $Nullable<UE.Object>) : boolean;
        RemoveAssetPtrsFromCollection(Name: string, AssetPtrs: TArray<UE.Object>) : boolean;
        RemoveAssetsFromCollection(Name: string, AssetPathNames: TArray<string>) : boolean;
        RenameCollection(Name: string, NewName: string) : boolean;
        ReparentCollection(Name: string, NewParentName: string) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetTagsSubsystem;
        static Load(InName: string): AssetTagsSubsystem;
    }
    
    class AssetRenameData {
        constructor();
        constructor(Asset: TWeakObjectPtr<UE.Object>, NewPackagePath: string, NewName: string, OldObjectPath: UE.SoftObjectPath, NewObjectPath: UE.SoftObjectPath, bOnlyFixSoftReferences: boolean);
        Asset: TWeakObjectPtr<UE.Object>;
        NewPackagePath: string;
        NewName: string;
        OldObjectPath: UE.SoftObjectPath;
        NewObjectPath: UE.SoftObjectPath;
        bOnlyFixSoftReferences: boolean;
        static StaticClass(): Class;
    }
    
    class AssetTools extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CreateAsset(AssetName: string, PackagePath: string, AssetClass: $Nullable<UE.Class>, Factory: $Nullable<UE.Factory>, CallingContext?: string /* = "None" */) : UE.Object;
        CreateAssetWithDialog(AssetName: string, PackagePath: string, AssetClass: $Nullable<UE.Class>, Factory: $Nullable<UE.Factory>, CallingContext?: string /* = "None" */) : UE.Object;
        CreateUniqueAssetName(InBasePackageName: string, InSuffix: string, OutPackageName: $Ref<string>, OutAssetName: $Ref<string>) : void;
        DuplicateAsset(AssetName: string, PackagePath: string, OriginalObject: $Nullable<UE.Object>) : UE.Object;
        DuplicateAssetWithDialog(AssetName: string, PackagePath: string, OriginalObject: $Nullable<UE.Object>) : UE.Object;
        ExportAssets(AssetsToExport: TArray<string>, ExportPath: string) : void;
        ExportAssetsWithDialog(AssetsToExport: TArray<string>, bPromptForIndividualFilenames: boolean) : void;
        FindSoftReferencesToObject(TargetObject: UE.SoftObjectPath, ReferencingObjects: $Ref<TArray<UE.Object>>) : void;
        ImportAssetsAutomated(ImportData: $Nullable<UE.AutomatedAssetImportData>) : TArray<UE.Object>;
        ImportAssetsWithDialog(DestinationPath: string) : TArray<UE.Object>;
        ImportAssetTasks(ImportTasks: TArray<UE.AssetImportTask>) : void;
        OpenEditorForAssets(Assets: TArray<UE.Object>) : void;
        RenameAssets(AssetsAndNames: TArray<UE.AssetRenameData>) : boolean;
        RenameAssetsWithDialog(AssetsAndNames: TArray<UE.AssetRenameData>, bAutoCheckout?: boolean /* = false */) : void;
        RenameReferencingSoftObjectPaths(PackagesToCheck: TArray<UE.Package>, AssetRedirectorMap: TMap<UE.SoftObjectPath, UE.SoftObjectPath>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetTools;
        static Load(InName: string): AssetTools;
    }
    
    class AssetToolsHelpers extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetAssetTools() : AssetTools;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetToolsHelpers;
        static Load(InName: string): AssetToolsHelpers;
    }
    
    class AssetToolsImpl extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetToolsImpl;
        static Load(InName: string): AssetToolsImpl;
    }
    
    class AdvancedCopyMap {
        constructor();
        constructor(ClassToCopy: UE.SoftClassPath, AdvancedCopyCustomization: UE.SoftClassPath);
        ClassToCopy: UE.SoftClassPath;
        AdvancedCopyCustomization: UE.SoftClassPath;
        static StaticClass(): Class;
    }
    
    class AssetToolsSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AdvancedCopyCustomizations: TArray<UE.AdvancedCopyMap>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetToolsSettings;
        static Load(InName: string): AssetToolsSettings;
    }
    
    class PreviewSceneProfile {
        constructor();
        constructor(ProfileName: string, bSharedProfile: boolean, bUseSkyLighting: boolean, DirectionalLightIntensity: number, DirectionalLightColor: UE.LinearColor, SkyLightIntensity: number, bRotateLightingRig: boolean, bShowEnvironment: boolean, bShowFloor: boolean, EnvironmentColor: UE.LinearColor, EnvironmentIntensity: number, EnvironmentCubeMap: TSoftObjectPtr<UE.TextureCube>, EnvironmentCubeMapPath: string, bPostProcessingEnabled: boolean, PostProcessingSettings: UE.PostProcessSettings, LightingRigRotation: number, RotationSpeed: number, DirectionalLightRotation: UE.Rotator);
        ProfileName: string;
        bSharedProfile: boolean;
        bUseSkyLighting: boolean;
        DirectionalLightIntensity: number;
        DirectionalLightColor: UE.LinearColor;
        SkyLightIntensity: number;
        bRotateLightingRig: boolean;
        bShowEnvironment: boolean;
        bShowFloor: boolean;
        EnvironmentColor: UE.LinearColor;
        EnvironmentIntensity: number;
        EnvironmentCubeMap: TSoftObjectPtr<UE.TextureCube>;
        EnvironmentCubeMapPath: string;
        bPostProcessingEnabled: boolean;
        PostProcessingSettings: UE.PostProcessSettings;
        LightingRigRotation: number;
        RotationSpeed: number;
        DirectionalLightRotation: UE.Rotator;
        static StaticClass(): Class;
    }
    
    class AssetViewerSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Profiles: TArray<UE.PreviewSceneProfile>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetViewerSettings;
        static Load(InName: string): AssetViewerSettings;
    }
    
    class AsyncActionLoadPrimaryAssetBase extends UE.BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncActionLoadPrimaryAssetBase;
        static Load(InName: string): AsyncActionLoadPrimaryAssetBase;
    }
    
    class AsyncActionChangePrimaryAssetBundles extends UE.AsyncActionLoadPrimaryAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Completed: $MulticastDelegate<() => void>;
        static AsyncChangeBundleStateForMatchingPrimaryAssets(WorldContextObject: $Nullable<UE.Object>, NewBundles: TArray<string>, OldBundles: TArray<string>) : UE.AsyncActionChangePrimaryAssetBundles;
        static AsyncChangeBundleStateForPrimaryAssetList(WorldContextObject: $Nullable<UE.Object>, PrimaryAssetList: TArray<UE.PrimaryAssetId>, AddBundles: TArray<string>, RemoveBundles: TArray<string>) : UE.AsyncActionChangePrimaryAssetBundles;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncActionChangePrimaryAssetBundles;
        static Load(InName: string): AsyncActionChangePrimaryAssetBundles;
    }
    
    class SaveGame extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SaveGame;
        static Load(InName: string): SaveGame;
    }
    
    class AsyncActionHandleSaveGame extends UE.BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Completed: $MulticastDelegate<(SaveGame: $Nullable<UE.SaveGame>, bSuccess: boolean) => void>;
        SaveGameObject: UE.SaveGame;
        static AsyncLoadGameFromSlot(WorldContextObject: $Nullable<UE.Object>, SlotName: string, UserIndex: number) : UE.AsyncActionHandleSaveGame;
        static AsyncSaveGameToSlot(WorldContextObject: $Nullable<UE.Object>, SaveGameObject: $Nullable<UE.SaveGame>, SlotName: string, UserIndex: number) : UE.AsyncActionHandleSaveGame;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncActionHandleSaveGame;
        static Load(InName: string): AsyncActionHandleSaveGame;
    }
    
    class AsyncActionLoadPrimaryAsset extends UE.AsyncActionLoadPrimaryAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Completed: $MulticastDelegate<(Loaded: $Nullable<UE.Object>) => void>;
        static AsyncLoadPrimaryAsset(WorldContextObject: $Nullable<UE.Object>, PrimaryAsset: UE.PrimaryAssetId, LoadBundles: TArray<string>) : UE.AsyncActionLoadPrimaryAsset;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncActionLoadPrimaryAsset;
        static Load(InName: string): AsyncActionLoadPrimaryAsset;
    }
    
    class AsyncActionLoadPrimaryAssetClass extends UE.AsyncActionLoadPrimaryAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Completed: $MulticastDelegate<(Loaded: $Nullable<UE.Class>) => void>;
        static AsyncLoadPrimaryAssetClass(WorldContextObject: $Nullable<UE.Object>, PrimaryAsset: UE.PrimaryAssetId, LoadBundles: TArray<string>) : UE.AsyncActionLoadPrimaryAssetClass;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncActionLoadPrimaryAssetClass;
        static Load(InName: string): AsyncActionLoadPrimaryAssetClass;
    }
    
    class AsyncActionLoadPrimaryAssetClassList extends UE.AsyncActionLoadPrimaryAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Completed: $MulticastDelegate<(Loaded: TArray<UE.Class>) => void>;
        static AsyncLoadPrimaryAssetClassList(WorldContextObject: $Nullable<UE.Object>, PrimaryAssetList: TArray<UE.PrimaryAssetId>, LoadBundles: TArray<string>) : UE.AsyncActionLoadPrimaryAssetClassList;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncActionLoadPrimaryAssetClassList;
        static Load(InName: string): AsyncActionLoadPrimaryAssetClassList;
    }
    
    class AsyncActionLoadPrimaryAssetList extends UE.AsyncActionLoadPrimaryAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Completed: $MulticastDelegate<(Loaded: TArray<UE.Object>) => void>;
        static AsyncLoadPrimaryAssetList(WorldContextObject: $Nullable<UE.Object>, PrimaryAssetList: TArray<UE.PrimaryAssetId>, LoadBundles: TArray<string>) : UE.AsyncActionLoadPrimaryAssetList;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncActionLoadPrimaryAssetList;
        static Load(InName: string): AsyncActionLoadPrimaryAssetList;
    }
    
    class AsyncLoadState extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LoadedCallback: $Delegate<(Obj: $Nullable<UE.Class>) => void>;
        StartLoad(InPath: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncLoadState;
        static Load(InName: string): AsyncLoadState;
    }
    
    class XRDeviceId {
        constructor();
        constructor(SystemName: string, DeviceId: number);
        SystemName: string;
        DeviceId: number;
        static StaticClass(): Class;
    }
    
    class AsyncTask_LoadXRDeviceVisComponent extends UE.BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnModelLoaded: $MulticastDelegate<(LoadedComponent: $Nullable<UE.PrimitiveComponent>) => void>;
        OnLoadFailure: $MulticastDelegate<(LoadedComponent: $Nullable<UE.PrimitiveComponent>) => void>;
        SpawnedComponent: UE.PrimitiveComponent;
        static AddDeviceVisualizationComponentAsync(Target: $Nullable<UE.Actor>, XRDeviceId: UE.XRDeviceId, bManualAttachment: boolean, RelativeTransform: UE.Transform, NewComponent: $Ref<UE.PrimitiveComponent>) : UE.AsyncTask_LoadXRDeviceVisComponent;
        static AddNamedDeviceVisualizationComponentAsync(Target: $Nullable<UE.Actor>, SystemName: string, DeviceName: string, bManualAttachment: boolean, RelativeTransform: UE.Transform, XRDeviceId: $Ref<UE.XRDeviceId>, NewComponent: $Ref<UE.PrimitiveComponent>) : UE.AsyncTask_LoadXRDeviceVisComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncTask_LoadXRDeviceVisComponent;
        static Load(InName: string): AsyncTask_LoadXRDeviceVisComponent;
    }
    
    enum EPixelFormat { PF_Unknown, PF_A32B32G32R32F, PF_B8G8R8A8, PF_G8, PF_G16, PF_DXT1, PF_DXT3, PF_DXT5, PF_UYVY, PF_FloatRGB, PF_FloatRGBA, PF_DepthStencil, PF_ShadowDepth, PF_R32_FLOAT, PF_G16R16, PF_G16R16F, PF_G16R16F_FILTER, PF_G32R32F, PF_A2B10G10R10, PF_A16B16G16R16, PF_D24, PF_R16F, PF_R16F_FILTER, PF_BC5, PF_V8U8, PF_A1, PF_FloatR11G11B10, PF_A8, PF_R32_UINT, PF_R32_SINT, PF_PVRTC2, PF_PVRTC4, PF_R16_UINT, PF_R16_SINT, PF_R16G16B16A16_UINT, PF_R16G16B16A16_SINT, PF_R5G6B5_UNORM, PF_R8G8B8A8, PF_A8R8G8B8, PF_BC4, PF_R8G8, PF_ATC_RGB, PF_ATC_RGBA_E, PF_ATC_RGBA_I, PF_X24_G8, PF_ETC1, PF_ETC2_RGB, PF_ETC2_RGBA, PF_R32G32B32A32_UINT, PF_R16G16_UINT, PF_ASTC_4x4, PF_ASTC_6x6, PF_ASTC_8x8, PF_ASTC_10x10, PF_ASTC_12x12, PF_BC6H, PF_BC7, PF_R8_UINT, PF_L8, PF_XGXR8, PF_R8G8B8A8_UINT, PF_R8G8B8A8_SNORM, PF_R16G16B16A16_UNORM, PF_R16G16B16A16_SNORM, PF_PLATFORM_HDR_0, PF_PLATFORM_HDR_1, PF_PLATFORM_HDR_2, PF_NV12, PF_R32G32_UINT, PF_MAX}
    class Texture2DDynamic extends UE.Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Format: UE.EPixelFormat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Texture2DDynamic;
        static Load(InName: string): Texture2DDynamic;
    }
    
    class AsyncTaskDownloadImage extends UE.BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(Texture: $Nullable<UE.Texture2DDynamic>) => void>;
        OnFail: $MulticastDelegate<(Texture: $Nullable<UE.Texture2DDynamic>) => void>;
        static DownloadImage(URL: string) : UE.AsyncTaskDownloadImage;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncTaskDownloadImage;
        static Load(InName: string): AsyncTaskDownloadImage;
    }
    
    class AtmospherePrecomputeParameters {
        constructor();
        constructor(DensityHeight: number, DecayHeight: number, MaxScatteringOrder: number, TransmittanceTexWidth: number, TransmittanceTexHeight: number, IrradianceTexWidth: number, IrradianceTexHeight: number, InscatterAltitudeSampleNum: number, InscatterMuNum: number, InscatterMuSNum: number, InscatterNuNum: number);
        DensityHeight: number;
        DecayHeight: number;
        MaxScatteringOrder: number;
        TransmittanceTexWidth: number;
        TransmittanceTexHeight: number;
        IrradianceTexWidth: number;
        IrradianceTexHeight: number;
        InscatterAltitudeSampleNum: number;
        InscatterMuNum: number;
        InscatterMuSNum: number;
        InscatterNuNum: number;
        static StaticClass(): Class;
    }
    
    class AtmosphericFogComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SunMultiplier: number;
        FogMultiplier: number;
        DensityMultiplier: number;
        DensityOffset: number;
        DistanceScale: number;
        AltitudeScale: number;
        DistanceOffset: number;
        GroundOffset: number;
        StartDistance: number;
        SunDiscScale: number;
        DefaultBrightness: number;
        DefaultLightColor: UE.Color;
        bDisableSunDisk: boolean;
        bAtmosphereAffectsSunIlluminance: boolean;
        bDisableGroundScattering: boolean;
        PrecomputeParams: UE.AtmospherePrecomputeParameters;
        TransmittanceTexture: UE.Texture2D;
        IrradianceTexture: UE.Texture2D;
        DisableGroundScattering(NewGroundScattering: boolean) : void;
        DisableSunDisk(NewSunDisk: boolean) : void;
        SetAltitudeScale(NewAltitudeScale: number) : void;
        SetDefaultBrightness(NewBrightness: number) : void;
        SetDefaultLightColor(NewLightColor: UE.LinearColor) : void;
        SetDensityMultiplier(NewDensityMultiplier: number) : void;
        SetDensityOffset(NewDensityOffset: number) : void;
        SetDistanceOffset(NewDistanceOffset: number) : void;
        SetDistanceScale(NewDistanceScale: number) : void;
        SetFogMultiplier(NewFogMultiplier: number) : void;
        SetPrecomputeParams(DensityHeight: number, MaxScatteringOrder: number, InscatterAltitudeSampleNum: number) : void;
        SetStartDistance(NewStartDistance: number) : void;
        SetSunMultiplier(NewSunMultiplier: number) : void;
        StartPrecompute() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AtmosphericFogComponent;
        static Load(InName: string): AtmosphericFogComponent;
    }
    
    class AtmosphericFog extends UE.Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AtmosphericFogComponent: UE.AtmosphericFogComponent;
        ArrowComponent: UE.ArrowComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AtmosphericFog;
        static Load(InName: string): AtmosphericFog;
    }
    
    class AudioGenerator extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioGenerator;
        static Load(InName: string): AudioGenerator;
    }
    
    class AudioCaptureDeviceInfo {
        constructor();
        constructor(DeviceName: string, NumInputChannels: number, SampleRate: number);
        DeviceName: string;
        NumInputChannels: number;
        SampleRate: number;
        static StaticClass(): Class;
    }
    
    class AudioCapture extends UE.AudioGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetAudioCaptureDeviceInfo(OutInfo: $Ref<UE.AudioCaptureDeviceInfo>) : boolean;
        IsCapturingAudio() : boolean;
        StartCapturingAudio() : void;
        StopCapturingAudio() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioCapture;
        static Load(InName: string): AudioCapture;
    }
    
    class SoundWaveProcedural extends UE.SoundWave {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundWaveProcedural;
        static Load(InName: string): SoundWaveProcedural;
    }
    
    class SynthSound extends UE.SoundWaveProcedural {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OwningSynthComponent: UE.SynthComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SynthSound;
        static Load(InName: string): SynthSound;
    }
    
    class SynthComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoDestroy: boolean;
        bStopWhenOwnerDestroyed: boolean;
        bAllowSpatialization: boolean;
        bOverrideAttenuation: boolean;
        bOutputToBusOnly: boolean;
        AttenuationSettings: UE.SoundAttenuation;
        AttenuationOverrides: UE.SoundAttenuationSettings;
        ConcurrencySettings: UE.SoundConcurrency;
        ConcurrencySet: TSet<UE.SoundConcurrency>;
        SoundClass: UE.SoundClass;
        SourceEffectChain: UE.SoundEffectSourcePresetChain;
        SoundSubmix: UE.SoundSubmix;
        SoundSubmixSends: TArray<UE.SoundSubmixSendInfo>;
        BusSends: TArray<UE.SoundSourceBusSendInfo>;
        Modulation: UE.SoundModulation;
        PreEffectBusSends: TArray<UE.SoundSourceBusSendInfo>;
        bIsUISound: boolean;
        bIsPreviewSound: boolean;
        EnvelopeFollowerAttackTime: number;
        EnvelopeFollowerReleaseTime: number;
        OnAudioEnvelopeValue: $MulticastDelegate<(EnvelopeValue: number) => void>;
        Synth: UE.SynthSound;
        AudioComponent: UE.AudioComponent;
        IsPlaying() : boolean;
        SetSubmixSend(Submix: $Nullable<UE.SoundSubmix>, SendLevel: number) : void;
        SetVolumeMultiplier(VolumeMultiplier: number) : void;
        Start() : void;
        Stop() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SynthComponent;
        static Load(InName: string): SynthComponent;
    }
    
    class AudioCaptureComponent extends UE.SynthComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        JitterLatencyFrames: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioCaptureComponent;
        static Load(InName: string): AudioCaptureComponent;
    }
    
    class AudioCaptureFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CreateAudioCapture() : UE.AudioCapture;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioCaptureFunctionLibrary;
        static Load(InName: string): AudioCaptureFunctionLibrary;
    }
    
    class AudioCurveSourceComponent extends UE.AudioComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurveSourceBindingName: string;
        CurveSyncOffset: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioCurveSourceComponent;
        static Load(InName: string): AudioCurveSourceComponent;
    }
    
    enum EFFTSize { DefaultSize, Min, Small, Medium, Large, Max, EFFTSize_MAX}
    enum EFFTPeakInterpolationMethod { NearestNeighbor, Linear, Quadratic, EFFTPeakInterpolationMethod_MAX}
    enum EFFTWindowType { None, Hamming, Hann, Blackman, EFFTWindowType_MAX}
    class SoundNode extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChildNodes: TArray<UE.SoundNode>;
        GraphNode: UE.EdGraphNode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNode;
        static Load(InName: string): SoundNode;
    }
    
    class SoundCue extends UE.SoundBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bPrimeOnLoad: boolean;
        FirstNode: UE.SoundNode;
        VolumeMultiplier: number;
        PitchMultiplier: number;
        AttenuationOverrides: UE.SoundAttenuationSettings;
        AllNodes: TArray<UE.SoundNode>;
        SoundCueGraph: UE.EdGraph;
        SubtitlePriority: number;
        bOverrideAttenuation: boolean;
        bExcludeFromRandomNodeBranchCulling: boolean;
        bHasPlayWhenSilent: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCue;
        static Load(InName: string): SoundCue;
    }
    
    class AudioMixerBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AddMasterSubmixEffect(WorldContextObject: $Nullable<UE.Object>, SubmixEffectPreset: $Nullable<UE.SoundEffectSubmixPreset>) : void;
        static AddSourceEffectToPresetChain(WorldContextObject: $Nullable<UE.Object>, PresetChain: $Nullable<UE.SoundEffectSourcePresetChain>, Entry: UE.SourceEffectChainEntry) : void;
        static ClearMasterSubmixEffects(WorldContextObject: $Nullable<UE.Object>) : void;
        static GetMagnitudeForFrequencies(WorldContextObject: $Nullable<UE.Object>, Frequencies: TArray<number>, Magnitudes: $Ref<TArray<number>>, SubmixToAnalyze?: UE.SoundSubmix /* = None */) : void;
        static GetNumberOfEntriesInSourceEffectChain(WorldContextObject: $Nullable<UE.Object>, PresetChain: $Nullable<UE.SoundEffectSourcePresetChain>) : number;
        static GetPhaseForFrequencies(WorldContextObject: $Nullable<UE.Object>, Frequencies: TArray<number>, Phases: $Ref<TArray<number>>, SubmixToAnalyze?: UE.SoundSubmix /* = None */) : void;
        static PauseRecordingOutput(WorldContextObject: $Nullable<UE.Object>, SubmixToPause?: UE.SoundSubmix /* = None */) : void;
        static PrimeSoundCueForPlayback(SoundCue: $Nullable<UE.SoundCue>) : void;
        static PrimeSoundForPlayback(SoundWave: $Nullable<UE.SoundWave>, OnLoadCompletion: $Delegate<(LoadedSoundWave: $Nullable<UE.SoundWave>, WasCancelled: boolean) => void>) : void;
        static RemoveMasterSubmixEffect(WorldContextObject: $Nullable<UE.Object>, SubmixEffectPreset: $Nullable<UE.SoundEffectSubmixPreset>) : void;
        static RemoveSourceEffectFromPresetChain(WorldContextObject: $Nullable<UE.Object>, PresetChain: $Nullable<UE.SoundEffectSourcePresetChain>, EntryIndex: number) : void;
        static ResumeRecordingOutput(WorldContextObject: $Nullable<UE.Object>, SubmixToPause?: UE.SoundSubmix /* = None */) : void;
        static SetBypassSourceEffectChainEntry(WorldContextObject: $Nullable<UE.Object>, PresetChain: $Nullable<UE.SoundEffectSourcePresetChain>, EntryIndex: number, bBypassed: boolean) : void;
        static StartAnalyzingOutput(WorldContextObject: $Nullable<UE.Object>, SubmixToAnalyze?: UE.SoundSubmix /* = None */, FFTSize?: UE.EFFTSize /* = DefaultSize */, InterpolationMethod?: UE.EFFTPeakInterpolationMethod /* = Linear */, WindowType?: UE.EFFTWindowType /* = Hann */, HopSize?: number /* = 0.000000 */) : void;
        static StartRecordingOutput(WorldContextObject: $Nullable<UE.Object>, ExpectedDuration: number, SubmixToRecord?: UE.SoundSubmix /* = None */) : void;
        static StopAnalyzingOutput(WorldContextObject: $Nullable<UE.Object>, SubmixToStopAnalyzing?: UE.SoundSubmix /* = None */) : void;
        static StopRecordingOutput(WorldContextObject: $Nullable<UE.Object>, ExportType: UE.EAudioRecordingExportType, Name: string, Path: string, SubmixToRecord?: UE.SoundSubmix /* = None */, ExistingSoundWaveToOverwrite?: UE.SoundWave /* = None */) : UE.SoundWave;
        static TrimAudioCache(InMegabytesToFree: number) : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioMixerBlueprintLibrary;
        static Load(InName: string): AudioMixerBlueprintLibrary;
    }
    
    class AudioMixerCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioMixerCommandlet;
        static Load(InName: string): AudioMixerCommandlet;
    }
    
    enum EVoiceSampleRate { Low16000Hz, Normal24000Hz, EVoiceSampleRate_MAX}
    class AudioQualitySettings {
        constructor();
        constructor(DisplayName: string, MaxChannels: number);
        DisplayName: string;
        MaxChannels: number;
        static StaticClass(): Class;
    }
    
    enum EPanningMethod { Linear, EqualPower, EPanningMethod_MAX}
    enum EMonoChannelUpmixMethod { Linear, EqualPower, FullVolume, EMonoChannelUpmixMethod_MAX}
    class AudioSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultSoundClassName: UE.SoftObjectPath;
        DefaultMediaSoundClassName: UE.SoftObjectPath;
        DefaultSoundConcurrencyName: UE.SoftObjectPath;
        DefaultBaseSoundMix: UE.SoftObjectPath;
        VoiPSoundClass: UE.SoftObjectPath;
        VoiPSampleRate: UE.EVoiceSampleRate;
        VoipBufferingDelay: number;
        DefaultReverbSendLevel: number;
        bEnableLegacyReverb: boolean;
        MaximumConcurrentStreams: number;
        GlobalMinPitchScale: number;
        GlobalMaxPitchScale: number;
        QualityLevels: TArray<UE.AudioQualitySettings>;
        bAllowPlayWhenSilent: boolean;
        bDisableMasterEQ: boolean;
        bAllowCenterChannel3DPanning: boolean;
        NumStoppingSources: number;
        PanningMethod: UE.EPanningMethod;
        MonoChannelUpmixMethod: UE.EMonoChannelUpmixMethod;
        DialogueFilenameFormat: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioSettings;
        static Load(InName: string): AudioSettings;
    }
    
    class AudioTestCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioTestCommandlet;
        static Load(InName: string): AudioTestCommandlet;
    }
    
    class AudioVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Priority: number;
        bEnabled: boolean;
        Settings: UE.ReverbSettings;
        AmbientZoneSettings: UE.InteriorSettings;
        OnRep_bEnabled() : void;
        SetEnabled(bNewEnabled: boolean) : void;
        SetInteriorSettings(NewInteriorSettings: UE.InteriorSettings) : void;
        SetPriority(NewPriority: number) : void;
        SetReverbSettings(NewReverbSettings: UE.ReverbSettings) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioVolume;
        static Load(InName: string): AudioVolume;
    }
    
    enum EMovieSceneCaptureProtocolState { Idle, Initialized, Capturing, Finalizing, EMovieSceneCaptureProtocolState_MAX}
    class MovieSceneCaptureProtocolBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        State: UE.EMovieSceneCaptureProtocolState;
        GetState() : UE.EMovieSceneCaptureProtocolState;
        IsCapturing() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCaptureProtocolBase;
        static Load(InName: string): MovieSceneCaptureProtocolBase;
    }
    
    class MovieSceneImageCaptureProtocolBase extends UE.MovieSceneCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneImageCaptureProtocolBase;
        static Load(InName: string): MovieSceneImageCaptureProtocolBase;
    }
    
    class MovieSceneAudioCaptureProtocolBase extends UE.MovieSceneCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneAudioCaptureProtocolBase;
        static Load(InName: string): MovieSceneAudioCaptureProtocolBase;
    }
    
    class CaptureResolution {
        constructor();
        constructor(ResX: number, ResY: number);
        ResX: number;
        ResY: number;
        static StaticClass(): Class;
    }
    
    class MovieSceneCaptureSettings {
        constructor();
        constructor(OutputDirectory: UE.DirectoryPath, GameModeOverride: UE.Class, OutputFormat: string, bOverwriteExisting: boolean, bUseRelativeFrameNumbers: boolean, HandleFrames: number, MovieExtension: string, ZeroPadFrameNumbers: number, FrameRate: UE.FrameRate, bUseCustomFrameRate: boolean, CustomFrameRate: UE.FrameRate, Resolution: UE.CaptureResolution, bEnableTextureStreaming: boolean, bCinematicEngineScalability: boolean, bCinematicMode: boolean, bAllowMovement: boolean, bAllowTurning: boolean, bShowPlayer: boolean, bShowHUD: boolean, bUsePathTracer: boolean, PathTracerSamplePerPixel: number);
        OutputDirectory: UE.DirectoryPath;
        GameModeOverride: UE.Class;
        OutputFormat: string;
        bOverwriteExisting: boolean;
        bUseRelativeFrameNumbers: boolean;
        HandleFrames: number;
        MovieExtension: string;
        ZeroPadFrameNumbers: number;
        FrameRate: UE.FrameRate;
        bUseCustomFrameRate: boolean;
        CustomFrameRate: UE.FrameRate;
        Resolution: UE.CaptureResolution;
        bEnableTextureStreaming: boolean;
        bCinematicEngineScalability: boolean;
        bCinematicMode: boolean;
        bAllowMovement: boolean;
        bAllowTurning: boolean;
        bShowPlayer: boolean;
        bShowHUD: boolean;
        bUsePathTracer: boolean;
        PathTracerSamplePerPixel: number;
        static StaticClass(): Class;
    }
    
    class MovieSceneCapture extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImageCaptureProtocolType: UE.SoftClassPath;
        AudioCaptureProtocolType: UE.SoftClassPath;
        ImageCaptureProtocol: UE.MovieSceneImageCaptureProtocolBase;
        AudioCaptureProtocol: UE.MovieSceneAudioCaptureProtocolBase;
        Settings: UE.MovieSceneCaptureSettings;
        bUseSeparateProcess: boolean;
        bCloseEditorWhenCaptureStarts: boolean;
        AdditionalCommandLineArguments: string;
        InheritedCommandLineArguments: string;
        GetAudioCaptureProtocol() : UE.MovieSceneCaptureProtocolBase;
        GetImageCaptureProtocol() : UE.MovieSceneCaptureProtocolBase;
        SetAudioCaptureProtocolType(ProtocolType: $Nullable<UE.Class>) : void;
        SetImageCaptureProtocolType(ProtocolType: $Nullable<UE.Class>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCapture;
        static Load(InName: string): MovieSceneCapture;
    }
    
    class LevelSequenceBurnInInitSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceBurnInInitSettings;
        static Load(InName: string): LevelSequenceBurnInInitSettings;
    }
    
    class LevelSequenceBurnInOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseBurnIn: boolean;
        BurnInClass: UE.SoftClassPath;
        Settings: UE.LevelSequenceBurnInInitSettings;
        SetBurnIn(InBurnInClass: UE.SoftClassPath) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceBurnInOptions;
        static Load(InName: string): LevelSequenceBurnInOptions;
    }
    
    class LevelSequencePlayer extends UE.MovieSceneSequencePlayer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnCameraCut: $MulticastDelegate<(CameraComponent: $Nullable<UE.CameraComponent>) => void>;
        GetActiveCameraComponent() : UE.CameraComponent;
        static CreateLevelSequencePlayer(WorldContextObject: $Nullable<UE.Object>, LevelSequence: $Nullable<UE.LevelSequence>, Settings: UE.MovieSceneSequencePlaybackSettings, OutActor: $Ref<UE.LevelSequenceActor>) : UE.LevelSequencePlayer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequencePlayer;
        static Load(InName: string): LevelSequencePlayer;
    }
    
    class LevelSequenceCameraSettings {
        constructor();
        constructor(bOverrideAspectRatioAxisConstraint: boolean, AspectRatioAxisConstraint: UE.EAspectRatioAxisConstraint);
        bOverrideAspectRatioAxisConstraint: boolean;
        AspectRatioAxisConstraint: UE.EAspectRatioAxisConstraint;
        static StaticClass(): Class;
    }
    
    class MovieSceneBindingOverrideData {
        constructor();
        constructor(ObjectBindingId: UE.MovieSceneObjectBindingID, Object: TWeakObjectPtr<UE.Object>, bOverridesDefault: boolean);
        ObjectBindingId: UE.MovieSceneObjectBindingID;
        Object: TWeakObjectPtr<UE.Object>;
        bOverridesDefault: boolean;
        static StaticClass(): Class;
    }
    
    class MovieSceneBindingOverrides extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BindingData: TArray<UE.MovieSceneBindingOverrideData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneBindingOverrides;
        static Load(InName: string): MovieSceneBindingOverrides;
    }
    
    class LevelSequenceSnapshotSettings {
        constructor();
        constructor(ZeroPadAmount: number, FrameRate: UE.FrameRate);
        ZeroPadAmount: number;
        FrameRate: UE.FrameRate;
        static StaticClass(): Class;
    }
    
    class LevelSequencePlayerSnapshot {
        constructor();
        constructor(MasterName: string, MasterTime: UE.QualifiedFrameTime, SourceTime: UE.QualifiedFrameTime, CurrentShotName: string, CurrentShotLocalTime: UE.QualifiedFrameTime, CurrentShotSourceTime: UE.QualifiedFrameTime, SourceTimecode: string, CameraComponent: TSoftObjectPtr<UE.CameraComponent>, Settings: UE.LevelSequenceSnapshotSettings, ActiveShot: UE.LevelSequence, ShotID: UE.MovieSceneSequenceID);
        MasterName: string;
        MasterTime: UE.QualifiedFrameTime;
        SourceTime: UE.QualifiedFrameTime;
        CurrentShotName: string;
        CurrentShotLocalTime: UE.QualifiedFrameTime;
        CurrentShotSourceTime: UE.QualifiedFrameTime;
        SourceTimecode: string;
        CameraComponent: TSoftObjectPtr<UE.CameraComponent>;
        Settings: UE.LevelSequenceSnapshotSettings;
        ActiveShot: UE.LevelSequence;
        ShotID: UE.MovieSceneSequenceID;
        static StaticClass(): Class;
    }
    
    class LevelSequenceBurnIn extends UE.UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FrameInformation: UE.LevelSequencePlayerSnapshot;
        LevelSequenceActor: UE.LevelSequenceActor;
        GetSettingsClass() : UE.Class;
        SetSettings(InSettings: $Nullable<UE.Object>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceBurnIn;
        static Load(InName: string): LevelSequenceBurnIn;
    }
    
    class LevelSequenceActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlaybackSettings: UE.MovieSceneSequencePlaybackSettings;
        SequencePlayer: UE.LevelSequencePlayer;
        LevelSequence: UE.SoftObjectPath;
        AdditionalEventReceivers: TArray<UE.Actor>;
        CameraSettings: UE.LevelSequenceCameraSettings;
        BurnInOptions: UE.LevelSequenceBurnInOptions;
        BindingOverrides: UE.MovieSceneBindingOverrides;
        bAutoPlay: boolean;
        bOverrideInstanceData: boolean;
        bReplicatePlayback: boolean;
        DefaultInstanceData: UE.Object;
        BurnInInstance: UE.LevelSequenceBurnIn;
        bShowBurnin: boolean;
        AddBinding(Binding: UE.MovieSceneObjectBindingID, Actor: $Nullable<UE.Actor>, bAllowBindingsFromAsset?: boolean /* = false */) : void;
        AddBindingByTag(BindingTag: string, Actor: $Nullable<UE.Actor>, bAllowBindingsFromAsset?: boolean /* = false */) : void;
        FindNamedBinding(Tag: string) : UE.MovieSceneObjectBindingID;
        FindNamedBindings(Tag: string) : TArray<UE.MovieSceneObjectBindingID>;
        GetSequence() : UE.LevelSequence;
        GetSequencePlayer() : UE.LevelSequencePlayer;
        HideBurnin() : void;
        LoadSequence() : UE.LevelSequence;
        OnLevelSequenceLoaded__DelegateSignature() : void;
        RemoveBinding(Binding: UE.MovieSceneObjectBindingID, Actor: $Nullable<UE.Actor>) : void;
        RemoveBindingByTag(Tag: string, Actor: $Nullable<UE.Actor>) : void;
        ResetBinding(Binding: UE.MovieSceneObjectBindingID) : void;
        ResetBindings() : void;
        SetBinding(Binding: UE.MovieSceneObjectBindingID, Actors: TArray<UE.Actor>, bAllowBindingsFromAsset?: boolean /* = false */) : void;
        SetBindingByTag(BindingTag: string, Actors: TArray<UE.Actor>, bAllowBindingsFromAsset?: boolean /* = false */) : void;
        SetEventReceivers(AdditionalReceivers: TArray<UE.Actor>) : void;
        SetReplicatePlayback(ReplicatePlayback: boolean) : void;
        SetSequence(InSequence: $Nullable<UE.LevelSequence>) : void;
        ShowBurnin() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceActor;
        static Load(InName: string): LevelSequenceActor;
    }
    
    class AutomatedLevelSequenceCapture extends UE.MovieSceneCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LevelSequenceAsset: UE.SoftObjectPath;
        ShotName: string;
        bUseCustomStartFrame: boolean;
        CustomStartFrame: UE.FrameNumber;
        bUseCustomEndFrame: boolean;
        CustomEndFrame: UE.FrameNumber;
        WarmUpFrameCount: number;
        DelayBeforeWarmUp: number;
        DelayBeforeShotWarmUp: number;
        DelayEveryFrame: number;
        BurnInOptions: UE.LevelSequenceBurnInOptions;
        bWriteEditDecisionList: boolean;
        bWriteFinalCutProXML: boolean;
        LevelSequenceActor: TWeakObjectPtr<UE.LevelSequenceActor>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomatedLevelSequenceCapture;
        static Load(InName: string): AutomatedLevelSequenceCapture;
    }
    
    enum EComparisonTolerance { Zero, Low, Medium, High, Custom, EComparisonTolerance_MAX}
    class AutomationEditorTask extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IsTaskDone() : boolean;
        IsValidTask() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomationEditorTask;
        static Load(InName: string): AutomationEditorTask;
    }
    
    class AutomationViewSettings extends UE.DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AntiAliasing: boolean;
        MotionBlur: boolean;
        TemporalAA: boolean;
        ScreenSpaceReflections: boolean;
        ScreenSpaceAO: boolean;
        DistanceFieldAO: boolean;
        ContactShadows: boolean;
        EyeAdaptation: boolean;
        Bloom: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomationViewSettings;
        static Load(InName: string): AutomationViewSettings;
    }
    
    class ComparisonToleranceAmount {
        constructor();
        constructor(Red: number, Green: number, Blue: number, Alpha: number, MinBrightness: number, MaxBrightness: number);
        Red: number;
        Green: number;
        Blue: number;
        Alpha: number;
        MinBrightness: number;
        MaxBrightness: number;
        static StaticClass(): Class;
    }
    
    class AutomationScreenshotOptions {
        constructor();
        constructor(Resolution: UE.Vector2D, Delay: number, bOverride_OverrideTimeTo: boolean, OverrideTimeTo: number, bDisableNoisyRenderingFeatures: boolean, bDisableTonemapping: boolean, ViewSettings: UE.AutomationViewSettings, VisualizeBuffer: string, Tolerance: UE.EComparisonTolerance, ToleranceAmount: UE.ComparisonToleranceAmount, MaximumLocalError: number, MaximumGlobalError: number, bIgnoreAntiAliasing: boolean, bIgnoreColors: boolean);
        Resolution: UE.Vector2D;
        Delay: number;
        bOverride_OverrideTimeTo: boolean;
        OverrideTimeTo: number;
        bDisableNoisyRenderingFeatures: boolean;
        bDisableTonemapping: boolean;
        ViewSettings: UE.AutomationViewSettings;
        VisualizeBuffer: string;
        Tolerance: UE.EComparisonTolerance;
        ToleranceAmount: UE.ComparisonToleranceAmount;
        MaximumLocalError: number;
        MaximumGlobalError: number;
        bIgnoreAntiAliasing: boolean;
        bIgnoreColors: boolean;
        static StaticClass(): Class;
    }
    
    class AutomationBlueprintFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AddExpectedLogError(ExpectedPatternString: string, Occurrences?: number /* = 1 */, ExactMatch?: boolean /* = false */) : void;
        static AreAutomatedTestsRunning() : boolean;
        static AutomationWaitForLoading(WorldContextObject: $Nullable<UE.Object>, LatentInfo: UE.LatentActionInfo) : void;
        static DisableStatGroup(WorldContextObject: $Nullable<UE.Object>, GroupName: string) : void;
        static EnableStatGroup(WorldContextObject: $Nullable<UE.Object>, GroupName: string) : void;
        static GetDefaultScreenshotOptionsForGameplay(Tolerance?: UE.EComparisonTolerance /* = Low */, Delay?: number /* = 0.200000 */) : UE.AutomationScreenshotOptions;
        static GetDefaultScreenshotOptionsForRendering(Tolerance?: UE.EComparisonTolerance /* = Low */, Delay?: number /* = 0.200000 */) : UE.AutomationScreenshotOptions;
        static GetStatCallCount(StatName: string) : number;
        static GetStatExcAverage(StatName: string) : number;
        static GetStatExcMax(StatName: string) : number;
        static GetStatIncAverage(StatName: string) : number;
        static GetStatIncMax(StatName: string) : number;
        static SetScalabilityQualityLevelRelativeToMax(WorldContextObject: $Nullable<UE.Object>, Value?: number /* = 1 */) : void;
        static SetScalabilityQualityToEpic(WorldContextObject: $Nullable<UE.Object>) : void;
        static SetScalabilityQualityToLow(WorldContextObject: $Nullable<UE.Object>) : void;
        static TakeAutomationScreenshot(WorldContextObject: $Nullable<UE.Object>, LatentInfo: UE.LatentActionInfo, Name: string, Notes: string, Options: UE.AutomationScreenshotOptions) : void;
        static TakeAutomationScreenshotAtCamera(WorldContextObject: $Nullable<UE.Object>, LatentInfo: UE.LatentActionInfo, Camera: $Nullable<UE.CameraActor>, NameOverride: string, Notes: string, Options: UE.AutomationScreenshotOptions) : void;
        static TakeAutomationScreenshotOfUI(WorldContextObject: $Nullable<UE.Object>, LatentInfo: UE.LatentActionInfo, Name: string, Options: UE.AutomationScreenshotOptions) : void;
        static TakeHighResScreenshot(ResX: number, ResY: number, Filename: string, Camera?: UE.CameraActor /* = None */, bMaskEnabled?: boolean /* = false */, bCaptureHDR?: boolean /* = false */, ComparisonTolerance?: UE.EComparisonTolerance /* = Low */, ComparisonNotes?: string /* = "" */) : UE.AutomationEditorTask;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomationBlueprintFunctionLibrary;
        static Load(InName: string): AutomationBlueprintFunctionLibrary;
    }
    
    class AutomatedTestFilter {
        constructor();
        constructor(Contains: string, MatchFromStart: boolean);
        Contains: string;
        MatchFromStart: boolean;
        static StaticClass(): Class;
    }
    
    class AutomatedTestGroup {
        constructor();
        constructor(Name: string, Filters: TArray<UE.AutomatedTestFilter>);
        Name: string;
        Filters: TArray<UE.AutomatedTestFilter>;
        static StaticClass(): Class;
    }
    
    class AutomationControllerSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Groups: TArray<UE.AutomatedTestGroup>;
        bTreatLogErrorsAsTestErrors: boolean;
        bTreatLogWarningsAsTestErrors: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomationControllerSettings;
        static Load(InName: string): AutomationControllerSettings;
    }
    
    class AutomationPerformaceHelper extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BeginRecording(RecordName: string, InGPUBudget: number, InRenderThreadBudget: number, InGameThreadBudget: number) : void;
        BeginRecordingBaseline(RecordName: string) : void;
        BeginStatsFile(RecordName: string) : void;
        EndRecording() : void;
        EndRecordingBaseline() : void;
        EndStatsFile() : void;
        IsCurrentRecordWithinGameThreadBudget() : boolean;
        IsCurrentRecordWithinGPUBudget() : boolean;
        IsCurrentRecordWithinRenderThreadBudget() : boolean;
        IsRecording() : boolean;
        OnAllTestsComplete() : void;
        OnBeginTests() : void;
        Sample(DeltaSeconds: number) : void;
        StartCPUProfiling() : void;
        StopCPUProfiling() : void;
        Tick(DeltaSeconds: number) : void;
        TriggerGPUTraceIfRecordFallsBelowBudget() : void;
        WriteLogFile(CaptureDir: string, CaptureExtension: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomationPerformaceHelper;
        static Load(InName: string): AutomationPerformaceHelper;
    }
    
    class EditorMapPerformanceTestDefinition {
        constructor();
        constructor(PerformanceTestmap: UE.SoftObjectPath, TestTimer: number);
        PerformanceTestmap: UE.SoftObjectPath;
        TestTimer: number;
        static StaticClass(): Class;
    }
    
    class FilePath {
        constructor();
        constructor(FilePath: string);
        FilePath: string;
        static StaticClass(): Class;
    }
    
    class ImportFactorySettingValues {
        constructor();
        constructor(SettingName: string, Value: string);
        SettingName: string;
        Value: string;
        static StaticClass(): Class;
    }
    
    class EditorImportWorkflowDefinition {
        constructor();
        constructor(ImportFilePath: UE.FilePath, FactorySettings: TArray<UE.ImportFactorySettingValues>);
        ImportFilePath: UE.FilePath;
        FactorySettings: TArray<UE.ImportFactorySettingValues>;
        static StaticClass(): Class;
    }
    
    class BuildPromotionImportWorkflowSettings {
        constructor();
        constructor(Diffuse: UE.EditorImportWorkflowDefinition, Normal: UE.EditorImportWorkflowDefinition, StaticMesh: UE.EditorImportWorkflowDefinition, ReimportStaticMesh: UE.EditorImportWorkflowDefinition, BlendShapeMesh: UE.EditorImportWorkflowDefinition, MorphMesh: UE.EditorImportWorkflowDefinition, SkeletalMesh: UE.EditorImportWorkflowDefinition, Animation: UE.EditorImportWorkflowDefinition, Sound: UE.EditorImportWorkflowDefinition, SurroundSound: UE.EditorImportWorkflowDefinition, OtherAssetsToImport: TArray<UE.EditorImportWorkflowDefinition>);
        Diffuse: UE.EditorImportWorkflowDefinition;
        Normal: UE.EditorImportWorkflowDefinition;
        StaticMesh: UE.EditorImportWorkflowDefinition;
        ReimportStaticMesh: UE.EditorImportWorkflowDefinition;
        BlendShapeMesh: UE.EditorImportWorkflowDefinition;
        MorphMesh: UE.EditorImportWorkflowDefinition;
        SkeletalMesh: UE.EditorImportWorkflowDefinition;
        Animation: UE.EditorImportWorkflowDefinition;
        Sound: UE.EditorImportWorkflowDefinition;
        SurroundSound: UE.EditorImportWorkflowDefinition;
        OtherAssetsToImport: TArray<UE.EditorImportWorkflowDefinition>;
        static StaticClass(): Class;
    }
    
    class BuildPromotionOpenAssetSettings {
        constructor();
        constructor(BlueprintAsset: UE.FilePath, MaterialAsset: UE.FilePath, ParticleSystemAsset: UE.FilePath, SkeletalMeshAsset: UE.FilePath, StaticMeshAsset: UE.FilePath, TextureAsset: UE.FilePath);
        BlueprintAsset: UE.FilePath;
        MaterialAsset: UE.FilePath;
        ParticleSystemAsset: UE.FilePath;
        SkeletalMeshAsset: UE.FilePath;
        StaticMeshAsset: UE.FilePath;
        TextureAsset: UE.FilePath;
        static StaticClass(): Class;
    }
    
    class BuildPromotionNewProjectSettings {
        constructor();
        constructor(NewProjectFolderOverride: UE.DirectoryPath, NewProjectNameOverride: string);
        NewProjectFolderOverride: UE.DirectoryPath;
        NewProjectNameOverride: string;
        static StaticClass(): Class;
    }
    
    class BuildPromotionTestSettings {
        constructor();
        constructor(DefaultStaticMeshAsset: UE.FilePath, ImportWorkflow: UE.BuildPromotionImportWorkflowSettings, OpenAssets: UE.BuildPromotionOpenAssetSettings, NewProjectSettings: UE.BuildPromotionNewProjectSettings, SourceControlMaterial: UE.FilePath);
        DefaultStaticMeshAsset: UE.FilePath;
        ImportWorkflow: UE.BuildPromotionImportWorkflowSettings;
        OpenAssets: UE.BuildPromotionOpenAssetSettings;
        NewProjectSettings: UE.BuildPromotionNewProjectSettings;
        SourceControlMaterial: UE.FilePath;
        static StaticClass(): Class;
    }
    
    class MaterialEditorPromotionSettings {
        constructor();
        constructor(DefaultMaterialAsset: UE.FilePath, DefaultDiffuseTexture: UE.FilePath, DefaultNormalTexture: UE.FilePath);
        DefaultMaterialAsset: UE.FilePath;
        DefaultDiffuseTexture: UE.FilePath;
        DefaultNormalTexture: UE.FilePath;
        static StaticClass(): Class;
    }
    
    class ParticleEditorPromotionSettings {
        constructor();
        constructor(DefaultParticleAsset: UE.FilePath);
        DefaultParticleAsset: UE.FilePath;
        static StaticClass(): Class;
    }
    
    class BlueprintEditorPromotionSettings {
        constructor();
        constructor(FirstMeshPath: UE.FilePath, SecondMeshPath: UE.FilePath, DefaultParticleAsset: UE.FilePath);
        FirstMeshPath: UE.FilePath;
        SecondMeshPath: UE.FilePath;
        DefaultParticleAsset: UE.FilePath;
        static StaticClass(): Class;
    }
    
    class ExternalToolDefinition {
        constructor();
        constructor(ToolName: string, ExecutablePath: UE.FilePath, CommandLineOptions: string, WorkingDirectory: UE.DirectoryPath, ScriptExtension: string, ScriptDirectory: UE.DirectoryPath);
        ToolName: string;
        ExecutablePath: UE.FilePath;
        CommandLineOptions: string;
        WorkingDirectory: UE.DirectoryPath;
        ScriptExtension: string;
        ScriptDirectory: UE.DirectoryPath;
        static StaticClass(): Class;
    }
    
    class EditorImportExportTestDefinition {
        constructor();
        constructor(ImportFilePath: UE.FilePath, ExportFileExtension: string, bSkipExport: boolean, FactorySettings: TArray<UE.ImportFactorySettingValues>);
        ImportFilePath: UE.FilePath;
        ExportFileExtension: string;
        bSkipExport: boolean;
        FactorySettings: TArray<UE.ImportFactorySettingValues>;
        static StaticClass(): Class;
    }
    
    class LaunchOnTestSettings {
        constructor();
        constructor(LaunchOnTestmap: UE.FilePath, DeviceID: string);
        LaunchOnTestmap: UE.FilePath;
        DeviceID: string;
        static StaticClass(): Class;
    }
    
    class AutomationTestSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EngineTestModules: TArray<string>;
        EditorTestModules: TArray<string>;
        AutomationTestmap: UE.SoftObjectPath;
        EditorPerformanceTestMaps: TArray<UE.EditorMapPerformanceTestDefinition>;
        AssetsToOpen: TArray<UE.SoftObjectPath>;
        BuildPromotionTest: UE.BuildPromotionTestSettings;
        MaterialEditorPromotionTest: UE.MaterialEditorPromotionSettings;
        ParticleEditorPromotionTest: UE.ParticleEditorPromotionSettings;
        BlueprintEditorPromotionTest: UE.BlueprintEditorPromotionSettings;
        TestLevelFolders: TArray<string>;
        ExternalTools: TArray<UE.ExternalToolDefinition>;
        ImportExportTestDefinitions: TArray<UE.EditorImportExportTestDefinition>;
        LaunchOnSettings: TArray<UE.LaunchOnTestSettings>;
        DefaultScreenshotResolution: UE.IntPoint;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomationTestSettings;
        static Load(InName: string): AutomationTestSettings;
    }
    
    class AutomationUtilsBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static TakeGameplayAutomationScreenshot(ScreenshotName: string, MaxGlobalError?: number /* = 0.020000 */, MaxLocalError?: number /* = 0.120000 */, MapNameOverride?: string /* = "" */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomationUtilsBlueprintLibrary;
        static Load(InName: string): AutomationUtilsBlueprintLibrary;
    }
    
    class AutoReimportManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutoReimportManager;
        static Load(InName: string): AutoReimportManager;
    }
    
    class AvfFileMediaSourceFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AvfFileMediaSourceFactory;
        static Load(InName: string): AvfFileMediaSourceFactory;
    }
    
    class AvfMediaSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NativeAudioOut: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AvfMediaSettings;
        static Load(InName: string): AvfMediaSettings;
    }
    
    class BehaviorInfo {
        constructor();
        constructor(Behavior: UE.InputBehavior);
        Behavior: UE.InputBehavior;
        static StaticClass(): Class;
    }
    
    class InputBehaviorSet extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Behaviors: TArray<UE.BehaviorInfo>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputBehaviorSet;
        static Load(InName: string): InputBehaviorSet;
    }
    
    class InteractiveGizmo extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputBehaviors: UE.InputBehaviorSet;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveGizmo;
        static Load(InName: string): InteractiveGizmo;
    }
    
    class GizmoAxisSource extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetDirection() : UE.Vector;
        GetOrigin() : UE.Vector;
        GetTangentVectors(TangentXOut: $Ref<UE.Vector>, TangentYOut: $Ref<UE.Vector>) : void;
        HasTangentVectors() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoAxisSource;
        static Load(InName: string): GizmoAxisSource;
    }
    
    class GizmoFloatParameterSource extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BeginModify() : void;
        EndModify() : void;
        GetParameter() : number;
        SetParameter(NewValue: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoFloatParameterSource;
        static Load(InName: string): GizmoFloatParameterSource;
    }
    
    class GizmoClickTarget extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UpdateHoverState(bHovering: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoClickTarget;
        static Load(InName: string): GizmoClickTarget;
    }
    
    class GizmoStateTarget extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BeginUpdate() : void;
        EndUpdate() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoStateTarget;
        static Load(InName: string): GizmoStateTarget;
    }
    
    class AxisAngleGizmo extends UE.InteractiveGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisSource: GizmoAxisSource;
        AngleSource: GizmoFloatParameterSource;
        HitTarget: GizmoClickTarget;
        StateTarget: GizmoStateTarget;
        bInInteraction: boolean;
        RotationOrigin: UE.Vector;
        RotationAxis: UE.Vector;
        RotationPlaneX: UE.Vector;
        RotationPlaneY: UE.Vector;
        InteractionStartPoint: UE.Vector;
        InteractionCurPoint: UE.Vector;
        InteractionStartAngle: number;
        InteractionCurAngle: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AxisAngleGizmo;
        static Load(InName: string): AxisAngleGizmo;
    }
    
    class InteractiveGizmoBuilder extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveGizmoBuilder;
        static Load(InName: string): InteractiveGizmoBuilder;
    }
    
    class AxisAngleGizmoBuilder extends UE.InteractiveGizmoBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AxisAngleGizmoBuilder;
        static Load(InName: string): AxisAngleGizmoBuilder;
    }
    
    class AxisGizmoHandleGroup extends UE.GizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AxisGizmoHandleGroup;
        static Load(InName: string): AxisGizmoHandleGroup;
    }
    
    class AxisPositionGizmo extends UE.InteractiveGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisSource: GizmoAxisSource;
        ParameterSource: GizmoFloatParameterSource;
        HitTarget: GizmoClickTarget;
        StateTarget: GizmoStateTarget;
        bInInteraction: boolean;
        InteractionOrigin: UE.Vector;
        InteractionAxis: UE.Vector;
        InteractionStartPoint: UE.Vector;
        InteractionCurPoint: UE.Vector;
        InteractionStartParameter: number;
        InteractionCurParameter: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AxisPositionGizmo;
        static Load(InName: string): AxisPositionGizmo;
    }
    
    class AxisPositionGizmoBuilder extends UE.InteractiveGizmoBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AxisPositionGizmoBuilder;
        static Load(InName: string): AxisPositionGizmoBuilder;
    }
    
    class ContentWidget extends UE.PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetContent() : UE.Widget;
        GetContentSlot() : UE.PanelSlot;
        SetContent(Content: $Nullable<UE.Widget>) : UE.PanelSlot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ContentWidget;
        static Load(InName: string): ContentWidget;
    }
    
    enum EHorizontalAlignment { HAlign_Fill, HAlign_Left, HAlign_Center, HAlign_Right, HAlign_MAX}
    enum EVerticalAlignment { VAlign_Fill, VAlign_Top, VAlign_Center, VAlign_Bottom, VAlign_MAX}
    class BackgroundBlur extends UE.ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: UE.Margin;
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        bApplyAlphaToBlur: boolean;
        BlurStrength: number;
        bOverrideAutoRadiusCalculation: boolean;
        BlurRadius: number;
        LowQualityFallbackBrush: UE.SlateBrush;
        SetApplyAlphaToBlur(bInApplyAlphaToBlur: boolean) : void;
        SetBlurRadius(InBlurRadius: number) : void;
        SetBlurStrength(InStrength: number) : void;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetLowQualityFallbackBrush(InBrush: UE.SlateBrush) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BackgroundBlur;
        static Load(InName: string): BackgroundBlur;
    }
    
    class BackgroundBlurSlot extends UE.PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: UE.Margin;
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BackgroundBlurSlot;
        static Load(InName: string): BackgroundBlurSlot;
    }
    
    class BandwidthTestItem {
        constructor();
        constructor(Kilobyte: TArray<number>);
        Kilobyte: TArray<number>;
        static StaticClass(): Class;
    }
    
    class BandwidthTestGenerator {
        constructor();
        constructor(ReplicatedBuffers: TArray<UE.BandwidthTestItem>);
        ReplicatedBuffers: TArray<UE.BandwidthTestItem>;
        static StaticClass(): Class;
    }
    
    class BandwidthTestActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BandwidthGenerator: UE.BandwidthTestGenerator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BandwidthTestActor;
        static Load(InName: string): BandwidthTestActor;
    }
    
    class MediaSource extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetUrl() : string;
        SetMediaOptionBool(Key: string, Value: boolean) : void;
        SetMediaOptionFloat(Key: string, Value: number) : void;
        SetMediaOptionInt64(Key: string, Value: bigint) : void;
        SetMediaOptionString(Key: string, Value: string) : void;
        Validate() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaSource;
        static Load(InName: string): MediaSource;
    }
    
    class BaseMediaSource extends UE.MediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlatformPlayerNames: TMap<string, string>;
        PlayerName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BaseMediaSource;
        static Load(InName: string): BaseMediaSource;
    }
    
    class BaseWidgetBlueprint extends UE.Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetTree: UE.WidgetTree;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BaseWidgetBlueprint;
        static Load(InName: string): BaseWidgetBlueprint;
    }
    
    class Overlays extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Overlays;
        static Load(InName: string): Overlays;
    }
    
    class Timespan {
        constructor();
        static StaticClass(): Class;
    }
    
    class OverlayItem {
        constructor();
        constructor(StartTime: UE.Timespan, EndTime: UE.Timespan, Text: string, Position: UE.Vector2D);
        StartTime: UE.Timespan;
        EndTime: UE.Timespan;
        Text: string;
        Position: UE.Vector2D;
        static StaticClass(): Class;
    }
    
    class BasicOverlays extends UE.Overlays {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Overlays: TArray<UE.OverlayItem>;
        AssetImportData: UE.AssetImportData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BasicOverlays;
        static Load(InName: string): BasicOverlays;
    }
    
    class BasicOverlaysFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BasicOverlaysFactory;
        static Load(InName: string): BasicOverlaysFactory;
    }
    
    class BasicOverlaysFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BasicOverlaysFactoryNew;
        static Load(InName: string): BasicOverlaysFactoryNew;
    }
    
    class BehaviorTreeDecoratorGraph extends UE.EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeDecoratorGraph;
        static Load(InName: string): BehaviorTreeDecoratorGraph;
    }
    
    class BehaviorTreeDecoratorGraphNode extends UE.EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeDecoratorGraphNode;
        static Load(InName: string): BehaviorTreeDecoratorGraphNode;
    }
    
    class BehaviorTreeDecoratorGraphNode_Decorator extends UE.BehaviorTreeDecoratorGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NodeInstance: UE.Object;
        ClassData: UE.GraphNodeClassData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeDecoratorGraphNode_Decorator;
        static Load(InName: string): BehaviorTreeDecoratorGraphNode_Decorator;
    }
    
    enum EDecoratorLogicMode { Sink, And, Or, Not, EDecoratorLogicMode_MAX}
    class BehaviorTreeDecoratorGraphNode_Logic extends UE.BehaviorTreeDecoratorGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LogicMode: UE.EDecoratorLogicMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeDecoratorGraphNode_Logic;
        static Load(InName: string): BehaviorTreeDecoratorGraphNode_Logic;
    }
    
    class BehaviorTreeEditorTypes extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeEditorTypes;
        static Load(InName: string): BehaviorTreeEditorTypes;
    }
    
    class BehaviorTreeFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeFactory;
        static Load(InName: string): BehaviorTreeFactory;
    }
    
    class BehaviorTreeGraph extends UE.AIGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ModCounter: number;
        bIsUsingModCounter: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraph;
        static Load(InName: string): BehaviorTreeGraph;
    }
    
    class BehaviorTreeGraphNode extends UE.AIGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Decorators: TArray<UE.BehaviorTreeGraphNode>;
        Services: TArray<UE.BehaviorTreeGraphNode>;
        bInjectedNode: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode;
        static Load(InName: string): BehaviorTreeGraphNode;
    }
    
    class BehaviorTreeGraphNode_Composite extends UE.BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_Composite;
        static Load(InName: string): BehaviorTreeGraphNode_Composite;
    }
    
    class BehaviorTreeGraphNode_CompositeDecorator extends UE.BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoundGraph: UE.EdGraph;
        CompositeName: string;
        bShowOperations: boolean;
        bCanAbortFlow: boolean;
        ParentNodeInstance: UE.BTCompositeNode;
        CachedDescription: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_CompositeDecorator;
        static Load(InName: string): BehaviorTreeGraphNode_CompositeDecorator;
    }
    
    class BehaviorTreeGraphNode_Decorator extends UE.BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_Decorator;
        static Load(InName: string): BehaviorTreeGraphNode_Decorator;
    }
    
    class BehaviorTreeGraphNode_Root extends UE.BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlackboardAsset: UE.BlackboardData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_Root;
        static Load(InName: string): BehaviorTreeGraphNode_Root;
    }
    
    class BehaviorTreeGraphNode_Service extends UE.BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_Service;
        static Load(InName: string): BehaviorTreeGraphNode_Service;
    }
    
    class BehaviorTreeGraphNode_SimpleParallel extends UE.BehaviorTreeGraphNode_Composite {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_SimpleParallel;
        static Load(InName: string): BehaviorTreeGraphNode_SimpleParallel;
    }
    
    class BehaviorTreeGraphNode_Task extends UE.BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_Task;
        static Load(InName: string): BehaviorTreeGraphNode_Task;
    }
    
    class BehaviorTreeGraphNode_SubtreeTask extends UE.BehaviorTreeGraphNode_Task {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_SubtreeTask;
        static Load(InName: string): BehaviorTreeGraphNode_SubtreeTask;
    }
    
    class BehaviorTreeTypes extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeTypes;
        static Load(InName: string): BehaviorTreeTypes;
    }
    
    class BlackboardDataFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardDataFactory;
        static Load(InName: string): BlackboardDataFactory;
    }
    
    class BlackboardKeyType_Bool extends UE.BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Bool;
        static Load(InName: string): BlackboardKeyType_Bool;
    }
    
    class BlackboardKeyType_Class extends UE.BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Class;
        static Load(InName: string): BlackboardKeyType_Class;
    }
    
    class BlackboardKeyType_Enum extends UE.BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EnumType: UE.Enum;
        EnumName: string;
        bIsEnumNameValid: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Enum;
        static Load(InName: string): BlackboardKeyType_Enum;
    }
    
    class BlackboardKeyType_Float extends UE.BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Float;
        static Load(InName: string): BlackboardKeyType_Float;
    }
    
    class BlackboardKeyType_Int extends UE.BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Int;
        static Load(InName: string): BlackboardKeyType_Int;
    }
    
    class BlackboardKeyType_Name extends UE.BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Name;
        static Load(InName: string): BlackboardKeyType_Name;
    }
    
    class BlackboardKeyType_NativeEnum extends UE.BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EnumName: string;
        EnumType: UE.Enum;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_NativeEnum;
        static Load(InName: string): BlackboardKeyType_NativeEnum;
    }
    
    class BlackboardKeyType_Object extends UE.BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Object;
        static Load(InName: string): BlackboardKeyType_Object;
    }
    
    class BlackboardKeyType_Rotator extends UE.BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Rotator;
        static Load(InName: string): BlackboardKeyType_Rotator;
    }
    
    class BlackboardKeyType_String extends UE.BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StringValue: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_String;
        static Load(InName: string): BlackboardKeyType_String;
    }
    
    class BlackboardKeyType_Vector extends UE.BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Vector;
        static Load(InName: string): BlackboardKeyType_Vector;
    }
    
    class BlendSpaceThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlendSpaceThumbnailRenderer;
        static Load(InName: string): BlendSpaceThumbnailRenderer;
    }
    
    class BlockingVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlockingVolume;
        static Load(InName: string): BlockingVolume;
    }
    
    class BlueprintNodeSpawner extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NodeClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintNodeSpawner;
        static Load(InName: string): BlueprintNodeSpawner;
    }
    
    class BlueprintEventNodeSpawner extends UE.BlueprintNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EventFunc: UE.Function;
        CustomEventName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintEventNodeSpawner;
        static Load(InName: string): BlueprintEventNodeSpawner;
    }
    
    class MulticastDelegateProperty extends UE.Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MulticastDelegateProperty;
        static Load(InName: string): MulticastDelegateProperty;
    }
    
    class BlueprintBoundEventNodeSpawner extends UE.BlueprintEventNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EventDelegate: UE.MulticastDelegateProperty;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintBoundEventNodeSpawner;
        static Load(InName: string): BlueprintBoundEventNodeSpawner;
    }
    
    class BlueprintBoundNodeSpawner extends UE.BlueprintNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintBoundNodeSpawner;
        static Load(InName: string): BlueprintBoundNodeSpawner;
    }
    
    class BlueprintCompilerExtension extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintCompilerExtension;
        static Load(InName: string): BlueprintCompilerExtension;
    }
    
    class BlueprintComponentNodeSpawner extends UE.BlueprintNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ComponentClass: UE.Class;
        ComponentName: string;
        ComponentAssetName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintComponentNodeSpawner;
        static Load(InName: string): BlueprintComponentNodeSpawner;
    }
    
    class BlueprintFieldNodeSpawner extends UE.BlueprintNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Field: UE.Field;
        OwnerClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintFieldNodeSpawner;
        static Load(InName: string): BlueprintFieldNodeSpawner;
    }
    
    class BlueprintDelegateNodeSpawner extends UE.BlueprintFieldNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintDelegateNodeSpawner;
        static Load(InName: string): BlueprintDelegateNodeSpawner;
    }
    
    class BlueprintEditorOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bHideUnrelatedNodes: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintEditorOptions;
        static Load(InName: string): BlueprintEditorOptions;
    }
    
    class BlueprintEditorProjectSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bForceAllDependenciesToRecompile: boolean;
        bValidateUnloadedSoftActorReferences: boolean;
        DisabledCompilerMessagesExceptEditor: TArray<string>;
        DisabledCompilerMessages: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintEditorProjectSettings;
        static Load(InName: string): BlueprintEditorProjectSettings;
    }
    
    enum ESaveOnCompile { SoC_Never, SoC_SuccessOnly, SoC_Always, SoC_MAX}
    class BlueprintEditorSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDrawMidpointArrowsInBlueprints: boolean;
        bShowGraphInstructionText: boolean;
        bSplitContextTargetSettings: boolean;
        bExposeAllMemberComponentFunctions: boolean;
        bShowContextualFavorites: boolean;
        bExposeDeprecatedFunctions: boolean;
        bCompactCallOnMemberNodes: boolean;
        bFlattenFavoritesMenus: boolean;
        bFavorPureCastNodes: boolean;
        bAutoCastObjectConnections: boolean;
        bShowViewportOnSimulate: boolean;
        bShowInheritedVariables: boolean;
        bAlwaysShowInterfacesInOverrides: boolean;
        bShowParentClassInOverrides: boolean;
        bShowEmptySections: boolean;
        bSpawnDefaultBlueprintNodes: boolean;
        bHideConstructionScriptComponentsInDetailsView: boolean;
        bHostFindInBlueprintsInGlobalTab: boolean;
        bNavigateToNativeFunctionsFromCallNodes: boolean;
        Bookmarks: TMap<UE.Guid, UE.EditedDocumentInfo>;
        BookmarkNodes: TArray<UE.BPEditorBookmarkNode>;
        bIncludeCommentNodesInBookmarksTab: boolean;
        bShowBookmarksForCurrentDocumentOnlyInTab: boolean;
        GraphEditorQuickJumps: TMap<number, UE.EditedDocumentInfo>;
        SaveOnCompile: UE.ESaveOnCompile;
        bJumpToNodeErrors: boolean;
        bAllowExplicitImpureNodeDisabling: boolean;
        bShowActionMenuItemSignatures: boolean;
        bBlueprintNodeUniqueNames: boolean;
        bShowDetailedCompileResults: boolean;
        CompileEventDisplayThresholdMs: number;
        NodeTemplateCacheCapMB: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintEditorSettings;
        static Load(InName: string): BlueprintEditorSettings;
    }
    
    class BlueprintFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParentClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintFactory;
        static Load(InName: string): BlueprintFactory;
    }
    
    class BlueprintFunctionLibraryFactory extends UE.BlueprintFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintFunctionLibraryFactory;
        static Load(InName: string): BlueprintFunctionLibraryFactory;
    }
    
    class BlueprintFunctionNodeSpawner extends UE.BlueprintFieldNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintFunctionNodeSpawner;
        static Load(InName: string): BlueprintFunctionNodeSpawner;
    }
    
    class GameplayTagContainer {
        constructor();
        constructor(GameplayTags: TArray<UE.GameplayTag>, ParentTags: TArray<UE.GameplayTag>);
        GameplayTags: TArray<UE.GameplayTag>;
        ParentTags: TArray<UE.GameplayTag>;
        static StaticClass(): Class;
    }
    
    class GameplayTagQuery {
        constructor();
        constructor(TokenStreamVersion: number, TagDictionary: TArray<UE.GameplayTag>, QueryTokenStream: TArray<number>, UserDescription: string, AutoDescription: string);
        TokenStreamVersion: number;
        TagDictionary: TArray<UE.GameplayTag>;
        QueryTokenStream: TArray<number>;
        UserDescription: string;
        AutoDescription: string;
        static StaticClass(): Class;
    }
    
    class GameplayTagAssetInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetOwnedGameplayTags(TagContainer: $Ref<UE.GameplayTagContainer>) : void;
        HasAllMatchingGameplayTags(TagContainer: UE.GameplayTagContainer) : boolean;
        HasAnyMatchingGameplayTags(TagContainer: UE.GameplayTagContainer) : boolean;
        HasMatchingGameplayTag(TagToCheck: UE.GameplayTag) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagAssetInterface;
        static Load(InName: string): GameplayTagAssetInterface;
    }
    
    class BlueprintGameplayTagLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AddGameplayTag(TagContainer: $Ref<UE.GameplayTagContainer>, Tag: UE.GameplayTag) : void;
        static AppendGameplayTagContainers(InOutTagContainer: $Ref<UE.GameplayTagContainer>, InTagContainer: UE.GameplayTagContainer) : void;
        static BreakGameplayTagContainer(GameplayTagContainer: UE.GameplayTagContainer, GameplayTags: $Ref<TArray<UE.GameplayTag>>) : void;
        static DoesContainerMatchTagQuery(TagContainer: UE.GameplayTagContainer, TagQuery: UE.GameplayTagQuery) : boolean;
        static DoesTagAssetInterfaceHaveTag(TagContainerInterface: GameplayTagAssetInterface, Tag: UE.GameplayTag) : boolean;
        static EqualEqual_GameplayTag(A: UE.GameplayTag, B: UE.GameplayTag) : boolean;
        static EqualEqual_GameplayTagContainer(A: UE.GameplayTagContainer, B: UE.GameplayTagContainer) : boolean;
        static GetAllActorsOfClassMatchingTagQuery(WorldContextObject: $Nullable<UE.Object>, ActorClass: $Nullable<UE.Class>, GameplayTagQuery: UE.GameplayTagQuery, OutActors: $Ref<TArray<UE.Actor>>) : void;
        static GetDebugStringFromGameplayTag(GameplayTag: UE.GameplayTag) : string;
        static GetDebugStringFromGameplayTagContainer(TagContainer: UE.GameplayTagContainer) : string;
        static GetNumGameplayTagsInContainer(TagContainer: UE.GameplayTagContainer) : number;
        static GetTagName(GameplayTag: UE.GameplayTag) : string;
        static HasAllMatchingGameplayTags(TagContainerInterface: GameplayTagAssetInterface, OtherContainer: UE.GameplayTagContainer) : boolean;
        static HasAllTags(TagContainer: UE.GameplayTagContainer, OtherContainer: UE.GameplayTagContainer, bExactMatch: boolean) : boolean;
        static HasAnyTags(TagContainer: UE.GameplayTagContainer, OtherContainer: UE.GameplayTagContainer, bExactMatch: boolean) : boolean;
        static HasTag(TagContainer: UE.GameplayTagContainer, Tag: UE.GameplayTag, bExactMatch: boolean) : boolean;
        static IsGameplayTagValid(GameplayTag: UE.GameplayTag) : boolean;
        static IsTagQueryEmpty(TagQuery: UE.GameplayTagQuery) : boolean;
        static MakeGameplayTagContainerFromArray(GameplayTags: TArray<UE.GameplayTag>) : UE.GameplayTagContainer;
        static MakeGameplayTagContainerFromTag(SingleTag: UE.GameplayTag) : UE.GameplayTagContainer;
        static MakeGameplayTagQuery(TagQuery: UE.GameplayTagQuery) : UE.GameplayTagQuery;
        static MakeLiteralGameplayTag(Value: UE.GameplayTag) : UE.GameplayTag;
        static MakeLiteralGameplayTagContainer(Value: UE.GameplayTagContainer) : UE.GameplayTagContainer;
        static MatchesAnyTags(TagOne: UE.GameplayTag, OtherContainer: UE.GameplayTagContainer, bExactMatch: boolean) : boolean;
        static MatchesTag(TagOne: UE.GameplayTag, TagTwo: UE.GameplayTag, bExactMatch: boolean) : boolean;
        static NotEqual_GameplayTag(A: UE.GameplayTag, B: UE.GameplayTag) : boolean;
        static NotEqual_GameplayTagContainer(A: UE.GameplayTagContainer, B: UE.GameplayTagContainer) : boolean;
        static NotEqual_TagContainerTagContainer(A: UE.GameplayTagContainer, B: string) : boolean;
        static NotEqual_TagTag(A: UE.GameplayTag, B: string) : boolean;
        static RemoveGameplayTag(TagContainer: $Ref<UE.GameplayTagContainer>, Tag: UE.GameplayTag) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintGameplayTagLibrary;
        static Load(InName: string): BlueprintGameplayTagLibrary;
    }
    
    class BlueprintInterfaceFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintInterfaceFactory;
        static Load(InName: string): BlueprintInterfaceFactory;
    }
    
    class BlueprintMacroFactory extends UE.BlueprintFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintMacroFactory;
        static Load(InName: string): BlueprintMacroFactory;
    }
    
    class BlueprintMapLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static Map_Add(TargetMap: TMap<number, number>, Key: number, Value: number) : void;
        static Map_Clear(TargetMap: TMap<number, number>) : void;
        static Map_Contains(TargetMap: TMap<number, number>, Key: number) : boolean;
        static Map_Find(TargetMap: TMap<number, number>, Key: number, Value: $Ref<number>) : boolean;
        static Map_Keys(TargetMap: TMap<number, number>, Keys: $Ref<TArray<number>>) : void;
        static Map_Length(TargetMap: TMap<number, number>) : number;
        static Map_Remove(TargetMap: TMap<number, number>, Key: number) : boolean;
        static Map_Values(TargetMap: TMap<number, number>, Values: $Ref<TArray<number>>) : void;
        static SetMapPropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: TMap<number, number>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintMapLibrary;
        static Load(InName: string): BlueprintMapLibrary;
    }
    
    class FavoritedBlueprintPaletteItem {
        constructor();
        static StaticClass(): Class;
    }
    
    class BlueprintPaletteFavorites extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CustomFavorites: TArray<string>;
        CurrentFavorites: TArray<UE.FavoritedBlueprintPaletteItem>;
        CurrentProfile: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintPaletteFavorites;
        static Load(InName: string): BlueprintPaletteFavorites;
    }
    
    class BlueprintPathsLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AutomationDir() : string;
        static AutomationLogDir() : string;
        static AutomationTransientDir() : string;
        static BugItDir() : string;
        static ChangeExtension(InPath: string, InNewExtension: string) : string;
        static CloudDir() : string;
        static CollapseRelativeDirectories(InPath: string, OutPath: $Ref<string>) : boolean;
        static Combine(InPaths: TArray<string>) : string;
        static ConvertFromSandboxPath(InPath: string, InSandboxName: string) : string;
        static ConvertRelativePathToFull(InPath: string, InBasePath?: string /* = "" */) : string;
        static ConvertToSandboxPath(InPath: string, InSandboxName: string) : string;
        static CreateTempFilename(Path: string, Prefix?: string /* = "" */, Extension?: string /* = ".tmp" */) : string;
        static DiffDir() : string;
        static DirectoryExists(InPath: string) : boolean;
        static EngineConfigDir() : string;
        static EngineContentDir() : string;
        static EngineDir() : string;
        static EngineIntermediateDir() : string;
        static EnginePluginsDir() : string;
        static EngineSavedDir() : string;
        static EngineSourceDir() : string;
        static EngineUserDir() : string;
        static EngineVersionAgnosticUserDir() : string;
        static EnterpriseDir() : string;
        static EnterpriseFeaturePackDir() : string;
        static EnterprisePluginsDir() : string;
        static FeaturePackDir() : string;
        static FileExists(InPath: string) : boolean;
        static GameAgnosticSavedDir() : string;
        static GameDevelopersDir() : string;
        static GameSourceDir() : string;
        static GameUserDeveloperDir() : string;
        static GeneratedConfigDir() : string;
        static GetBaseFilename(InPath: string, bRemovePath?: boolean /* = true */) : string;
        static GetCleanFilename(InPath: string) : string;
        static GetEditorLocalizationPaths() : TArray<string>;
        static GetEngineLocalizationPaths() : TArray<string>;
        static GetExtension(InPath: string, bIncludeDot?: boolean /* = false */) : string;
        static GetGameLocalizationPaths() : TArray<string>;
        static GetInvalidFileSystemChars() : string;
        static GetPath(InPath: string) : string;
        static GetProjectFilePath() : string;
        static GetPropertyNameLocalizationPaths() : TArray<string>;
        static GetRelativePathToRoot() : string;
        static GetRestrictedFolderNames() : TArray<string>;
        static GetToolTipLocalizationPaths() : TArray<string>;
        static HasProjectPersistentDownloadDir() : boolean;
        static IsDrive(InPath: string) : boolean;
        static IsProjectFilePathSet() : boolean;
        static IsRelative(InPath: string) : boolean;
        static IsRestrictedPath(InPath: string) : boolean;
        static IsSamePath(PathA: string, PathB: string) : boolean;
        static LaunchDir() : string;
        static MakePathRelativeTo(InPath: string, InRelativeTo: string, OutPath: $Ref<string>) : boolean;
        static MakePlatformFilename(InPath: string, OutPath: $Ref<string>) : void;
        static MakeStandardFilename(InPath: string, OutPath: $Ref<string>) : void;
        static MakeValidFileName(InString: string, InReplacementChar?: string /* = "" */) : string;
        static NormalizeDirectoryName(InPath: string, OutPath: $Ref<string>) : void;
        static NormalizeFilename(InPath: string, OutPath: $Ref<string>) : void;
        static ProfilingDir() : string;
        static ProjectConfigDir() : string;
        static ProjectContentDir() : string;
        static ProjectDir() : string;
        static ProjectIntermediateDir() : string;
        static ProjectLogDir() : string;
        static ProjectModsDir() : string;
        static ProjectPersistentDownloadDir() : string;
        static ProjectPluginsDir() : string;
        static ProjectSavedDir() : string;
        static ProjectUserDir() : string;
        static RemoveDuplicateSlashes(InPath: string, OutPath: $Ref<string>) : void;
        static RootDir() : string;
        static SandboxesDir() : string;
        static ScreenShotDir() : string;
        static SetExtension(InPath: string, InNewExtension: string) : string;
        static SetProjectFilePath(NewGameProjectFilePath: string) : void;
        static ShaderWorkingDir() : string;
        static ShouldSaveToUserDir() : boolean;
        static SourceConfigDir() : string;
        static Split(InPath: string, PathPart: $Ref<string>, FilenamePart: $Ref<string>, ExtensionPart: $Ref<string>) : void;
        static ValidatePath(InPath: string, bDidSucceed: $Ref<boolean>, OutReason: $Ref<string>) : void;
        static VideoCaptureDir() : string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintPathsLibrary;
        static Load(InName: string): BlueprintPathsLibrary;
    }
    
    class DateTime {
        constructor();
        static StaticClass(): Class;
    }
    
    enum EScreenOrientation { Unknown, Portrait, PortraitUpsideDown, LandscapeLeft, LandscapeRight, FaceUp, FaceDown, EScreenOrientation_MAX}
    class BlueprintPlatformLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CancelLocalNotification(ActivationEvent: string) : void;
        static CancelLocalNotificationById(NotificationId: number) : void;
        static ClearAllLocalNotifications() : void;
        static GetDeviceOrientation() : UE.EScreenOrientation;
        static GetLaunchNotification(NotificationLaunchedApp: $Ref<boolean>, ActivationEvent: $Ref<string>, FireDate: $Ref<number>) : void;
        static ScheduleLocalNotificationAtTime(FireDateTime: UE.DateTime, LocalTime: boolean, Title: string, Body: string, Action: string, ActivationEvent: string) : number;
        static ScheduleLocalNotificationBadgeAtTime(FireDateTime: UE.DateTime, LocalTime: boolean, ActivationEvent: string) : number;
        static ScheduleLocalNotificationBadgeFromNow(inSecondsFromNow: number, ActivationEvent: string) : void;
        static ScheduleLocalNotificationFromNow(inSecondsFromNow: number, Title: string, Body: string, Action: string, ActivationEvent: string) : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintPlatformLibrary;
        static Load(InName: string): BlueprintPlatformLibrary;
    }
    
    class BlueprintSetLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static Set_Add(TargetSet: TSet<number>, NewItem: number) : void;
        static Set_AddItems(TargetSet: TSet<number>, NewItems: TArray<number>) : void;
        static Set_Clear(TargetSet: TSet<number>) : void;
        static Set_Contains(TargetSet: TSet<number>, ItemToFind: number) : boolean;
        static Set_Difference(A: TSet<number>, B: TSet<number>, Result: $Ref<TSet<number>>) : void;
        static Set_Intersection(A: TSet<number>, B: TSet<number>, Result: $Ref<TSet<number>>) : void;
        static Set_Length(TargetSet: TSet<number>) : number;
        static Set_Remove(TargetSet: TSet<number>, Item: number) : boolean;
        static Set_RemoveItems(TargetSet: TSet<number>, Items: TArray<number>) : void;
        static Set_ToArray(A: TSet<number>, Result: $Ref<TArray<number>>) : void;
        static Set_Union(A: TSet<number>, B: TSet<number>, Result: $Ref<TSet<number>>) : void;
        static SetSetPropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: TSet<number>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintSetLibrary;
        static Load(InName: string): BlueprintSetLibrary;
    }
    
    class BlueprintThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintThumbnailRenderer;
        static Load(InName: string): BlueprintThumbnailRenderer;
    }
    
    class BlueprintVariableNodeSpawner extends UE.BlueprintFieldNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LocalVarOuter: UE.EdGraph;
        LocalVarDesc: UE.BPVariableDescription;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintVariableNodeSpawner;
        static Load(InName: string): BlueprintVariableNodeSpawner;
    }
    
    class BoneMaskFilter extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlendPoses: TArray<UE.InputBlendPose>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BoneMaskFilter;
        static Load(InName: string): BoneMaskFilter;
    }
    
    class BookMark2D extends UE.BookmarkBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Zoom2D: number;
        Location: UE.IntPoint;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BookMark2D;
        static Load(InName: string): BookMark2D;
    }
    
    class BoolBinding extends UE.PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetValue() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BoolBinding;
        static Load(InName: string): BoolBinding;
    }
    
    class BoolProperty extends UE.Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BoolProperty;
        static Load(InName: string): BoolProperty;
    }
    
    class SlateBrushAsset extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Brush: UE.SlateBrush;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateBrushAsset;
        static Load(InName: string): SlateBrushAsset;
    }
    
    class Border extends UE.ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        bShowEffectWhenDisabled: boolean;
        ContentColorAndOpacity: UE.LinearColor;
        ContentColorAndOpacityDelegate: $Delegate<() => UE.LinearColor>;
        Padding: UE.Margin;
        Background: UE.SlateBrush;
        BackgroundDelegate: $Delegate<() => UE.SlateBrush>;
        BrushColor: UE.LinearColor;
        BrushColorDelegate: $Delegate<() => UE.LinearColor>;
        DesiredSizeScale: UE.Vector2D;
        bFlipForRightToLeftFlowDirection: boolean;
        OnMouseButtonDownEvent: $Delegate<(MyGeometry: UE.Geometry, MouseEvent: UE.PointerEvent) => UE.EventReply>;
        OnMouseButtonUpEvent: $Delegate<(MyGeometry: UE.Geometry, MouseEvent: UE.PointerEvent) => UE.EventReply>;
        OnMouseMoveEvent: $Delegate<(MyGeometry: UE.Geometry, MouseEvent: UE.PointerEvent) => UE.EventReply>;
        OnMouseDoubleClickEvent: $Delegate<(MyGeometry: UE.Geometry, MouseEvent: UE.PointerEvent) => UE.EventReply>;
        Brush: UE.SlateBrushAsset;
        GetDynamicMaterial() : UE.MaterialInstanceDynamic;
        SetBrush(InBrush: UE.SlateBrush) : void;
        SetBrushColor(InBrushColor: UE.LinearColor) : void;
        SetBrushFromAsset(Asset: $Nullable<UE.SlateBrushAsset>) : void;
        SetBrushFromMaterial(Material: $Nullable<UE.MaterialInterface>) : void;
        SetBrushFromTexture(Texture: $Nullable<UE.Texture2D>) : void;
        SetContentColorAndOpacity(InContentColorAndOpacity: UE.LinearColor) : void;
        SetDesiredSizeScale(InScale: UE.Vector2D) : void;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Border;
        static Load(InName: string): Border;
    }
    
    class BorderSlot extends UE.PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: UE.Margin;
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BorderSlot;
        static Load(InName: string): BorderSlot;
    }
    
    class BoxComponent extends UE.ShapeComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoxExtent: UE.Vector;
        LineThickness: number;
        GetScaledBoxExtent() : UE.Vector;
        GetUnscaledBoxExtent() : UE.Vector;
        SetBoxExtent(InBoxExtent: UE.Vector, bUpdateOverlaps?: boolean /* = true */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BoxComponent;
        static Load(InName: string): BoxComponent;
    }
    
    class FieldNodeBase extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldNodeBase;
        static Load(InName: string): FieldNodeBase;
    }
    
    class FieldNodeFloat extends UE.FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldNodeFloat;
        static Load(InName: string): FieldNodeFloat;
    }
    
    enum EFieldFalloffType { Field_FallOff_None, Field_Falloff_Linear, Field_Falloff_Inverse, Field_Falloff_Squared, Field_Falloff_Logarithmic, Field_Falloff_Max}
    class BoxFalloff extends UE.FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        MinRange: number;
        MaxRange: number;
        Default: number;
        Transform: UE.Transform;
        Falloff: UE.EFieldFalloffType;
        SetBoxFalloff(Magnitude: number, MinRange: number, MaxRange: number, Default: number, Transform: UE.Transform, Falloff: UE.EFieldFalloffType) : UE.BoxFalloff;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BoxFalloff;
        static Load(InName: string): BoxFalloff;
    }
    
    enum EReflectionSourceType { CapturedScene, SpecifiedCubemap, EReflectionSourceType_MAX}
    class ReflectionCaptureComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CaptureOffsetComponent: UE.BillboardComponent;
        ReflectionSourceType: UE.EReflectionSourceType;
        Cubemap: UE.TextureCube;
        SourceCubemapAngle: number;
        Brightness: number;
        CaptureOffset: UE.Vector;
        MapBuildDataId: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReflectionCaptureComponent;
        static Load(InName: string): ReflectionCaptureComponent;
    }
    
    class ReflectionCapture extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CaptureComponent: UE.ReflectionCaptureComponent;
        SpriteComponent: UE.BillboardComponent;
        CaptureOffsetComponent: UE.BillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReflectionCapture;
        static Load(InName: string): ReflectionCapture;
    }
    
    class BoxReflectionCapture extends UE.ReflectionCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BoxReflectionCapture;
        static Load(InName: string): BoxReflectionCapture;
    }
    
    class BoxReflectionCaptureComponent extends UE.ReflectionCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoxTransitionDistance: number;
        PreviewInfluenceBox: UE.BoxComponent;
        PreviewCaptureBox: UE.BoxComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BoxReflectionCaptureComponent;
        static Load(InName: string): BoxReflectionCaptureComponent;
    }
    
    class TextureLightProfile extends UE.Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Brightness: number;
        TextureMultiplier: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureLightProfile;
        static Load(InName: string): TextureLightProfile;
    }
    
    class LightComponent extends UE.LightComponentBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Temperature: number;
        MaxDrawDistance: number;
        MaxDistanceFadeRange: number;
        bUseTemperature: boolean;
        ShadowMapChannel: number;
        MinRoughness: number;
        SpecularScale: number;
        ShadowResolutionScale: number;
        ShadowBias: number;
        ShadowSlopeBias: number;
        ShadowSharpen: number;
        ContactShadowLength: number;
        ContactShadowLengthInWS: boolean;
        InverseSquaredFalloff: boolean;
        CastTranslucentShadows: boolean;
        bCastShadowsFromCinematicObjectsOnly: boolean;
        bAffectDynamicIndirectLighting: boolean;
        bForceCachedShadowsForMovablePrimitives: boolean;
        LightingChannels: UE.LightingChannels;
        LightFunctionMaterial: UE.MaterialInterface;
        LightFunctionScale: UE.Vector;
        IESTexture: UE.TextureLightProfile;
        bUseIESBrightness: boolean;
        IESBrightnessScale: number;
        LightFunctionFadeDistance: number;
        DisabledBrightness: number;
        bEnableLightShaftBloom: boolean;
        BloomScale: number;
        BloomThreshold: number;
        BloomMaxBrightness: number;
        BloomTint: UE.Color;
        bUseRayTracedDistanceFieldShadows: boolean;
        RayStartOffsetDepthScale: number;
        SetAffectDynamicIndirectLighting(bNewValue: boolean) : void;
        SetAffectTranslucentLighting(bNewValue: boolean) : void;
        SetBloomMaxBrightness(NewValue: number) : void;
        SetBloomScale(NewValue: number) : void;
        SetBloomThreshold(NewValue: number) : void;
        SetBloomTint(NewValue: UE.Color) : void;
        SetEnableLightShaftBloom(bNewValue: boolean) : void;
        SetForceCachedShadowsForMovablePrimitives(bNewValue: boolean) : void;
        SetIESBrightnessScale(NewValue: number) : void;
        SetIESTexture(NewValue: $Nullable<UE.TextureLightProfile>) : void;
        SetIndirectLightingIntensity(NewIntensity: number) : void;
        SetIntensity(NewIntensity: number) : void;
        SetLightColor(NewLightColor: UE.LinearColor, bSRGB?: boolean /* = true */) : void;
        SetLightFunctionDisabledBrightness(NewValue: number) : void;
        SetLightFunctionFadeDistance(NewLightFunctionFadeDistance: number) : void;
        SetLightFunctionMaterial(NewLightFunctionMaterial: $Nullable<UE.MaterialInterface>) : void;
        SetLightFunctionScale(NewLightFunctionScale: UE.Vector) : void;
        SetShadowBias(NewValue: number) : void;
        SetShadowSlopeBias(NewValue: number) : void;
        SetSpecularScale(NewValue: number) : void;
        SetTemperature(NewTemperature: number) : void;
        SetTransmission(bNewValue: boolean) : void;
        SetUseIESBrightness(bNewValue: boolean) : void;
        SetVolumetricScatteringIntensity(NewIntensity: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightComponent;
        static Load(InName: string): LightComponent;
    }
    
    class Light extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightComponent: UE.LightComponent;
        bEnabled: boolean;
        GetBrightness() : number;
        GetLightColor() : UE.LinearColor;
        IsEnabled() : boolean;
        OnRep_bEnabled() : void;
        SetAffectTranslucentLighting(bNewValue: boolean) : void;
        SetBrightness(NewBrightness: number) : void;
        SetCastShadows(bNewValue: boolean) : void;
        SetEnabled(bSetEnabled: boolean) : void;
        SetLightColor(NewLightColor: UE.LinearColor) : void;
        SetLightFunctionFadeDistance(NewLightFunctionFadeDistance: number) : void;
        SetLightFunctionMaterial(NewLightFunctionMaterial: $Nullable<UE.MaterialInterface>) : void;
        SetLightFunctionScale(NewLightFunctionScale: UE.Vector) : void;
        ToggleEnabled() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Light;
        static Load(InName: string): Light;
    }
    
    class LightmassLightSettings {
        constructor();
        constructor(IndirectLightingSaturation: number, ShadowExponent: number, bUseAreaShadowsForStationaryLight: boolean);
        IndirectLightingSaturation: number;
        ShadowExponent: number;
        bUseAreaShadowsForStationaryLight: boolean;
        static StaticClass(): Class;
    }
    
    class LightmassDirectionalLightSettings extends UE.LightmassLightSettings {
        constructor();
        constructor(LightSourceAngle: number);
        LightSourceAngle: number;
        static StaticClass(): Class;
    }
    
    class DirectionalLightComponent extends UE.LightComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShadowCascadeBiasDistribution: number;
        bEnableLightShaftOcclusion: boolean;
        OcclusionMaskDarkness: number;
        OcclusionDepthRange: number;
        LightShaftOverrideDirection: UE.Vector;
        WholeSceneDynamicShadowRadius: number;
        DynamicShadowDistanceMovableLight: number;
        DynamicShadowDistanceStationaryLight: number;
        DynamicShadowCascades: number;
        CascadeDistributionExponent: number;
        CascadeTransitionFraction: number;
        ShadowDistanceFadeoutFraction: number;
        bUseInsetShadowsForMovableObjects: boolean;
        FarShadowCascadeCount: number;
        FarShadowDistance: number;
        DistanceFieldShadowDistance: number;
        LightSourceAngle: number;
        LightSourceSoftAngle: number;
        TraceDistance: number;
        LightmassSettings: UE.LightmassDirectionalLightSettings;
        bCastModulatedShadows: boolean;
        ModulatedShadowColor: UE.Color;
        ShadowAmount: number;
        bUsedAsAtmosphereSunLight: boolean;
        AtmosphereSunLightIndex: number;
        SetCascadeDistributionExponent(NewValue: number) : void;
        SetCascadeTransitionFraction(NewValue: number) : void;
        SetDynamicShadowCascades(NewValue: number) : void;
        SetDynamicShadowDistanceMovableLight(NewValue: number) : void;
        SetDynamicShadowDistanceStationaryLight(NewValue: number) : void;
        SetEnableLightShaftOcclusion(bNewValue: boolean) : void;
        SetLightShaftOverrideDirection(NewValue: UE.Vector) : void;
        SetOcclusionMaskDarkness(NewValue: number) : void;
        SetShadowAmount(NewValue: number) : void;
        SetShadowDistanceFadeoutFraction(NewValue: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DirectionalLightComponent;
        static Load(InName: string): DirectionalLightComponent;
    }
    
    class DirectionalLight extends UE.Light {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ArrowComponent: UE.ArrowComponent;
        DirectionalLightComponent: UE.DirectionalLightComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DirectionalLight;
        static Load(InName: string): DirectionalLight;
    }
    
    namespace Engine.EngineSky.BP_Sky_Sphere {
        class BP_Sky_Sphere_C extends UE.Actor {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            SkySphereMesh: UE.StaticMeshComponent;
            Base: UE.SceneComponent;
            ["Sky material"]: UE.MaterialInstanceDynamic;
            ["Refresh material"]: boolean;
            ["Directional light actor"]: UE.DirectionalLight;
            ["Colors determined by sun position"]: boolean;
            ["Sun height"]: number;
            ["Sun brightness"]: number;
            ["Horizon Falloff"]: number;
            ["Zenith Color"]: UE.LinearColor;
            ["Horizon color"]: UE.LinearColor;
            ["Cloud color"]: UE.LinearColor;
            ["Overall Color"]: UE.LinearColor;
            ["Cloud speed"]: number;
            ["Cloud opacity"]: number;
            ["Stars brightness"]: number;
            ["Horizon color curve"]: UE.CurveLinearColor;
            ["Zenith color curve"]: UE.CurveLinearColor;
            ["Cloud color curve"]: UE.CurveLinearColor;
            RefreshMaterial() : void;
            UpdateSunDirection() : void;
            UserConstructionScript() : void;
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): BP_Sky_Sphere_C;
            static Load(InName: string): BP_Sky_Sphere_C;
        }
        
    }

    class BrushBinding extends UE.PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetValue() : UE.SlateBrush;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BrushBinding;
        static Load(InName: string): BrushBinding;
    }
    
    class BrushShape extends UE.Brush {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BrushShape;
        static Load(InName: string): BrushShape;
    }
    
    class BTComposite_Selector extends UE.BTCompositeNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTComposite_Selector;
        static Load(InName: string): BTComposite_Selector;
    }
    
    class BTComposite_Sequence extends UE.BTCompositeNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTComposite_Sequence;
        static Load(InName: string): BTComposite_Sequence;
    }
    
    enum EBTParallelMode { AbortBackground, WaitForBackground, EBTParallelMode_MAX}
    class BTComposite_SimpleParallel extends UE.BTCompositeNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FinishMode: UE.EBTParallelMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTComposite_SimpleParallel;
        static Load(InName: string): BTComposite_SimpleParallel;
    }
    
    class BlackboardKeySelector {
        constructor();
        constructor(AllowedTypes: TArray<UE.BlackboardKeyType>, SelectedKeyName: string, SelectedKeyType: UE.Class, SelectedKeyID: number, bNoneIsAllowedValue: boolean);
        AllowedTypes: TArray<UE.BlackboardKeyType>;
        SelectedKeyName: string;
        SelectedKeyType: UE.Class;
        SelectedKeyID: number;
        bNoneIsAllowedValue: boolean;
        static StaticClass(): Class;
    }
    
    class BTDecorator_BlackboardBase extends UE.BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlackboardKey: UE.BlackboardKeySelector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_BlackboardBase;
        static Load(InName: string): BTDecorator_BlackboardBase;
    }
    
    enum EBTBlackboardRestart { ValueChange, ResultChange, EBTBlackboardRestart_MAX}
    enum EBasicKeyOperation { Set, NotSet, EBasicKeyOperation_MAX}
    enum EArithmeticKeyOperation { Equal, NotEqual, Less, LessOrEqual, Greater, GreaterOrEqual, EArithmeticKeyOperation_MAX}
    enum ETextKeyOperation { Equal, NotEqual, Contain, NotContain, ETextKeyOperation_MAX}
    class BTDecorator_Blackboard extends UE.BTDecorator_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IntValue: number;
        FloatValue: number;
        StringValue: string;
        CachedDescription: string;
        OperationType: number;
        NotifyObserver: UE.EBTBlackboardRestart;
        BasicOperation: UE.EBasicKeyOperation;
        ArithmeticOperation: UE.EArithmeticKeyOperation;
        TextOperation: UE.ETextKeyOperation;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_Blackboard;
        static Load(InName: string): BTDecorator_Blackboard;
    }
    
    enum EBTNodeResult { Succeeded, Failed, Aborted, InProgress, EBTNodeResult_MAX}
    class BTDecorator_BlueprintBase extends UE.BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AIOwner: UE.AIController;
        ActorOwner: UE.Actor;
        ObservedKeyNames: TArray<string>;
        bShowPropertyDetails: boolean;
        bCheckConditionOnlyBlackBoardChanges: boolean;
        bIsObservingBB: boolean;
        IsDecoratorExecutionActive() : boolean;
        IsDecoratorObserverActive() : boolean;
        PerformConditionCheck(OwnerActor: $Nullable<UE.Actor>) : boolean;
        PerformConditionCheckAI(OwnerController: $Nullable<UE.AIController>, ControlledPawn: $Nullable<UE.Pawn>) : boolean;
        ReceiveExecutionFinish(OwnerActor: $Nullable<UE.Actor>, NodeResult: UE.EBTNodeResult) : void;
        ReceiveExecutionFinishAI(OwnerController: $Nullable<UE.AIController>, ControlledPawn: $Nullable<UE.Pawn>, NodeResult: UE.EBTNodeResult) : void;
        ReceiveExecutionStart(OwnerActor: $Nullable<UE.Actor>) : void;
        ReceiveExecutionStartAI(OwnerController: $Nullable<UE.AIController>, ControlledPawn: $Nullable<UE.Pawn>) : void;
        ReceiveObserverActivated(OwnerActor: $Nullable<UE.Actor>) : void;
        ReceiveObserverActivatedAI(OwnerController: $Nullable<UE.AIController>, ControlledPawn: $Nullable<UE.Pawn>) : void;
        ReceiveObserverDeactivated(OwnerActor: $Nullable<UE.Actor>) : void;
        ReceiveObserverDeactivatedAI(OwnerController: $Nullable<UE.AIController>, ControlledPawn: $Nullable<UE.Pawn>) : void;
        ReceiveTick(OwnerActor: $Nullable<UE.Actor>, DeltaSeconds: number) : void;
        ReceiveTickAI(OwnerController: $Nullable<UE.AIController>, ControlledPawn: $Nullable<UE.Pawn>, DeltaSeconds: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_BlueprintBase;
        static Load(InName: string): BTDecorator_BlueprintBase;
    }
    
    enum EGameplayContainerMatchType { Any, All, EGameplayContainerMatchType_MAX}
    class BTDecorator_CheckGameplayTagsOnActor extends UE.BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActorToCheck: UE.BlackboardKeySelector;
        TagsToMatch: UE.EGameplayContainerMatchType;
        GameplayTags: UE.GameplayTagContainer;
        CachedDescription: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_CheckGameplayTagsOnActor;
        static Load(InName: string): BTDecorator_CheckGameplayTagsOnActor;
    }
    
    enum EBlackBoardEntryComparison { Equal, NotEqual, EBlackBoardEntryComparison_MAX}
    class BTDecorator_CompareBBEntries extends UE.BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Operator: UE.EBlackBoardEntryComparison;
        BlackboardKeyA: UE.BlackboardKeySelector;
        BlackboardKeyB: UE.BlackboardKeySelector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_CompareBBEntries;
        static Load(InName: string): BTDecorator_CompareBBEntries;
    }
    
    class BTDecorator_ConditionalLoop extends UE.BTDecorator_Blackboard {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_ConditionalLoop;
        static Load(InName: string): BTDecorator_ConditionalLoop;
    }
    
    class BTDecorator_ConeCheck extends UE.BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConeHalfAngle: number;
        ConeOrigin: UE.BlackboardKeySelector;
        ConeDirection: UE.BlackboardKeySelector;
        Observed: UE.BlackboardKeySelector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_ConeCheck;
        static Load(InName: string): BTDecorator_ConeCheck;
    }
    
    class BTDecorator_Cooldown extends UE.BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CoolDownTime: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_Cooldown;
        static Load(InName: string): BTDecorator_Cooldown;
    }
    
    enum EPathExistanceQueryType { NavmeshRaycast2D, HierarchicalQuery, RegularPathFinding, EPathExistanceQueryType_MAX}
    class BTDecorator_DoesPathExist extends UE.BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlackboardKeyA: UE.BlackboardKeySelector;
        BlackboardKeyB: UE.BlackboardKeySelector;
        bUseSelf: boolean;
        PathQueryType: UE.EPathExistanceQueryType;
        FilterClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_DoesPathExist;
        static Load(InName: string): BTDecorator_DoesPathExist;
    }
    
    class BTDecorator_ForceSuccess extends UE.BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_ForceSuccess;
        static Load(InName: string): BTDecorator_ForceSuccess;
    }
    
    enum FAIDistanceType { Distance3D, Distance2D, DistanceZ, MAX}
    class BTDecorator_IsAtLocation extends UE.BTDecorator_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AcceptableRadius: number;
        ParametrizedAcceptableRadius: UE.AIDataProviderFloatValue;
        GeometricDistanceType: UE.FAIDistanceType;
        bUseParametrizedRadius: boolean;
        bUseNavAgentGoalLocation: boolean;
        bPathFindingBasedTest: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_IsAtLocation;
        static Load(InName: string): BTDecorator_IsAtLocation;
    }
    
    class BTDecorator_IsBBEntryOfClass extends UE.BTDecorator_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TestClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_IsBBEntryOfClass;
        static Load(InName: string): BTDecorator_IsBBEntryOfClass;
    }
    
    class BTDecorator_KeepInCone extends UE.BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConeHalfAngle: number;
        ConeOrigin: UE.BlackboardKeySelector;
        Observed: UE.BlackboardKeySelector;
        bUseSelfAsOrigin: boolean;
        bUseSelfAsObserved: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_KeepInCone;
        static Load(InName: string): BTDecorator_KeepInCone;
    }
    
    class BTDecorator_Loop extends UE.BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumLoops: number;
        bInfiniteLoop: boolean;
        InfiniteLoopTimeoutTime: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_Loop;
        static Load(InName: string): BTDecorator_Loop;
    }
    
    class BTDecorator_ReachedMoveGoal extends UE.BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_ReachedMoveGoal;
        static Load(InName: string): BTDecorator_ReachedMoveGoal;
    }
    
    class BTDecorator_SetTagCooldown extends UE.BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CooldownTag: UE.GameplayTag;
        CooldownDuration: number;
        bAddToExistingDuration: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_SetTagCooldown;
        static Load(InName: string): BTDecorator_SetTagCooldown;
    }
    
    class BTDecorator_TagCooldown extends UE.BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CooldownTag: UE.GameplayTag;
        CooldownDuration: number;
        bAddToExistingDuration: boolean;
        bActivatesCooldown: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_TagCooldown;
        static Load(InName: string): BTDecorator_TagCooldown;
    }
    
    class BTDecorator_TimeLimit extends UE.BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TimeLimit: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_TimeLimit;
        static Load(InName: string): BTDecorator_TimeLimit;
    }
    
    class BTFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ClearBlackboardValue(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector) : void;
        static ClearBlackboardValueAsVector(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector) : void;
        static GetBlackboardValueAsActor(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector) : UE.Actor;
        static GetBlackboardValueAsBool(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector) : boolean;
        static GetBlackboardValueAsClass(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector) : UE.Class;
        static GetBlackboardValueAsEnum(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector) : number;
        static GetBlackboardValueAsFloat(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector) : number;
        static GetBlackboardValueAsInt(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector) : number;
        static GetBlackboardValueAsName(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector) : string;
        static GetBlackboardValueAsObject(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector) : UE.Object;
        static GetBlackboardValueAsRotator(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector) : UE.Rotator;
        static GetBlackboardValueAsString(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector) : string;
        static GetBlackboardValueAsVector(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector) : UE.Vector;
        static GetOwnerComponent(NodeOwner: $Nullable<UE.BTNode>) : UE.BehaviorTreeComponent;
        static GetOwnersBlackboard(NodeOwner: $Nullable<UE.BTNode>) : UE.BlackboardComponent;
        static SetBlackboardValueAsBool(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector, Value: boolean) : void;
        static SetBlackboardValueAsClass(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector, Value: $Nullable<UE.Class>) : void;
        static SetBlackboardValueAsEnum(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector, Value: number) : void;
        static SetBlackboardValueAsFloat(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector, Value: number) : void;
        static SetBlackboardValueAsInt(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector, Value: number) : void;
        static SetBlackboardValueAsName(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector, Value: string) : void;
        static SetBlackboardValueAsObject(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector, Value: $Nullable<UE.Object>) : void;
        static SetBlackboardValueAsRotator(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector, Value: UE.Rotator) : void;
        static SetBlackboardValueAsString(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector, Value: string) : void;
        static SetBlackboardValueAsVector(NodeOwner: $Nullable<UE.BTNode>, Key: UE.BlackboardKeySelector, Value: UE.Vector) : void;
        static StartUsingExternalEvent(NodeOwner: $Nullable<UE.BTNode>, OwningActor: $Nullable<UE.Actor>) : void;
        static StopUsingExternalEvent(NodeOwner: $Nullable<UE.BTNode>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTFunctionLibrary;
        static Load(InName: string): BTFunctionLibrary;
    }
    
    class BTService_BlackboardBase extends UE.BTService {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlackboardKey: UE.BlackboardKeySelector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTService_BlackboardBase;
        static Load(InName: string): BTService_BlackboardBase;
    }
    
    class BTService_BlueprintBase extends UE.BTService {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AIOwner: UE.AIController;
        ActorOwner: UE.Actor;
        bShowPropertyDetails: boolean;
        bShowEventDetails: boolean;
        IsServiceActive() : boolean;
        ReceiveActivation(OwnerActor: $Nullable<UE.Actor>) : void;
        ReceiveActivationAI(OwnerController: $Nullable<UE.AIController>, ControlledPawn: $Nullable<UE.Pawn>) : void;
        ReceiveDeactivation(OwnerActor: $Nullable<UE.Actor>) : void;
        ReceiveDeactivationAI(OwnerController: $Nullable<UE.AIController>, ControlledPawn: $Nullable<UE.Pawn>) : void;
        ReceiveSearchStart(OwnerActor: $Nullable<UE.Actor>) : void;
        ReceiveSearchStartAI(OwnerController: $Nullable<UE.AIController>, ControlledPawn: $Nullable<UE.Pawn>) : void;
        ReceiveTick(OwnerActor: $Nullable<UE.Actor>, DeltaSeconds: number) : void;
        ReceiveTickAI(OwnerController: $Nullable<UE.AIController>, ControlledPawn: $Nullable<UE.Pawn>, DeltaSeconds: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTService_BlueprintBase;
        static Load(InName: string): BTService_BlueprintBase;
    }
    
    class BTService_DefaultFocus extends UE.BTService_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FocusPriority: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTService_DefaultFocus;
        static Load(InName: string): BTService_DefaultFocus;
    }
    
    enum EAIParamType { Float, Int, Bool, MAX}
    class AIDynamicParam {
        constructor();
        constructor(ParamName: string, ParamType: UE.EAIParamType, Value: number, BBKey: UE.BlackboardKeySelector);
        ParamName: string;
        ParamType: UE.EAIParamType;
        Value: number;
        BBKey: UE.BlackboardKeySelector;
        static StaticClass(): Class;
    }
    
    class EQSParametrizedQueryExecutionRequest {
        constructor();
        constructor(QueryTemplate: UE.EnvQuery, QueryConfig: TArray<UE.AIDynamicParam>, EQSQueryBlackboardKey: UE.BlackboardKeySelector, RunMode: UE.EEnvQueryRunMode, bUseBBKeyForQueryTemplate: boolean);
        QueryTemplate: UE.EnvQuery;
        QueryConfig: TArray<UE.AIDynamicParam>;
        EQSQueryBlackboardKey: UE.BlackboardKeySelector;
        RunMode: UE.EEnvQueryRunMode;
        bUseBBKeyForQueryTemplate: boolean;
        static StaticClass(): Class;
    }
    
    class BTService_RunEQS extends UE.BTService_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EQSRequest: UE.EQSParametrizedQueryExecutionRequest;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTService_RunEQS;
        static Load(InName: string): BTService_RunEQS;
    }
    
    class BTTask_BlackboardBase extends UE.BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlackboardKey: UE.BlackboardKeySelector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_BlackboardBase;
        static Load(InName: string): BTTask_BlackboardBase;
    }
    
    class IntervalCountdown {
        constructor();
        constructor(Interval: number);
        Interval: number;
        static StaticClass(): Class;
    }
    
    class BTTask_BlueprintBase extends UE.BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AIOwner: UE.AIController;
        ActorOwner: UE.Actor;
        TickInterval: UE.IntervalCountdown;
        bShowPropertyDetails: boolean;
        FinishAbort() : void;
        FinishExecute(bSuccess: boolean) : void;
        IsTaskAborting() : boolean;
        IsTaskExecuting() : boolean;
        ReceiveAbort(OwnerActor: $Nullable<UE.Actor>) : void;
        ReceiveAbortAI(OwnerController: $Nullable<UE.AIController>, ControlledPawn: $Nullable<UE.Pawn>) : void;
        ReceiveExecute(OwnerActor: $Nullable<UE.Actor>) : void;
        ReceiveExecuteAI(OwnerController: $Nullable<UE.AIController>, ControlledPawn: $Nullable<UE.Pawn>) : void;
        ReceiveTick(OwnerActor: $Nullable<UE.Actor>, DeltaSeconds: number) : void;
        ReceiveTickAI(OwnerController: $Nullable<UE.AIController>, ControlledPawn: $Nullable<UE.Pawn>, DeltaSeconds: number) : void;
        SetFinishOnMessage(MessageName: string) : void;
        SetFinishOnMessageWithId(MessageName: string, RequestID?: number /* = -1 */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_BlueprintBase;
        static Load(InName: string): BTTask_BlueprintBase;
    }
    
    class BTTask_FinishWithResult extends UE.BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Result: UE.EBTNodeResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_FinishWithResult;
        static Load(InName: string): BTTask_FinishWithResult;
    }
    
    class BTTask_GameplayTaskBase extends UE.BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bWaitForGameplayTask: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_GameplayTaskBase;
        static Load(InName: string): BTTask_GameplayTaskBase;
    }
    
    class BTTask_MakeNoise extends UE.BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Loudnes: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_MakeNoise;
        static Load(InName: string): BTTask_MakeNoise;
    }
    
    class BTTask_MoveTo extends UE.BTTask_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AcceptableRadius: number;
        FilterClass: UE.Class;
        ObservedBlackboardValueTolerance: number;
        bObserveBlackboardValue: boolean;
        bAllowStrafe: boolean;
        bAllowPartialPath: boolean;
        bTrackMovingGoal: boolean;
        bProjectGoalLocation: boolean;
        bReachTestIncludesAgentRadius: boolean;
        bReachTestIncludesGoalRadius: boolean;
        bStopOnOverlap: boolean;
        bStopOnOverlapNeedsUpdate: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_MoveTo;
        static Load(InName: string): BTTask_MoveTo;
    }
    
    class BTTask_MoveDirectlyToward extends UE.BTTask_MoveTo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDisablePathUpdateOnGoalLocationChange: boolean;
        bProjectVectorGoalToNavigation: boolean;
        bUpdatedDeprecatedProperties: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_MoveDirectlyToward;
        static Load(InName: string): BTTask_MoveDirectlyToward;
    }
    
    class BTTask_PawnActionBase extends UE.BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_PawnActionBase;
        static Load(InName: string): BTTask_PawnActionBase;
    }
    
    class BTTask_PlayAnimation extends UE.BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimationToPlay: UE.AnimationAsset;
        bLooping: boolean;
        bNonBlocking: boolean;
        MyOwnerComp: UE.BehaviorTreeComponent;
        CachedSkelMesh: UE.SkeletalMeshComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_PlayAnimation;
        static Load(InName: string): BTTask_PlayAnimation;
    }
    
    class BTTask_PlaySound extends UE.BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundToPlay: UE.SoundCue;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_PlaySound;
        static Load(InName: string): BTTask_PlaySound;
    }
    
    class BTTask_PushPawnAction extends UE.BTTask_PawnActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Action: UE.PawnAction;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_PushPawnAction;
        static Load(InName: string): BTTask_PushPawnAction;
    }
    
    class BTTask_RotateToFaceBBEntry extends UE.BTTask_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Precision: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_RotateToFaceBBEntry;
        static Load(InName: string): BTTask_RotateToFaceBBEntry;
    }
    
    class BTTask_RunBehavior extends UE.BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BehaviorAsset: UE.BehaviorTree;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_RunBehavior;
        static Load(InName: string): BTTask_RunBehavior;
    }
    
    class BTTask_RunBehaviorDynamic extends UE.BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InjectionTag: UE.GameplayTag;
        DefaultBehaviorAsset: UE.BehaviorTree;
        BehaviorAsset: UE.BehaviorTree;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_RunBehaviorDynamic;
        static Load(InName: string): BTTask_RunBehaviorDynamic;
    }
    
    class EnvNamedValue {
        constructor();
        constructor(ParamName: string, ParamType: UE.EAIParamType, Value: number);
        ParamName: string;
        ParamType: UE.EAIParamType;
        Value: number;
        static StaticClass(): Class;
    }
    
    class BTTask_RunEQSQuery extends UE.BTTask_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        QueryTemplate: UE.EnvQuery;
        QueryParams: TArray<UE.EnvNamedValue>;
        QueryConfig: TArray<UE.AIDynamicParam>;
        RunMode: UE.EEnvQueryRunMode;
        EQSQueryBlackboardKey: UE.BlackboardKeySelector;
        bUseBBKey: boolean;
        EQSRequest: UE.EQSParametrizedQueryExecutionRequest;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_RunEQSQuery;
        static Load(InName: string): BTTask_RunEQSQuery;
    }
    
    class BTTask_SetTagCooldown extends UE.BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CooldownTag: UE.GameplayTag;
        bAddToExistingDuration: boolean;
        CooldownDuration: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_SetTagCooldown;
        static Load(InName: string): BTTask_SetTagCooldown;
    }
    
    class BTTask_Wait extends UE.BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WaitTime: number;
        RandomDeviation: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_Wait;
        static Load(InName: string): BTTask_Wait;
    }
    
    class BTTask_WaitBlackboardTime extends UE.BTTask_Wait {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlackboardKey: UE.BlackboardKeySelector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_WaitBlackboardTime;
        static Load(InName: string): BTTask_WaitBlackboardTime;
    }
    
    class SHAHashData {
        constructor();
        constructor(Hash: FixSizeArray<number>);
        Hash: FixSizeArray<number>;
        static StaticClass(): Class;
    }
    
    class ChunkPartData {
        constructor();
        constructor(Guid: UE.Guid, Offset: number, Size: number);
        Guid: UE.Guid;
        Offset: number;
        Size: number;
        static StaticClass(): Class;
    }
    
    class FileManifestData {
        constructor();
        constructor(Filename: string, FileHash: UE.SHAHashData, FileChunkParts: TArray<UE.ChunkPartData>, InstallTags: TArray<string>, bIsUnixExecutable: boolean, SymlinkTarget: string, bIsReadOnly: boolean, bIsCompressed: boolean);
        Filename: string;
        FileHash: UE.SHAHashData;
        FileChunkParts: TArray<UE.ChunkPartData>;
        InstallTags: TArray<string>;
        bIsUnixExecutable: boolean;
        SymlinkTarget: string;
        bIsReadOnly: boolean;
        bIsCompressed: boolean;
        static StaticClass(): Class;
    }
    
    class ChunkInfoData {
        constructor();
        constructor(Guid: UE.Guid, Hash: bigint, ShaHash: UE.SHAHashData, FileSize: bigint, GroupNumber: number);
        Guid: UE.Guid;
        Hash: bigint;
        ShaHash: UE.SHAHashData;
        FileSize: bigint;
        GroupNumber: number;
        static StaticClass(): Class;
    }
    
    class CustomFieldData {
        constructor();
        constructor(Key: string, Value: string);
        Key: string;
        Value: string;
        static StaticClass(): Class;
    }
    
    class BuildPatchManifest extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ManifestFileVersion: number;
        bIsFileData: boolean;
        AppID: number;
        AppName: string;
        BuildVersion: string;
        LaunchExe: string;
        LaunchCommand: string;
        PrereqIds: TSet<string>;
        PrereqName: string;
        PrereqPath: string;
        PrereqArgs: string;
        FileManifestList: TArray<UE.FileManifestData>;
        ChunkList: TArray<UE.ChunkInfoData>;
        CustomFields: TArray<UE.CustomFieldData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BuildPatchManifest;
        static Load(InName: string): BuildPatchManifest;
    }
    
    class SlateWidgetStyleContainerBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateWidgetStyleContainerBase;
        static Load(InName: string): SlateWidgetStyleContainerBase;
    }
    
    class SlateWidgetStyleAsset extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CustomStyle: UE.SlateWidgetStyleContainerBase;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateWidgetStyleAsset;
        static Load(InName: string): SlateWidgetStyleAsset;
    }
    
    class SlateWidgetStyle {
        constructor();
        static StaticClass(): Class;
    }
    
    class SlateSound {
        constructor();
        constructor(ResourceObject: UE.Object);
        ResourceObject: UE.Object;
        static StaticClass(): Class;
    }
    
    class ButtonStyle extends UE.SlateWidgetStyle {
        constructor();
        constructor(Normal: UE.SlateBrush, Hovered: UE.SlateBrush, Pressed: UE.SlateBrush, Disabled: UE.SlateBrush, NormalPadding: UE.Margin, PressedPadding: UE.Margin, PressedSlateSound: UE.SlateSound, HoveredSlateSound: UE.SlateSound, PressedSound: string, HoveredSound: string);
        Normal: UE.SlateBrush;
        Hovered: UE.SlateBrush;
        Pressed: UE.SlateBrush;
        Disabled: UE.SlateBrush;
        NormalPadding: UE.Margin;
        PressedPadding: UE.Margin;
        PressedSlateSound: UE.SlateSound;
        HoveredSlateSound: UE.SlateSound;
        PressedSound: string;
        HoveredSound: string;
        static StaticClass(): Class;
    }
    
    enum EButtonClickMethod { DownAndUp, MouseDown, MouseUp, PreciseClick, EButtonClickMethod_MAX}
    enum EButtonTouchMethod { DownAndUp, Down, PreciseTap, EButtonTouchMethod_MAX}
    enum EButtonPressMethod { DownAndUp, ButtonPress, ButtonRelease, EButtonPressMethod_MAX}
    class Button extends UE.ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Style: UE.SlateWidgetStyleAsset;
        WidgetStyle: UE.ButtonStyle;
        ColorAndOpacity: UE.LinearColor;
        BackgroundColor: UE.LinearColor;
        ClickMethod: UE.EButtonClickMethod;
        TouchMethod: UE.EButtonTouchMethod;
        PressMethod: UE.EButtonPressMethod;
        IsFocusable: boolean;
        OnClicked: $MulticastDelegate<() => void>;
        OnPressed: $MulticastDelegate<() => void>;
        OnReleased: $MulticastDelegate<() => void>;
        OnHovered: $MulticastDelegate<() => void>;
        OnUnhovered: $MulticastDelegate<() => void>;
        IsPressed() : boolean;
        SetBackgroundColor(InBackgroundColor: UE.LinearColor) : void;
        SetClickMethod(InClickMethod: UE.EButtonClickMethod) : void;
        SetColorAndOpacity(InColorAndOpacity: UE.LinearColor) : void;
        SetPressMethod(InPressMethod: UE.EButtonPressMethod) : void;
        SetStyle(InStyle: UE.ButtonStyle) : void;
        SetTouchMethod(InTouchMethod: UE.EButtonTouchMethod) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Button;
        static Load(InName: string): Button;
    }
    
    class ButtonSlot extends UE.PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: UE.Margin;
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ButtonSlot;
        static Load(InName: string): ButtonSlot;
    }
    
    class ButtonStyleAsset extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ButtonStyle: UE.ButtonStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ButtonStyleAsset;
        static Load(InName: string): ButtonStyleAsset;
    }
    
    class ButtonWidgetStyle extends UE.SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ButtonStyle: UE.ButtonStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ButtonWidgetStyle;
        static Load(InName: string): ButtonWidgetStyle;
    }
    
    class NumericProperty extends UE.Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NumericProperty;
        static Load(InName: string): NumericProperty;
    }
    
    class ByteProperty extends UE.NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ByteProperty;
        static Load(InName: string): ByteProperty;
    }
    
    class ComponentReference {
        constructor();
        constructor(OtherActor: UE.Actor, ComponentProperty: string, PathToComponent: string);
        OtherActor: UE.Actor;
        ComponentProperty: string;
        PathToComponent: string;
        static StaticClass(): Class;
    }
    
    class CableComponent extends UE.MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAttachStart: boolean;
        bAttachEnd: boolean;
        AttachEndTo: UE.ComponentReference;
        AttachEndToSocketName: string;
        EndLocation: UE.Vector;
        CableLength: number;
        NumSegments: number;
        SubstepTime: number;
        SolverIterations: number;
        bEnableStiffness: boolean;
        bEnableCollision: boolean;
        CollisionFriction: number;
        CableForce: UE.Vector;
        CableGravityScale: number;
        CableWidth: number;
        NumSides: number;
        TileMaterial: number;
        GetAttachedActor() : UE.Actor;
        GetAttachedComponent() : UE.SceneComponent;
        GetCableParticleLocations(Locations: $Ref<TArray<UE.Vector>>) : void;
        SetAttachEndTo(Actor: $Nullable<UE.Actor>, ComponentProperty: string, SocketName?: string /* = "None" */) : void;
        SetAttachEndToComponent(Component: $Nullable<UE.SceneComponent>, SocketName?: string /* = "None" */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CableComponent;
        static Load(InName: string): CableComponent;
    }
    
    class CableActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CableComponent: UE.CableComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CableActor;
        static Load(InName: string): CableActor;
    }
    
    class CameraAnimFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraAnimFactory;
        static Load(InName: string): CameraAnimFactory;
    }
    
    class CameraBlockingVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraBlockingVolume;
        static Load(InName: string): CameraBlockingVolume;
    }
    
    class CameraRig_Crane extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CranePitch: number;
        CraneYaw: number;
        CraneArmLength: number;
        bLockMountPitch: boolean;
        bLockMountYaw: boolean;
        TransformComponent: UE.SceneComponent;
        CraneYawControl: UE.SceneComponent;
        CranePitchControl: UE.SceneComponent;
        CraneCameraMount: UE.SceneComponent;
        PreviewMesh_CraneArm: UE.StaticMeshComponent;
        PreviewMesh_CraneBase: UE.StaticMeshComponent;
        PreviewMesh_CraneMount: UE.StaticMeshComponent;
        PreviewMesh_CraneCounterWeight: UE.StaticMeshComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraRig_Crane;
        static Load(InName: string): CameraRig_Crane;
    }
    
    class InterpCurvePointQuat {
        constructor();
        constructor(InVal: number, OutVal: UE.Quat, ArriveTangent: UE.Quat, LeaveTangent: UE.Quat, InterpMode: UE.EInterpCurveMode);
        InVal: number;
        OutVal: UE.Quat;
        ArriveTangent: UE.Quat;
        LeaveTangent: UE.Quat;
        InterpMode: UE.EInterpCurveMode;
        static StaticClass(): Class;
    }
    
    class InterpCurveQuat {
        constructor();
        constructor(Points: TArray<UE.InterpCurvePointQuat>, bIsLooped: boolean, LoopKeyOffset: number);
        Points: TArray<UE.InterpCurvePointQuat>;
        bIsLooped: boolean;
        LoopKeyOffset: number;
        static StaticClass(): Class;
    }
    
    class InterpCurvePointFloat {
        constructor();
        constructor(InVal: number, OutVal: number, ArriveTangent: number, LeaveTangent: number, InterpMode: UE.EInterpCurveMode);
        InVal: number;
        OutVal: number;
        ArriveTangent: number;
        LeaveTangent: number;
        InterpMode: UE.EInterpCurveMode;
        static StaticClass(): Class;
    }
    
    class InterpCurveFloat {
        constructor();
        constructor(Points: TArray<UE.InterpCurvePointFloat>, bIsLooped: boolean, LoopKeyOffset: number);
        Points: TArray<UE.InterpCurvePointFloat>;
        bIsLooped: boolean;
        LoopKeyOffset: number;
        static StaticClass(): Class;
    }
    
    class SplineMetadata extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SplineMetadata;
        static Load(InName: string): SplineMetadata;
    }
    
    class SplineCurves {
        constructor();
        constructor(Position: UE.InterpCurveVector, Rotation: UE.InterpCurveQuat, Scale: UE.InterpCurveVector, ReparamTable: UE.InterpCurveFloat, Metadata: UE.SplineMetadata);
        Position: UE.InterpCurveVector;
        Rotation: UE.InterpCurveQuat;
        Scale: UE.InterpCurveVector;
        ReparamTable: UE.InterpCurveFloat;
        Metadata: UE.SplineMetadata;
        static StaticClass(): Class;
    }
    
    enum ESplineCoordinateSpace { Local, World, ESplineCoordinateSpace_MAX}
    enum ESplinePointType { Linear, Curve, Constant, CurveClamped, CurveCustomTangent, ESplinePointType_MAX}
    class SplinePoint {
        constructor();
        constructor(InputKey: number, Position: UE.Vector, ArriveTangent: UE.Vector, LeaveTangent: UE.Vector, Rotation: UE.Rotator, Scale: UE.Vector, Type: UE.ESplinePointType);
        InputKey: number;
        Position: UE.Vector;
        ArriveTangent: UE.Vector;
        LeaveTangent: UE.Vector;
        Rotation: UE.Rotator;
        Scale: UE.Vector;
        Type: UE.ESplinePointType;
        static StaticClass(): Class;
    }
    
    class SplineComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SplineCurves: UE.SplineCurves;
        SplineInfo: UE.InterpCurveVector;
        SplineRotInfo: UE.InterpCurveQuat;
        SplineScaleInfo: UE.InterpCurveVector;
        SplineReparamTable: UE.InterpCurveFloat;
        bAllowSplineEditingPerInstance: boolean;
        ReparamStepsPerSegment: number;
        Duration: number;
        bStationaryEndpoints: boolean;
        bSplineHasBeenEdited: boolean;
        bModifiedByConstructionScript: boolean;
        bInputSplinePointsToConstructionScript: boolean;
        bDrawDebug: boolean;
        bClosedLoop: boolean;
        bLoopPositionOverride: boolean;
        LoopPosition: number;
        DefaultUpVector: UE.Vector;
        EditorUnselectedSplineSegmentColor: UE.LinearColor;
        EditorSelectedSplineSegmentColor: UE.LinearColor;
        bAllowDiscontinuousSpline: boolean;
        bShouldVisualizeScale: boolean;
        ScaleVisualizationWidth: number;
        AddPoint(Point: UE.SplinePoint, bUpdateSpline?: boolean /* = true */) : void;
        AddPoints(Points: TArray<UE.SplinePoint>, bUpdateSpline?: boolean /* = true */) : void;
        AddSplineLocalPoint(Position: UE.Vector) : void;
        AddSplinePoint(Position: UE.Vector, CoordinateSpace: UE.ESplineCoordinateSpace, bUpdateSpline?: boolean /* = true */) : void;
        AddSplinePointAtIndex(Position: UE.Vector, Index: number, CoordinateSpace: UE.ESplineCoordinateSpace, bUpdateSpline?: boolean /* = true */) : void;
        AddSplineWorldPoint(Position: UE.Vector) : void;
        ClearSplinePoints(bUpdateSpline?: boolean /* = true */) : void;
        FindDirectionClosestToWorldLocation(WorldLocation: UE.Vector, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        FindInputKeyClosestToWorldLocation(WorldLocation: UE.Vector) : number;
        FindLocationClosestToWorldLocation(WorldLocation: UE.Vector, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        FindRightVectorClosestToWorldLocation(WorldLocation: UE.Vector, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        FindRollClosestToWorldLocation(WorldLocation: UE.Vector, CoordinateSpace: UE.ESplineCoordinateSpace) : number;
        FindRotationClosestToWorldLocation(WorldLocation: UE.Vector, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Rotator;
        FindScaleClosestToWorldLocation(WorldLocation: UE.Vector) : UE.Vector;
        FindTangentClosestToWorldLocation(WorldLocation: UE.Vector, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        FindTransformClosestToWorldLocation(WorldLocation: UE.Vector, CoordinateSpace: UE.ESplineCoordinateSpace, bUseScale?: boolean /* = false */) : UE.Transform;
        FindUpVectorClosestToWorldLocation(WorldLocation: UE.Vector, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetArriveTangentAtSplinePoint(PointIndex: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetDefaultUpVector(CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetDirectionAtDistanceAlongSpline(Distance: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetDirectionAtSplineInputKey(InKey: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetDirectionAtSplinePoint(PointIndex: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetDirectionAtTime(Time: number, CoordinateSpace: UE.ESplineCoordinateSpace, bUseConstantVelocity?: boolean /* = false */) : UE.Vector;
        GetDistanceAlongSplineAtSplinePoint(PointIndex: number) : number;
        GetFloatPropertyAtSplineInputKey(InKey: number, PropertyName: string) : number;
        GetFloatPropertyAtSplinePoint(Index: number, PropertyName: string) : number;
        GetInputKeyAtDistanceAlongSpline(Distance: number) : number;
        GetLeaveTangentAtSplinePoint(PointIndex: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetLocalLocationAndTangentAtSplinePoint(PointIndex: number, LocalLocation: $Ref<UE.Vector>, LocalTangent: $Ref<UE.Vector>) : void;
        GetLocationAndTangentAtSplinePoint(PointIndex: number, Location: $Ref<UE.Vector>, Tangent: $Ref<UE.Vector>, CoordinateSpace: UE.ESplineCoordinateSpace) : void;
        GetLocationAtDistanceAlongSpline(Distance: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetLocationAtSplineInputKey(InKey: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetLocationAtSplinePoint(PointIndex: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetLocationAtTime(Time: number, CoordinateSpace: UE.ESplineCoordinateSpace, bUseConstantVelocity?: boolean /* = false */) : UE.Vector;
        GetNumberOfSplinePoints() : number;
        GetNumberOfSplineSegments() : number;
        GetRightVectorAtDistanceAlongSpline(Distance: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetRightVectorAtSplineInputKey(InKey: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetRightVectorAtSplinePoint(PointIndex: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetRightVectorAtTime(Time: number, CoordinateSpace: UE.ESplineCoordinateSpace, bUseConstantVelocity?: boolean /* = false */) : UE.Vector;
        GetRollAtDistanceAlongSpline(Distance: number, CoordinateSpace: UE.ESplineCoordinateSpace) : number;
        GetRollAtSplineInputKey(InKey: number, CoordinateSpace: UE.ESplineCoordinateSpace) : number;
        GetRollAtSplinePoint(PointIndex: number, CoordinateSpace: UE.ESplineCoordinateSpace) : number;
        GetRollAtTime(Time: number, CoordinateSpace: UE.ESplineCoordinateSpace, bUseConstantVelocity?: boolean /* = false */) : number;
        GetRotationAtDistanceAlongSpline(Distance: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Rotator;
        GetRotationAtSplineInputKey(InKey: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Rotator;
        GetRotationAtSplinePoint(PointIndex: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Rotator;
        GetRotationAtTime(Time: number, CoordinateSpace: UE.ESplineCoordinateSpace, bUseConstantVelocity?: boolean /* = false */) : UE.Rotator;
        GetScaleAtDistanceAlongSpline(Distance: number) : UE.Vector;
        GetScaleAtSplineInputKey(InKey: number) : UE.Vector;
        GetScaleAtSplinePoint(PointIndex: number) : UE.Vector;
        GetScaleAtTime(Time: number, bUseConstantVelocity?: boolean /* = false */) : UE.Vector;
        GetSplineLength() : number;
        GetSplinePointType(PointIndex: number) : UE.ESplinePointType;
        GetTangentAtDistanceAlongSpline(Distance: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetTangentAtSplineInputKey(InKey: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetTangentAtSplinePoint(PointIndex: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetTangentAtTime(Time: number, CoordinateSpace: UE.ESplineCoordinateSpace, bUseConstantVelocity?: boolean /* = false */) : UE.Vector;
        GetTransformAtDistanceAlongSpline(Distance: number, CoordinateSpace: UE.ESplineCoordinateSpace, bUseScale?: boolean /* = false */) : UE.Transform;
        GetTransformAtSplineInputKey(InKey: number, CoordinateSpace: UE.ESplineCoordinateSpace, bUseScale?: boolean /* = false */) : UE.Transform;
        GetTransformAtSplinePoint(PointIndex: number, CoordinateSpace: UE.ESplineCoordinateSpace, bUseScale?: boolean /* = false */) : UE.Transform;
        GetTransformAtTime(Time: number, CoordinateSpace: UE.ESplineCoordinateSpace, bUseConstantVelocity?: boolean /* = false */, bUseScale?: boolean /* = false */) : UE.Transform;
        GetUpVectorAtDistanceAlongSpline(Distance: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetUpVectorAtSplineInputKey(InKey: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetUpVectorAtSplinePoint(PointIndex: number, CoordinateSpace: UE.ESplineCoordinateSpace) : UE.Vector;
        GetUpVectorAtTime(Time: number, CoordinateSpace: UE.ESplineCoordinateSpace, bUseConstantVelocity?: boolean /* = false */) : UE.Vector;
        GetVectorPropertyAtSplineInputKey(InKey: number, PropertyName: string) : UE.Vector;
        GetVectorPropertyAtSplinePoint(Index: number, PropertyName: string) : UE.Vector;
        GetWorldDirectionAtDistanceAlongSpline(Distance: number) : UE.Vector;
        GetWorldDirectionAtTime(Time: number, bUseConstantVelocity?: boolean /* = false */) : UE.Vector;
        GetWorldLocationAtDistanceAlongSpline(Distance: number) : UE.Vector;
        GetWorldLocationAtSplinePoint(PointIndex: number) : UE.Vector;
        GetWorldLocationAtTime(Time: number, bUseConstantVelocity?: boolean /* = false */) : UE.Vector;
        GetWorldRotationAtDistanceAlongSpline(Distance: number) : UE.Rotator;
        GetWorldRotationAtTime(Time: number, bUseConstantVelocity?: boolean /* = false */) : UE.Rotator;
        GetWorldTangentAtDistanceAlongSpline(Distance: number) : UE.Vector;
        IsClosedLoop() : boolean;
        RemoveSplinePoint(Index: number, bUpdateSpline?: boolean /* = true */) : void;
        SetClosedLoop(bInClosedLoop: boolean, bUpdateSpline?: boolean /* = true */) : void;
        SetClosedLoopAtPosition(bInClosedLoop: boolean, Key: number, bUpdateSpline?: boolean /* = true */) : void;
        SetDefaultUpVector(UpVector: UE.Vector, CoordinateSpace: UE.ESplineCoordinateSpace) : void;
        SetDrawDebug(bShow: boolean) : void;
        SetLocationAtSplinePoint(PointIndex: number, InLocation: UE.Vector, CoordinateSpace: UE.ESplineCoordinateSpace, bUpdateSpline?: boolean /* = true */) : void;
        SetSelectedSplineSegmentColor(SegmentColor: UE.LinearColor) : void;
        SetSplineLocalPoints(Points: TArray<UE.Vector>) : void;
        SetSplinePoints(Points: TArray<UE.Vector>, CoordinateSpace: UE.ESplineCoordinateSpace, bUpdateSpline?: boolean /* = true */) : void;
        SetSplinePointType(PointIndex: number, Type: UE.ESplinePointType, bUpdateSpline?: boolean /* = true */) : void;
        SetSplineWorldPoints(Points: TArray<UE.Vector>) : void;
        SetTangentAtSplinePoint(PointIndex: number, InTangent: UE.Vector, CoordinateSpace: UE.ESplineCoordinateSpace, bUpdateSpline?: boolean /* = true */) : void;
        SetTangentsAtSplinePoint(PointIndex: number, InArriveTangent: UE.Vector, InLeaveTangent: UE.Vector, CoordinateSpace: UE.ESplineCoordinateSpace, bUpdateSpline?: boolean /* = true */) : void;
        SetUnselectedSplineSegmentColor(SegmentColor: UE.LinearColor) : void;
        SetUpVectorAtSplinePoint(PointIndex: number, InUpVector: UE.Vector, CoordinateSpace: UE.ESplineCoordinateSpace, bUpdateSpline?: boolean /* = true */) : void;
        SetWorldLocationAtSplinePoint(PointIndex: number, InLocation: UE.Vector) : void;
        UpdateSpline() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SplineComponent;
        static Load(InName: string): SplineComponent;
    }
    
    class SplineMeshParams {
        constructor();
        constructor(StartPos: UE.Vector, StartTangent: UE.Vector, StartScale: UE.Vector2D, StartRoll: number, StartOffset: UE.Vector2D, EndPos: UE.Vector, EndScale: UE.Vector2D, EndTangent: UE.Vector, EndRoll: number, EndOffset: UE.Vector2D);
        StartPos: UE.Vector;
        StartTangent: UE.Vector;
        StartScale: UE.Vector2D;
        StartRoll: number;
        StartOffset: UE.Vector2D;
        EndPos: UE.Vector;
        EndScale: UE.Vector2D;
        EndTangent: UE.Vector;
        EndRoll: number;
        EndOffset: UE.Vector2D;
        static StaticClass(): Class;
    }
    
    enum ESplineMeshAxis { X, Y, Z, ESplineMeshAxis_MAX}
    class SplineMeshComponent extends UE.StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SplineParams: UE.SplineMeshParams;
        SplineUpDir: UE.Vector;
        SplineBoundaryMin: number;
        CachedMeshBodySetupGuid: UE.Guid;
        BodySetup: UE.BodySetup;
        SplineBoundaryMax: number;
        bAllowSplineEditingPerInstance: boolean;
        bSmoothInterpRollScale: boolean;
        bMeshDirty: boolean;
        ForwardAxis: UE.ESplineMeshAxis;
        VirtualTextureMainPassMaxDrawDistance: number;
        bSelected: boolean;
        GetBoundaryMax() : number;
        GetBoundaryMin() : number;
        GetEndOffset() : UE.Vector2D;
        GetEndPosition() : UE.Vector;
        GetEndRoll() : number;
        GetEndScale() : UE.Vector2D;
        GetEndTangent() : UE.Vector;
        GetForwardAxis() : UE.ESplineMeshAxis;
        GetSplineUpDir() : UE.Vector;
        GetStartOffset() : UE.Vector2D;
        GetStartPosition() : UE.Vector;
        GetStartRoll() : number;
        GetStartScale() : UE.Vector2D;
        GetStartTangent() : UE.Vector;
        SetBoundaryMax(InBoundaryMax: number, bUpdateMesh?: boolean /* = true */) : void;
        SetBoundaryMin(InBoundaryMin: number, bUpdateMesh?: boolean /* = true */) : void;
        SetEndOffset(EndOffset: UE.Vector2D, bUpdateMesh?: boolean /* = true */) : void;
        SetEndPosition(EndPos: UE.Vector, bUpdateMesh?: boolean /* = true */) : void;
        SetEndRoll(EndRoll: number, bUpdateMesh?: boolean /* = true */) : void;
        SetEndScale(EndScale?: UE.Vector2D /* = (X=1.000,Y=1.000) */, bUpdateMesh?: boolean /* = true */) : void;
        SetEndTangent(EndTangent: UE.Vector, bUpdateMesh?: boolean /* = true */) : void;
        SetForwardAxis(InForwardAxis: UE.ESplineMeshAxis, bUpdateMesh?: boolean /* = true */) : void;
        SetSplineUpDir(InSplineUpDir: UE.Vector, bUpdateMesh?: boolean /* = true */) : void;
        SetStartAndEnd(StartPos: UE.Vector, StartTangent: UE.Vector, EndPos: UE.Vector, EndTangent: UE.Vector, bUpdateMesh?: boolean /* = true */) : void;
        SetStartOffset(StartOffset: UE.Vector2D, bUpdateMesh?: boolean /* = true */) : void;
        SetStartPosition(StartPos: UE.Vector, bUpdateMesh?: boolean /* = true */) : void;
        SetStartRoll(StartRoll: number, bUpdateMesh?: boolean /* = true */) : void;
        SetStartScale(StartScale?: UE.Vector2D /* = (X=1.000,Y=1.000) */, bUpdateMesh?: boolean /* = true */) : void;
        SetStartTangent(StartTangent: UE.Vector, bUpdateMesh?: boolean /* = true */) : void;
        UpdateMesh() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SplineMeshComponent;
        static Load(InName: string): SplineMeshComponent;
    }
    
    class CameraRig_Rail extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurrentPositionOnRail: number;
        bLockOrientationToRail: boolean;
        bShowRailVisualization: boolean;
        PreviewMeshScale: number;
        TransformComponent: UE.SceneComponent;
        RailSplineComponent: UE.SplineComponent;
        RailCameraMount: UE.SceneComponent;
        PreviewMesh_Rail: UE.SplineMeshComponent;
        PreviewRailMeshSegments: TArray<UE.SplineMeshComponent>;
        PreviewRailStaticMesh: UE.StaticMesh;
        PreviewMesh_Mount: UE.StaticMeshComponent;
        GetRailSplineComponent() : UE.SplineComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraRig_Rail;
        static Load(InName: string): CameraRig_Rail;
    }
    
    class AnchorData {
        constructor();
        constructor(Offsets: UE.Margin, Anchors: UE.Anchors, Alignment: UE.Vector2D);
        Offsets: UE.Margin;
        Anchors: UE.Anchors;
        Alignment: UE.Vector2D;
        static StaticClass(): Class;
    }
    
    class CanvasPanelSlot extends UE.PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LayoutData: UE.AnchorData;
        bAutoSize: boolean;
        ZOrder: number;
        GetAlignment() : UE.Vector2D;
        GetAnchors() : UE.Anchors;
        GetAutoSize() : boolean;
        GetLayout() : UE.AnchorData;
        GetOffsets() : UE.Margin;
        GetPosition() : UE.Vector2D;
        GetSize() : UE.Vector2D;
        GetZOrder() : number;
        SetAlignment(InAlignment: UE.Vector2D) : void;
        SetAnchors(InAnchors: UE.Anchors) : void;
        SetAutoSize(InbAutoSize: boolean) : void;
        SetLayout(InLayoutData: UE.AnchorData) : void;
        SetMaximum(InMaximumAnchors: UE.Vector2D) : void;
        SetMinimum(InMinimumAnchors: UE.Vector2D) : void;
        SetOffsets(InOffset: UE.Margin) : void;
        SetPosition(InPosition: UE.Vector2D) : void;
        SetSize(InSize: UE.Vector2D) : void;
        SetZOrder(InZOrder: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CanvasPanelSlot;
        static Load(InName: string): CanvasPanelSlot;
    }
    
    class CanvasPanel extends UE.PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddChildToCanvas(Content: $Nullable<UE.Widget>) : UE.CanvasPanelSlot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CanvasPanel;
        static Load(InName: string): CanvasPanel;
    }
    
    class TextureRenderTarget extends UE.Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetGamma: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureRenderTarget;
        static Load(InName: string): TextureRenderTarget;
    }
    
    enum ETextureRenderTargetFormat { RTF_R8, RTF_RG8, RTF_RGBA8, RTF_RGBA8_SRGB, RTF_R16f, RTF_RG16f, RTF_RGBA16f, RTF_R32f, RTF_RG32f, RTF_RGBA32f, RTF_RGB10A2, RTF_MAX}
    class TextureRenderTarget2D extends UE.TextureRenderTarget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SizeX: number;
        SizeY: number;
        ClearColor: UE.LinearColor;
        AddressX: UE.TextureAddress;
        AddressY: UE.TextureAddress;
        bForceLinearGamma: boolean;
        bHDR: boolean;
        bGPUSharedFlag: boolean;
        RenderTargetFormat: UE.ETextureRenderTargetFormat;
        bAutoGenerateMips: boolean;
        MipsSamplerFilter: UE.TextureFilter;
        MipsAddressU: UE.TextureAddress;
        MipsAddressV: UE.TextureAddress;
        OverrideFormat: UE.EPixelFormat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureRenderTarget2D;
        static Load(InName: string): TextureRenderTarget2D;
    }
    
    class CanvasRenderTarget2D extends UE.TextureRenderTarget2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnCanvasRenderTargetUpdate: $MulticastDelegate<(Canvas: $Nullable<UE.Canvas>, Width: number, Height: number) => void>;
        World: TWeakObjectPtr<UE.World>;
        bShouldClearRenderTargetOnReceiveUpdate: boolean;
        GetSize(Width: $Ref<number>, Height: $Ref<number>) : void;
        ReceiveUpdate(Canvas: $Nullable<UE.Canvas>, Width: number, Height: number) : void;
        UpdateResource() : void;
        static CreateCanvasRenderTarget2D(WorldContextObject: $Nullable<UE.Object>, CanvasRenderTarget2DClass: $Nullable<UE.Class>, Width?: number /* = 1024 */, Height?: number /* = 1024 */) : UE.CanvasRenderTarget2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CanvasRenderTarget2D;
        static Load(InName: string): CanvasRenderTarget2D;
    }
    
    class CanvasRenderTarget2DFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Width: number;
        Height: number;
        Format: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CanvasRenderTarget2DFactoryNew;
        static Load(InName: string): CanvasRenderTarget2DFactoryNew;
    }
    
    class CascadeOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bShowModuleDump: boolean;
        BackgroundColor: UE.Color;
        bUseSubMenus: boolean;
        bUseSpaceBarReset: boolean;
        bUseSpaceBarResetInLevel: boolean;
        Empty_Background: UE.Color;
        Emitter_Background: UE.Color;
        Emitter_Unselected: UE.Color;
        Emitter_Selected: UE.Color;
        ModuleColor_General_Unselected: UE.Color;
        ModuleColor_General_Selected: UE.Color;
        ModuleColor_TypeData_Unselected: UE.Color;
        ModuleColor_TypeData_Selected: UE.Color;
        ModuleColor_Beam_Unselected: UE.Color;
        ModuleColor_Beam_Selected: UE.Color;
        ModuleColor_Trail_Unselected: UE.Color;
        ModuleColor_Trail_Selected: UE.Color;
        ModuleColor_Spawn_Unselected: UE.Color;
        ModuleColor_Spawn_Selected: UE.Color;
        ModuleColor_Light_Unselected: UE.Color;
        ModuleColor_Light_Selected: UE.Color;
        ModuleColor_SubUV_Unselected: UE.Color;
        ModuleColor_SubUV_Selected: UE.Color;
        ModuleColor_Required_Unselected: UE.Color;
        ModuleColor_Required_Selected: UE.Color;
        ModuleColor_Event_Unselected: UE.Color;
        ModuleColor_Event_Selected: UE.Color;
        bShowGrid: boolean;
        GridColor_Hi: UE.Color;
        GridColor_Low: UE.Color;
        GridPerspectiveSize: number;
        bShowParticleCounts: boolean;
        bShowParticleEvents: boolean;
        bShowParticleTimes: boolean;
        bShowParticleDistance: boolean;
        bShowParticleMemory: boolean;
        ParticleMemoryUpdateTime: number;
        bShowFloor: boolean;
        FloorMesh: string;
        FloorPosition: UE.Vector;
        FloorRotation: UE.Rotator;
        FloorScale: number;
        FloorScale3D: UE.Vector;
        ShowPPFlags: number;
        bUseSlimCascadeDraw: boolean;
        SlimCascadeDrawHeight: number;
        bCenterCascadeModuleText: boolean;
        Cascade_MouseMoveThreshold: number;
        MotionModeRadius: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CascadeOptions;
        static Load(InName: string): CascadeOptions;
    }
    
    class ChaosDebugDrawComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosDebugDrawComponent;
        static Load(InName: string): ChaosDebugDrawComponent;
    }
    
    enum EChaosCollisionSortMethod { SortNone, SortByHighestMass, SortByHighestSpeed, SortByHighestImpulse, SortByNearestFirst, Count, EChaosCollisionSortMethod_MAX}
    class ChaosCollisionEventRequestSettings {
        constructor();
        constructor(MaxNumberResults: number, MinMass: number, MinSpeed: number, MinImpulse: number, MaxDistance: number, SortMethod: UE.EChaosCollisionSortMethod);
        MaxNumberResults: number;
        MinMass: number;
        MinSpeed: number;
        MinImpulse: number;
        MaxDistance: number;
        SortMethod: UE.EChaosCollisionSortMethod;
        static StaticClass(): Class;
    }
    
    enum EChaosBreakingSortMethod { SortNone, SortByHighestMass, SortByHighestSpeed, SortByNearestFirst, Count, EChaosBreakingSortMethod_MAX}
    class ChaosBreakingEventRequestSettings {
        constructor();
        constructor(MaxNumberOfResults: number, MinRadius: number, MinSpeed: number, MinMass: number, MaxDistance: number, SortMethod: UE.EChaosBreakingSortMethod);
        MaxNumberOfResults: number;
        MinRadius: number;
        MinSpeed: number;
        MinMass: number;
        MaxDistance: number;
        SortMethod: UE.EChaosBreakingSortMethod;
        static StaticClass(): Class;
    }
    
    enum EChaosTrailingSortMethod { SortNone, SortByHighestMass, SortByHighestSpeed, SortByNearestFirst, Count, EChaosTrailingSortMethod_MAX}
    class ChaosTrailingEventRequestSettings {
        constructor();
        constructor(MaxNumberOfResults: number, MinMass: number, MinSpeed: number, MinAngularSpeed: number, MaxDistance: number, SortMethod: UE.EChaosTrailingSortMethod);
        MaxNumberOfResults: number;
        MinMass: number;
        MinSpeed: number;
        MinAngularSpeed: number;
        MaxDistance: number;
        SortMethod: UE.EChaosTrailingSortMethod;
        static StaticClass(): Class;
    }
    
    enum EClusterConnectionTypeEnum { Chaos_PointImplicit, Chaos_DelaunayTriangulation, Chaos_MinimalSpanningSubsetDelaunayTriangulation, Chaos_PointImplicitAugmentedWithMinimalDelaunay, Chaos_None, Chaos_EClsuterCreationParameters_Max, Chaos_MAX}
    class SolverCollisionFilterSettings {
        constructor();
        constructor(FilterEnabled: boolean, MinMass: number, MinSpeed: number, MinImpulse: number);
        FilterEnabled: boolean;
        MinMass: number;
        MinSpeed: number;
        MinImpulse: number;
        static StaticClass(): Class;
    }
    
    class SolverBreakingFilterSettings {
        constructor();
        constructor(FilterEnabled: boolean, MinMass: number, MinSpeed: number, MinVolume: number);
        FilterEnabled: boolean;
        MinMass: number;
        MinSpeed: number;
        MinVolume: number;
        static StaticClass(): Class;
    }
    
    class SolverTrailingFilterSettings {
        constructor();
        constructor(FilterEnabled: boolean, MinMass: number, MinSpeed: number, MinVolume: number);
        FilterEnabled: boolean;
        MinMass: number;
        MinSpeed: number;
        MinVolume: number;
        static StaticClass(): Class;
    }
    
    class ChaosDebugSubstepControl {
        constructor();
        constructor(bPause: boolean, bSubstep: boolean, bStep: boolean);
        bPause: boolean;
        bSubstep: boolean;
        bStep: boolean;
        static StaticClass(): Class;
    }
    
    class ChaosEventListenerComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosEventListenerComponent;
        static Load(InName: string): ChaosEventListenerComponent;
    }
    
    class ChaosHandlerSet {
        constructor();
        constructor(ChaosHandlers: TSet<UE.Object>);
        ChaosHandlers: TSet<UE.Object>;
        static StaticClass(): Class;
    }
    
    class BreakEventCallbackWrapper {
        constructor();
        static StaticClass(): Class;
    }
    
    class ChaosGameplayEventDispatcher extends UE.ChaosEventListenerComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CollisionEventRegistrations: TMap<UE.PrimitiveComponent, UE.ChaosHandlerSet>;
        BreakEventRegistrations: TMap<UE.PrimitiveComponent, UE.BreakEventCallbackWrapper>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosGameplayEventDispatcher;
        static Load(InName: string): ChaosGameplayEventDispatcher;
    }
    
    class ChaosSolverActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TimeStepMultiplier: number;
        CollisionIterations: number;
        PushOutIterations: number;
        PushOutPairIterations: number;
        ClusterConnectionFactor: number;
        ClusterUnionConnectionType: UE.EClusterConnectionTypeEnum;
        DoGenerateCollisionData: boolean;
        CollisionFilterSettings: UE.SolverCollisionFilterSettings;
        DoGenerateBreakingData: boolean;
        BreakingFilterSettings: UE.SolverBreakingFilterSettings;
        DoGenerateTrailingData: boolean;
        TrailingFilterSettings: UE.SolverTrailingFilterSettings;
        bHasFloor: boolean;
        FloorHeight: number;
        MassScale: number;
        ChaosDebugSubstepControl: UE.ChaosDebugSubstepControl;
        SpriteComponent: UE.BillboardComponent;
        GameplayEventDispatcherComponent: UE.ChaosGameplayEventDispatcher;
        SetAsCurrentWorldSolver() : void;
        SetSolverActive(bActive: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosSolverActor;
        static Load(InName: string): ChaosSolverActor;
    }
    
    enum ECollisionTypeEnum { Chaos_Volumetric, Chaos_Surface_Volumetric, Chaos_Max, Chaos_MAX}
    enum EImplicitTypeEnum { Chaos_Implicit_Box, Chaos_Implicit_Sphere, Chaos_Implicit_Capsule, Chaos_Implicit_LevelSet, Chaos_Implicit_None, Chaos_Max, Chaos_MAX}
    class GeometryCollectionSizeSpecificData {
        constructor();
        constructor(MaxSize: number, CollisionType: UE.ECollisionTypeEnum, ImplicitType: UE.EImplicitTypeEnum, MinLevelSetResolution: number, MaxLevelSetResolution: number, MinClusterLevelSetResolution: number, MaxClusterLevelSetResolution: number, CollisionObjectReductionPercentage: number, CollisionParticlesFraction: number, MaximumCollisionParticles: number);
        MaxSize: number;
        CollisionType: UE.ECollisionTypeEnum;
        ImplicitType: UE.EImplicitTypeEnum;
        MinLevelSetResolution: number;
        MaxLevelSetResolution: number;
        MinClusterLevelSetResolution: number;
        MaxClusterLevelSetResolution: number;
        CollisionObjectReductionPercentage: number;
        CollisionParticlesFraction: number;
        MaximumCollisionParticles: number;
        static StaticClass(): Class;
    }
    
    class GeometryCollection extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Materials: TArray<UE.MaterialInterface>;
        CollisionType: UE.ECollisionTypeEnum;
        ImplicitType: UE.EImplicitTypeEnum;
        MinLevelSetResolution: number;
        MaxLevelSetResolution: number;
        MinClusterLevelSetResolution: number;
        MaxClusterLevelSetResolution: number;
        CollisionObjectReductionPercentage: number;
        bMassAsDensity: boolean;
        Mass: number;
        MinimumMassClamp: number;
        CollisionParticlesFraction: number;
        MaximumCollisionParticles: number;
        SizeSpecificData: TArray<UE.GeometryCollectionSizeSpecificData>;
        EnableRemovePiecesOnFracture: boolean;
        RemoveOnFractureMaterials: TArray<UE.MaterialInterface>;
        ThumbnailInfo: UE.ThumbnailInfo;
        PersistentGuid: UE.Guid;
        StateGuid: UE.Guid;
        BoneSelectedMaterialIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCollection;
        static Load(InName: string): GeometryCollection;
    }
    
    class FieldSystem extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldSystem;
        static Load(InName: string): FieldSystem;
    }
    
    enum EFieldPhysicsType { Field_None, Field_DynamicState, Field_LinearForce, Field_ExternalClusterStrain, Field_Kill, Field_LinearVelocity, Field_AngularVelociy, Field_AngularTorque, Field_InternalClusterStrain, Field_DisableThreshold, Field_SleepingThreshold, Field_PositionStatic, Field_PositionAnimated, Field_PositionTarget, Field_DynamicConstraint, Field_CollisionGroup, Field_ActivateDisabled, Field_PhysicsType_Max}
    class FieldSystemMetaData extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldSystemMetaData;
        static Load(InName: string): FieldSystemMetaData;
    }
    
    class FieldSystemComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FieldSystem: UE.FieldSystem;
        SupportedSolvers: TArray<TSoftObjectPtr<UE.ChaosSolverActor>>;
        AddFieldCommand(Enabled: boolean, Target: UE.EFieldPhysicsType, MetaData: $Nullable<UE.FieldSystemMetaData>, Field: $Nullable<UE.FieldNodeBase>) : void;
        ApplyLinearForce(Enabled: boolean, Direction: UE.Vector, Magnitude: number) : void;
        ApplyPhysicsField(Enabled: boolean, Target: UE.EFieldPhysicsType, MetaData: $Nullable<UE.FieldSystemMetaData>, Field: $Nullable<UE.FieldNodeBase>) : void;
        ApplyRadialForce(Enabled: boolean, Position: UE.Vector, Magnitude: number) : void;
        ApplyRadialVectorFalloffForce(Enabled: boolean, Position: UE.Vector, Radius: number, Magnitude: number) : void;
        ApplyStayDynamicField(Enabled: boolean, Position: UE.Vector, Radius: number) : void;
        ApplyStrainField(Enabled: boolean, Position: UE.Vector, Radius: number, Magnitude: number, Iterations: number) : void;
        ApplyUniformVectorFalloffForce(Enabled: boolean, Position: UE.Vector, Direction: UE.Vector, Radius: number, Magnitude: number) : void;
        ResetFieldSystem() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldSystemComponent;
        static Load(InName: string): FieldSystemComponent;
    }
    
    class FieldSystemActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FieldSystemComponent: UE.FieldSystemComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldSystemActor;
        static Load(InName: string): FieldSystemActor;
    }
    
    enum EObjectStateTypeEnum { Chaos_NONE, Chaos_Object_Sleeping, Chaos_Object_Kinematic, Chaos_Object_Static, Chaos_Object_Dynamic, Chaos_Object_UserDefined, Chaos_Max, Chaos_MAX}
    class ChaosPhysicalMaterial extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Friction: number;
        Restitution: number;
        SleepingLinearVelocityThreshold: number;
        SleepingAngularVelocityThreshold: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosPhysicalMaterial;
        static Load(InName: string): ChaosPhysicalMaterial;
    }
    
    enum EInitialVelocityTypeEnum { Chaos_Initial_Velocity_User_Defined, Chaos_Initial_Velocity_None, Chaos_Max, Chaos_MAX}
    enum EGeometryCollectionCacheType { None, Record, Play, RecordAndPlay, EGeometryCollectionCacheType_MAX}
    class SolverCollisionData {
        constructor();
        constructor(Location: UE.Vector, AccumulatedImpulse: UE.Vector, Normal: UE.Vector, Velocity1: UE.Vector, Velocity2: UE.Vector, AngularVelocity1: UE.Vector, AngularVelocity2: UE.Vector, Mass1: number, Mass2: number, ParticleIndex: number, LevelsetIndex: number, ParticleIndexMesh: number, LevelsetIndexMesh: number);
        Location: UE.Vector;
        AccumulatedImpulse: UE.Vector;
        Normal: UE.Vector;
        Velocity1: UE.Vector;
        Velocity2: UE.Vector;
        AngularVelocity1: UE.Vector;
        AngularVelocity2: UE.Vector;
        Mass1: number;
        Mass2: number;
        ParticleIndex: number;
        LevelsetIndex: number;
        ParticleIndexMesh: number;
        LevelsetIndexMesh: number;
        static StaticClass(): Class;
    }
    
    class SolverBreakingData {
        constructor();
        constructor(Location: UE.Vector, Velocity: UE.Vector, AngularVelocity: UE.Vector, Mass: number, ParticleIndex: number, ParticleIndexMesh: number);
        Location: UE.Vector;
        Velocity: UE.Vector;
        AngularVelocity: UE.Vector;
        Mass: number;
        ParticleIndex: number;
        ParticleIndexMesh: number;
        static StaticClass(): Class;
    }
    
    class SolverTrailingData {
        constructor();
        constructor(Location: UE.Vector, Velocity: UE.Vector, AngularVelocity: UE.Vector, Mass: number, ParticleIndex: number, ParticleIndexMesh: number);
        Location: UE.Vector;
        Velocity: UE.Vector;
        AngularVelocity: UE.Vector;
        Mass: number;
        ParticleIndex: number;
        ParticleIndexMesh: number;
        static StaticClass(): Class;
    }
    
    class RecordedFrame {
        constructor();
        constructor(Transforms: TArray<UE.Transform>, TransformIndices: TArray<number>, PreviousTransformIndices: TArray<number>, DisabledFlags: TArray<boolean>, Collisions: TArray<UE.SolverCollisionData>, Breakings: TArray<UE.SolverBreakingData>, Trailings: TSet<UE.SolverTrailingData>, Timestamp: number);
        Transforms: TArray<UE.Transform>;
        TransformIndices: TArray<number>;
        PreviousTransformIndices: TArray<number>;
        DisabledFlags: TArray<boolean>;
        Collisions: TArray<UE.SolverCollisionData>;
        Breakings: TArray<UE.SolverBreakingData>;
        Trailings: TSet<UE.SolverTrailingData>;
        Timestamp: number;
        static StaticClass(): Class;
    }
    
    class RecordedTransformTrack {
        constructor();
        constructor(Records: TArray<UE.RecordedFrame>);
        Records: TArray<UE.RecordedFrame>;
        static StaticClass(): Class;
    }
    
    class GeometryCollectionCache extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RecordedData: UE.RecordedTransformTrack;
        SupportedCollection: UE.GeometryCollection;
        CompatibleCollectionState: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCollectionCache;
        static Load(InName: string): GeometryCollectionCache;
    }
    
    class GeomComponentCacheParameters {
        constructor();
        constructor(CacheMode: UE.EGeometryCollectionCacheType, TargetCache: UE.GeometryCollectionCache, ReverseCacheBeginTime: number, SaveCollisionData: boolean, DoGenerateCollisionData: boolean, CollisionDataSizeMax: number, DoCollisionDataSpatialHash: boolean, CollisionDataSpatialHashRadius: number, MaxCollisionPerCell: number, SaveBreakingData: boolean, DoGenerateBreakingData: boolean, BreakingDataSizeMax: number, DoBreakingDataSpatialHash: boolean, BreakingDataSpatialHashRadius: number, MaxBreakingPerCell: number, SaveTrailingData: boolean, DoGenerateTrailingData: boolean, TrailingDataSizeMax: number, TrailingMinSpeedThreshold: number, TrailingMinVolumeThreshold: number);
        CacheMode: UE.EGeometryCollectionCacheType;
        TargetCache: UE.GeometryCollectionCache;
        ReverseCacheBeginTime: number;
        SaveCollisionData: boolean;
        DoGenerateCollisionData: boolean;
        CollisionDataSizeMax: number;
        DoCollisionDataSpatialHash: boolean;
        CollisionDataSpatialHashRadius: number;
        MaxCollisionPerCell: number;
        SaveBreakingData: boolean;
        DoGenerateBreakingData: boolean;
        BreakingDataSizeMax: number;
        DoBreakingDataSpatialHash: boolean;
        BreakingDataSpatialHashRadius: number;
        MaxBreakingPerCell: number;
        SaveTrailingData: boolean;
        DoGenerateTrailingData: boolean;
        TrailingDataSizeMax: number;
        TrailingMinSpeedThreshold: number;
        TrailingMinVolumeThreshold: number;
        static StaticClass(): Class;
    }
    
    class ChaosBreakEvent {
        constructor();
        constructor(Component: UE.PrimitiveComponent, Location: UE.Vector, Velocity: UE.Vector, AngularVelocity: UE.Vector, Mass: number);
        Component: UE.PrimitiveComponent;
        Location: UE.Vector;
        Velocity: UE.Vector;
        AngularVelocity: UE.Vector;
        Mass: number;
        static StaticClass(): Class;
    }
    
    class ChaosPhysicsCollisionInfo {
        constructor();
        constructor(Component: UE.PrimitiveComponent, OtherComponent: UE.PrimitiveComponent, Location: UE.Vector, Normal: UE.Vector, AccumulatedImpulse: UE.Vector, Velocity: UE.Vector, OtherVelocity: UE.Vector, AngularVelocity: UE.Vector, OtherAngularVelocity: UE.Vector, Mass: number, OtherMass: number);
        Component: UE.PrimitiveComponent;
        OtherComponent: UE.PrimitiveComponent;
        Location: UE.Vector;
        Normal: UE.Vector;
        AccumulatedImpulse: UE.Vector;
        Velocity: UE.Vector;
        OtherVelocity: UE.Vector;
        AngularVelocity: UE.Vector;
        OtherAngularVelocity: UE.Vector;
        Mass: number;
        OtherMass: number;
        static StaticClass(): Class;
    }
    
    enum EGeometryCollectionPhysicsTypeEnum { Chaos_AngularVelocity, Chaos_DynamicState, Chaos_LinearVelocity, Chaos_InitialAngularVelocity, Chaos_InitialLinearVelocity, Chaos_CollisionGroup, Chaos_LinearForce, Chaos_AngularTorque, Chaos_Max, Chaos_MAX}
    class GeometryCollectionComponent extends UE.MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChaosSolverActor: UE.ChaosSolverActor;
        RestCollection: UE.GeometryCollection;
        InitializationFields: TArray<UE.FieldSystemActor>;
        Simulating: boolean;
        ObjectType: UE.EObjectStateTypeEnum;
        EnableClustering: boolean;
        ClusterGroupIndex: number;
        MaxClusterLevel: number;
        DamageThreshold: TArray<number>;
        ClusterConnectionType: UE.EClusterConnectionTypeEnum;
        CollisionGroup: number;
        CollisionSampleFraction: number;
        PhysicalMaterial: UE.ChaosPhysicalMaterial;
        InitialVelocityType: UE.EInitialVelocityTypeEnum;
        InitialLinearVelocity: UE.Vector;
        InitialAngularVelocity: UE.Vector;
        CacheParameters: UE.GeomComponentCacheParameters;
        NotifyGeometryCollectionPhysicsStateChange: $MulticastDelegate<(FracturedComponent: $Nullable<UE.GeometryCollectionComponent>) => void>;
        NotifyGeometryCollectionPhysicsLoadingStateChange: $MulticastDelegate<(FracturedComponent: $Nullable<UE.GeometryCollectionComponent>) => void>;
        OnChaosBreakEvent: $MulticastDelegate<(BreakEvent: UE.ChaosBreakEvent) => void>;
        DesiredCacheTime: number;
        CachePlayback: boolean;
        OnChaosPhysicsCollision: $MulticastDelegate<(CollisionInfo: UE.ChaosPhysicsCollisionInfo) => void>;
        bNotifyBreaks: boolean;
        bNotifyCollisions: boolean;
        SelectedBones: TArray<number>;
        HighlightedBones: TArray<number>;
        DummyBodySetup: UE.BodySetup;
        EditorActor: UE.Actor;
        ApplyKinematicField(Radius: number, Position: UE.Vector) : void;
        ApplyPhysicsField(Enabled: boolean, Target: UE.EGeometryCollectionPhysicsTypeEnum, MetaData: $Nullable<UE.FieldSystemMetaData>, Field: $Nullable<UE.FieldNodeBase>) : void;
        NotifyGeometryCollectionPhysicsLoadingStateChange__DelegateSignature(FracturedComponent: $Nullable<UE.GeometryCollectionComponent>) : void;
        NotifyGeometryCollectionPhysicsStateChange__DelegateSignature(FracturedComponent: $Nullable<UE.GeometryCollectionComponent>) : void;
        ReceivePhysicsCollision(CollisionInfo: UE.ChaosPhysicsCollisionInfo) : void;
        SetNotifyBreaks(bNewNotifyBreaks: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCollectionComponent;
        static Load(InName: string): GeometryCollectionComponent;
    }
    
    class GeometryCollectionDebugDrawWarningMessage {
        constructor();
        static StaticClass(): Class;
    }
    
    class GeometryCollectionDebugDrawActorSelectedRigidBody {
        constructor();
        constructor(Id: number, Solver: UE.ChaosSolverActor, GeometryCollection: UE.GeometryCollectionActor);
        Id: number;
        Solver: UE.ChaosSolverActor;
        GeometryCollection: UE.GeometryCollectionActor;
        static StaticClass(): Class;
    }
    
    enum EGeometryCollectionDebugDrawActorHideGeometry { HideNone, HideWithCollision, HideSelected, HideWholeCollection, HideAll, EGeometryCollectionDebugDrawActorHideGeometry_MAX}
    class GeometryCollectionDebugDrawActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WarningMessage: UE.GeometryCollectionDebugDrawWarningMessage;
        SelectedRigidBody: UE.GeometryCollectionDebugDrawActorSelectedRigidBody;
        bDebugDrawWholeCollection: boolean;
        bDebugDrawHierarchy: boolean;
        bDebugDrawClustering: boolean;
        HideGeometry: UE.EGeometryCollectionDebugDrawActorHideGeometry;
        bShowRigidBodyId: boolean;
        bShowRigidBodyCollision: boolean;
        bCollisionAtOrigin: boolean;
        bShowRigidBodyTransform: boolean;
        bShowRigidBodyInertia: boolean;
        bShowRigidBodyVelocity: boolean;
        bShowRigidBodyForce: boolean;
        bShowRigidBodyInfos: boolean;
        bShowTransformIndex: boolean;
        bShowTransform: boolean;
        bShowParent: boolean;
        bShowLevel: boolean;
        bShowConnectivityEdges: boolean;
        bShowGeometryIndex: boolean;
        bShowGeometryTransform: boolean;
        bShowBoundingBox: boolean;
        bShowFaces: boolean;
        bShowFaceIndices: boolean;
        bShowFaceNormals: boolean;
        bShowSingleFace: boolean;
        SingleFaceIndex: number;
        bShowVertices: boolean;
        bShowVertexIndices: boolean;
        bShowVertexNormals: boolean;
        bUseActiveVisualization: boolean;
        PointThickness: number;
        LineThickness: number;
        bTextShadow: boolean;
        TextScale: number;
        NormalScale: number;
        AxisScale: number;
        ArrowScale: number;
        RigidBodyIdColor: UE.Color;
        RigidBodyTransformScale: number;
        RigidBodyCollisionColor: UE.Color;
        RigidBodyInertiaColor: UE.Color;
        RigidBodyVelocityColor: UE.Color;
        RigidBodyForceColor: UE.Color;
        RigidBodyInfoColor: UE.Color;
        TransformIndexColor: UE.Color;
        TransformScale: number;
        LevelColor: UE.Color;
        ParentColor: UE.Color;
        ConnectivityEdgeThickness: number;
        GeometryIndexColor: UE.Color;
        GeometryTransformScale: number;
        BoundingBoxColor: UE.Color;
        FaceColor: UE.Color;
        FaceIndexColor: UE.Color;
        FaceNormalColor: UE.Color;
        SingleFaceColor: UE.Color;
        VertexColor: UE.Color;
        VertexIndexColor: UE.Color;
        VertexNormalColor: UE.Color;
        SpriteComponent: UE.BillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCollectionDebugDrawActor;
        static Load(InName: string): GeometryCollectionDebugDrawActor;
    }
    
    class VolumeTexture extends UE.Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Source2DTexture: UE.Texture2D;
        SourceLightingGuid: UE.Guid;
        Source2DTileSizeX: number;
        Source2DTileSizeY: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VolumeTexture;
        static Load(InName: string): VolumeTexture;
    }
    
    class GeometryCollectionRenderLevelSetActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetVolumeTexture: UE.VolumeTexture;
        RayMarchMaterial: UE.Material;
        SurfaceTolerance: number;
        Isovalue: number;
        Enabled: boolean;
        RenderVolumeBoundingBox: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCollectionRenderLevelSetActor;
        static Load(InName: string): GeometryCollectionRenderLevelSetActor;
    }
    
    class GeometryCollectionDebugDrawComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GeometryCollectionDebugDrawActor: UE.GeometryCollectionDebugDrawActor;
        GeometryCollectionRenderLevelSetActor: UE.GeometryCollectionRenderLevelSetActor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCollectionDebugDrawComponent;
        static Load(InName: string): GeometryCollectionDebugDrawComponent;
    }
    
    class GeometryCollectionActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GeometryCollectionComponent: UE.GeometryCollectionComponent;
        GeometryCollectionDebugDrawComponent: UE.GeometryCollectionDebugDrawComponent;
        RaycastSingle(Start: UE.Vector, End: UE.Vector, OutHit: $Ref<UE.HitResult>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCollectionActor;
        static Load(InName: string): GeometryCollectionActor;
    }
    
    class ChaosCollisionEventData {
        constructor();
        constructor(Location: UE.Vector, Normal: UE.Vector, Velocity1: UE.Vector, Velocity2: UE.Vector, Mass1: number, Mass2: number, Impulse: UE.Vector);
        Location: UE.Vector;
        Normal: UE.Vector;
        Velocity1: UE.Vector;
        Velocity2: UE.Vector;
        Mass1: number;
        Mass2: number;
        Impulse: UE.Vector;
        static StaticClass(): Class;
    }
    
    class ChaosBreakingEventData {
        constructor();
        constructor(Location: UE.Vector, Velocity: UE.Vector, Mass: number, ParticleIndex: number);
        Location: UE.Vector;
        Velocity: UE.Vector;
        Mass: number;
        ParticleIndex: number;
        static StaticClass(): Class;
    }
    
    class ChaosTrailingEventData {
        constructor();
        constructor(Location: UE.Vector, Velocity: UE.Vector, AngularVelocity: UE.Vector, Mass: number, ParticleIndex: number);
        Location: UE.Vector;
        Velocity: UE.Vector;
        AngularVelocity: UE.Vector;
        Mass: number;
        ParticleIndex: number;
        static StaticClass(): Class;
    }
    
    class ChaosDestructionListener extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsCollisionEventListeningEnabled: boolean;
        bIsBreakingEventListeningEnabled: boolean;
        bIsTrailingEventListeningEnabled: boolean;
        CollisionEventRequestSettings: UE.ChaosCollisionEventRequestSettings;
        BreakingEventRequestSettings: UE.ChaosBreakingEventRequestSettings;
        TrailingEventRequestSettings: UE.ChaosTrailingEventRequestSettings;
        ChaosSolverActors: TSet<UE.ChaosSolverActor>;
        GeometryCollectionActors: TSet<UE.GeometryCollectionActor>;
        OnCollisionEvents: $MulticastDelegate<(CollisionEvents: TArray<UE.ChaosCollisionEventData>) => void>;
        OnBreakingEvents: $MulticastDelegate<(BreakingEvents: TArray<UE.ChaosBreakingEventData>) => void>;
        OnTrailingEvents: $MulticastDelegate<(TrailingEvents: TArray<UE.ChaosTrailingEventData>) => void>;
        AddChaosSolverActor(ChaosSolverActor: $Nullable<UE.ChaosSolverActor>) : void;
        AddGeometryCollectionActor(GeometryCollectionActor: $Nullable<UE.GeometryCollectionActor>) : void;
        IsEventListening() : boolean;
        RemoveChaosSolverActor(ChaosSolverActor: $Nullable<UE.ChaosSolverActor>) : void;
        RemoveGeometryCollectionActor(GeometryCollectionActor: $Nullable<UE.GeometryCollectionActor>) : void;
        SetBreakingEventEnabled(bIsEnabled: boolean) : void;
        SetBreakingEventRequestSettings(InSettings: UE.ChaosBreakingEventRequestSettings) : void;
        SetCollisionEventEnabled(bIsEnabled: boolean) : void;
        SetCollisionEventRequestSettings(InSettings: UE.ChaosCollisionEventRequestSettings) : void;
        SetTrailingEventEnabled(bIsEnabled: boolean) : void;
        SetTrailingEventRequestSettings(InSettings: UE.ChaosTrailingEventRequestSettings) : void;
        SortBreakingEvents(BreakingEvents: $Ref<TArray<UE.ChaosBreakingEventData>>, SortMethod: UE.EChaosBreakingSortMethod) : void;
        SortCollisionEvents(CollisionEvents: $Ref<TArray<UE.ChaosCollisionEventData>>, SortMethod: UE.EChaosCollisionSortMethod) : void;
        SortTrailingEvents(TrailingEvents: $Ref<TArray<UE.ChaosTrailingEventData>>, SortMethod: UE.EChaosTrailingSortMethod) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosDestructionListener;
        static Load(InName: string): ChaosDestructionListener;
    }
    
    class ChaosNotifyHandlerInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosNotifyHandlerInterface;
        static Load(InName: string): ChaosNotifyHandlerInterface;
    }
    
    class ChaosPhysicalMaterialFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosPhysicalMaterialFactory;
        static Load(InName: string): ChaosPhysicalMaterialFactory;
    }
    
    class ChaosSolver extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosSolver;
        static Load(InName: string): ChaosSolver;
    }
    
    class ChaosSolverEngineBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ConvertPhysicsCollisionToHitResult(PhysicsCollision: UE.ChaosPhysicsCollisionInfo) : UE.HitResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosSolverEngineBlueprintLibrary;
        static Load(InName: string): ChaosSolverEngineBlueprintLibrary;
    }
    
    class ChaosSolverSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultChaosSolverActorClass: UE.SoftClassPath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosSolverSettings;
        static Load(InName: string): ChaosSolverSettings;
    }
    
    enum ESlateCheckBoxType { CheckBox, ToggleButton, ESlateCheckBoxType_MAX}
    class CheckBoxStyle extends UE.SlateWidgetStyle {
        constructor();
        constructor(CheckBoxType: UE.ESlateCheckBoxType, UncheckedImage: UE.SlateBrush, UncheckedHoveredImage: UE.SlateBrush, UncheckedPressedImage: UE.SlateBrush, CheckedImage: UE.SlateBrush, CheckedHoveredImage: UE.SlateBrush, CheckedPressedImage: UE.SlateBrush, UndeterminedImage: UE.SlateBrush, UndeterminedHoveredImage: UE.SlateBrush, UndeterminedPressedImage: UE.SlateBrush, Padding: UE.Margin, ForegroundColor: UE.SlateColor, BorderBackgroundColor: UE.SlateColor, CheckedSlateSound: UE.SlateSound, UncheckedSlateSound: UE.SlateSound, HoveredSlateSound: UE.SlateSound, CheckedSound: string, UncheckedSound: string, HoveredSound: string);
        CheckBoxType: UE.ESlateCheckBoxType;
        UncheckedImage: UE.SlateBrush;
        UncheckedHoveredImage: UE.SlateBrush;
        UncheckedPressedImage: UE.SlateBrush;
        CheckedImage: UE.SlateBrush;
        CheckedHoveredImage: UE.SlateBrush;
        CheckedPressedImage: UE.SlateBrush;
        UndeterminedImage: UE.SlateBrush;
        UndeterminedHoveredImage: UE.SlateBrush;
        UndeterminedPressedImage: UE.SlateBrush;
        Padding: UE.Margin;
        ForegroundColor: UE.SlateColor;
        BorderBackgroundColor: UE.SlateColor;
        CheckedSlateSound: UE.SlateSound;
        UncheckedSlateSound: UE.SlateSound;
        HoveredSlateSound: UE.SlateSound;
        CheckedSound: string;
        UncheckedSound: string;
        HoveredSound: string;
        static StaticClass(): Class;
    }
    
    class CheckBox extends UE.ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CheckedState: UE.ECheckBoxState;
        CheckedStateDelegate: $Delegate<() => UE.ECheckBoxState>;
        WidgetStyle: UE.CheckBoxStyle;
        Style: UE.SlateWidgetStyleAsset;
        UncheckedImage: UE.SlateBrushAsset;
        UncheckedHoveredImage: UE.SlateBrushAsset;
        UncheckedPressedImage: UE.SlateBrushAsset;
        CheckedImage: UE.SlateBrushAsset;
        CheckedHoveredImage: UE.SlateBrushAsset;
        CheckedPressedImage: UE.SlateBrushAsset;
        UndeterminedImage: UE.SlateBrushAsset;
        UndeterminedHoveredImage: UE.SlateBrushAsset;
        UndeterminedPressedImage: UE.SlateBrushAsset;
        HorizontalAlignment: UE.EHorizontalAlignment;
        Padding: UE.Margin;
        BorderBackgroundColor: UE.SlateColor;
        IsFocusable: boolean;
        OnCheckStateChanged: $MulticastDelegate<(bIsChecked: boolean) => void>;
        GetCheckedState() : UE.ECheckBoxState;
        IsChecked() : boolean;
        IsPressed() : boolean;
        SetCheckedState(InCheckedState: UE.ECheckBoxState) : void;
        SetIsChecked(InIsChecked: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CheckBox;
        static Load(InName: string): CheckBox;
    }
    
    class CheckBoxStyleAsset extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CheckBoxStyle: UE.CheckBoxStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CheckBoxStyleAsset;
        static Load(InName: string): CheckBoxStyleAsset;
    }
    
    class CheckBoxWidgetStyle extends UE.SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CheckBoxStyle: UE.CheckBoxStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CheckBoxWidgetStyle;
        static Load(InName: string): CheckBoxWidgetStyle;
    }
    
    class CheckedStateBinding extends UE.PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetValue() : UE.ECheckBoxState;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CheckedStateBinding;
        static Load(InName: string): CheckedStateBinding;
    }
    
    class ChunkDependency {
        constructor();
        constructor(ChunkID: number, ParentChunkID: number);
        ChunkID: number;
        ParentChunkID: number;
        static StaticClass(): Class;
    }
    
    class ChunkDependencyInfo extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DependencyArray: TArray<UE.ChunkDependency>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChunkDependencyInfo;
        static Load(InName: string): ChunkDependencyInfo;
    }
    
    class CameraLookatTrackingSettings {
        constructor();
        constructor(bEnableLookAtTracking: boolean, bDrawDebugLookAtTrackingPosition: boolean, LookAtTrackingInterpSpeed: number, ActorToTrack: TSoftObjectPtr<UE.Actor>, RelativeOffset: UE.Vector, bAllowRoll: boolean);
        bEnableLookAtTracking: boolean;
        bDrawDebugLookAtTrackingPosition: boolean;
        LookAtTrackingInterpSpeed: number;
        ActorToTrack: TSoftObjectPtr<UE.Actor>;
        RelativeOffset: UE.Vector;
        bAllowRoll: boolean;
        static StaticClass(): Class;
    }
    
    class CameraFilmbackSettings {
        constructor();
        constructor(SensorWidth: number, SensorHeight: number, SensorAspectRatio: number);
        SensorWidth: number;
        SensorHeight: number;
        SensorAspectRatio: number;
        static StaticClass(): Class;
    }
    
    class CameraLensSettings {
        constructor();
        constructor(MinFocalLength: number, MaxFocalLength: number, MinFStop: number, MaxFStop: number, MinimumFocusDistance: number, DiaphragmBladeCount: number);
        MinFocalLength: number;
        MaxFocalLength: number;
        MinFStop: number;
        MaxFStop: number;
        MinimumFocusDistance: number;
        DiaphragmBladeCount: number;
        static StaticClass(): Class;
    }
    
    enum ECameraFocusMethod { None, Manual, Tracking, ECameraFocusMethod_MAX}
    class CameraTrackingFocusSettings {
        constructor();
        constructor(ActorToTrack: TSoftObjectPtr<UE.Actor>, RelativeOffset: UE.Vector, bDrawDebugTrackingFocusPoint: boolean);
        ActorToTrack: TSoftObjectPtr<UE.Actor>;
        RelativeOffset: UE.Vector;
        bDrawDebugTrackingFocusPoint: boolean;
        static StaticClass(): Class;
    }
    
    class CameraFocusSettings {
        constructor();
        constructor(FocusMethod: UE.ECameraFocusMethod, ManualFocusDistance: number, TrackingFocusSettings: UE.CameraTrackingFocusSettings, bDrawDebugFocusPlane: boolean, DebugFocusPlaneColor: UE.Color, bSmoothFocusChanges: boolean, FocusSmoothingInterpSpeed: number, FocusOffset: number);
        FocusMethod: UE.ECameraFocusMethod;
        ManualFocusDistance: number;
        TrackingFocusSettings: UE.CameraTrackingFocusSettings;
        bDrawDebugFocusPlane: boolean;
        DebugFocusPlaneColor: UE.Color;
        bSmoothFocusChanges: boolean;
        FocusSmoothingInterpSpeed: number;
        FocusOffset: number;
        static StaticClass(): Class;
    }
    
    class NamedFilmbackPreset {
        constructor();
        constructor(Name: string, FilmbackSettings: UE.CameraFilmbackSettings);
        Name: string;
        FilmbackSettings: UE.CameraFilmbackSettings;
        static StaticClass(): Class;
    }
    
    class NamedLensPreset {
        constructor();
        constructor(Name: string, LensSettings: UE.CameraLensSettings);
        Name: string;
        LensSettings: UE.CameraLensSettings;
        static StaticClass(): Class;
    }
    
    class CineCameraComponent extends UE.CameraComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FilmbackSettings: UE.CameraFilmbackSettings;
        Filmback: UE.CameraFilmbackSettings;
        LensSettings: UE.CameraLensSettings;
        FocusSettings: UE.CameraFocusSettings;
        CurrentFocalLength: number;
        CurrentAperture: number;
        CurrentFocusDistance: number;
        CurrentHorizontalFOV: number;
        FocusPlaneVisualizationMesh: UE.StaticMesh;
        FocusPlaneVisualizationMaterial: UE.Material;
        DebugFocusPlaneComponent: UE.StaticMeshComponent;
        DebugFocusPlaneMID: UE.MaterialInstanceDynamic;
        FilmbackPresets: TArray<UE.NamedFilmbackPreset>;
        LensPresets: TArray<UE.NamedLensPreset>;
        DefaultFilmbackPresetName: string;
        DefaultFilmbackPreset: string;
        DefaultLensPresetName: string;
        DefaultLensFocalLength: number;
        DefaultLensFStop: number;
        GetDefaultFilmbackPresetName() : string;
        GetFilmbackPresetName() : string;
        GetHorizontalFieldOfView() : number;
        GetLensPresetName() : string;
        GetVerticalFieldOfView() : number;
        SetCurrentFocalLength(InFocalLength: number) : void;
        SetFilmbackPresetByName(InPresetName: string) : void;
        SetLensPresetByName(InPresetName: string) : void;
        static GetLensPresetsCopy() : TArray<UE.NamedLensPreset>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CineCameraComponent;
        static Load(InName: string): CineCameraComponent;
    }
    
    class CineCameraActor extends UE.CameraActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LookatTrackingSettings: UE.CameraLookatTrackingSettings;
        GetCineCameraComponent() : UE.CineCameraComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CineCameraActor;
        static Load(InName: string): CineCameraActor;
    }
    
    class CircleSplineGenerator extends UE.SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumberOfPoints: number;
        Radius: number;
        bReverseDir: boolean;
        bKeepFirstKeyTangent: boolean;
        bBranchRight: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CircleSplineGenerator;
        static Load(InName: string): CircleSplineGenerator;
    }
    
    class CircularThrobber extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumberOfPieces: number;
        Period: number;
        Radius: number;
        PieceImage: UE.SlateBrushAsset;
        Image: UE.SlateBrush;
        bEnableRadius: boolean;
        SetNumberOfPieces(InNumberOfPieces: number) : void;
        SetPeriod(InPeriod: number) : void;
        SetRadius(InRadius: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CircularThrobber;
        static Load(InName: string): CircularThrobber;
    }
    
    class ObjectPropertyBase extends UE.Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ObjectPropertyBase;
        static Load(InName: string): ObjectPropertyBase;
    }
    
    class ObjectProperty extends UE.ObjectPropertyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ObjectProperty;
        static Load(InName: string): ObjectProperty;
    }
    
    class ClassProperty extends UE.ObjectProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClassProperty;
        static Load(InName: string): ClassProperty;
    }
    
    class ClassThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClassThumbnailRenderer;
        static Load(InName: string): ClassThumbnailRenderer;
    }
    
    class ClassViewerProjectSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InternalOnlyPaths: TArray<UE.DirectoryPath>;
        InternalOnlyClasses: TArray<UE.SoftClassPath>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClassViewerProjectSettings;
        static Load(InName: string): ClassViewerProjectSettings;
    }
    
    enum EClassViewerDeveloperType { CVDT_None, CVDT_CurrentUser, CVDT_All, CVDT_Max, CVDT_MAX}
    class ClassViewerSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DisplayInternalClasses: boolean;
        DeveloperFolderType: UE.EClassViewerDeveloperType;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClassViewerSettings;
        static Load(InName: string): ClassViewerSettings;
    }
    
    class ClickDragInputBehavior extends UE.AnyButtonInputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClickDragInputBehavior;
        static Load(InName: string): ClickDragInputBehavior;
    }
    
    class InteractiveTool extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputBehaviors: UE.InputBehaviorSet;
        ToolPropertyObjects: TArray<UE.Object>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveTool;
        static Load(InName: string): InteractiveTool;
    }
    
    class ClickDragTool extends UE.InteractiveTool {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClickDragTool;
        static Load(InName: string): ClickDragTool;
    }
    
    class InteractiveToolBuilder extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveToolBuilder;
        static Load(InName: string): InteractiveToolBuilder;
    }
    
    class ClickDragToolBuilder extends UE.InteractiveToolBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClickDragToolBuilder;
        static Load(InName: string): ClickDragToolBuilder;
    }
    
    class UnitTestBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnitTestBase;
        static Load(InName: string): UnitTestBase;
    }
    
    class UnitTask extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnitTask;
        static Load(InName: string): UnitTask;
    }
    
    enum EUnitTestVerification { Unverified, VerifiedNotFixed, VerifiedFixed, VerifiedNeedsUpdate, VerifiedUnreliable, EUnitTestVerification_MAX}
    class UnitTest extends UE.UnitTestBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PeakMemoryUsage: bigint;
        TimeToPeakMem: number;
        LastExecutionTime: number;
        UnitTasks: TArray<UE.UnitTask>;
        VerificationState: UE.EUnitTestVerification;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnitTest;
        static Load(InName: string): UnitTest;
    }
    
    class ProcessUnitTest extends UE.UnitTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProcessUnitTest;
        static Load(InName: string): ProcessUnitTest;
    }
    
    class MinimalClient extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MinimalClient;
        static Load(InName: string): MinimalClient;
    }
    
    class ClientUnitTest extends UE.ProcessUnitTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MinClient: UE.MinimalClient;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClientUnitTest;
        static Load(InName: string): ClientUnitTest;
    }
    
    class ClothConfigBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothConfigBase;
        static Load(InName: string): ClothConfigBase;
    }
    
    enum EClothingWindMethod { Legacy, Accurate, EClothingWindMethod_MAX}
    class ClothConstraintSetup {
        constructor();
        constructor(Stiffness: number, StiffnessMultiplier: number, StretchLimit: number, CompressionLimit: number);
        Stiffness: number;
        StiffnessMultiplier: number;
        StretchLimit: number;
        CompressionLimit: number;
        static StaticClass(): Class;
    }
    
    class ClothConfigNv extends UE.ClothConfigBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WindMethod: UE.EClothingWindMethod;
        VerticalConstraintConfig: UE.ClothConstraintSetup;
        HorizontalConstraintConfig: UE.ClothConstraintSetup;
        BendConstraintConfig: UE.ClothConstraintSetup;
        ShearConstraintConfig: UE.ClothConstraintSetup;
        SelfCollisionRadius: number;
        SelfCollisionStiffness: number;
        SelfCollisionCullScale: number;
        Damping: UE.Vector;
        Friction: number;
        WindDragCoefficient: number;
        WindLiftCoefficient: number;
        LinearDrag: UE.Vector;
        AngularDrag: UE.Vector;
        LinearInertiaScale: UE.Vector;
        AngularInertiaScale: UE.Vector;
        CentrifugalInertiaScale: UE.Vector;
        SolverFrequency: number;
        StiffnessFrequency: number;
        GravityScale: number;
        GravityOverride: UE.Vector;
        bUseGravityOverride: boolean;
        TetherStiffness: number;
        TetherLimit: number;
        CollisionThickness: number;
        AnimDriveSpringStiffness: number;
        AnimDriveDamperStiffness: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothConfigNv;
        static Load(InName: string): ClothConfigNv;
    }
    
    class ClothVertBoneData {
        constructor();
        constructor(NumInfluences: number, BoneIndices: FixSizeArray<number>, BoneWeights: FixSizeArray<number>);
        NumInfluences: number;
        BoneIndices: FixSizeArray<number>;
        BoneWeights: FixSizeArray<number>;
        static StaticClass(): Class;
    }
    
    class ClothPhysicalMeshDataBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Vertices: TArray<UE.Vector>;
        Normals: TArray<UE.Vector>;
        VertexColors: TArray<UE.Color>;
        Indices: TArray<number>;
        InverseMasses: TArray<number>;
        BoneData: TArray<UE.ClothVertBoneData>;
        NumFixedVerts: number;
        MaxBoneWeights: number;
        SelfCollisionIndices: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothPhysicalMeshDataBase;
        static Load(InName: string): ClothPhysicalMeshDataBase;
    }
    
    class ClothCollisionPrim_Sphere {
        constructor();
        constructor(BoneIndex: number, Radius: number, LocalPosition: UE.Vector);
        BoneIndex: number;
        Radius: number;
        LocalPosition: UE.Vector;
        static StaticClass(): Class;
    }
    
    class ClothCollisionPrim_SphereConnection {
        constructor();
        constructor(SphereIndices: FixSizeArray<number>);
        SphereIndices: FixSizeArray<number>;
        static StaticClass(): Class;
    }
    
    class ClothCollisionPrim_Convex {
        constructor();
        constructor(Planes: TArray<UE.Plane>, BoneIndex: number);
        Planes: TArray<UE.Plane>;
        BoneIndex: number;
        static StaticClass(): Class;
    }
    
    class ClothCollisionPrim_Box {
        constructor();
        constructor(BoneIndex: number, LocalMin: UE.Vector, LocalMax: UE.Vector);
        BoneIndex: number;
        LocalMin: UE.Vector;
        LocalMax: UE.Vector;
        static StaticClass(): Class;
    }
    
    class ClothCollisionData {
        constructor();
        constructor(Spheres: TArray<UE.ClothCollisionPrim_Sphere>, SphereConnections: TArray<UE.ClothCollisionPrim_SphereConnection>, Convexes: TArray<UE.ClothCollisionPrim_Convex>, Boxes: TArray<UE.ClothCollisionPrim_Box>);
        Spheres: TArray<UE.ClothCollisionPrim_Sphere>;
        SphereConnections: TArray<UE.ClothCollisionPrim_SphereConnection>;
        Convexes: TArray<UE.ClothCollisionPrim_Convex>;
        Boxes: TArray<UE.ClothCollisionPrim_Box>;
        static StaticClass(): Class;
    }
    
    class PointWeightMap {
        constructor();
        constructor(Name: string, CurrentTarget: number, Values: TArray<number>, bEnabled: boolean);
        Name: string;
        CurrentTarget: number;
        Values: TArray<number>;
        bEnabled: boolean;
        static StaticClass(): Class;
    }
    
    class ClothLODDataBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysicalMeshData: UE.ClothPhysicalMeshDataBase;
        CollisionData: UE.ClothCollisionData;
        ParameterMasks: TArray<UE.PointWeightMap>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothLODDataBase;
        static Load(InName: string): ClothLODDataBase;
    }
    
    class ClothingAssetCustomData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingAssetCustomData;
        static Load(InName: string): ClothingAssetCustomData;
    }
    
    class ClothingAssetCommon extends UE.ClothingAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysicsAsset: UE.PhysicsAsset;
        ClothSimConfig: UE.ClothConfigBase;
        ClothLodData: TArray<UE.ClothLODDataBase>;
        LodMap: TArray<number>;
        UsedBoneNames: TArray<string>;
        UsedBoneIndices: TArray<number>;
        ReferenceBoneIndex: number;
        CustomData: UE.ClothingAssetCustomData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingAssetCommon;
        static Load(InName: string): ClothingAssetCommon;
    }
    
    class ClothingAssetFactoryBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingAssetFactoryBase;
        static Load(InName: string): ClothingAssetFactoryBase;
    }
    
    class ClothingAssetFactory extends UE.ClothingAssetFactoryBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingAssetFactory;
        static Load(InName: string): ClothingAssetFactory;
    }
    
    class ClothConfig {
        constructor();
        constructor(WindMethod: UE.EClothingWindMethod, VerticalConstraintConfig: UE.ClothConstraintSetup, HorizontalConstraintConfig: UE.ClothConstraintSetup, BendConstraintConfig: UE.ClothConstraintSetup, ShearConstraintConfig: UE.ClothConstraintSetup, SelfCollisionRadius: number, SelfCollisionStiffness: number, SelfCollisionCullScale: number, Damping: UE.Vector, Friction: number, WindDragCoefficient: number, WindLiftCoefficient: number, LinearDrag: UE.Vector, AngularDrag: UE.Vector, LinearInertiaScale: UE.Vector, AngularInertiaScale: UE.Vector, CentrifugalInertiaScale: UE.Vector, SolverFrequency: number, StiffnessFrequency: number, GravityScale: number, GravityOverride: UE.Vector, bUseGravityOverride: boolean, TetherStiffness: number, TetherLimit: number, CollisionThickness: number, AnimDriveSpringStiffness: number, AnimDriveDamperStiffness: number);
        WindMethod: UE.EClothingWindMethod;
        VerticalConstraintConfig: UE.ClothConstraintSetup;
        HorizontalConstraintConfig: UE.ClothConstraintSetup;
        BendConstraintConfig: UE.ClothConstraintSetup;
        ShearConstraintConfig: UE.ClothConstraintSetup;
        SelfCollisionRadius: number;
        SelfCollisionStiffness: number;
        SelfCollisionCullScale: number;
        Damping: UE.Vector;
        Friction: number;
        WindDragCoefficient: number;
        WindLiftCoefficient: number;
        LinearDrag: UE.Vector;
        AngularDrag: UE.Vector;
        LinearInertiaScale: UE.Vector;
        AngularInertiaScale: UE.Vector;
        CentrifugalInertiaScale: UE.Vector;
        SolverFrequency: number;
        StiffnessFrequency: number;
        GravityScale: number;
        GravityOverride: UE.Vector;
        bUseGravityOverride: boolean;
        TetherStiffness: number;
        TetherLimit: number;
        CollisionThickness: number;
        AnimDriveSpringStiffness: number;
        AnimDriveDamperStiffness: number;
        static StaticClass(): Class;
    }
    
    class ClothPhysicalMeshData {
        constructor();
        constructor(Vertices: TArray<UE.Vector>, Normals: TArray<UE.Vector>, VertexColors: TArray<UE.Color>, Indices: TArray<number>, MaxDistances: TArray<number>, BackstopDistances: TArray<number>, BackstopRadiuses: TArray<number>, AnimDriveMultipliers: TArray<number>, InverseMasses: TArray<number>, BoneData: TArray<UE.ClothVertBoneData>, MaxBoneWeights: number, NumFixedVerts: number, SelfCollisionIndices: TArray<number>);
        Vertices: TArray<UE.Vector>;
        Normals: TArray<UE.Vector>;
        VertexColors: TArray<UE.Color>;
        Indices: TArray<number>;
        MaxDistances: TArray<number>;
        BackstopDistances: TArray<number>;
        BackstopRadiuses: TArray<number>;
        AnimDriveMultipliers: TArray<number>;
        InverseMasses: TArray<number>;
        BoneData: TArray<UE.ClothVertBoneData>;
        MaxBoneWeights: number;
        NumFixedVerts: number;
        SelfCollisionIndices: TArray<number>;
        static StaticClass(): Class;
    }
    
    enum MaskTarget_PhysMesh { None, MaxDistance, BackstopDistance, BackstopRadius, AnimDriveMultiplier, MaskTarget_MAX}
    class ClothParameterMask_PhysMesh {
        constructor();
        constructor(MaskName: string, CurrentTarget: UE.MaskTarget_PhysMesh, MaxValue: number, MinValue: number, Values: TArray<number>, bEnabled: boolean);
        MaskName: string;
        CurrentTarget: UE.MaskTarget_PhysMesh;
        MaxValue: number;
        MinValue: number;
        Values: TArray<number>;
        bEnabled: boolean;
        static StaticClass(): Class;
    }
    
    class ClothLODData {
        constructor();
        constructor(PhysicalMeshData: UE.ClothPhysicalMeshData, CollisionData: UE.ClothCollisionData, ParameterMasks: TArray<UE.ClothParameterMask_PhysMesh>);
        PhysicalMeshData: UE.ClothPhysicalMeshData;
        CollisionData: UE.ClothCollisionData;
        ParameterMasks: TArray<UE.ClothParameterMask_PhysMesh>;
        static StaticClass(): Class;
    }
    
    class ClothingAssetNv extends UE.ClothingAssetCommon {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ClothConfig: UE.ClothConfig;
        LodData: TArray<UE.ClothLODData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingAssetNv;
        static Load(InName: string): ClothingAssetNv;
    }
    
    class ClothingSimulationFactory extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingSimulationFactory;
        static Load(InName: string): ClothingSimulationFactory;
    }
    
    class ClothingSimulationFactoryNv extends UE.ClothingSimulationFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingSimulationFactoryNv;
        static Load(InName: string): ClothingSimulationFactoryNv;
    }
    
    class ClothingSimulationInteractorNv extends UE.ClothingSimulationInteractor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DisableGravityOverride() : void;
        EnableGravityOverride(InVector: UE.Vector) : void;
        SetAnimDriveDamperStiffness(InStiffness: number) : void;
        SetAnimDriveSpringStiffness(InStiffness: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingSimulationInteractorNv;
        static Load(InName: string): ClothingSimulationInteractorNv;
    }
    
    class ClothLODDataNv extends UE.ClothLODDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothLODDataNv;
        static Load(InName: string): ClothLODDataNv;
    }
    
    class MeshPaintSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VertexPreviewSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshPaintSettings;
        static Load(InName: string): MeshPaintSettings;
    }
    
    class ClothPainterSettings extends UE.MeshPaintSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ViewMin: number;
        ViewMax: number;
        bAutoViewRange: boolean;
        AutoCalculatedViewMin: number;
        AutoCalculatedViewMax: number;
        ClothingAssets: TArray<UE.ClothingAssetCommon>;
        bFlipNormal: boolean;
        bCullBackface: boolean;
        Opacity: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothPainterSettings;
        static Load(InName: string): ClothPainterSettings;
    }
    
    class ClothPaintTool_BrushSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PaintValue: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothPaintTool_BrushSettings;
        static Load(InName: string): ClothPaintTool_BrushSettings;
    }
    
    class ClothPaintTool_FillSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Threshold: number;
        FillValue: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothPaintTool_FillSettings;
        static Load(InName: string): ClothPaintTool_FillSettings;
    }
    
    class ClothPaintTool_GradientSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GradientStartValue: number;
        GradientEndValue: number;
        bUseRegularBrush: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothPaintTool_GradientSettings;
        static Load(InName: string): ClothPaintTool_GradientSettings;
    }
    
    class ClothPaintTool_SmoothSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Strength: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothPaintTool_SmoothSettings;
        static Load(InName: string): ClothPaintTool_SmoothSettings;
    }
    
    class ClothPhysicalMeshDataNv extends UE.ClothPhysicalMeshDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxDistances: TArray<number>;
        BackstopDistances: TArray<number>;
        BackstopRadiuses: TArray<number>;
        AnimDriveMultipliers: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothPhysicalMeshDataNv;
        static Load(InName: string): ClothPhysicalMeshDataNv;
    }
    
    enum EPlatformInterfaceDataType { PIDT_None, PIDT_Int, PIDT_Float, PIDT_String, PIDT_Object, PIDT_Custom, PIDT_MAX}
    class PlatformInterfaceData {
        constructor();
        constructor(DataName: string, Type: UE.EPlatformInterfaceDataType, IntValue: number, FloatValue: number, StringValue: string, ObjectValue: UE.Object);
        DataName: string;
        Type: UE.EPlatformInterfaceDataType;
        IntValue: number;
        FloatValue: number;
        StringValue: string;
        ObjectValue: UE.Object;
        static StaticClass(): Class;
    }
    
    class PlatformInterfaceDelegateResult {
        constructor();
        constructor(bSuccessful: boolean, Data: UE.PlatformInterfaceData);
        bSuccessful: boolean;
        Data: UE.PlatformInterfaceData;
        static StaticClass(): Class;
    }
    
    class DelegateArray {
        constructor();
        constructor(Delegates: TArray<$Delegate<(Result: UE.PlatformInterfaceDelegateResult) => void>>);
        Delegates: TArray<$Delegate<(Result: UE.PlatformInterfaceDelegateResult) => void>>;
        static StaticClass(): Class;
    }
    
    class PlatformInterfaceBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AllDelegates: TArray<UE.DelegateArray>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlatformInterfaceBase;
        static Load(InName: string): PlatformInterfaceBase;
    }
    
    class CloudStorageBase extends UE.PlatformInterfaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LocalCloudFiles: TArray<string>;
        bSuppressDelegateCalls: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CloudStorageBase;
        static Load(InName: string): CloudStorageBase;
    }
    
    class CodeGenerator extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Gen() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CodeGenerator;
        static Load(InName: string): CodeGenerator;
    }
    
    class CollisionResponseTemplate {
        constructor();
        constructor(Name: string, CollisionEnabled: UE.ECollisionEnabled, bCanModify: boolean, ObjectTypeName: string, CustomResponses: TArray<UE.ResponseChannel>, HelpMessage: string);
        Name: string;
        CollisionEnabled: UE.ECollisionEnabled;
        bCanModify: boolean;
        ObjectTypeName: string;
        CustomResponses: TArray<UE.ResponseChannel>;
        HelpMessage: string;
        static StaticClass(): Class;
    }
    
    class CustomChannelSetup {
        constructor();
        constructor(Channel: UE.ECollisionChannel, DefaultResponse: UE.ECollisionResponse, bTraceType: boolean, bStaticObject: boolean, Name: string);
        Channel: UE.ECollisionChannel;
        DefaultResponse: UE.ECollisionResponse;
        bTraceType: boolean;
        bStaticObject: boolean;
        Name: string;
        static StaticClass(): Class;
    }
    
    class CustomProfile {
        constructor();
        constructor(Name: string, CustomResponses: TArray<UE.ResponseChannel>);
        Name: string;
        CustomResponses: TArray<UE.ResponseChannel>;
        static StaticClass(): Class;
    }
    
    class Redirector {
        constructor();
        constructor(OldName: string, NewName: string);
        OldName: string;
        NewName: string;
        static StaticClass(): Class;
    }
    
    class CollisionProfile extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Profiles: TArray<UE.CollisionResponseTemplate>;
        DefaultChannelResponses: TArray<UE.CustomChannelSetup>;
        EditProfiles: TArray<UE.CustomProfile>;
        ProfileRedirects: TArray<UE.Redirector>;
        CollisionChannelRedirects: TArray<UE.Redirector>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CollisionProfile;
        static Load(InName: string): CollisionProfile;
    }
    
    class ColorBinding extends UE.PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetLinearValue() : UE.LinearColor;
        GetSlateValue() : UE.SlateColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ColorBinding;
        static Load(InName: string): ColorBinding;
    }
    
    class ComboBox extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Items: TArray<UE.Object>;
        OnGenerateWidgetEvent: $Delegate<(Item: $Nullable<UE.Object>) => UE.Widget>;
        bIsFocusable: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ComboBox;
        static Load(InName: string): ComboBox;
    }
    
    class ComboButtonStyle extends UE.SlateWidgetStyle {
        constructor();
        constructor(ButtonStyle: UE.ButtonStyle, DownArrowImage: UE.SlateBrush, MenuBorderBrush: UE.SlateBrush, MenuBorderPadding: UE.Margin);
        ButtonStyle: UE.ButtonStyle;
        DownArrowImage: UE.SlateBrush;
        MenuBorderBrush: UE.SlateBrush;
        MenuBorderPadding: UE.Margin;
        static StaticClass(): Class;
    }
    
    class ComboBoxStyle extends UE.SlateWidgetStyle {
        constructor();
        constructor(ComboButtonStyle: UE.ComboButtonStyle, PressedSlateSound: UE.SlateSound, SelectionChangeSlateSound: UE.SlateSound, PressedSound: string, SelectionChangeSound: string);
        ComboButtonStyle: UE.ComboButtonStyle;
        PressedSlateSound: UE.SlateSound;
        SelectionChangeSlateSound: UE.SlateSound;
        PressedSound: string;
        SelectionChangeSound: string;
        static StaticClass(): Class;
    }
    
    class TableRowStyle extends UE.SlateWidgetStyle {
        constructor();
        constructor(SelectorFocusedBrush: UE.SlateBrush, ActiveHoveredBrush: UE.SlateBrush, ActiveBrush: UE.SlateBrush, InactiveHoveredBrush: UE.SlateBrush, InactiveBrush: UE.SlateBrush, EvenRowBackgroundHoveredBrush: UE.SlateBrush, EvenRowBackgroundBrush: UE.SlateBrush, OddRowBackgroundHoveredBrush: UE.SlateBrush, OddRowBackgroundBrush: UE.SlateBrush, TextColor: UE.SlateColor, SelectedTextColor: UE.SlateColor, DropIndicator_Above: UE.SlateBrush, DropIndicator_Onto: UE.SlateBrush, DropIndicator_Below: UE.SlateBrush, ActiveHighlightedBrush: UE.SlateBrush, InactiveHighlightedBrush: UE.SlateBrush);
        SelectorFocusedBrush: UE.SlateBrush;
        ActiveHoveredBrush: UE.SlateBrush;
        ActiveBrush: UE.SlateBrush;
        InactiveHoveredBrush: UE.SlateBrush;
        InactiveBrush: UE.SlateBrush;
        EvenRowBackgroundHoveredBrush: UE.SlateBrush;
        EvenRowBackgroundBrush: UE.SlateBrush;
        OddRowBackgroundHoveredBrush: UE.SlateBrush;
        OddRowBackgroundBrush: UE.SlateBrush;
        TextColor: UE.SlateColor;
        SelectedTextColor: UE.SlateColor;
        DropIndicator_Above: UE.SlateBrush;
        DropIndicator_Onto: UE.SlateBrush;
        DropIndicator_Below: UE.SlateBrush;
        ActiveHighlightedBrush: UE.SlateBrush;
        InactiveHighlightedBrush: UE.SlateBrush;
        static StaticClass(): Class;
    }
    
    class FontOutlineSettings {
        constructor();
        constructor(OutlineSize: number, bSeparateFillAlpha: boolean, bApplyOutlineToDropShadows: boolean, OutlineMaterial: UE.Object, OutlineColor: UE.LinearColor);
        OutlineSize: number;
        bSeparateFillAlpha: boolean;
        bApplyOutlineToDropShadows: boolean;
        OutlineMaterial: UE.Object;
        OutlineColor: UE.LinearColor;
        static StaticClass(): Class;
    }
    
    class SlateFontInfo {
        constructor();
        constructor(FontObject: UE.Object, FontMaterial: UE.Object, OutlineSettings: UE.FontOutlineSettings, TypefaceFontName: string, Size: number, FontName: string, Hinting: UE.EFontHinting);
        FontObject: UE.Object;
        FontMaterial: UE.Object;
        OutlineSettings: UE.FontOutlineSettings;
        TypefaceFontName: string;
        Size: number;
        FontName: string;
        Hinting: UE.EFontHinting;
        static StaticClass(): Class;
    }
    
    enum ESelectInfo { OnKeyPress, OnNavigation, OnMouseClick, Direct, ESelectInfo_MAX}
    class ComboBoxString extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultOptions: TArray<string>;
        SelectedOption: string;
        WidgetStyle: UE.ComboBoxStyle;
        ItemStyle: UE.TableRowStyle;
        ContentPadding: UE.Margin;
        MaxListHeight: number;
        HasDownArrow: boolean;
        EnableGamepadNavigationMode: boolean;
        Font: UE.SlateFontInfo;
        ForegroundColor: UE.SlateColor;
        bIsFocusable: boolean;
        OnGenerateWidgetEvent: $Delegate<(Item: string) => UE.Widget>;
        OnSelectionChanged: $MulticastDelegate<(SelectedItem: string, SelectionType: UE.ESelectInfo) => void>;
        OnOpening: $MulticastDelegate<() => void>;
        AddOption(Option: string) : void;
        ClearOptions() : void;
        ClearSelection() : void;
        FindOptionIndex(Option: string) : number;
        GetOptionAtIndex(Index: number) : string;
        GetOptionCount() : number;
        GetSelectedIndex() : number;
        GetSelectedOption() : string;
        IsOpen() : boolean;
        OnOpeningEvent__DelegateSignature() : void;
        OnSelectionChangedEvent__DelegateSignature(SelectedItem: string, SelectionType: UE.ESelectInfo) : void;
        RefreshOptions() : void;
        RemoveOption(Option: string) : boolean;
        SetSelectedIndex(Index: number) : void;
        SetSelectedOption(Option: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ComboBoxString;
        static Load(InName: string): ComboBoxString;
    }
    
    class ComboBoxWidgetStyle extends UE.SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ComboBoxStyle: UE.ComboBoxStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ComboBoxWidgetStyle;
        static Load(InName: string): ComboBoxWidgetStyle;
    }
    
    class ComboButtonWidgetStyle extends UE.SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ComboButtonStyle: UE.ComboButtonStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ComboButtonWidgetStyle;
        static Load(InName: string): ComboButtonWidgetStyle;
    }
    
    class CompileAllBlueprintsCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompileAllBlueprintsCommandlet;
        static Load(InName: string): CompileAllBlueprintsCommandlet;
    }
    
    class BlueprintComponentDelegateBinding {
        constructor();
        constructor(ComponentPropertyName: string, DelegatePropertyName: string, FunctionNameToBind: string);
        ComponentPropertyName: string;
        DelegatePropertyName: string;
        FunctionNameToBind: string;
        static StaticClass(): Class;
    }
    
    class ComponentDelegateBinding extends UE.DynamicBlueprintBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ComponentDelegateBindings: TArray<UE.BlueprintComponentDelegateBinding>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ComponentDelegateBinding;
        static Load(InName: string): ComponentDelegateBinding;
    }
    
    class CompositeCurveTable extends UE.CurveTable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParentTables: TArray<UE.CurveTable>;
        OldParentTables: TArray<UE.CurveTable>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompositeCurveTable;
        static Load(InName: string): CompositeCurveTable;
    }
    
    class CompositeCurveTableFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompositeCurveTableFactory;
        static Load(InName: string): CompositeCurveTableFactory;
    }
    
    class DataTable extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RowStruct: UE.ScriptStruct;
        bStripFromClientBuilds: boolean;
        bIgnoreExtraFields: boolean;
        bIgnoreMissingFields: boolean;
        ImportKeyField: string;
        AssetImportData: UE.AssetImportData;
        ImportPath: string;
        RowStructName: string;
        RowsSerializedWithTags: TArray<number>;
        TemporarilyReferencedObjects: TSet<UE.Object>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DataTable;
        static Load(InName: string): DataTable;
    }
    
    class CompositeDataTable extends UE.DataTable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParentTables: TArray<UE.DataTable>;
        OldParentTables: TArray<UE.DataTable>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompositeDataTable;
        static Load(InName: string): CompositeDataTable;
    }
    
    class DataTableFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Struct: UE.ScriptStruct;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DataTableFactory;
        static Load(InName: string): DataTableFactory;
    }
    
    class CompositeDataTableFactory extends UE.DataTableFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompositeDataTableFactory;
        static Load(InName: string): CompositeDataTableFactory;
    }
    
    class CompositionGraphCapturePasses {
        constructor();
        constructor(Value: TArray<string>);
        Value: TArray<string>;
        static StaticClass(): Class;
    }
    
    enum EHDRCaptureGamut { HCGM_Rec709, HCGM_P3DCI, HCGM_Rec2020, HCGM_ACES, HCGM_ACEScg, HCGM_Linear, HCGM_MAX}
    class CompositionGraphCaptureProtocol extends UE.MovieSceneImageCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IncludeRenderPasses: UE.CompositionGraphCapturePasses;
        bCaptureFramesInHDR: boolean;
        HDRCompressionQuality: number;
        CaptureGamut: UE.EHDRCaptureGamut;
        PostProcessingMaterial: UE.SoftObjectPath;
        bDisableScreenPercentage: boolean;
        PostProcessingMaterialPtr: UE.MaterialInterface;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompositionGraphCaptureProtocol;
        static Load(InName: string): CompositionGraphCaptureProtocol;
    }
    
    class CompressAnimationsCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompressAnimationsCommandlet;
        static Load(InName: string): CompressAnimationsCommandlet;
    }
    
    class FrameGrabberProtocol extends UE.MovieSceneImageCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FrameGrabberProtocol;
        static Load(InName: string): FrameGrabberProtocol;
    }
    
    class ImageSequenceProtocol extends UE.FrameGrabberProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImageSequenceProtocol;
        static Load(InName: string): ImageSequenceProtocol;
    }
    
    class CompressedImageSequenceProtocol extends UE.ImageSequenceProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CompressionQuality: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompressedImageSequenceProtocol;
        static Load(InName: string): CompressedImageSequenceProtocol;
    }
    
    class CompressionHolder extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Compression: UE.AnimCompress;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompressionHolder;
        static Load(InName: string): CompressionHolder;
    }
    
    class EditorBrushBuilder extends UE.BrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorBrushBuilder;
        static Load(InName: string): EditorBrushBuilder;
    }
    
    class ConeBuilder extends UE.EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Z: number;
        CapZ: number;
        OuterRadius: number;
        InnerRadius: number;
        Sides: number;
        GroupName: string;
        AlignToSide: boolean;
        Hollow: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ConeBuilder;
        static Load(InName: string): ConeBuilder;
    }
    
    class PropertyConfigFileDisplayRow extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConfigFileName: string;
        ExternalProperty: UE.Property;
        bIsFileWritable: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyConfigFileDisplayRow;
        static Load(InName: string): PropertyConfigFileDisplayRow;
    }
    
    class ConfigHierarchyPropertyView extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditProperty: TWeakObjectPtr<UE.Property>;
        ConfigFilePropertyObjects: TArray<UE.PropertyConfigFileDisplayRow>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ConfigHierarchyPropertyView;
        static Load(InName: string): ConfigHierarchyPropertyView;
    }
    
    class ConnectionCallbackProxy extends UE.OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(ErrorCode: number) => void>;
        OnFailure: $MulticastDelegate<(ErrorCode: number) => void>;
        static ConnectToService(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>) : UE.ConnectionCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ConnectionCallbackProxy;
        static Load(InName: string): ConnectionCallbackProxy;
    }
    
    class AutoCompleteCommand {
        constructor();
        constructor(Command: string, Desc: string);
        Command: string;
        Desc: string;
        static StaticClass(): Class;
    }
    
    class ConsoleSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxScrollbackSize: number;
        ManualAutoCompleteList: TArray<UE.AutoCompleteCommand>;
        AutoCompleteMapPaths: TArray<string>;
        BackgroundOpacityPercentage: number;
        bOrderTopToBottom: boolean;
        bDisplayHelpInAutoComplete: boolean;
        InputColor: UE.Color;
        HistoryColor: UE.Color;
        AutoCompleteCommandColor: UE.Color;
        AutoCompleteCVarColor: UE.Color;
        AutoCompleteFadedColor: UE.Color;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ConsoleSettings;
        static Load(InName: string): ConsoleSettings;
    }
    
    enum EnumInt32 { VM1, V0, V1, V2, V3, EnumInt32_MAX}
    enum EnumInt8Min { VINT8_MIN, VINT8_MAX}
    enum EnumInt8Max { VINT8_MAX}
    class ContainersTest extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Int32Array: TArray<number>;
        Int32ArrayWithInit: TArray<number>;
        UInt32Array: TArray<number>;
        Int64Array: TArray<bigint>;
        UInt64Array: TArray<bigint>;
        FloatArray: TArray<number>;
        DoubleArray: TArray<number>;
        BoolArray: TArray<boolean>;
        EnumInt32Array: TArray<UE.EnumInt32>;
        EnumInt8MinArray: TArray<UE.EnumInt8Min>;
        EnumInt8MaxArray: TArray<UE.EnumInt8Max>;
        FStringArray: TArray<string>;
        FNameArray: TArray<string>;
        FTextArray: TArray<string>;
        Int32FixSizeArray: FixSizeArray<number>;
        Int32Set: TSet<number>;
        FStringSet: TSet<string>;
        Int32ToStrMap: TMap<number, string>;
        StrToStrMap: TMap<string, string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ContainersTest;
        static Load(InName: string): ContainersTest;
    }
    
    class ContentBrowserAssetContextMenuContext extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SelectedObjects: TArray<TWeakObjectPtr<UE.Object>>;
        CommonClass: UE.Class;
        GetSelectedObjects() : TArray<UE.Object>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ContentBrowserAssetContextMenuContext;
        static Load(InName: string): ContentBrowserAssetContextMenuContext;
    }
    
    class ContentBrowserFrontEndFilterExtension extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ContentBrowserFrontEndFilterExtension;
        static Load(InName: string): ContentBrowserFrontEndFilterExtension;
    }
    
    class ContentBrowserSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumObjectsToLoadBeforeWarning: number;
        bOpenSourcesPanelByDefault: boolean;
        RealTimeThumbnails: boolean;
        DisplayFolders: boolean;
        DisplayEmptyFolders: boolean;
        FilterRecursively: boolean;
        NumObjectsInRecentList: number;
        bShowFullCollectionNameInToolTip: boolean;
        DisplayEngineFolder: boolean;
        DisplayDevelopersFolder: boolean;
        DisplayL10NFolder: boolean;
        DisplayPluginFolders: boolean;
        DisplayFavorites: boolean;
        DisplayCppFolders: boolean;
        IncludeClassNames: boolean;
        IncludeAssetPaths: boolean;
        IncludeCollectionNames: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ContentBrowserSettings;
        static Load(InName: string): ContentBrowserSettings;
    }
    
    class ControlChannel extends UE.Channel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ControlChannel;
        static Load(InName: string): ControlChannel;
    }
    
    class ControlPointMeshComponent extends UE.StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bSelected: boolean;
        VirtualTextureMainPassMaxDrawDistance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ControlPointMeshComponent;
        static Load(InName: string): ControlPointMeshComponent;
    }
    
    class ControlPointMeshActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ControlPointMeshComponent: UE.ControlPointMeshComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ControlPointMeshActor;
        static Load(InName: string): ControlPointMeshActor;
    }
    
    class CookCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FullGCAssetClassNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CookCommandlet;
        static Load(InName: string): CookCommandlet;
    }
    
    enum ECookProgressDisplayMode { Nothing, RemainingPackages, PackageNames, NamesAndRemainingPackages, Max, ECookProgressDisplayMode_MAX}
    enum EBlueprintComponentDataCookingMethod { Disabled, AllBlueprints, EnabledBlueprintsOnly, EBlueprintComponentDataCookingMethod_MAX}
    class CookerSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnableCookOnTheSide: boolean;
        bEnableBuildDDCInBackground: boolean;
        bIterativeCookingForLaunchOn: boolean;
        bIterativeCookingForFileCookContent: boolean;
        bCookOnTheFlyForLaunchOn: boolean;
        CookProgressDisplayMode: UE.ECookProgressDisplayMode;
        bIgnoreIniSettingsOutOfDateForIteration: boolean;
        bIgnoreScriptPackagesOutOfDateForIteration: boolean;
        bCompileBlueprintsInDevelopmentMode: boolean;
        BlueprintComponentDataCookingMethod: UE.EBlueprintComponentDataCookingMethod;
        ClassesExcludedOnDedicatedServer: TArray<string>;
        ModulesExcludedOnDedicatedServer: TArray<string>;
        ClassesExcludedOnDedicatedClient: TArray<string>;
        ModulesExcludedOnDedicatedClient: TArray<string>;
        VersionedIntRValues: TArray<string>;
        DefaultPVRTCQuality: number;
        DefaultASTCQualityBySpeed: number;
        DefaultASTCQualityBySize: number;
        bAllowCookedDataInEditorBuilds: boolean;
        bCookBlueprintComponentTemplateData: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CookerSettings;
        static Load(InName: string): CookerSettings;
    }
    
    class CookerStats extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Assets: TArray<TWeakObjectPtr<UE.Object>>;
        SizeBefore: number;
        SizeAfter: number;
        Path: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CookerStats;
        static Load(InName: string): CookerStats;
    }
    
    class CookOnTheFlyServer extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CookOnTheFlyServer;
        static Load(InName: string): CookOnTheFlyServer;
    }
    
    class CrashReporterSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UploadSymbolsPath: string;
        DownstreamStorage: string;
        RemoteStorage: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CrashReporterSettings;
        static Load(InName: string): CrashReporterSettings;
    }
    
    class CrashReportsPrivacySettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bSendUnattendedBugReports: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CrashReportsPrivacySettings;
        static Load(InName: string): CrashReportsPrivacySettings;
    }
    
    class CreateSessionCallbackProxy extends UE.OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;
        static CreateSession(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>, PublicConnections: number, bUseLAN: boolean) : UE.CreateSessionCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CreateSessionCallbackProxy;
        static Load(InName: string): CreateSessionCallbackProxy;
    }
    
    class CrowdAgentInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CrowdAgentInterface;
        static Load(InName: string): CrowdAgentInterface;
    }
    
    class CrowdFollowingComponent extends UE.PathFollowingComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CharacterMovement: UE.CharacterMovementComponent;
        CrowdAgentMoveDirection: UE.Vector;
        AvoidanceGroup: UE.NavAvoidanceMask;
        GroupsToAvoid: UE.NavAvoidanceMask;
        GroupsToIgnore: UE.NavAvoidanceMask;
        SuspendCrowdSteering(bSuspend: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CrowdFollowingComponent;
        static Load(InName: string): CrowdFollowingComponent;
    }
    
    class CrowdManagerBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CrowdManagerBase;
        static Load(InName: string): CrowdManagerBase;
    }
    
    class CrowdAvoidanceConfig {
        constructor();
        constructor(VelocityBias: number, DesiredVelocityWeight: number, CurrentVelocityWeight: number, SideBiasWeight: number, ImpactTimeWeight: number, ImpactTimeRange: number, CustomPatternIdx: number, AdaptiveDivisions: number, AdaptiveRings: number, AdaptiveDepth: number);
        VelocityBias: number;
        DesiredVelocityWeight: number;
        CurrentVelocityWeight: number;
        SideBiasWeight: number;
        ImpactTimeWeight: number;
        ImpactTimeRange: number;
        CustomPatternIdx: number;
        AdaptiveDivisions: number;
        AdaptiveRings: number;
        AdaptiveDepth: number;
        static StaticClass(): Class;
    }
    
    class CrowdAvoidanceSamplingPattern {
        constructor();
        constructor(Angles: TArray<number>, Radii: TArray<number>);
        Angles: TArray<number>;
        Radii: TArray<number>;
        static StaticClass(): Class;
    }
    
    class CrowdManager extends UE.CrowdManagerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MyNavData: UE.NavigationData;
        AvoidanceConfig: TArray<UE.CrowdAvoidanceConfig>;
        SamplingPatterns: TArray<UE.CrowdAvoidanceSamplingPattern>;
        MaxAgents: number;
        MaxAgentRadius: number;
        MaxAvoidedAgents: number;
        MaxAvoidedWalls: number;
        NavmeshCheckInterval: number;
        PathOptimizationInterval: number;
        SeparationDirClamp: number;
        PathOffsetRadiusMultiplier: number;
        bResolveCollisions: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CrowdManager;
        static Load(InName: string): CrowdManager;
    }
    
    class CryptoKeysCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CryptoKeysCommandlet;
        static Load(InName: string): CryptoKeysCommandlet;
    }
    
    class CryptoEncryptionKey {
        constructor();
        constructor(Guid: UE.Guid, Name: string, Key: string);
        Guid: UE.Guid;
        Name: string;
        Key: string;
        static StaticClass(): Class;
    }
    
    class CryptoKeysSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EncryptionKey: string;
        SecondaryEncryptionKeys: TArray<UE.CryptoEncryptionKey>;
        bEncryptPakIniFiles: boolean;
        bEncryptPakIndex: boolean;
        bEncryptUAssetFiles: boolean;
        bEncryptAllAssetFiles: boolean;
        SigningPublicExponent: string;
        SigningModulus: string;
        SigningPrivateExponent: string;
        bEnablePakSigning: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CryptoKeysSettings;
        static Load(InName: string): CryptoKeysSettings;
    }
    
    enum ECSVImportType { ECSV_DataTable, ECSV_CurveTable, ECSV_CurveFloat, ECSV_CurveVector, ECSV_CurveLinearColor, ECSV_MAX}
    class CSVImportSettings {
        constructor();
        constructor(ImportRowStruct: UE.ScriptStruct, ImportType: UE.ECSVImportType, ImportCurveInterpMode: UE.ERichCurveInterpMode);
        ImportRowStruct: UE.ScriptStruct;
        ImportType: UE.ECSVImportType;
        ImportCurveInterpMode: UE.ERichCurveInterpMode;
        static StaticClass(): Class;
    }
    
    class CSVImportFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AutomatedImportSettings: UE.CSVImportSettings;
        TempImportDataTable: UE.DataTable;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CSVImportFactory;
        static Load(InName: string): CSVImportFactory;
    }
    
    class CubeBuilder extends UE.EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        X: number;
        Y: number;
        Z: number;
        WallThickness: number;
        GroupName: string;
        Hollow: boolean;
        Tessellated: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CubeBuilder;
        static Load(InName: string): CubeBuilder;
    }
    
    class CullDistanceSizePair {
        constructor();
        constructor(Size: number, CullDistance: number);
        Size: number;
        CullDistance: number;
        static StaticClass(): Class;
    }
    
    class CullDistanceVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CullDistances: TArray<UE.CullDistanceSizePair>;
        bEnabled: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CullDistanceVolume;
        static Load(InName: string): CullDistanceVolume;
    }
    
    enum EFieldCullingOperationType { Field_Culling_Inside, Field_Culling_Outside, Field_Culling_Operation_Max, Field_Culling_MAX}
    class CullingField extends UE.FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Culling: UE.FieldNodeBase;
        Field: UE.FieldNodeBase;
        Operation: UE.EFieldCullingOperationType;
        SetCullingField(Culling: $Nullable<UE.FieldNodeBase>, Field: $Nullable<UE.FieldNodeBase>, Operation: UE.EFieldCullingOperationType) : UE.CullingField;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CullingField;
        static Load(InName: string): CullingField;
    }
    
    class CurvedStairBuilder extends UE.EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InnerRadius: number;
        StepHeight: number;
        StepWidth: number;
        AngleOfCurve: number;
        NumSteps: number;
        AddToFirstStep: number;
        GroupName: string;
        CounterClockwise: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurvedStairBuilder;
        static Load(InName: string): CurvedStairBuilder;
    }
    
    class CurveEditorFilterBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEditorFilterBase;
        static Load(InName: string): CurveEditorFilterBase;
    }
    
    class CurveEditorBakeFilter extends UE.CurveEditorFilterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseSnapRateForInterval: boolean;
        BakeInterval: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEditorBakeFilter;
        static Load(InName: string): CurveEditorBakeFilter;
    }
    
    class CurveEditorEulerFilter extends UE.CurveEditorFilterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEditorEulerFilter;
        static Load(InName: string): CurveEditorEulerFilter;
    }
    
    enum ECurveEditorFFTFilterType { Lowpass, Highpass, ECurveEditorFFTFilterType_MAX}
    enum ECurveEditorFFTFilterClass { Butterworth, Chebyshev, ECurveEditorFFTFilterClass_MAX}
    class CurveEditorFFTFilter extends UE.CurveEditorFilterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CutoffFrequency: number;
        Type: UE.ECurveEditorFFTFilterType;
        Response: UE.ECurveEditorFFTFilterClass;
        Order: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEditorFFTFilter;
        static Load(InName: string): CurveEditorFFTFilter;
    }
    
    class CurveEditorKeyProxy extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEditorKeyProxy;
        static Load(InName: string): CurveEditorKeyProxy;
    }
    
    class CurveEditorReduceFilter extends UE.CurveEditorFilterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Tolerance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEditorReduceFilter;
        static Load(InName: string): CurveEditorReduceFilter;
    }
    
    class CurveEditorRetimeAnchor {
        constructor();
        constructor(ValueInSeconds: number, bIsSelected: boolean);
        ValueInSeconds: number;
        bIsSelected: boolean;
        static StaticClass(): Class;
    }
    
    class CurveEditorRetimeToolData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RetimingAnchors: TArray<UE.CurveEditorRetimeAnchor>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEditorRetimeToolData;
        static Load(InName: string): CurveEditorRetimeToolData;
    }
    
    enum ECurveEditorTangentVisibility { AllTangents, SelectedKeys, NoTangents, ECurveEditorTangentVisibility_MAX}
    enum ECurveEditorZoomPosition { CurrentTime, MousePosition, ECurveEditorZoomPosition_MAX}
    class CurveEditorSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoFrameCurveEditor: boolean;
        bShowCurveEditorCurveToolTips: boolean;
        TangentVisibility: UE.ECurveEditorTangentVisibility;
        ZoomPosition: UE.ECurveEditorZoomPosition;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEditorSettings;
        static Load(InName: string): CurveEditorSettings;
    }
    
    class CurveEdOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MinViewRange: number;
        MaxViewRange: number;
        BackgroundColor: UE.LinearColor;
        LabelColor: UE.LinearColor;
        SelectedLabelColor: UE.LinearColor;
        GridColor: UE.LinearColor;
        GridTextColor: UE.LinearColor;
        LabelBlockBkgColor: UE.LinearColor;
        SelectedKeyColor: UE.LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEdOptions;
        static Load(InName: string): CurveEdOptions;
    }
    
    class CurveEdPresetCurve extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEdPresetCurve;
        static Load(InName: string): CurveEdPresetCurve;
    }
    
    class CurveFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurveClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveFactory;
        static Load(InName: string): CurveFactory;
    }
    
    class CurveFloatFactory extends UE.CurveFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveFloatFactory;
        static Load(InName: string): CurveFloatFactory;
    }
    
    class CurveImportFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveImportFactory;
        static Load(InName: string): CurveImportFactory;
    }
    
    class CurveLinearColorAtlasFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Width: number;
        Height: number;
        Format: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveLinearColorAtlasFactory;
        static Load(InName: string): CurveLinearColorAtlasFactory;
    }
    
    class CurveLinearColorFactory extends UE.CurveFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveLinearColorFactory;
        static Load(InName: string): CurveLinearColorFactory;
    }
    
    class CurveLinearColorThumbnailRenderer extends UE.ThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveLinearColorThumbnailRenderer;
        static Load(InName: string): CurveLinearColorThumbnailRenderer;
    }
    
    class CurveVectorFactory extends UE.CurveFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveVectorFactory;
        static Load(InName: string): CurveVectorFactory;
    }
    
    class CustomMeshTriangle {
        constructor();
        constructor(Vertex0: UE.Vector, Vertex1: UE.Vector, Vertex2: UE.Vector);
        Vertex0: UE.Vector;
        Vertex1: UE.Vector;
        Vertex2: UE.Vector;
        static StaticClass(): Class;
    }
    
    class CustomMeshComponent extends UE.MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddCustomMeshTriangles(Triangles: TArray<UE.CustomMeshTriangle>) : void;
        ClearCustomMeshTriangles() : void;
        SetCustomMeshTriangles(Triangles: TArray<UE.CustomMeshTriangle>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CustomMeshComponent;
        static Load(InName: string): CustomMeshComponent;
    }
    
    class CylinderBuilder extends UE.EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Z: number;
        OuterRadius: number;
        InnerRadius: number;
        Sides: number;
        GroupName: string;
        AlignToSide: boolean;
        Hollow: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CylinderBuilder;
        static Load(InName: string): CylinderBuilder;
    }
    
    class DataAssetFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DataAssetClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DataAssetFactory;
        static Load(InName: string): DataAssetFactory;
    }
    
    class DatasmithObjectTemplate extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithObjectTemplate;
        static Load(InName: string): DatasmithObjectTemplate;
    }
    
    class DatasmithActorTemplate extends UE.DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Layers: TSet<string>;
        Tags: TSet<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithActorTemplate;
        static Load(InName: string): DatasmithActorTemplate;
    }
    
    class DatasmithAdditionalData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithAdditionalData;
        static Load(InName: string): DatasmithAdditionalData;
    }
    
    enum EDatasmithAreaLightActorType { Point, Spot, Rect, EDatasmithAreaLightActorType_MAX}
    enum EDatasmithAreaLightActorShape { Rectangle, Disc, Sphere, Cylinder, None, EDatasmithAreaLightActorShape_MAX}
    enum ELightUnits { Unitless, Candelas, Lumens, ELightUnits_MAX}
    class DatasmithAreaLightActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightType: UE.EDatasmithAreaLightActorType;
        LightShape: UE.EDatasmithAreaLightActorShape;
        Dimensions: UE.Vector2D;
        Intensity: number;
        IntensityUnits: UE.ELightUnits;
        Color: UE.LinearColor;
        Temperature: number;
        IESTexture: UE.TextureLightProfile;
        bUseIESBrightness: boolean;
        IESBrightnessScale: number;
        Rotation: UE.Rotator;
        SourceRadius: number;
        SourceLength: number;
        AttenuationRadius: number;
        SpotlightInnerAngle: number;
        SpotlightOuterAngle: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithAreaLightActor;
        static Load(InName: string): DatasmithAreaLightActor;
    }
    
    class DatasmithAreaLightActorTemplate extends UE.DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightType: UE.EDatasmithAreaLightActorType;
        LightShape: UE.EDatasmithAreaLightActorShape;
        Dimensions: UE.Vector2D;
        Color: UE.LinearColor;
        Intensity: number;
        IntensityUnits: UE.ELightUnits;
        Temperature: number;
        IESTexture: TSoftObjectPtr<UE.TextureLightProfile>;
        bUseIESBrightness: boolean;
        IESBrightnessScale: number;
        Rotation: UE.Rotator;
        SourceRadius: number;
        SourceLength: number;
        AttenuationRadius: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithAreaLightActorTemplate;
        static Load(InName: string): DatasmithAreaLightActorTemplate;
    }
    
    class DatasmithAssetImportOptions {
        constructor();
        constructor(PackagePath: string);
        PackagePath: string;
        static StaticClass(): Class;
    }
    
    class DatasmithAssetImportData extends UE.AssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssetImportOptions: UE.DatasmithAssetImportOptions;
        AdditionalData: TArray<UE.DatasmithAdditionalData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithAssetImportData;
        static Load(InName: string): DatasmithAssetImportData;
    }
    
    class DatasmithAssetUserData extends UE.AssetUserData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MetaData: TMap<string, string>;
        ObjectTemplates: TMap<UE.Class, UE.DatasmithObjectTemplate>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithAssetUserData;
        static Load(InName: string): DatasmithAssetUserData;
    }
    
    enum EDatasmithImportScene { NewLevel, CurrentLevel, AssetsOnly, EDatasmithImportScene_MAX}
    enum EDatasmithImportLightmapMin { LIGHTMAP_16, LIGHTMAP_32, LIGHTMAP_64, LIGHTMAP_128, LIGHTMAP_256, LIGHTMAP_512, LIGHTMAP_MAX}
    enum EDatasmithImportLightmapMax { LIGHTMAP_64, LIGHTMAP_128, LIGHTMAP_256, LIGHTMAP_512, LIGHTMAP_1024, LIGHTMAP_2048, LIGHTMAP_4096, LIGHTMAP_MAX}
    class DatasmithStaticMeshImportOptions {
        constructor();
        constructor(MinLightmapResolution: UE.EDatasmithImportLightmapMin, MaxLightmapResolution: UE.EDatasmithImportLightmapMax, bGenerateLightmapUVs: boolean, bRemoveDegenerates: boolean);
        MinLightmapResolution: UE.EDatasmithImportLightmapMin;
        MaxLightmapResolution: UE.EDatasmithImportLightmapMax;
        bGenerateLightmapUVs: boolean;
        bRemoveDegenerates: boolean;
        static StaticClass(): Class;
    }
    
    class DatasmithImportBaseOptions {
        constructor();
        constructor(SceneHandling: UE.EDatasmithImportScene, bIncludeGeometry: boolean, bIncludeMaterial: boolean, bIncludeLight: boolean, bIncludeCamera: boolean, bIncludeAnimation: boolean, AssetOptions: UE.DatasmithAssetImportOptions, StaticMeshOptions: UE.DatasmithStaticMeshImportOptions);
        SceneHandling: UE.EDatasmithImportScene;
        bIncludeGeometry: boolean;
        bIncludeMaterial: boolean;
        bIncludeLight: boolean;
        bIncludeCamera: boolean;
        bIncludeAnimation: boolean;
        AssetOptions: UE.DatasmithAssetImportOptions;
        StaticMeshOptions: UE.DatasmithStaticMeshImportOptions;
        static StaticClass(): Class;
    }
    
    class DatasmithSceneImportData extends UE.AssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseOptions: UE.DatasmithImportBaseOptions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithSceneImportData;
        static Load(InName: string): DatasmithSceneImportData;
    }
    
    enum EDatasmithCADStitchingTechnique { StitchingNone, StitchingHeal, StitchingSew, EDatasmithCADStitchingTechnique_MAX}
    class DatasmithTessellationOptions {
        constructor();
        constructor(ChordTolerance: number, MaxEdgeLength: number, NormalTolerance: number, StitchingTechnique: UE.EDatasmithCADStitchingTechnique);
        ChordTolerance: number;
        MaxEdgeLength: number;
        NormalTolerance: number;
        StitchingTechnique: UE.EDatasmithCADStitchingTechnique;
        static StaticClass(): Class;
    }
    
    class DatasmithCADImportSceneData extends UE.DatasmithSceneImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TessellationOptions: UE.DatasmithTessellationOptions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithCADImportSceneData;
        static Load(InName: string): DatasmithCADImportSceneData;
    }
    
    class DatasmithCameraLookatTrackingSettingsTemplate {
        constructor();
        constructor(bEnableLookAtTracking: boolean, bAllowRoll: boolean, ActorToTrack: TSoftObjectPtr<UE.Actor>);
        bEnableLookAtTracking: boolean;
        bAllowRoll: boolean;
        ActorToTrack: TSoftObjectPtr<UE.Actor>;
        static StaticClass(): Class;
    }
    
    class DatasmithCineCameraActorTemplate extends UE.DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LookatTrackingSettings: UE.DatasmithCameraLookatTrackingSettingsTemplate;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithCineCameraActorTemplate;
        static Load(InName: string): DatasmithCineCameraActorTemplate;
    }
    
    class DatasmithCameraFilmbackSettingsTemplate {
        constructor();
        constructor(SensorWidth: number, SensorHeight: number);
        SensorWidth: number;
        SensorHeight: number;
        static StaticClass(): Class;
    }
    
    class DatasmithCameraLensSettingsTemplate {
        constructor();
        constructor(MaxFStop: number);
        MaxFStop: number;
        static StaticClass(): Class;
    }
    
    class DatasmithCameraFocusSettingsTemplate {
        constructor();
        constructor(FocusMethod: UE.ECameraFocusMethod, ManualFocusDistance: number);
        FocusMethod: UE.ECameraFocusMethod;
        ManualFocusDistance: number;
        static StaticClass(): Class;
    }
    
    class DatasmithPostProcessSettingsTemplate {
        constructor();
        constructor(bOverride_WhiteTemp: boolean, bOverride_ColorSaturation: boolean, bOverride_VignetteIntensity: boolean, bOverride_FilmWhitePoint: boolean, bOverride_AutoExposureMethod: boolean, bOverride_CameraISO: boolean, bOverride_CameraShutterSpeed: boolean, bOverride_DepthOfFieldFstop: boolean, WhiteTemp: number, VignetteIntensity: number, FilmWhitePoint: UE.LinearColor, ColorSaturation: UE.Vector4, AutoExposureMethod: UE.EAutoExposureMethod, CameraISO: number, CameraShutterSpeed: number, DepthOfFieldFstop: number);
        bOverride_WhiteTemp: boolean;
        bOverride_ColorSaturation: boolean;
        bOverride_VignetteIntensity: boolean;
        bOverride_FilmWhitePoint: boolean;
        bOverride_AutoExposureMethod: boolean;
        bOverride_CameraISO: boolean;
        bOverride_CameraShutterSpeed: boolean;
        bOverride_DepthOfFieldFstop: boolean;
        WhiteTemp: number;
        VignetteIntensity: number;
        FilmWhitePoint: UE.LinearColor;
        ColorSaturation: UE.Vector4;
        AutoExposureMethod: UE.EAutoExposureMethod;
        CameraISO: number;
        CameraShutterSpeed: number;
        DepthOfFieldFstop: number;
        static StaticClass(): Class;
    }
    
    class DatasmithCineCameraComponentTemplate extends UE.DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FilmbackSettings: UE.DatasmithCameraFilmbackSettingsTemplate;
        LensSettings: UE.DatasmithCameraLensSettingsTemplate;
        FocusSettings: UE.DatasmithCameraFocusSettingsTemplate;
        CurrentFocalLength: number;
        CurrentAperture: number;
        PostProcessSettings: UE.DatasmithPostProcessSettingsTemplate;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithCineCameraComponentTemplate;
        static Load(InName: string): DatasmithCineCameraComponentTemplate;
    }
    
    class DatasmithCommonTessellationOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Options: UE.DatasmithTessellationOptions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithCommonTessellationOptions;
        static Load(InName: string): DatasmithCommonTessellationOptions;
    }
    
    class DatasmithContentBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetAllDatasmithUserData(ObjectClass: $Nullable<UE.Class>, OutUserData: $Ref<TArray<UE.DatasmithAssetUserData>>) : void;
        static GetAllObjectsAndValuesForKey(Key: string, ObjectClass: $Nullable<UE.Class>, OutObjects: $Ref<TArray<UE.Object>>, OutValues: $Ref<TArray<string>>) : void;
        static GetDatasmithUserData(Object: $Nullable<UE.Object>) : UE.DatasmithAssetUserData;
        static GetDatasmithUserDataKeysAndValuesForValue(Object: $Nullable<UE.Object>, StringToMatch: string, OutKeys: $Ref<TArray<string>>, OutValues: $Ref<TArray<string>>) : void;
        static GetDatasmithUserDataValueForKey(Object: $Nullable<UE.Object>, Key: string) : string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithContentBlueprintLibrary;
        static Load(InName: string): DatasmithContentBlueprintLibrary;
    }
    
    class DatasmithCustomActionBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithCustomActionBase;
        static Load(InName: string): DatasmithCustomActionBase;
    }
    
    class DatasmithDeltaGenAssetImportData extends UE.DatasmithAssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithDeltaGenAssetImportData;
        static Load(InName: string): DatasmithDeltaGenAssetImportData;
    }
    
    class DatasmithFBXSceneImportData extends UE.DatasmithSceneImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bGenerateLightmapUVs: boolean;
        TexturesDir: string;
        IntermediateSerialization: number;
        bColorizeMaterials: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithFBXSceneImportData;
        static Load(InName: string): DatasmithFBXSceneImportData;
    }
    
    class DatasmithDeltaGenSceneImportData extends UE.DatasmithFBXSceneImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bMergeNodes: boolean;
        bOptimizeDuplicatedNodes: boolean;
        bRemoveInvisibleNodes: boolean;
        bSimplifyNodeHierarchy: boolean;
        bImportVar: boolean;
        VarPath: string;
        bImportPos: boolean;
        PosPath: string;
        bImportTml: boolean;
        TmlPath: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithDeltaGenSceneImportData;
        static Load(InName: string): DatasmithDeltaGenSceneImportData;
    }
    
    class DatasmithGLTFSceneImportData extends UE.DatasmithSceneImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Generator: string;
        Version: number;
        Author: string;
        License: string;
        Source: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithGLTFSceneImportData;
        static Load(InName: string): DatasmithGLTFSceneImportData;
    }
    
    class DatasmithIFCSceneImportData extends UE.DatasmithSceneImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithIFCSceneImportData;
        static Load(InName: string): DatasmithIFCSceneImportData;
    }
    
    class DatasmithImportedSequencesActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportedSequences: TArray<UE.LevelSequence>;
        PlayLevelSequence(SequenceToPlay: $Nullable<UE.LevelSequence>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithImportedSequencesActor;
        static Load(InName: string): DatasmithImportedSequencesActor;
    }
    
    enum EDatasmithImportSearchPackagePolicy { Current, All, EDatasmithImportSearchPackagePolicy_MAX}
    enum EDatasmithImportAssetConflictPolicy { Replace, Update, Use, Ignore, EDatasmithImportAssetConflictPolicy_MAX}
    enum EDatasmithImportActorPolicy { Update, Full, Ignore, EDatasmithImportActorPolicy_MAX}
    enum EDatasmithImportMaterialQuality { UseNoFresnelCurves, UseSimplifierFresnelCurves, UseRealFresnelCurves, EDatasmithImportMaterialQuality_MAX}
    class DatasmithReimportOptions {
        constructor();
        constructor(bUpdateActors: boolean, bRespawnDeletedActors: boolean);
        bUpdateActors: boolean;
        bRespawnDeletedActors: boolean;
        static StaticClass(): Class;
    }
    
    class DatasmithImportOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SearchPackagePolicy: UE.EDatasmithImportSearchPackagePolicy;
        MaterialConflictPolicy: UE.EDatasmithImportAssetConflictPolicy;
        TextureConflictPolicy: UE.EDatasmithImportAssetConflictPolicy;
        StaticMeshActorImportPolicy: UE.EDatasmithImportActorPolicy;
        LightImportPolicy: UE.EDatasmithImportActorPolicy;
        CameraImportPolicy: UE.EDatasmithImportActorPolicy;
        OtherActorImportPolicy: UE.EDatasmithImportActorPolicy;
        MaterialQuality: UE.EDatasmithImportMaterialQuality;
        BaseOptions: UE.DatasmithImportBaseOptions;
        ReimportOptions: UE.DatasmithReimportOptions;
        FileName: string;
        FilePath: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithImportOptions;
        static Load(InName: string): DatasmithImportOptions;
    }
    
    class DatasmithLandscapeTemplate extends UE.DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LandscapeMaterial: UE.MaterialInterface;
        StaticLightingLOD: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithLandscapeTemplate;
        static Load(InName: string): DatasmithLandscapeTemplate;
    }
    
    class DatasmithLightComponentTemplate extends UE.DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bVisible: boolean;
        CastShadows: boolean;
        bUseTemperature: boolean;
        bUseIESBrightness: boolean;
        Intensity: number;
        Temperature: number;
        IESBrightnessScale: number;
        LightColor: UE.LinearColor;
        LightFunctionMaterial: UE.MaterialInterface;
        IESTexture: UE.TextureLightProfile;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithLightComponentTemplate;
        static Load(InName: string): DatasmithLightComponentTemplate;
    }
    
    class DatasmithStaticParameterSetTemplate {
        constructor();
        constructor(StaticSwitchParameters: TMap<string, boolean>);
        StaticSwitchParameters: TMap<string, boolean>;
        static StaticClass(): Class;
    }
    
    class DatasmithMaterialInstanceTemplate extends UE.DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ScalarParameterValues: TMap<string, number>;
        VectorParameterValues: TMap<string, UE.LinearColor>;
        TextureParameterValues: TMap<string, TSoftObjectPtr<UE.Texture>>;
        StaticParameters: UE.DatasmithStaticParameterSetTemplate;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithMaterialInstanceTemplate;
        static Load(InName: string): DatasmithMaterialInstanceTemplate;
    }
    
    class DatasmithMDLSceneImportData extends UE.DatasmithSceneImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithMDLSceneImportData;
        static Load(InName: string): DatasmithMDLSceneImportData;
    }
    
    class DatasmithPointLightComponentTemplate extends UE.DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IntensityUnits: UE.ELightUnits;
        SourceRadius: number;
        SourceLength: number;
        AttenuationRadius: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithPointLightComponentTemplate;
        static Load(InName: string): DatasmithPointLightComponentTemplate;
    }
    
    class DatasmithPostProcessVolumeTemplate extends UE.DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: UE.DatasmithPostProcessSettingsTemplate;
        bEnabled: boolean;
        bUnbound: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithPostProcessVolumeTemplate;
        static Load(InName: string): DatasmithPostProcessVolumeTemplate;
    }
    
    class CapturedPropSegment {
        constructor();
        constructor(PropertyName: string, PropertyIndex: number, ComponentName: string);
        PropertyName: string;
        PropertyIndex: number;
        ComponentName: string;
        static StaticClass(): Class;
    }
    
    enum EPropertyValueCategory { Undefined, Generic, RelativeLocation, RelativeRotation, RelativeScale3D, Visibility, Material, Color, Option, EPropertyValueCategory_MAX}
    class PropertyValue extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Properties: TArray<UE.Property>;
        PropertyIndices: TArray<number>;
        CapturedPropSegments: TArray<UE.CapturedPropSegment>;
        FullDisplayString: string;
        PropertySetterName: string;
        PropertySetterParameterDefaults: TMap<string, string>;
        bHasRecordedData: boolean;
        LeafPropertyClass: UE.Class;
        ValueBytes: TArray<number>;
        PropCategory: UE.EPropertyValueCategory;
        GetFullDisplayString() : string;
        GetPropertyTooltip() : string;
        HasRecordedData() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyValue;
        static Load(InName: string): PropertyValue;
    }
    
    class FunctionCaller {
        constructor();
        constructor(FunctionName: string, FunctionEntry: TWeakObjectPtr<UE.Object>);
        FunctionName: string;
        FunctionEntry: TWeakObjectPtr<UE.Object>;
        static StaticClass(): Class;
    }
    
    class VariantObjectBinding extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ObjectPtr: UE.SoftObjectPath;
        LazyObjectPtr: TLazyObjectPtr<UE.Object>;
        CapturedProperties: TArray<UE.PropertyValue>;
        FunctionCallers: TArray<UE.FunctionCaller>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VariantObjectBinding;
        static Load(InName: string): VariantObjectBinding;
    }
    
    class Variant extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DisplayText: string;
        ObjectBindings: TArray<UE.VariantObjectBinding>;
        GetActor(ActorIndex: number) : UE.Actor;
        GetDisplayText() : string;
        GetNumActors() : number;
        SetDisplayText(NewDisplayText: string) : void;
        SwitchOn() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Variant;
        static Load(InName: string): Variant;
    }
    
    class VariantSet extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DisplayText: string;
        bExpanded: boolean;
        Variants: TArray<UE.Variant>;
        GetDisplayText() : string;
        GetNumVariants() : number;
        GetVariant(VariantIndex: number) : UE.Variant;
        GetVariantByName(VariantName: string) : UE.Variant;
        SetDisplayText(NewDisplayText: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VariantSet;
        static Load(InName: string): VariantSet;
    }
    
    class LevelVariantSets extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DirectorBlueprint: UE.Object;
        DirectorClass: UE.BlueprintGeneratedClass;
        VariantSets: TArray<UE.VariantSet>;
        GetNumVariantSets() : number;
        GetVariantSet(VariantSetIndex: number) : UE.VariantSet;
        GetVariantSetByName(VariantSetName: string) : UE.VariantSet;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelVariantSets;
        static Load(InName: string): LevelVariantSets;
    }
    
    class DatasmithScene extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssetImportData: UE.DatasmithSceneImportData;
        BulkDataVersion: number;
        StaticMeshes: TMap<string, TSoftObjectPtr<UE.StaticMesh>>;
        Textures: TMap<string, TSoftObjectPtr<UE.Texture>>;
        MaterialFunctions: TMap<string, TSoftObjectPtr<UE.MaterialFunction>>;
        Materials: TMap<string, TSoftObjectPtr<UE.MaterialInterface>>;
        LevelSequences: TMap<string, TSoftObjectPtr<UE.LevelSequence>>;
        LevelVariantSets: TMap<string, TSoftObjectPtr<UE.LevelVariantSets>>;
        AssetUserData: TArray<UE.AssetUserData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithScene;
        static Load(InName: string): DatasmithScene;
    }
    
    class DatasmithSceneActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Scene: UE.DatasmithScene;
        RelatedActors: TMap<string, TSoftObjectPtr<UE.Actor>>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithSceneActor;
        static Load(InName: string): DatasmithSceneActor;
    }
    
    class DatasmithSceneComponentTemplate extends UE.DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RelativeTransform: UE.Transform;
        Mobility: UE.EComponentMobility;
        AttachParent: TSoftObjectPtr<UE.SceneComponent>;
        Tags: TSet<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithSceneComponentTemplate;
        static Load(InName: string): DatasmithSceneComponentTemplate;
    }
    
    class DatasmithSkyLightComponentTemplate extends UE.DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceType: UE.ESkyLightSourceType;
        CubemapResolution: number;
        Cubemap: UE.TextureCube;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithSkyLightComponentTemplate;
        static Load(InName: string): DatasmithSkyLightComponentTemplate;
    }
    
    class DatasmithSpotLightComponentTemplate extends UE.DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InnerConeAngle: number;
        OuterConeAngle: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithSpotLightComponentTemplate;
        static Load(InName: string): DatasmithSpotLightComponentTemplate;
    }
    
    class DatasmithStaticMeshImportData extends UE.DatasmithAssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportOptions: UE.DatasmithStaticMeshImportOptions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithStaticMeshImportData;
        static Load(InName: string): DatasmithStaticMeshImportData;
    }
    
    class DatasmithStaticMeshCADImportData extends UE.DatasmithStaticMeshImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TessellationOptions: UE.DatasmithTessellationOptions;
        ModelUnit: number;
        ModelTolerance: number;
        ResourcePath: string;
        ResourceFilename: string;
        AuxiliaryFilenames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithStaticMeshCADImportData;
        static Load(InName: string): DatasmithStaticMeshCADImportData;
    }
    
    class DatasmithStaticMeshComponentTemplate extends UE.DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StaticMesh: UE.StaticMesh;
        OverrideMaterials: TArray<UE.MaterialInterface>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithStaticMeshComponentTemplate;
        static Load(InName: string): DatasmithStaticMeshComponentTemplate;
    }
    
    class DatasmithStaticMeshGLTFImportData extends UE.DatasmithStaticMeshImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceMeshName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithStaticMeshGLTFImportData;
        static Load(InName: string): DatasmithStaticMeshGLTFImportData;
    }
    
    class DatasmithStaticMeshIFCImportData extends UE.DatasmithStaticMeshImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceGlobalId: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithStaticMeshIFCImportData;
        static Load(InName: string): DatasmithStaticMeshIFCImportData;
    }
    
    class DatasmithMeshSectionInfoTemplate {
        constructor();
        constructor(MaterialIndex: number);
        MaterialIndex: number;
        static StaticClass(): Class;
    }
    
    class DatasmithMeshSectionInfoMapTemplate {
        constructor();
        constructor(Map: TMap<number, UE.DatasmithMeshSectionInfoTemplate>);
        Map: TMap<number, UE.DatasmithMeshSectionInfoTemplate>;
        static StaticClass(): Class;
    }
    
    class DatasmithMeshBuildSettingsTemplate {
        constructor();
        constructor(bUseMikkTSpace: boolean, bRecomputeNormals: boolean, bRecomputeTangents: boolean, bRemoveDegenerates: boolean, bBuildAdjacencyBuffer: boolean, bUseHighPrecisionTangentBasis: boolean, bUseFullPrecisionUVs: boolean, bGenerateLightmapUVs: boolean, MinLightmapResolution: number, SrcLightmapIndex: number, DstLightmapIndex: number);
        bUseMikkTSpace: boolean;
        bRecomputeNormals: boolean;
        bRecomputeTangents: boolean;
        bRemoveDegenerates: boolean;
        bBuildAdjacencyBuffer: boolean;
        bUseHighPrecisionTangentBasis: boolean;
        bUseFullPrecisionUVs: boolean;
        bGenerateLightmapUVs: boolean;
        MinLightmapResolution: number;
        SrcLightmapIndex: number;
        DstLightmapIndex: number;
        static StaticClass(): Class;
    }
    
    class DatasmithStaticMaterialTemplate {
        constructor();
        constructor(MaterialSlotName: string, MaterialInterface: UE.MaterialInterface);
        MaterialSlotName: string;
        MaterialInterface: UE.MaterialInterface;
        static StaticClass(): Class;
    }
    
    class DatasmithStaticMeshTemplate extends UE.DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SectionInfoMap: UE.DatasmithMeshSectionInfoMapTemplate;
        LightMapCoordinateIndex: number;
        LightMapResolution: number;
        BuildSettings: TArray<UE.DatasmithMeshBuildSettingsTemplate>;
        StaticMaterials: TArray<UE.DatasmithStaticMaterialTemplate>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithStaticMeshTemplate;
        static Load(InName: string): DatasmithStaticMeshTemplate;
    }
    
    class DatasmithTranslatedSceneImportData extends UE.DatasmithSceneImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OriginFactory: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithTranslatedSceneImportData;
        static Load(InName: string): DatasmithTranslatedSceneImportData;
    }
    
    class DatasmithVREDAssetImportData extends UE.DatasmithAssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithVREDAssetImportData;
        static Load(InName: string): DatasmithVREDAssetImportData;
    }
    
    class DatasmithVREDSceneImportData extends UE.DatasmithFBXSceneImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bMergeNodes: boolean;
        bOptimizeDuplicatedNodes: boolean;
        bImportMats: boolean;
        MatsPath: string;
        bImportVar: boolean;
        bCleanVar: boolean;
        VarPath: string;
        bImportLightInfo: boolean;
        LightInfoPath: string;
        bImportClipInfo: boolean;
        ClipInfoPath: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithVREDSceneImportData;
        static Load(InName: string): DatasmithVREDSceneImportData;
    }
    
    class TableRowBase {
        constructor();
        static StaticClass(): Class;
    }
    
    enum EEvaluateCurveTableResult { RowFound, RowNotFound, EEvaluateCurveTableResult_MAX}
    class DataTableFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static DoesDataTableRowExist(Table: $Nullable<UE.DataTable>, RowName: string) : boolean;
        static EvaluateCurveTableRow(CurveTable: $Nullable<UE.CurveTable>, RowName: string, InXY: number, OutResult: $Ref<UE.EEvaluateCurveTableResult>, OutXY: $Ref<number>, ContextString: string) : void;
        static FillDataTableFromCSVFile(DataTable: $Nullable<UE.DataTable>, CSVFilePath: string) : boolean;
        static FillDataTableFromCSVString(DataTable: $Nullable<UE.DataTable>, CSVString: string) : boolean;
        static FillDataTableFromJSONFile(DataTable: $Nullable<UE.DataTable>, JSONFilePath: string) : boolean;
        static FillDataTableFromJSONString(DataTable: $Nullable<UE.DataTable>, JSONString: string) : boolean;
        static GetDataTableColumnAsString(DataTable: $Nullable<UE.DataTable>, PropertyName: string) : TArray<string>;
        static GetDataTableRowFromName(Table: $Nullable<UE.DataTable>, RowName: string, OutRow: $Ref<UE.TableRowBase>) : boolean;
        static GetDataTableRowNames(Table: $Nullable<UE.DataTable>, OutRowNames: $Ref<TArray<string>>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DataTableFunctionLibrary;
        static Load(InName: string): DataTableFunctionLibrary;
    }
    
    class DataValidationCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DataValidationCommandlet;
        static Load(InName: string): DataValidationCommandlet;
    }
    
    class DataValidationManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ExcludedDirectories: TArray<UE.DirectoryPath>;
        bValidateOnSave: boolean;
        DataValidationManagerClassName: UE.SoftClassPath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DataValidationManager;
        static Load(InName: string): DataValidationManager;
    }
    
    class DDCCleanupCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DDCCleanupCommandlet;
        static Load(InName: string): DDCCleanupCommandlet;
    }
    
    enum EViewModeIndex { VMI_BrushWireframe, VMI_Wireframe, VMI_Unlit, VMI_Lit, VMI_Lit_DetailLighting, VMI_LightingOnly, VMI_LightComplexity, VMI_ShaderComplexity, VMI_LightmapDensity, VMI_LitLightmapDensity, VMI_ReflectionOverride, VMI_VisualizeBuffer, VMI_StationaryLightOverlap, VMI_CollisionPawn, VMI_CollisionVisibility, VMI_LODColoration, VMI_QuadOverdraw, VMI_PrimitiveDistanceAccuracy, VMI_MeshUVDensityAccuracy, VMI_ShaderComplexityWithQuadOverdraw, VMI_HLODColoration, VMI_GroupLODColoration, VMI_MaterialTextureScaleAccuracy, VMI_RequiredTextureResolution, VMI_PathTracing, VMI_RayTracingDebug, VMI_Max, VMI_Unknown, VMI_MAX}
    class DebugCameraControllerSettingsViewModeIndex {
        constructor();
        constructor(ViewModeIndex: UE.EViewModeIndex);
        ViewModeIndex: UE.EViewModeIndex;
        static StaticClass(): Class;
    }
    
    class DebugCameraControllerSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CycleViewModes: TArray<UE.DebugCameraControllerSettingsViewModeIndex>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DebugCameraControllerSettings;
        static Load(InName: string): DebugCameraControllerSettings;
    }
    
    class DebugCameraHUD extends UE.HUD {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DebugCameraHUD;
        static Load(InName: string): DebugCameraHUD;
    }
    
    class DebugDrawService extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DebugDrawService;
        static Load(InName: string): DebugDrawService;
    }
    
    class DebugSkelMeshComponent extends UE.SkeletalMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bRenderRawSkeleton: boolean;
        bDrawMesh: boolean;
        bShowBoneNames: boolean;
        bDrawBoneInfluences: boolean;
        bDrawMorphTargetVerts: boolean;
        bDrawNormals: boolean;
        bDrawTangents: boolean;
        bDrawBinormals: boolean;
        bDrawSockets: boolean;
        bSkeletonSocketsVisible: boolean;
        bMeshSocketsVisible: boolean;
        bDisplayRawAnimation: boolean;
        bDisplayNonRetargetedPose: boolean;
        bDisplayAdditiveBasePose: boolean;
        bDisplayBakedAnimation: boolean;
        bDisplaySourceAnimation: boolean;
        bDisplayBound: boolean;
        bDisplayVertexColors: boolean;
        bPreviewRootMotion: boolean;
        bShowClothData: boolean;
        MinClothPropertyView: number;
        MaxClothPropertyView: number;
        ClothMeshOpacity: number;
        bClothFlipNormal: boolean;
        bClothCullBackface: boolean;
        BonesOfInterest: TArray<number>;
        MorphTargetOfInterests: TArray<UE.MorphTarget>;
        SkelMaterials: TArray<UE.MaterialInterface>;
        PreviewInstance: UE.AnimPreviewInstance;
        SavedAnimScriptInstance: UE.AnimInstance;
        bIsUsingInGameBounds: boolean;
        bIsUsingPreSkinnedBounds: boolean;
        bPerformSingleClothingTick: boolean;
        bPauseClothingSimulationWithAnim: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DebugSkelMeshComponent;
        static Load(InName: string): DebugSkelMeshComponent;
    }
    
    class DecalComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DecalMaterial: UE.MaterialInterface;
        SortOrder: number;
        FadeScreenSize: number;
        FadeStartDelay: number;
        FadeDuration: number;
        FadeInDuration: number;
        FadeInStartDelay: number;
        bDestroyOwnerAfterFade: boolean;
        DecalSize: UE.Vector;
        CreateDynamicMaterialInstance() : UE.MaterialInstanceDynamic;
        GetDecalMaterial() : UE.MaterialInterface;
        GetFadeDuration() : number;
        GetFadeInDuration() : number;
        GetFadeInStartDelay() : number;
        GetFadeStartDelay() : number;
        SetDecalMaterial(NewDecalMaterial: $Nullable<UE.MaterialInterface>) : void;
        SetFadeIn(StartDelay: number, Duaration: number) : void;
        SetFadeOut(StartDelay: number, Duration: number, DestroyOwnerAfterFade?: boolean /* = true */) : void;
        SetFadeScreenSize(NewFadeScreenSize: number) : void;
        SetSortOrder(Value: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DecalComponent;
        static Load(InName: string): DecalComponent;
    }
    
    class DecalActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Decal: UE.DecalComponent;
        ArrowComponent: UE.ArrowComponent;
        SpriteComponent: UE.BillboardComponent;
        BoxComponent: UE.BoxComponent;
        CreateDynamicMaterialInstance() : UE.MaterialInstanceDynamic;
        GetDecalMaterial() : UE.MaterialInterface;
        SetDecalMaterial(NewDecalMaterial: $Nullable<UE.MaterialInterface>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DecalActor;
        static Load(InName: string): DecalActor;
    }
    
    class DEditorParameterValue extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bOverride: boolean;
        ParameterInfo: UE.MaterialParameterInfo;
        ExpressionId: UE.Guid;
        SortPriority: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorParameterValue;
        static Load(InName: string): DEditorParameterValue;
    }
    
    class DFontParameters {
        constructor();
        constructor(FontValue: UE.Font, FontPage: number);
        FontValue: UE.Font;
        FontPage: number;
        static StaticClass(): Class;
    }
    
    class DEditorFontParameterValue extends UE.DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterValue: UE.DFontParameters;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorFontParameterValue;
        static Load(InName: string): DEditorFontParameterValue;
    }
    
    class DEditorMaterialLayersParameterValue extends UE.DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterValue: UE.MaterialLayersFunctions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorMaterialLayersParameterValue;
        static Load(InName: string): DEditorMaterialLayersParameterValue;
    }
    
    class DEditorRuntimeVirtualTextureParameterValue extends UE.DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterValue: UE.RuntimeVirtualTexture;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorRuntimeVirtualTextureParameterValue;
        static Load(InName: string): DEditorRuntimeVirtualTextureParameterValue;
    }
    
    class ScalarParameterAtlasData {
        constructor();
        constructor(bIsUsedAsAtlasPosition: boolean, Curve: TSoftObjectPtr<UE.CurveLinearColor>, Atlas: TSoftObjectPtr<UE.CurveLinearColorAtlas>);
        bIsUsedAsAtlasPosition: boolean;
        Curve: TSoftObjectPtr<UE.CurveLinearColor>;
        Atlas: TSoftObjectPtr<UE.CurveLinearColorAtlas>;
        static StaticClass(): Class;
    }
    
    class DEditorScalarParameterValue extends UE.DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterValue: number;
        AtlasData: UE.ScalarParameterAtlasData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorScalarParameterValue;
        static Load(InName: string): DEditorScalarParameterValue;
    }
    
    class DComponentMaskParameter {
        constructor();
        constructor(R: boolean, G: boolean, B: boolean, A: boolean);
        R: boolean;
        G: boolean;
        B: boolean;
        A: boolean;
        static StaticClass(): Class;
    }
    
    class DEditorStaticComponentMaskParameterValue extends UE.DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterValue: UE.DComponentMaskParameter;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorStaticComponentMaskParameterValue;
        static Load(InName: string): DEditorStaticComponentMaskParameterValue;
    }
    
    class DEditorStaticSwitchParameterValue extends UE.DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterValue: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorStaticSwitchParameterValue;
        static Load(InName: string): DEditorStaticSwitchParameterValue;
    }
    
    class ParameterChannelNames {
        constructor();
        constructor(R: string, G: string, B: string, A: string);
        R: string;
        G: string;
        B: string;
        A: string;
        static StaticClass(): Class;
    }
    
    class DEditorTextureParameterValue extends UE.DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterValue: UE.Texture;
        ChannelNames: UE.ParameterChannelNames;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorTextureParameterValue;
        static Load(InName: string): DEditorTextureParameterValue;
    }
    
    class DEditorVectorParameterValue extends UE.DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterValue: UE.LinearColor;
        bIsUsedAsChannelMask: boolean;
        ChannelNames: UE.ParameterChannelNames;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorVectorParameterValue;
        static Load(InName: string): DEditorVectorParameterValue;
    }
    
    class DefaultLevelSequenceInstanceData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TransformOriginActor: UE.Actor;
        TransformOrigin: UE.Transform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DefaultLevelSequenceInstanceData;
        static Load(InName: string): DefaultLevelSequenceInstanceData;
    }
    
    class DefaultPhysicsVolume extends UE.PhysicsVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DefaultPhysicsVolume;
        static Load(InName: string): DefaultPhysicsVolume;
    }
    
    class LocalizedTemplateString {
        constructor();
        constructor(Language: string, Text: string);
        Language: string;
        Text: string;
        static StaticClass(): Class;
    }
    
    class TemplateFolderRename {
        constructor();
        constructor(From: string, To: string);
        From: string;
        To: string;
        static StaticClass(): Class;
    }
    
    class TemplateReplacement {
        constructor();
        constructor(Extensions: TArray<string>, From: string, To: string, bCaseSensitive: boolean);
        Extensions: TArray<string>;
        From: string;
        To: string;
        bCaseSensitive: boolean;
        static StaticClass(): Class;
    }
    
    enum ETemplateSetting { Languages, HardwareTarget, GraphicsPreset, StarterContent, XR, Raytracing, All, ETemplateSetting_MAX}
    enum EFeaturePackDetailLevel { Standard, High, EFeaturePackDetailLevel_MAX}
    class FeaturePackLevelSet {
        constructor();
        constructor(DetailLevels: TArray<UE.EFeaturePackDetailLevel>, MountName: string);
        DetailLevels: TArray<UE.EFeaturePackDetailLevel>;
        MountName: string;
        static StaticClass(): Class;
    }
    
    class TemplateProjectDefs extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LocalizedDisplayNames: TArray<UE.LocalizedTemplateString>;
        LocalizedDescriptions: TArray<UE.LocalizedTemplateString>;
        FoldersToIgnore: TArray<string>;
        FilesToIgnore: TArray<string>;
        FolderRenames: TArray<UE.TemplateFolderRename>;
        FilenameReplacements: TArray<UE.TemplateReplacement>;
        ReplacementsInFiles: TArray<UE.TemplateReplacement>;
        SortKey: string;
        Categories: TArray<string>;
        ClassTypes: string;
        AssetTypes: string;
        bAllowProjectCreation: boolean;
        bIsEnterprise: boolean;
        bIsBlank: boolean;
        HiddenSettings: TArray<UE.ETemplateSetting>;
        PacksToInclude: TArray<string>;
        EditDetailLevelPreference: UE.EFeaturePackDetailLevel;
        SharedContentPacks: TArray<UE.FeaturePackLevelSet>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TemplateProjectDefs;
        static Load(InName: string): TemplateProjectDefs;
    }
    
    class DefaultTemplateProjectDefs extends UE.TemplateProjectDefs {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DefaultTemplateProjectDefs;
        static Load(InName: string): DefaultTemplateProjectDefs;
    }
    
    class DelegateFunction extends UE.Function {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DelegateFunction;
        static Load(InName: string): DelegateFunction;
    }
    
    class DelegateProperty extends UE.Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DelegateProperty;
        static Load(InName: string): DelegateProperty;
    }
    
    class DemoNetConnection extends UE.NetConnection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DemoNetConnection;
        static Load(InName: string): DemoNetConnection;
    }
    
    class PendingNetGame extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NetDriver: UE.NetDriver;
        DemoNetDriver: UE.DemoNetDriver;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PendingNetGame;
        static Load(InName: string): PendingNetGame;
    }
    
    class DemoPendingNetGame extends UE.PendingNetGame {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DemoPendingNetGame;
        static Load(InName: string): DemoPendingNetGame;
    }
    
    class DerivedDataCacheCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DerivedDataCacheCommandlet;
        static Load(InName: string): DerivedDataCacheCommandlet;
    }
    
    class DestroySessionCallbackProxy extends UE.OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;
        static DestroySession(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>) : UE.DestroySessionCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DestroySessionCallbackProxy;
        static Load(InName: string): DestroySessionCallbackProxy;
    }
    
    class DestructibleInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DestructibleInterface;
        static Load(InName: string): DestructibleInterface;
    }
    
    class PropertyViewBase extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LazyObject: TLazyObjectPtr<UE.Object>;
        SoftObjectPath: UE.SoftObjectPath;
        bAutoLoadAsset: boolean;
        OnPropertyChanged: $MulticastDelegate<(PropertyName: string) => void>;
        GetObject() : UE.Object;
        SetObject(NewObject: $Nullable<UE.Object>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyViewBase;
        static Load(InName: string): PropertyViewBase;
    }
    
    class DetailsView extends UE.PropertyViewBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAllowFiltering: boolean;
        bAllowFavoriteSystem: boolean;
        bShowModifiedPropertiesOption: boolean;
        bShowKeyablePropertiesOption: boolean;
        bShowAnimatedPropertiesOption: boolean;
        ColumnWidth: number;
        bShowScrollBar: boolean;
        bForceHiddenPropertyVisibility: boolean;
        ViewIdentifier: string;
        CategoriesToShow: TArray<string>;
        PropertiesToShow: TArray<string>;
        bShowOnlyWhitelisted: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DetailsView;
        static Load(InName: string): DetailsView;
    }
    
    class DetourCrowdAIController extends UE.AIController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DetourCrowdAIController;
        static Load(InName: string): DetourCrowdAIController;
    }
    
    class TextureLODGroup {
        constructor();
        constructor(Group: UE.TextureGroup, LODBias: number, LODBias_Smaller: number, LODBias_Smallest: number, NumStreamedMips: number, MipGenSettings: UE.TextureMipGenSettings, MinLODSize: number, MaxLODSize: number, MaxLODSize_Smaller: number, MaxLODSize_Smallest: number, OptionalLODBias: number, OptionalMaxLODSize: number, MinMagFilter: string, MipFilter: string, MipLoadOptions: UE.ETextureMipLoadOptions, DuplicateNonOptionalMips: boolean);
        Group: UE.TextureGroup;
        LODBias: number;
        LODBias_Smaller: number;
        LODBias_Smallest: number;
        NumStreamedMips: number;
        MipGenSettings: UE.TextureMipGenSettings;
        MinLODSize: number;
        MaxLODSize: number;
        MaxLODSize_Smaller: number;
        MaxLODSize_Smallest: number;
        OptionalLODBias: number;
        OptionalMaxLODSize: number;
        MinMagFilter: string;
        MipFilter: string;
        MipLoadOptions: UE.ETextureMipLoadOptions;
        DuplicateNonOptionalMips: boolean;
        static StaticClass(): Class;
    }
    
    class TextureLODSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TextureLODGroups: TArray<UE.TextureLODGroup>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureLODSettings;
        static Load(InName: string): TextureLODSettings;
    }
    
    class DeviceProfile extends UE.TextureLODSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DeviceType: string;
        BaseProfileName: string;
        Parent: UE.Object;
        CVars: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DeviceProfile;
        static Load(InName: string): DeviceProfile;
    }
    
    class DeviceProfileManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Profiles: TArray<UE.Object>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DeviceProfileManager;
        static Load(InName: string): DeviceProfileManager;
    }
    
    class DialogueSoundWaveProxy extends UE.SoundBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DialogueSoundWaveProxy;
        static Load(InName: string): DialogueSoundWaveProxy;
    }
    
    enum EGrammaticalGender { Neuter, Masculine, Feminine, Mixed, EGrammaticalGender_MAX}
    enum EGrammaticalNumber { Singular, Plural, EGrammaticalNumber_MAX}
    class DialogueVoice extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Gender: UE.EGrammaticalGender;
        Plurality: UE.EGrammaticalNumber;
        LocalizationGUID: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DialogueVoice;
        static Load(InName: string): DialogueVoice;
    }
    
    class DialogueVoiceFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DialogueVoiceFactory;
        static Load(InName: string): DialogueVoiceFactory;
    }
    
    class DialogueContext {
        constructor();
        constructor(Speaker: UE.DialogueVoice, Targets: TArray<UE.DialogueVoice>);
        Speaker: UE.DialogueVoice;
        Targets: TArray<UE.DialogueVoice>;
        static StaticClass(): Class;
    }
    
    class DialogueContextMapping {
        constructor();
        constructor(Context: UE.DialogueContext, SoundWave: UE.SoundWave, LocalizationKeyFormat: string, Proxy: UE.DialogueSoundWaveProxy);
        Context: UE.DialogueContext;
        SoundWave: UE.SoundWave;
        LocalizationKeyFormat: string;
        Proxy: UE.DialogueSoundWaveProxy;
        static StaticClass(): Class;
    }
    
    class DialogueWave extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bMature: boolean;
        bOverride_SubtitleOverride: boolean;
        SpokenText: string;
        SubtitleOverride: string;
        VoiceActorDirection: string;
        ContextMappings: TArray<UE.DialogueContextMapping>;
        LocalizationGUID: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DialogueWave;
        static Load(InName: string): DialogueWave;
    }
    
    class DialogueWaveFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialSoundWave: UE.SoundWave;
        InitialSpeakerVoice: UE.DialogueVoice;
        HasSetInitialTargetVoice: boolean;
        InitialTargetVoices: TArray<UE.DialogueVoice>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DialogueWaveFactory;
        static Load(InName: string): DialogueWaveFactory;
    }
    
    class DiffAssetRegistriesCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssetRegistrySearchPath: TArray<string>;
        P4Repository: string;
        P4EngineBasePath: string;
        P4EngineAssetPath: string;
        P4GameBasePath: string;
        P4GameAssetPath: string;
        RegexBranchCL: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DiffAssetRegistriesCommandlet;
        static Load(InName: string): DiffAssetRegistriesCommandlet;
    }
    
    class DiffAssetsCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DiffAssetsCommandlet;
        static Load(InName: string): DiffAssetsCommandlet;
    }
    
    class DiffFilesCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DiffFilesCommandlet;
        static Load(InName: string): DiffFilesCommandlet;
    }
    
    class DiffPackagesCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Packages: FixSizeArray<UE.Package>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DiffPackagesCommandlet;
        static Load(InName: string): DiffPackagesCommandlet;
    }
    
    class DistributionFloatConstant extends UE.DistributionFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Constant: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionFloatConstant;
        static Load(InName: string): DistributionFloatConstant;
    }
    
    class DistributionFloatConstantCurve extends UE.DistributionFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstantCurve: UE.InterpCurveFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionFloatConstantCurve;
        static Load(InName: string): DistributionFloatConstantCurve;
    }
    
    enum DistributionParamMode { DPM_Normal, DPM_Abs, DPM_Direct, DPM_MAX}
    class DistributionFloatParameterBase extends UE.DistributionFloatConstant {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterName: string;
        MinInput: number;
        MaxInput: number;
        MinOutput: number;
        MaxOutput: number;
        ParamMode: UE.DistributionParamMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionFloatParameterBase;
        static Load(InName: string): DistributionFloatParameterBase;
    }
    
    class DistributionFloatParticleParameter extends UE.DistributionFloatParameterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionFloatParticleParameter;
        static Load(InName: string): DistributionFloatParticleParameter;
    }
    
    class DistributionFloatUniform extends UE.DistributionFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Min: number;
        Max: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionFloatUniform;
        static Load(InName: string): DistributionFloatUniform;
    }
    
    class InterpCurvePointVector2D {
        constructor();
        constructor(InVal: number, OutVal: UE.Vector2D, ArriveTangent: UE.Vector2D, LeaveTangent: UE.Vector2D, InterpMode: UE.EInterpCurveMode);
        InVal: number;
        OutVal: UE.Vector2D;
        ArriveTangent: UE.Vector2D;
        LeaveTangent: UE.Vector2D;
        InterpMode: UE.EInterpCurveMode;
        static StaticClass(): Class;
    }
    
    class InterpCurveVector2D {
        constructor();
        constructor(Points: TArray<UE.InterpCurvePointVector2D>, bIsLooped: boolean, LoopKeyOffset: number);
        Points: TArray<UE.InterpCurvePointVector2D>;
        bIsLooped: boolean;
        LoopKeyOffset: number;
        static StaticClass(): Class;
    }
    
    class DistributionFloatUniformCurve extends UE.DistributionFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstantCurve: UE.InterpCurveVector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionFloatUniformCurve;
        static Load(InName: string): DistributionFloatUniformCurve;
    }
    
    enum EDistributionVectorLockFlags { EDVLF_None, EDVLF_XY, EDVLF_XZ, EDVLF_YZ, EDVLF_XYZ, EDVLF_MAX}
    class DistributionVectorConstant extends UE.DistributionVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Constant: UE.Vector;
        bLockAxes: boolean;
        LockedAxes: UE.EDistributionVectorLockFlags;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionVectorConstant;
        static Load(InName: string): DistributionVectorConstant;
    }
    
    class DistributionVectorConstantCurve extends UE.DistributionVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstantCurve: UE.InterpCurveVector;
        bLockAxes: boolean;
        LockedAxes: UE.EDistributionVectorLockFlags;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionVectorConstantCurve;
        static Load(InName: string): DistributionVectorConstantCurve;
    }
    
    class DistributionVectorParameterBase extends UE.DistributionVectorConstant {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterName: string;
        MinInput: UE.Vector;
        MaxInput: UE.Vector;
        MinOutput: UE.Vector;
        MaxOutput: UE.Vector;
        ParamModes: FixSizeArray<UE.DistributionParamMode>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionVectorParameterBase;
        static Load(InName: string): DistributionVectorParameterBase;
    }
    
    class DistributionVectorParticleParameter extends UE.DistributionVectorParameterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionVectorParticleParameter;
        static Load(InName: string): DistributionVectorParticleParameter;
    }
    
    enum EDistributionVectorMirrorFlags { EDVMF_Same, EDVMF_Different, EDVMF_Mirror, EDVMF_MAX}
    class DistributionVectorUniform extends UE.DistributionVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Max: UE.Vector;
        Min: UE.Vector;
        bLockAxes: boolean;
        LockedAxes: UE.EDistributionVectorLockFlags;
        MirrorFlags: FixSizeArray<UE.EDistributionVectorMirrorFlags>;
        bUseExtremes: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionVectorUniform;
        static Load(InName: string): DistributionVectorUniform;
    }
    
    class TwoVectors {
        constructor();
        constructor(v1: UE.Vector, v2: UE.Vector);
        v1: UE.Vector;
        v2: UE.Vector;
        static StaticClass(): Class;
    }
    
    class InterpCurvePointTwoVectors {
        constructor();
        constructor(InVal: number, OutVal: UE.TwoVectors, ArriveTangent: UE.TwoVectors, LeaveTangent: UE.TwoVectors, InterpMode: UE.EInterpCurveMode);
        InVal: number;
        OutVal: UE.TwoVectors;
        ArriveTangent: UE.TwoVectors;
        LeaveTangent: UE.TwoVectors;
        InterpMode: UE.EInterpCurveMode;
        static StaticClass(): Class;
    }
    
    class InterpCurveTwoVectors {
        constructor();
        constructor(Points: TArray<UE.InterpCurvePointTwoVectors>, bIsLooped: boolean, LoopKeyOffset: number);
        Points: TArray<UE.InterpCurvePointTwoVectors>;
        bIsLooped: boolean;
        LoopKeyOffset: number;
        static StaticClass(): Class;
    }
    
    class DistributionVectorUniformCurve extends UE.DistributionVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstantCurve: UE.InterpCurveTwoVectors;
        bLockAxes1: boolean;
        bLockAxes2: boolean;
        LockedAxes: FixSizeArray<UE.EDistributionVectorLockFlags>;
        MirrorFlags: FixSizeArray<UE.EDistributionVectorMirrorFlags>;
        bUseExtremes: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionVectorUniformCurve;
        static Load(InName: string): DistributionVectorUniformCurve;
    }
    
    namespace Engine.EngineDamageTypes.DmgTypeBP_Environmental {
        class DmgTypeBP_Environmental_C extends UE.DamageType {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): DmgTypeBP_Environmental_C;
            static Load(InName: string): DmgTypeBP_Environmental_C;
        }
        
    }

    class DockableWindowDragOperation extends UE.ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DockableWindowDragOperation;
        static Load(InName: string): DockableWindowDragOperation;
    }
    
    class MaterialSpriteElement {
        constructor();
        constructor(Material: UE.MaterialInterface, DistanceToOpacityCurve: UE.CurveFloat, bSizeIsInScreenSpace: boolean, BaseSizeX: number, BaseSizeY: number, DistanceToSizeCurve: UE.CurveFloat);
        Material: UE.MaterialInterface;
        DistanceToOpacityCurve: UE.CurveFloat;
        bSizeIsInScreenSpace: boolean;
        BaseSizeX: number;
        BaseSizeY: number;
        DistanceToSizeCurve: UE.CurveFloat;
        static StaticClass(): Class;
    }
    
    class MaterialBillboardComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Elements: TArray<UE.MaterialSpriteElement>;
        AddElement(Material: $Nullable<UE.MaterialInterface>, DistanceToOpacityCurve: $Nullable<UE.CurveFloat>, bSizeIsInScreenSpace: boolean, BaseSizeX: number, BaseSizeY: number, DistanceToSizeCurve: $Nullable<UE.CurveFloat>) : void;
        SetElements(NewElements: TArray<UE.MaterialSpriteElement>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialBillboardComponent;
        static Load(InName: string): MaterialBillboardComponent;
    }
    
    class DocumentationActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DocumentLink: string;
        Billboard: UE.MaterialBillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DocumentationActor;
        static Load(InName: string): DocumentationActor;
    }
    
    class DoubleProperty extends UE.NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DoubleProperty;
        static Load(InName: string): DoubleProperty;
    }
    
    class DPICustomScalingRule extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DPICustomScalingRule;
        static Load(InName: string): DPICustomScalingRule;
    }
    
    class DrawSphereComponent extends UE.SphereComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DrawSphereComponent;
        static Load(InName: string): DrawSphereComponent;
    }
    
    class DumpBlueprintsInfoCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DumpBlueprintsInfoCommandlet;
        static Load(InName: string): DumpBlueprintsInfoCommandlet;
    }
    
    class DumpHiddenCategoriesCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DumpHiddenCategoriesCommandlet;
        static Load(InName: string): DumpHiddenCategoriesCommandlet;
    }
    
    class DynamicClass extends UE.Class {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DynamicClass;
        static Load(InName: string): DynamicClass;
    }
    
    class DynamicDelegateProxy extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Fire() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DynamicDelegateProxy;
        static Load(InName: string): DynamicDelegateProxy;
    }
    
    enum EDynamicBoxType { Horizontal, Vertical, Wrap, Overlay, EDynamicBoxType_MAX}
    enum ESlateSizeRule { Automatic, Fill, ESlateSizeRule_MAX}
    class SlateChildSize {
        constructor();
        constructor(Value: number, SizeRule: UE.ESlateSizeRule);
        Value: number;
        SizeRule: UE.ESlateSizeRule;
        static StaticClass(): Class;
    }
    
    class UserWidgetPool {
        constructor();
        constructor(ActiveWidgets: TArray<UE.UserWidget>, InactiveWidgets: TArray<UE.UserWidget>);
        ActiveWidgets: TArray<UE.UserWidget>;
        InactiveWidgets: TArray<UE.UserWidget>;
        static StaticClass(): Class;
    }
    
    class DynamicEntryBoxBase extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EntryBoxType: UE.EDynamicBoxType;
        EntrySpacing: UE.Vector2D;
        SpacingPattern: TArray<UE.Vector2D>;
        EntrySizeRule: UE.SlateChildSize;
        EntryHorizontalAlignment: UE.EHorizontalAlignment;
        EntryVerticalAlignment: UE.EVerticalAlignment;
        MaxElementSize: number;
        EntryWidgetPool: UE.UserWidgetPool;
        GetAllEntries() : TArray<UE.UserWidget>;
        GetNumEntries() : number;
        SetEntrySpacing(InEntrySpacing: UE.Vector2D) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DynamicEntryBoxBase;
        static Load(InName: string): DynamicEntryBoxBase;
    }
    
    class DynamicEntryBox extends UE.DynamicEntryBoxBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumDesignerPreviewEntries: number;
        EntryWidgetClass: UE.Class;
        BP_CreateEntry() : UE.UserWidget;
        BP_CreateEntryOfClass(EntryClass: $Nullable<UE.Class>) : UE.UserWidget;
        RemoveEntry(EntryWidget: $Nullable<UE.UserWidget>) : void;
        Reset(bDeleteWidgets?: boolean /* = false */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DynamicEntryBox;
        static Load(InName: string): DynamicEntryBox;
    }
    
    class EdGraph_ReferenceViewer extends UE.EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraph_ReferenceViewer;
        static Load(InName: string): EdGraph_ReferenceViewer;
    }
    
    enum ECommentBoxMode { GroupMovement, NoGroupMovement, ECommentBoxMode_MAX}
    class EdGraphNode_Comment extends UE.EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CommentColor: UE.LinearColor;
        FontSize: number;
        bCommentBubbleVisible_InDetailsPanel: boolean;
        bColorCommentBubble: boolean;
        MoveMode: UE.ECommentBoxMode;
        CommentDepth: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphNode_Comment;
        static Load(InName: string): EdGraphNode_Comment;
    }
    
    class EdGraphNode_Documentation extends UE.EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Link: string;
        Excerpt: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphNode_Documentation;
        static Load(InName: string): EdGraphNode_Documentation;
    }
    
    class EdGraphNode_Reference extends UE.EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphNode_Reference;
        static Load(InName: string): EdGraphNode_Reference;
    }
    
    class EdGraphSchema_BehaviorTree extends UE.AIGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphSchema_BehaviorTree;
        static Load(InName: string): EdGraphSchema_BehaviorTree;
    }
    
    class EdGraphSchema_BehaviorTreeDecorator extends UE.EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PC_Boolean: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphSchema_BehaviorTreeDecorator;
        static Load(InName: string): EdGraphSchema_BehaviorTreeDecorator;
    }
    
    class EditableGameplayTagQueryExpression extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression;
        static Load(InName: string): EditableGameplayTagQueryExpression;
    }
    
    class EditableGameplayTagQuery extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UserDescription: string;
        RootExpression: UE.EditableGameplayTagQueryExpression;
        TagQueryExportText_Helper: UE.GameplayTagQuery;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQuery;
        static Load(InName: string): EditableGameplayTagQuery;
    }
    
    class EditableGameplayTagQueryExpression_AllExprMatch extends UE.EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Expressions: TArray<UE.EditableGameplayTagQueryExpression>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_AllExprMatch;
        static Load(InName: string): EditableGameplayTagQueryExpression_AllExprMatch;
    }
    
    class EditableGameplayTagQueryExpression_AllTagsMatch extends UE.EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Tags: UE.GameplayTagContainer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_AllTagsMatch;
        static Load(InName: string): EditableGameplayTagQueryExpression_AllTagsMatch;
    }
    
    class EditableGameplayTagQueryExpression_AnyExprMatch extends UE.EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Expressions: TArray<UE.EditableGameplayTagQueryExpression>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_AnyExprMatch;
        static Load(InName: string): EditableGameplayTagQueryExpression_AnyExprMatch;
    }
    
    class EditableGameplayTagQueryExpression_AnyTagsMatch extends UE.EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Tags: UE.GameplayTagContainer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_AnyTagsMatch;
        static Load(InName: string): EditableGameplayTagQueryExpression_AnyTagsMatch;
    }
    
    class EditableGameplayTagQueryExpression_NoExprMatch extends UE.EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Expressions: TArray<UE.EditableGameplayTagQueryExpression>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_NoExprMatch;
        static Load(InName: string): EditableGameplayTagQueryExpression_NoExprMatch;
    }
    
    class EditableGameplayTagQueryExpression_NoTagsMatch extends UE.EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Tags: UE.GameplayTagContainer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_NoTagsMatch;
        static Load(InName: string): EditableGameplayTagQueryExpression_NoTagsMatch;
    }
    
    class EditableMeshAdapter extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableMeshAdapter;
        static Load(InName: string): EditableMeshAdapter;
    }
    
    class EditableGeometryCollectionAdapter extends UE.EditableMeshAdapter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GeometryCollection: UE.GeometryCollection;
        OriginalGeometryCollection: UE.GeometryCollection;
        GeometryCollectionLODIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGeometryCollectionAdapter;
        static Load(InName: string): EditableGeometryCollectionAdapter;
    }
    
    enum ETriangleTessellationMode { ThreeTriangles, FourTriangles, ETriangleTessellationMode_MAX}
    enum EMeshModificationType { FirstInterim, Interim, Final, EMeshModificationType_MAX}
    enum EMeshTopologyChange { NoTopologyChange, TopologyChange, EMeshTopologyChange_MAX}
    class VertexPair {
        constructor();
        constructor(VertexID0: UE.VertexID, VertexID1: UE.VertexID);
        VertexID0: UE.VertexID;
        VertexID1: UE.VertexID;
        static StaticClass(): Class;
    }
    
    class PolygonToSplit {
        constructor();
        constructor(PolygonID: UE.PolygonID, VertexPairsToSplitAt: TArray<UE.VertexPair>);
        PolygonID: UE.PolygonID;
        VertexPairsToSplitAt: TArray<UE.VertexPair>;
        static StaticClass(): Class;
    }
    
    class MeshElementAttributeValue {
        constructor();
        static StaticClass(): Class;
    }
    
    class MeshElementAttributeData {
        constructor();
        constructor(AttributeName: string, AttributeIndex: number, AttributeValue: UE.MeshElementAttributeValue);
        AttributeName: string;
        AttributeIndex: number;
        AttributeValue: UE.MeshElementAttributeValue;
        static StaticClass(): Class;
    }
    
    class MeshElementAttributeList {
        constructor();
        constructor(Attributes: TArray<UE.MeshElementAttributeData>);
        Attributes: TArray<UE.MeshElementAttributeData>;
        static StaticClass(): Class;
    }
    
    class AttributesForVertex {
        constructor();
        constructor(VertexID: UE.VertexID, VertexAttributes: UE.MeshElementAttributeList);
        VertexID: UE.VertexID;
        VertexAttributes: UE.MeshElementAttributeList;
        static StaticClass(): Class;
    }
    
    class AttributesForVertexInstance {
        constructor();
        constructor(VertexInstanceID: UE.VertexInstanceID, VertexInstanceAttributes: UE.MeshElementAttributeList);
        VertexInstanceID: UE.VertexInstanceID;
        VertexInstanceAttributes: UE.MeshElementAttributeList;
        static StaticClass(): Class;
    }
    
    class VertexAttributesForPolygonHole {
        constructor();
        constructor(VertexAttributeList: TArray<UE.MeshElementAttributeList>);
        VertexAttributeList: TArray<UE.MeshElementAttributeList>;
        static StaticClass(): Class;
    }
    
    class VertexAttributesForPolygon {
        constructor();
        constructor(PolygonID: UE.PolygonID, PerimeterVertexAttributeLists: TArray<UE.MeshElementAttributeList>, VertexAttributeListsForEachHole: TArray<UE.VertexAttributesForPolygonHole>);
        PolygonID: UE.PolygonID;
        PerimeterVertexAttributeLists: TArray<UE.MeshElementAttributeList>;
        VertexAttributeListsForEachHole: TArray<UE.VertexAttributesForPolygonHole>;
        static StaticClass(): Class;
    }
    
    class AttributesForEdge {
        constructor();
        constructor(EdgeID: UE.EdgeID, EdgeAttributes: UE.MeshElementAttributeList);
        EdgeID: UE.EdgeID;
        EdgeAttributes: UE.MeshElementAttributeList;
        static StaticClass(): Class;
    }
    
    class VertexToMove {
        constructor();
        constructor(VertexID: UE.VertexID, NewVertexPosition: UE.Vector);
        VertexID: UE.VertexID;
        NewVertexPosition: UE.Vector;
        static StaticClass(): Class;
    }
    
    enum EInsetPolygonsMode { All, CenterPolygonOnly, SidePolygonsOnly, EInsetPolygonsMode_MAX}
    class SubdividedQuadVertex {
        constructor();
        constructor(VertexPositionIndex: number, TextureCoordinate0: UE.Vector2D, TextureCoordinate1: UE.Vector2D, VertexColor: UE.Color, VertexNormal: UE.Vector, VertexTangent: UE.Vector, VertexBinormalSign: number);
        VertexPositionIndex: number;
        TextureCoordinate0: UE.Vector2D;
        TextureCoordinate1: UE.Vector2D;
        VertexColor: UE.Color;
        VertexNormal: UE.Vector;
        VertexTangent: UE.Vector;
        VertexBinormalSign: number;
        static StaticClass(): Class;
    }
    
    class SubdividedQuad {
        constructor();
        constructor(QuadVertex0: UE.SubdividedQuadVertex, QuadVertex1: UE.SubdividedQuadVertex, QuadVertex2: UE.SubdividedQuadVertex, QuadVertex3: UE.SubdividedQuadVertex);
        QuadVertex0: UE.SubdividedQuadVertex;
        QuadVertex1: UE.SubdividedQuadVertex;
        QuadVertex2: UE.SubdividedQuadVertex;
        QuadVertex3: UE.SubdividedQuadVertex;
        static StaticClass(): Class;
    }
    
    class SubdivisionLimitSection {
        constructor();
        constructor(SubdividedQuads: TArray<UE.SubdividedQuad>);
        SubdividedQuads: TArray<UE.SubdividedQuad>;
        static StaticClass(): Class;
    }
    
    class SubdividedWireEdge {
        constructor();
        constructor(EdgeVertex0PositionIndex: number, EdgeVertex1PositionIndex: number);
        EdgeVertex0PositionIndex: number;
        EdgeVertex1PositionIndex: number;
        static StaticClass(): Class;
    }
    
    class SubdivisionLimitData {
        constructor();
        constructor(VertexPositions: TArray<UE.Vector>, Sections: TArray<UE.SubdivisionLimitSection>, SubdividedWireEdges: TArray<UE.SubdividedWireEdge>);
        VertexPositions: TArray<UE.Vector>;
        Sections: TArray<UE.SubdivisionLimitSection>;
        SubdividedWireEdges: TArray<UE.SubdividedWireEdge>;
        static StaticClass(): Class;
    }
    
    class VertexToCreate {
        constructor();
        constructor(VertexAttributes: UE.MeshElementAttributeList, OriginalVertexID: UE.VertexID);
        VertexAttributes: UE.MeshElementAttributeList;
        OriginalVertexID: UE.VertexID;
        static StaticClass(): Class;
    }
    
    class VertexInstanceToCreate {
        constructor();
        constructor(VertexID: UE.VertexID, VertexInstanceAttributes: UE.MeshElementAttributeList, OriginalVertexInstanceID: UE.VertexInstanceID);
        VertexID: UE.VertexID;
        VertexInstanceAttributes: UE.MeshElementAttributeList;
        OriginalVertexInstanceID: UE.VertexInstanceID;
        static StaticClass(): Class;
    }
    
    class VertexAndAttributes {
        constructor();
        constructor(VertexInstanceID: UE.VertexInstanceID, VertexID: UE.VertexID, PolygonVertexAttributes: UE.MeshElementAttributeList);
        VertexInstanceID: UE.VertexInstanceID;
        VertexID: UE.VertexID;
        PolygonVertexAttributes: UE.MeshElementAttributeList;
        static StaticClass(): Class;
    }
    
    enum EPolygonEdgeHardness { NewEdgesSoft, NewEdgesHard, AllEdgesSoft, AllEdgesHard, EPolygonEdgeHardness_MAX}
    class PolygonToCreate {
        constructor();
        constructor(PolygonGroupID: UE.PolygonGroupID, PerimeterVertices: TArray<UE.VertexAndAttributes>, OriginalPolygonID: UE.PolygonID, PolygonEdgeHardness: UE.EPolygonEdgeHardness);
        PolygonGroupID: UE.PolygonGroupID;
        PerimeterVertices: TArray<UE.VertexAndAttributes>;
        OriginalPolygonID: UE.PolygonID;
        PolygonEdgeHardness: UE.EPolygonEdgeHardness;
        static StaticClass(): Class;
    }
    
    class PolygonGroupToCreate {
        constructor();
        constructor(PolygonGroupAttributes: UE.MeshElementAttributeList, OriginalPolygonGroupID: UE.PolygonGroupID);
        PolygonGroupAttributes: UE.MeshElementAttributeList;
        OriginalPolygonGroupID: UE.PolygonGroupID;
        static StaticClass(): Class;
    }
    
    class EdgeToCreate {
        constructor();
        constructor(VertexID0: UE.VertexID, VertexID1: UE.VertexID, EdgeAttributes: UE.MeshElementAttributeList, OriginalEdgeID: UE.EdgeID);
        VertexID0: UE.VertexID;
        VertexID1: UE.VertexID;
        EdgeAttributes: UE.MeshElementAttributeList;
        OriginalEdgeID: UE.EdgeID;
        static StaticClass(): Class;
    }
    
    class VertexIndexAndInstanceID {
        constructor();
        constructor(ContourIndex: number, VertexInstanceID: UE.VertexInstanceID);
        ContourIndex: number;
        VertexInstanceID: UE.VertexInstanceID;
        static StaticClass(): Class;
    }
    
    class VertexInstancesForPolygonHole {
        constructor();
        constructor(VertexIndicesAndInstanceIDs: TArray<UE.VertexIndexAndInstanceID>);
        VertexIndicesAndInstanceIDs: TArray<UE.VertexIndexAndInstanceID>;
        static StaticClass(): Class;
    }
    
    class ChangeVertexInstancesForPolygon {
        constructor();
        constructor(PolygonID: UE.PolygonID, PerimeterVertexIndicesAndInstanceIDs: TArray<UE.VertexIndexAndInstanceID>, VertexIndicesAndInstanceIDsForEachHole: TArray<UE.VertexInstancesForPolygonHole>);
        PolygonID: UE.PolygonID;
        PerimeterVertexIndicesAndInstanceIDs: TArray<UE.VertexIndexAndInstanceID>;
        VertexIndicesAndInstanceIDsForEachHole: TArray<UE.VertexInstancesForPolygonHole>;
        static StaticClass(): Class;
    }
    
    class PolygonGroupForPolygon {
        constructor();
        constructor(PolygonID: UE.PolygonID, PolygonGroupID: UE.PolygonGroupID);
        PolygonID: UE.PolygonID;
        PolygonGroupID: UE.PolygonGroupID;
        static StaticClass(): Class;
    }
    
    class EditableMesh extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Adapters: TArray<UE.EditableMeshAdapter>;
        TextureCoordinateCount: number;
        PendingCompactCounter: number;
        SubdivisionCount: number;
        AnyChangesToUndo() : boolean;
        AssignPolygonsToPolygonGroups(PolygonGroupForPolygons: TArray<UE.PolygonGroupForPolygon>, bDeleteOrphanedPolygonGroups: boolean) : void;
        BevelPolygons(PolygonIDs: TArray<UE.PolygonID>, BevelFixedDistance: number, BevelProgressTowardCenter: number, OutNewCenterPolygonIDs: $Ref<TArray<UE.PolygonID>>, OutNewSidePolygonIDs: $Ref<TArray<UE.PolygonID>>) : void;
        ChangePolygonsVertexInstances(VertexInstancesForPolygons: TArray<UE.ChangeVertexInstancesForPolygon>) : void;
        Commit() : void;
        CommitInstance(ComponentToInstanceTo: $Nullable<UE.PrimitiveComponent>) : UE.EditableMesh;
        ComputeBoundingBox() : UE.Box;
        ComputeBoundingBoxAndSphere() : UE.BoxSphereBounds;
        ComputePolygonCenter(PolygonID: UE.PolygonID) : UE.Vector;
        ComputePolygonNormal(PolygonID: UE.PolygonID) : UE.Vector;
        ComputePolygonPlane(PolygonID: UE.PolygonID) : UE.Plane;
        ComputePolygonsSharedEdges(PolygonIDs: TArray<UE.PolygonID>, OutSharedEdgeIDs: $Ref<TArray<UE.EdgeID>>) : void;
        CreateEdges(EdgesToCreate: TArray<UE.EdgeToCreate>, OutNewEdgeIDs: $Ref<TArray<UE.EdgeID>>) : void;
        CreateEmptyVertexRange(NumVerticesToCreate: number, OutNewVertexIDs: $Ref<TArray<UE.VertexID>>) : void;
        CreateMissingPolygonPerimeterEdges(PolygonID: UE.PolygonID, OutNewEdgeIDs: $Ref<TArray<UE.EdgeID>>) : void;
        CreatePolygonGroups(PolygonGroupsToCreate: TArray<UE.PolygonGroupToCreate>, OutNewPolygonGroupIDs: $Ref<TArray<UE.PolygonGroupID>>) : void;
        CreatePolygons(PolygonsToCreate: TArray<UE.PolygonToCreate>, OutNewPolygonIDs: $Ref<TArray<UE.PolygonID>>, OutNewEdgeIDs: $Ref<TArray<UE.EdgeID>>) : void;
        CreateVertexInstances(VertexInstancesToCreate: TArray<UE.VertexInstanceToCreate>, OutNewVertexInstanceIDs: $Ref<TArray<UE.VertexInstanceID>>) : void;
        CreateVertices(VerticesToCreate: TArray<UE.VertexToCreate>, OutNewVertexIDs: $Ref<TArray<UE.VertexID>>) : void;
        DeleteEdgeAndConnectedPolygons(EdgeID: UE.EdgeID, bDeleteOrphanedEdges: boolean, bDeleteOrphanedVertices: boolean, bDeleteOrphanedVertexInstances: boolean, bDeleteEmptyPolygonGroups: boolean) : void;
        DeleteEdges(EdgeIDsToDelete: TArray<UE.EdgeID>, bDeleteOrphanedVertices: boolean) : void;
        DeleteOrphanVertices(VertexIDsToDelete: TArray<UE.VertexID>) : void;
        DeletePolygonGroups(PolygonGroupIDs: TArray<UE.PolygonGroupID>) : void;
        DeletePolygons(PolygonIDsToDelete: TArray<UE.PolygonID>, bDeleteOrphanedEdges: boolean, bDeleteOrphanedVertices: boolean, bDeleteOrphanedVertexInstances: boolean, bDeleteEmptyPolygonGroups: boolean) : void;
        DeleteVertexAndConnectedEdgesAndPolygons(VertexID: UE.VertexID, bDeleteOrphanedEdges: boolean, bDeleteOrphanedVertices: boolean, bDeleteOrphanedVertexInstances: boolean, bDeleteEmptyPolygonGroups: boolean) : void;
        DeleteVertexInstances(VertexInstanceIDsToDelete: TArray<UE.VertexInstanceID>, bDeleteOrphanedVertices: boolean) : void;
        EndModification(bFromUndo?: boolean /* = false */) : void;
        ExtendEdges(EdgeIDs: TArray<UE.EdgeID>, bWeldNeighbors: boolean, OutNewExtendedEdgeIDs: $Ref<TArray<UE.EdgeID>>) : void;
        ExtendVertices(VertexIDs: TArray<UE.VertexID>, bOnlyExtendClosestEdge: boolean, ReferencePosition: UE.Vector, OutNewExtendedVertexIDs: $Ref<TArray<UE.VertexID>>) : void;
        ExtrudePolygons(Polygons: TArray<UE.PolygonID>, ExtrudeDistance: number, bKeepNeighborsTogether: boolean, OutNewExtrudedFrontPolygons: $Ref<TArray<UE.PolygonID>>) : void;
        FindPolygonLoop(EdgeID: UE.EdgeID, OutEdgeLoopEdgeIDs: $Ref<TArray<UE.EdgeID>>, OutFlippedEdgeIDs: $Ref<TArray<UE.EdgeID>>, OutReversedEdgeIDPathToTake: $Ref<TArray<UE.EdgeID>>, OutPolygonIDsToSplit: $Ref<TArray<UE.PolygonID>>) : void;
        FindPolygonPerimeterEdgeNumberForVertices(PolygonID: UE.PolygonID, EdgeVertexID0: UE.VertexID, EdgeVertexID1: UE.VertexID) : number;
        FindPolygonPerimeterVertexNumberForVertex(PolygonID: UE.PolygonID, VertexID: UE.VertexID) : number;
        FlipPolygons(PolygonIDs: TArray<UE.PolygonID>) : void;
        GeneratePolygonTangentsAndNormals(PolygonIDs: TArray<UE.PolygonID>) : void;
        GetEdgeConnectedPolygon(EdgeID: UE.EdgeID, ConnectedPolygonNumber: number) : UE.PolygonID;
        GetEdgeConnectedPolygonCount(EdgeID: UE.EdgeID) : number;
        GetEdgeConnectedPolygons(EdgeID: UE.EdgeID, OutConnectedPolygonIDs: $Ref<TArray<UE.PolygonID>>) : void;
        GetEdgeCount() : number;
        GetEdgeLoopElements(EdgeID: UE.EdgeID, EdgeLoopIDs: $Ref<TArray<UE.EdgeID>>) : void;
        GetEdgeThatConnectsVertices(VertexID0: UE.VertexID, VertexID1: UE.VertexID) : UE.EdgeID;
        GetEdgeVertex(EdgeID: UE.EdgeID, EdgeVertexNumber: number) : UE.VertexID;
        GetEdgeVertices(EdgeID: UE.EdgeID, OutEdgeVertexID0: $Ref<UE.VertexID>, OutEdgeVertexID1: $Ref<UE.VertexID>) : void;
        GetFirstValidPolygonGroup() : UE.PolygonGroupID;
        GetGroupForPolygon(PolygonID: UE.PolygonID) : UE.PolygonGroupID;
        GetPolygonAdjacentPolygons(PolygonID: UE.PolygonID, OutAdjacentPolygons: $Ref<TArray<UE.PolygonID>>) : void;
        GetPolygonCount() : number;
        GetPolygonCountInGroup(PolygonGroupID: UE.PolygonGroupID) : number;
        GetPolygonGroupCount() : number;
        GetPolygonInGroup(PolygonGroupID: UE.PolygonGroupID, PolygonNumber: number) : UE.PolygonID;
        GetPolygonPerimeterEdge(PolygonID: UE.PolygonID, PerimeterEdgeNumber: number, bOutEdgeWindingIsReversedForPolygon: $Ref<boolean>) : UE.EdgeID;
        GetPolygonPerimeterEdgeCount(PolygonID: UE.PolygonID) : number;
        GetPolygonPerimeterEdges(PolygonID: UE.PolygonID, OutPolygonPerimeterEdgeIDs: $Ref<TArray<UE.EdgeID>>) : void;
        GetPolygonPerimeterVertex(PolygonID: UE.PolygonID, PolygonVertexNumber: number) : UE.VertexID;
        GetPolygonPerimeterVertexCount(PolygonID: UE.PolygonID) : number;
        GetPolygonPerimeterVertexInstance(PolygonID: UE.PolygonID, PolygonVertexNumber: number) : UE.VertexInstanceID;
        GetPolygonPerimeterVertexInstances(PolygonID: UE.PolygonID, OutPolygonPerimeterVertexInstanceIDs: $Ref<TArray<UE.VertexInstanceID>>) : void;
        GetPolygonPerimeterVertices(PolygonID: UE.PolygonID, OutPolygonPerimeterVertexIDs: $Ref<TArray<UE.VertexID>>) : void;
        GetPolygonTriangulatedTriangle(PolygonID: UE.PolygonID, PolygonTriangleNumber: number) : UE.TriangleID;
        GetPolygonTriangulatedTriangleCount(PolygonID: UE.PolygonID) : number;
        GetSubdivisionCount() : number;
        GetSubdivisionLimitData() : UE.SubdivisionLimitData;
        GetTextureCoordinateCount() : number;
        GetVertexAdjacentVertices(VertexID: UE.VertexID, OutAdjacentVertexIDs: $Ref<TArray<UE.VertexID>>) : void;
        GetVertexConnectedEdge(VertexID: UE.VertexID, ConnectedEdgeNumber: number) : UE.EdgeID;
        GetVertexConnectedEdgeCount(VertexID: UE.VertexID) : number;
        GetVertexConnectedEdges(VertexID: UE.VertexID, OutConnectedEdgeIDs: $Ref<TArray<UE.EdgeID>>) : void;
        GetVertexConnectedPolygons(VertexID: UE.VertexID, OutConnectedPolygonIDs: $Ref<TArray<UE.PolygonID>>) : void;
        GetVertexCount() : number;
        GetVertexInstanceConnectedPolygon(VertexInstanceID: UE.VertexInstanceID, ConnectedPolygonNumber: number) : UE.PolygonID;
        GetVertexInstanceConnectedPolygonCount(VertexInstanceID: UE.VertexInstanceID) : number;
        GetVertexInstanceConnectedPolygons(VertexInstanceID: UE.VertexInstanceID, OutConnectedPolygonIDs: $Ref<TArray<UE.PolygonID>>) : void;
        GetVertexInstanceCount() : number;
        GetVertexInstanceVertex(VertexInstanceID: UE.VertexInstanceID) : UE.VertexID;
        GetVertexPairEdge(VertexID: UE.VertexID, NextVertexID: UE.VertexID, bOutEdgeWindingIsReversed: $Ref<boolean>) : UE.EdgeID;
        InitializeAdapters() : void;
        InsertEdgeLoop(EdgeID: UE.EdgeID, Splits: TArray<number>, OutNewEdgeIDs: $Ref<TArray<UE.EdgeID>>) : void;
        InsetPolygons(PolygonIDs: TArray<UE.PolygonID>, InsetFixedDistance: number, InsetProgressTowardCenter: number, Mode: UE.EInsetPolygonsMode, OutNewCenterPolygonIDs: $Ref<TArray<UE.PolygonID>>, OutNewSidePolygonIDs: $Ref<TArray<UE.PolygonID>>) : void;
        IsBeingModified() : boolean;
        IsCommitted() : boolean;
        IsCommittedAsInstance() : boolean;
        IsCompactAllowed() : boolean;
        IsOrphanedVertex(VertexID: UE.VertexID) : boolean;
        IsPreviewingSubdivisions() : boolean;
        IsSpatialDatabaseAllowed() : boolean;
        IsUndoAllowed() : boolean;
        IsValidEdge(EdgeID: UE.EdgeID) : boolean;
        IsValidPolygon(PolygonID: UE.PolygonID) : boolean;
        IsValidPolygonGroup(PolygonGroupID: UE.PolygonGroupID) : boolean;
        IsValidVertex(VertexID: UE.VertexID) : boolean;
        MoveVertices(VerticesToMove: TArray<UE.VertexToMove>) : void;
        PropagateInstanceChanges() : void;
        QuadrangulateMesh(OutNewPolygonIDs: $Ref<TArray<UE.PolygonID>>) : void;
        RebuildRenderMesh() : void;
        Revert() : void;
        RevertInstance() : UE.EditableMesh;
        SearchSpatialDatabaseForPolygonsInVolume(Planes: TArray<UE.Plane>, OutPolygons: $Ref<TArray<UE.PolygonID>>) : void;
        SearchSpatialDatabaseForPolygonsPotentiallyIntersectingLineSegment(LineSegmentStart: UE.Vector, LineSegmentEnd: UE.Vector, OutPolygons: $Ref<TArray<UE.PolygonID>>) : void;
        SearchSpatialDatabaseForPolygonsPotentiallyIntersectingPlane(InPlane: UE.Plane, OutPolygons: $Ref<TArray<UE.PolygonID>>) : void;
        SetAllowCompact(bInAllowCompact: boolean) : void;
        SetAllowSpatialDatabase(bInAllowSpatialDatabase: boolean) : void;
        SetAllowUndo(bInAllowUndo: boolean) : void;
        SetEdgesAttributes(AttributesForEdges: TArray<UE.AttributesForEdge>) : void;
        SetEdgesCreaseSharpness(EdgeIDs: TArray<UE.EdgeID>, EdgesNewCreaseSharpness: TArray<number>) : void;
        SetEdgesHardness(EdgeIDs: TArray<UE.EdgeID>, EdgesNewIsHard: TArray<boolean>) : void;
        SetEdgesHardnessAutomatically(EdgeIDs: TArray<UE.EdgeID>, MaxDotProductForSoftEdge: number) : void;
        SetPolygonsVertexAttributes(VertexAttributesForPolygons: TArray<UE.VertexAttributesForPolygon>) : void;
        SetSubdivisionCount(NewSubdivisionCount: number) : void;
        SetTextureCoordinateCount(NumTexCoords: number) : void;
        SetVertexInstancesAttributes(AttributesForVertexInstances: TArray<UE.AttributesForVertexInstance>) : void;
        SetVerticesAttributes(AttributesForVertices: TArray<UE.AttributesForVertex>) : void;
        SetVerticesCornerSharpness(VertexIDs: TArray<UE.VertexID>, VerticesNewCornerSharpness: TArray<number>) : void;
        SplitEdge(EdgeID: UE.EdgeID, Splits: TArray<number>, OutNewVertexIDs: $Ref<TArray<UE.VertexID>>) : void;
        SplitPolygonalMesh(InPlane: UE.Plane, PolygonIDs1: $Ref<TArray<UE.PolygonID>>, PolygonIDs2: $Ref<TArray<UE.PolygonID>>, BoundaryIDs: $Ref<TArray<UE.EdgeID>>) : void;
        SplitPolygons(PolygonsToSplit: TArray<UE.PolygonToSplit>, OutNewEdgeIDs: $Ref<TArray<UE.EdgeID>>) : void;
        StartModification(MeshModificationType: UE.EMeshModificationType, MeshTopologyChange: UE.EMeshTopologyChange) : void;
        TessellatePolygons(PolygonIDs: TArray<UE.PolygonID>, TriangleTessellationMode: UE.ETriangleTessellationMode, OutNewPolygonIDs: $Ref<TArray<UE.PolygonID>>) : void;
        TriangulatePolygons(PolygonIDs: TArray<UE.PolygonID>, OutNewTrianglePolygons: $Ref<TArray<UE.PolygonID>>) : void;
        TryToRemovePolygonEdge(EdgeID: UE.EdgeID, bOutWasEdgeRemoved: $Ref<boolean>, OutNewPolygonID: $Ref<UE.PolygonID>) : void;
        TryToRemoveVertex(VertexID: UE.VertexID, bOutWasVertexRemoved: $Ref<boolean>, OutNewEdgeID: $Ref<UE.EdgeID>) : void;
        WeldVertices(VertexIDs: TArray<UE.VertexID>, OutNewVertexID: $Ref<UE.VertexID>) : void;
        static InvalidEdgeID() : UE.EdgeID;
        static InvalidPolygonGroupID() : UE.PolygonGroupID;
        static InvalidPolygonID() : UE.PolygonID;
        static InvalidVertexID() : UE.VertexID;
        static MakeEdgeID(EdgeIndex: number) : UE.EdgeID;
        static MakePolygonGroupID(PolygonGroupIndex: number) : UE.PolygonGroupID;
        static MakePolygonID(PolygonIndex: number) : UE.PolygonID;
        static MakeVertexID(VertexIndex: number) : UE.VertexID;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableMesh;
        static Load(InName: string): EditableMesh;
    }
    
    class EditableMeshFactory extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static MakeEditableMesh(PrimitiveComponent: $Nullable<UE.PrimitiveComponent>, LODIndex: number) : UE.EditableMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableMeshFactory;
        static Load(InName: string): EditableMeshFactory;
    }
    
    class EditableStaticMeshAdapter extends UE.EditableMeshAdapter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StaticMesh: UE.StaticMesh;
        OriginalStaticMesh: UE.StaticMesh;
        StaticMeshLODIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableStaticMeshAdapter;
        static Load(InName: string): EditableStaticMeshAdapter;
    }
    
    class EditableTextStyle extends UE.SlateWidgetStyle {
        constructor();
        constructor(Font: UE.SlateFontInfo, ColorAndOpacity: UE.SlateColor, BackgroundImageSelected: UE.SlateBrush, BackgroundImageComposing: UE.SlateBrush, CaretImage: UE.SlateBrush);
        Font: UE.SlateFontInfo;
        ColorAndOpacity: UE.SlateColor;
        BackgroundImageSelected: UE.SlateBrush;
        BackgroundImageComposing: UE.SlateBrush;
        CaretImage: UE.SlateBrush;
        static StaticClass(): Class;
    }
    
    enum EVirtualKeyboardType { Default, Number, Web, Email, Password, AlphaNumeric, EVirtualKeyboardType_MAX}
    class VirtualKeyboardOptions {
        constructor();
        constructor(bEnableAutocorrect: boolean);
        bEnableAutocorrect: boolean;
        static StaticClass(): Class;
    }
    
    enum EVirtualKeyboardDismissAction { TextChangeOnDismiss, TextCommitOnAccept, TextCommitOnDismiss, EVirtualKeyboardDismissAction_MAX}
    enum ETextJustify { Left, Center, Right, ETextJustify_MAX}
    enum ETextShapingMethod { Auto, KerningOnly, FullShaping, ETextShapingMethod_MAX}
    enum ETextFlowDirection { Auto, LeftToRight, RightToLeft, ETextFlowDirection_MAX}
    class ShapedTextOptions {
        constructor();
        constructor(bOverride_TextShapingMethod: boolean, bOverride_TextFlowDirection: boolean, TextShapingMethod: UE.ETextShapingMethod, TextFlowDirection: UE.ETextFlowDirection);
        bOverride_TextShapingMethod: boolean;
        bOverride_TextFlowDirection: boolean;
        TextShapingMethod: UE.ETextShapingMethod;
        TextFlowDirection: UE.ETextFlowDirection;
        static StaticClass(): Class;
    }
    
    enum ETextCommit { Default, OnEnter, OnUserMovedFocus, OnCleared, ETextCommit_MAX}
    class EditableText extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Text: string;
        TextDelegate: $Delegate<() => string>;
        HintText: string;
        HintTextDelegate: $Delegate<() => string>;
        WidgetStyle: UE.EditableTextStyle;
        Style: UE.SlateWidgetStyleAsset;
        BackgroundImageSelected: UE.SlateBrushAsset;
        BackgroundImageComposing: UE.SlateBrushAsset;
        CaretImage: UE.SlateBrushAsset;
        Font: UE.SlateFontInfo;
        ColorAndOpacity: UE.SlateColor;
        IsReadOnly: boolean;
        IsPassword: boolean;
        MinimumDesiredWidth: number;
        IsCaretMovedWhenGainFocus: boolean;
        SelectAllTextWhenFocused: boolean;
        RevertTextOnEscape: boolean;
        ClearKeyboardFocusOnCommit: boolean;
        SelectAllTextOnCommit: boolean;
        AllowContextMenu: boolean;
        KeyboardType: UE.EVirtualKeyboardType;
        VirtualKeyboardOptions: UE.VirtualKeyboardOptions;
        VirtualKeyboardDismissAction: UE.EVirtualKeyboardDismissAction;
        Justification: UE.ETextJustify;
        ShapedTextOptions: UE.ShapedTextOptions;
        OnTextChanged: $MulticastDelegate<(Text: string) => void>;
        OnTextCommitted: $MulticastDelegate<(Text: string, CommitMethod: UE.ETextCommit) => void>;
        GetText() : string;
        OnEditableTextChangedEvent__DelegateSignature(Text: string) : void;
        OnEditableTextCommittedEvent__DelegateSignature(Text: string, CommitMethod: UE.ETextCommit) : void;
        SetHintText(InHintText: string) : void;
        SetIsPassword(InbIsPassword: boolean) : void;
        SetIsReadOnly(InbIsReadyOnly: boolean) : void;
        SetJustification(InJustification: UE.ETextJustify) : void;
        SetText(InText: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableText;
        static Load(InName: string): EditableText;
    }
    
    class ScrollBarStyle extends UE.SlateWidgetStyle {
        constructor();
        constructor(HorizontalBackgroundImage: UE.SlateBrush, VerticalBackgroundImage: UE.SlateBrush, VerticalTopSlotImage: UE.SlateBrush, HorizontalTopSlotImage: UE.SlateBrush, VerticalBottomSlotImage: UE.SlateBrush, HorizontalBottomSlotImage: UE.SlateBrush, NormalThumbImage: UE.SlateBrush, HoveredThumbImage: UE.SlateBrush, DraggedThumbImage: UE.SlateBrush);
        HorizontalBackgroundImage: UE.SlateBrush;
        VerticalBackgroundImage: UE.SlateBrush;
        VerticalTopSlotImage: UE.SlateBrush;
        HorizontalTopSlotImage: UE.SlateBrush;
        VerticalBottomSlotImage: UE.SlateBrush;
        HorizontalBottomSlotImage: UE.SlateBrush;
        NormalThumbImage: UE.SlateBrush;
        HoveredThumbImage: UE.SlateBrush;
        DraggedThumbImage: UE.SlateBrush;
        static StaticClass(): Class;
    }
    
    class EditableTextBoxStyle extends UE.SlateWidgetStyle {
        constructor();
        constructor(BackgroundImageNormal: UE.SlateBrush, BackgroundImageHovered: UE.SlateBrush, BackgroundImageFocused: UE.SlateBrush, BackgroundImageReadOnly: UE.SlateBrush, Padding: UE.Margin, Font: UE.SlateFontInfo, ForegroundColor: UE.SlateColor, BackgroundColor: UE.SlateColor, ReadOnlyForegroundColor: UE.SlateColor, HScrollBarPadding: UE.Margin, VScrollBarPadding: UE.Margin, ScrollBarStyle: UE.ScrollBarStyle);
        BackgroundImageNormal: UE.SlateBrush;
        BackgroundImageHovered: UE.SlateBrush;
        BackgroundImageFocused: UE.SlateBrush;
        BackgroundImageReadOnly: UE.SlateBrush;
        Padding: UE.Margin;
        Font: UE.SlateFontInfo;
        ForegroundColor: UE.SlateColor;
        BackgroundColor: UE.SlateColor;
        ReadOnlyForegroundColor: UE.SlateColor;
        HScrollBarPadding: UE.Margin;
        VScrollBarPadding: UE.Margin;
        ScrollBarStyle: UE.ScrollBarStyle;
        static StaticClass(): Class;
    }
    
    class EditableTextBox extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Text: string;
        TextDelegate: $Delegate<() => string>;
        WidgetStyle: UE.EditableTextBoxStyle;
        Style: UE.SlateWidgetStyleAsset;
        HintText: string;
        HintTextDelegate: $Delegate<() => string>;
        Font: UE.SlateFontInfo;
        ForegroundColor: UE.LinearColor;
        BackgroundColor: UE.LinearColor;
        ReadOnlyForegroundColor: UE.LinearColor;
        IsReadOnly: boolean;
        IsPassword: boolean;
        MinimumDesiredWidth: number;
        Padding: UE.Margin;
        IsCaretMovedWhenGainFocus: boolean;
        SelectAllTextWhenFocused: boolean;
        RevertTextOnEscape: boolean;
        ClearKeyboardFocusOnCommit: boolean;
        SelectAllTextOnCommit: boolean;
        AllowContextMenu: boolean;
        KeyboardType: UE.EVirtualKeyboardType;
        VirtualKeyboardOptions: UE.VirtualKeyboardOptions;
        VirtualKeyboardDismissAction: UE.EVirtualKeyboardDismissAction;
        Justification: UE.ETextJustify;
        ShapedTextOptions: UE.ShapedTextOptions;
        OnTextChanged: $MulticastDelegate<(Text: string) => void>;
        OnTextCommitted: $MulticastDelegate<(Text: string, CommitMethod: UE.ETextCommit) => void>;
        ClearError() : void;
        GetText() : string;
        HasError() : boolean;
        OnEditableTextBoxChangedEvent__DelegateSignature(Text: string) : void;
        OnEditableTextBoxCommittedEvent__DelegateSignature(Text: string, CommitMethod: UE.ETextCommit) : void;
        SetError(InError: string) : void;
        SetHintText(InText: string) : void;
        SetIsPassword(bIsPassword: boolean) : void;
        SetIsReadOnly(bReadOnly: boolean) : void;
        SetJustification(InJustification: UE.ETextJustify) : void;
        SetText(InText: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableTextBox;
        static Load(InName: string): EditableTextBox;
    }
    
    class EditableTextBoxWidgetStyle extends UE.SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditableTextBoxStyle: UE.EditableTextBoxStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableTextBoxWidgetStyle;
        static Load(InName: string): EditableTextBoxWidgetStyle;
    }
    
    class EditableTextWidgetStyle extends UE.SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditableTextStyle: UE.EditableTextStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableTextWidgetStyle;
        static Load(InName: string): EditableTextWidgetStyle;
    }
    
    enum EditConditionTestEnum { First, Second, EditConditionTestEnum_MAX}
    enum EditConditionByteEnum { First, Second, EditConditionByteEnum_MAX}
    class EditConditionTestObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoolProperty: boolean;
        EnumProperty: UE.EditConditionTestEnum;
        ByteEnumProperty: UE.EditConditionByteEnum;
        DoubleProperty: number;
        IntegerProperty: number;
        UintBitfieldProperty: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditConditionTestObject;
        static Load(InName: string): EditConditionTestObject;
    }
    
    class EditorActorFolders extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorActorFolders;
        static Load(InName: string): EditorActorFolders;
    }
    
    class EditorAnimBaseObj extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorAnimBaseObj;
        static Load(InName: string): EditorAnimBaseObj;
    }
    
    class EditorAnimCompositeSegment extends UE.EditorAnimBaseObj {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimSegment: UE.AnimSegment;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorAnimCompositeSegment;
        static Load(InName: string): EditorAnimCompositeSegment;
    }
    
    class EditorAnimCurveBoneLinks extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurveName: UE.SmartName;
        ConnectedBones: TArray<UE.BoneReference>;
        MaxLOD: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorAnimCurveBoneLinks;
        static Load(InName: string): EditorAnimCurveBoneLinks;
    }
    
    class EditorAnimSegment extends UE.EditorAnimBaseObj {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimSegment: UE.AnimSegment;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorAnimSegment;
        static Load(InName: string): EditorAnimSegment;
    }
    
    class EditorCompositeSection extends UE.EditorAnimBaseObj {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CompositeSection: UE.CompositeSection;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorCompositeSection;
        static Load(InName: string): EditorCompositeSection;
    }
    
    enum EWindowMode { Fullscreen, WindowedFullscreen, Windowed, EWindowMode_MAX}
    class GameUserSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseVSync: boolean;
        bUseDynamicResolution: boolean;
        ResolutionSizeX: number;
        ResolutionSizeY: number;
        LastUserConfirmedResolutionSizeX: number;
        LastUserConfirmedResolutionSizeY: number;
        WindowPosX: number;
        WindowPosY: number;
        FullscreenMode: number;
        LastConfirmedFullscreenMode: number;
        PreferredFullscreenMode: number;
        Version: number;
        AudioQualityLevel: number;
        LastConfirmedAudioQualityLevel: number;
        FrameRateLimit: number;
        DesiredScreenWidth: number;
        bUseDesiredScreenHeight: boolean;
        DesiredScreenHeight: number;
        LastUserConfirmedDesiredScreenWidth: number;
        LastUserConfirmedDesiredScreenHeight: number;
        LastRecommendedScreenWidth: number;
        LastRecommendedScreenHeight: number;
        LastCPUBenchmarkResult: number;
        LastGPUBenchmarkResult: number;
        LastCPUBenchmarkSteps: TArray<number>;
        LastGPUBenchmarkSteps: TArray<number>;
        LastGPUBenchmarkMultiplier: number;
        bUseHDRDisplayOutput: boolean;
        HDRDisplayOutputNits: number;
        OnGameUserSettingsUINeedsUpdate: $MulticastDelegate<() => void>;
        ApplyHardwareBenchmarkResults() : void;
        ApplyNonResolutionSettings() : void;
        ApplyResolutionSettings(bCheckForCommandLineOverrides: boolean) : void;
        ApplySettings(bCheckForCommandLineOverrides: boolean) : void;
        ConfirmVideoMode() : void;
        EnableHDRDisplayOutput(bEnable: boolean, DisplayNits?: number /* = 1000 */) : void;
        GetAntiAliasingQuality() : number;
        GetAudioQualityLevel() : number;
        GetCurrentHDRDisplayNits() : number;
        GetDefaultResolutionScale() : number;
        GetDesktopResolution() : UE.IntPoint;
        GetFoliageQuality() : number;
        GetFrameRateLimit() : number;
        GetFullscreenMode() : UE.EWindowMode;
        GetLastConfirmedFullscreenMode() : UE.EWindowMode;
        GetLastConfirmedScreenResolution() : UE.IntPoint;
        GetOverallScalabilityLevel() : number;
        GetPostProcessingQuality() : number;
        GetPreferredFullscreenMode() : UE.EWindowMode;
        GetRecommendedResolutionScale() : number;
        GetResolutionScaleInformation(CurrentScaleNormalized: $Ref<number>, CurrentScaleValue: $Ref<number>, MinScaleValue: $Ref<number>, MaxScaleValue: $Ref<number>) : void;
        GetResolutionScaleInformationEx(CurrentScaleNormalized: $Ref<number>, CurrentScaleValue: $Ref<number>, MinScaleValue: $Ref<number>, MaxScaleValue: $Ref<number>) : void;
        GetResolutionScaleNormalized() : number;
        GetScreenResolution() : UE.IntPoint;
        GetShadingQuality() : number;
        GetShadowQuality() : number;
        GetTextureQuality() : number;
        GetViewDistanceQuality() : number;
        GetVisualEffectQuality() : number;
        IsDirty() : boolean;
        IsDynamicResolutionDirty() : boolean;
        IsDynamicResolutionEnabled() : boolean;
        IsFullscreenModeDirty() : boolean;
        IsHDREnabled() : boolean;
        IsScreenResolutionDirty() : boolean;
        IsVSyncDirty() : boolean;
        IsVSyncEnabled() : boolean;
        LoadSettings(bForceReload?: boolean /* = false */) : void;
        ResetToCurrentSettings() : void;
        RevertVideoMode() : void;
        RunHardwareBenchmark(WorkScale?: number /* = 10 */, CPUMultiplier?: number /* = 1.000000 */, GPUMultiplier?: number /* = 1.000000 */) : void;
        SaveSettings() : void;
        SetAntiAliasingQuality(Value: number) : void;
        SetAudioQualityLevel(QualityLevel: number) : void;
        SetBenchmarkFallbackValues() : void;
        SetDynamicResolutionEnabled(bEnable: boolean) : void;
        SetFoliageQuality(Value: number) : void;
        SetFrameRateLimit(NewLimit: number) : void;
        SetFullscreenMode(InFullscreenMode: UE.EWindowMode) : void;
        SetOverallScalabilityLevel(Value: number) : void;
        SetPostProcessingQuality(Value: number) : void;
        SetResolutionScaleNormalized(NewScaleNormalized: number) : void;
        SetResolutionScaleValue(NewScaleValue: number) : void;
        SetResolutionScaleValueEx(NewScaleValue: number) : void;
        SetScreenResolution(Resolution: UE.IntPoint) : void;
        SetShadingQuality(Value: number) : void;
        SetShadowQuality(Value: number) : void;
        SetTextureQuality(Value: number) : void;
        SetToDefaults() : void;
        SetViewDistanceQuality(Value: number) : void;
        SetVisualEffectQuality(Value: number) : void;
        SetVSyncEnabled(bEnable: boolean) : void;
        SupportsHDRDisplayOutput() : boolean;
        ValidateSettings() : void;
        static GetDefaultResolution() : UE.IntPoint;
        static GetDefaultWindowMode() : UE.EWindowMode;
        static GetDefaultWindowPosition() : UE.IntPoint;
        static GetGameUserSettings() : UE.GameUserSettings;
        static GetSyncInterval() : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameUserSettings;
        static Load(InName: string): GameUserSettings;
    }
    
    class StatColorMapEntry {
        constructor();
        constructor(In: number, Out: UE.Color);
        In: number;
        Out: UE.Color;
        static StaticClass(): Class;
    }
    
    class StatColorMapping {
        constructor();
        constructor(StatName: string, ColorMap: TArray<UE.StatColorMapEntry>, DisableBlend: boolean);
        StatName: string;
        ColorMap: TArray<UE.StatColorMapEntry>;
        DisableBlend: boolean;
        static StaticClass(): Class;
    }
    
    class GameNameRedirect {
        constructor();
        constructor(OldGameName: string, NewGameName: string);
        OldGameName: string;
        NewGameName: string;
        static StaticClass(): Class;
    }
    
    class ClassRedirect {
        constructor();
        constructor(ObjectName: string, OldClassName: string, NewClassName: string, OldSubobjName: string, NewSubobjName: string, NewClassClass: string, NewClassPackage: string, InstanceOnly: boolean);
        ObjectName: string;
        OldClassName: string;
        NewClassName: string;
        OldSubobjName: string;
        NewSubobjName: string;
        NewClassClass: string;
        NewClassPackage: string;
        InstanceOnly: boolean;
        static StaticClass(): Class;
    }
    
    class PluginRedirect {
        constructor();
        constructor(OldPluginName: string, NewPluginName: string);
        OldPluginName: string;
        NewPluginName: string;
        static StaticClass(): Class;
    }
    
    class StructRedirect {
        constructor();
        constructor(OldStructName: string, NewStructName: string);
        OldStructName: string;
        NewStructName: string;
        static StaticClass(): Class;
    }
    
    class EngineCustomTimeStep extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EngineCustomTimeStep;
        static Load(InName: string): EngineCustomTimeStep;
    }
    
    enum ETimecodeProviderSynchronizationState { Closed, Error, Synchronized, Synchronizing, ETimecodeProviderSynchronizationState_MAX}
    class TimecodeProvider extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FrameDelay: number;
        GetDelayedTimecode() : UE.Timecode;
        GetFrameRate() : UE.FrameRate;
        GetSynchronizationState() : UE.ETimecodeProviderSynchronizationState;
        GetTimecode() : UE.Timecode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TimecodeProvider;
        static Load(InName: string): TimecodeProvider;
    }
    
    enum ETransitionType { None, Paused, Loading, Saving, Connecting, Precaching, WaitingToConnect, MAX}
    class DropNoteInfo {
        constructor();
        constructor(Location: UE.Vector, Rotation: UE.Rotator, Comment: string);
        Location: UE.Vector;
        Rotation: UE.Rotator;
        Comment: string;
        static StaticClass(): Class;
    }
    
    class NetDriverDefinition {
        constructor();
        constructor(DefName: string, DriverClassName: string, DriverClassNameFallback: string);
        DefName: string;
        DriverClassName: string;
        DriverClassNameFallback: string;
        static StaticClass(): Class;
    }
    
    class Engine extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TinyFont: UE.Font;
        TinyFontName: UE.SoftObjectPath;
        SmallFont: UE.Font;
        SmallFontName: UE.SoftObjectPath;
        MediumFont: UE.Font;
        MediumFontName: UE.SoftObjectPath;
        LargeFont: UE.Font;
        LargeFontName: UE.SoftObjectPath;
        SubtitleFont: UE.Font;
        SubtitleFontName: UE.SoftObjectPath;
        AdditionalFonts: TArray<UE.Font>;
        AdditionalFontNames: TArray<string>;
        ConsoleClass: UE.Class;
        ConsoleClassName: UE.SoftClassPath;
        GameViewportClientClass: UE.Class;
        GameViewportClientClassName: UE.SoftClassPath;
        LocalPlayerClass: UE.Class;
        LocalPlayerClassName: UE.SoftClassPath;
        WorldSettingsClass: UE.Class;
        WorldSettingsClassName: UE.SoftClassPath;
        NavigationSystemClassName: UE.SoftClassPath;
        NavigationSystemClass: UE.Class;
        NavigationSystemConfigClassName: UE.SoftClassPath;
        NavigationSystemConfigClass: UE.Class;
        AvoidanceManagerClassName: UE.SoftClassPath;
        AvoidanceManagerClass: UE.Class;
        PhysicsCollisionHandlerClass: UE.Class;
        PhysicsCollisionHandlerClassName: UE.SoftClassPath;
        GameUserSettingsClassName: UE.SoftClassPath;
        GameUserSettingsClass: UE.Class;
        AIControllerClassName: UE.SoftClassPath;
        GameUserSettings: UE.GameUserSettings;
        LevelScriptActorClass: UE.Class;
        LevelScriptActorClassName: UE.SoftClassPath;
        DefaultBlueprintBaseClassName: UE.SoftClassPath;
        GameSingletonClassName: UE.SoftClassPath;
        GameSingleton: UE.Object;
        AssetManagerClassName: UE.SoftClassPath;
        AssetManager: UE.AssetManager;
        DefaultTexture: UE.Texture2D;
        DefaultTextureName: UE.SoftObjectPath;
        DefaultDiffuseTexture: UE.Texture;
        DefaultDiffuseTextureName: UE.SoftObjectPath;
        DefaultBSPVertexTexture: UE.Texture2D;
        DefaultBSPVertexTextureName: UE.SoftObjectPath;
        HighFrequencyNoiseTexture: UE.Texture2D;
        HighFrequencyNoiseTextureName: UE.SoftObjectPath;
        DefaultBokehTexture: UE.Texture2D;
        DefaultBokehTextureName: UE.SoftObjectPath;
        DefaultBloomKernelTexture: UE.Texture2D;
        DefaultBloomKernelTextureName: UE.SoftObjectPath;
        WireframeMaterial: UE.Material;
        WireframeMaterialName: string;
        HairDefaultMaterial: UE.Material;
        HairDefaultMaterialName: string;
        HairDebugMaterial: UE.Material;
        HairDebugMaterialName: string;
        GeomMaterial: UE.Material;
        GeomMaterialName: UE.SoftObjectPath;
        DebugMeshMaterial: UE.Material;
        DebugMeshMaterialName: UE.SoftObjectPath;
        EmissiveMeshMaterial: UE.Material;
        EmissiveMeshMaterialName: UE.SoftObjectPath;
        LevelColorationLitMaterial: UE.Material;
        LevelColorationLitMaterialName: string;
        LevelColorationUnlitMaterial: UE.Material;
        LevelColorationUnlitMaterialName: string;
        LightingTexelDensityMaterial: UE.Material;
        LightingTexelDensityName: string;
        ShadedLevelColorationLitMaterial: UE.Material;
        ShadedLevelColorationLitMaterialName: string;
        ShadedLevelColorationUnlitMaterial: UE.Material;
        ShadedLevelColorationUnlitMaterialName: string;
        RemoveSurfaceMaterial: UE.Material;
        RemoveSurfaceMaterialName: UE.SoftObjectPath;
        VertexColorMaterial: UE.Material;
        VertexColorMaterialName: string;
        VertexColorViewModeMaterial_ColorOnly: UE.Material;
        VertexColorViewModeMaterialName_ColorOnly: string;
        VertexColorViewModeMaterial_AlphaAsColor: UE.Material;
        VertexColorViewModeMaterialName_AlphaAsColor: string;
        VertexColorViewModeMaterial_RedOnly: UE.Material;
        VertexColorViewModeMaterialName_RedOnly: string;
        VertexColorViewModeMaterial_GreenOnly: UE.Material;
        VertexColorViewModeMaterialName_GreenOnly: string;
        VertexColorViewModeMaterial_BlueOnly: UE.Material;
        VertexColorViewModeMaterialName_BlueOnly: string;
        BoneWeightMaterial: UE.Material;
        BoneWeightMaterialName: UE.SoftObjectPath;
        ClothPaintMaterial: UE.Material;
        ClothPaintMaterialWireframe: UE.Material;
        ClothPaintMaterialInstance: UE.MaterialInstanceDynamic;
        ClothPaintMaterialWireframeInstance: UE.MaterialInstanceDynamic;
        ClothPaintMaterialName: UE.SoftObjectPath;
        ClothPaintMaterialWireframeName: UE.SoftObjectPath;
        DebugEditorMaterial: UE.Material;
        DebugEditorMaterialName: UE.SoftObjectPath;
        ConstraintLimitMaterial: UE.Material;
        ConstraintLimitMaterialX: UE.MaterialInstanceDynamic;
        ConstraintLimitMaterialXAxis: UE.MaterialInstanceDynamic;
        ConstraintLimitMaterialY: UE.MaterialInstanceDynamic;
        ConstraintLimitMaterialYAxis: UE.MaterialInstanceDynamic;
        ConstraintLimitMaterialZ: UE.MaterialInstanceDynamic;
        ConstraintLimitMaterialZAxis: UE.MaterialInstanceDynamic;
        ConstraintLimitMaterialPrismatic: UE.MaterialInstanceDynamic;
        InvalidLightmapSettingsMaterial: UE.Material;
        InvalidLightmapSettingsMaterialName: UE.SoftObjectPath;
        PreviewShadowsIndicatorMaterial: UE.Material;
        PreviewShadowsIndicatorMaterialName: UE.SoftObjectPath;
        ArrowMaterial: UE.Material;
        ArrowMaterialYellow: UE.MaterialInstanceDynamic;
        ArrowMaterialName: UE.SoftObjectPath;
        LightingOnlyBrightness: UE.LinearColor;
        ShaderComplexityColors: TArray<UE.LinearColor>;
        QuadComplexityColors: TArray<UE.LinearColor>;
        LightComplexityColors: TArray<UE.LinearColor>;
        StationaryLightOverlapColors: TArray<UE.LinearColor>;
        LODColorationColors: TArray<UE.LinearColor>;
        HLODColorationColors: TArray<UE.LinearColor>;
        StreamingAccuracyColors: TArray<UE.LinearColor>;
        MaxPixelShaderAdditiveComplexityCount: number;
        MaxES2PixelShaderAdditiveComplexityCount: number;
        MaxES3PixelShaderAdditiveComplexityCount: number;
        MinLightMapDensity: number;
        IdealLightMapDensity: number;
        MaxLightMapDensity: number;
        bRenderLightMapDensityGrayscale: boolean;
        RenderLightMapDensityGrayscaleScale: number;
        RenderLightMapDensityColorScale: number;
        LightMapDensityVertexMappedColor: UE.LinearColor;
        LightMapDensitySelectedColor: UE.LinearColor;
        StatColorMappings: TArray<UE.StatColorMapping>;
        EditorBrushMaterial: UE.Material;
        EditorBrushMaterialName: UE.SoftObjectPath;
        DefaultPhysMaterial: UE.PhysicalMaterial;
        DefaultPhysMaterialName: UE.SoftObjectPath;
        ActiveGameNameRedirects: TArray<UE.GameNameRedirect>;
        ActiveClassRedirects: TArray<UE.ClassRedirect>;
        ActivePluginRedirects: TArray<UE.PluginRedirect>;
        ActiveStructRedirects: TArray<UE.StructRedirect>;
        PreIntegratedSkinBRDFTexture: UE.Texture2D;
        PreIntegratedSkinBRDFTextureName: UE.SoftObjectPath;
        BlueNoiseTexture: UE.Texture2D;
        BlueNoiseTextureName: UE.SoftObjectPath;
        MiniFontTexture: UE.Texture2D;
        MiniFontTextureName: UE.SoftObjectPath;
        WeightMapPlaceholderTexture: UE.Texture;
        WeightMapPlaceholderTextureName: UE.SoftObjectPath;
        LightMapDensityTexture: UE.Texture2D;
        LightMapDensityTextureName: UE.SoftObjectPath;
        GameViewport: UE.GameViewportClient;
        DeferredCommands: TArray<string>;
        TickCycles: number;
        GameCycles: number;
        ClientCycles: number;
        NearClipPlane: number;
        bHardwareSurveyEnabled: boolean;
        bSubtitlesEnabled: boolean;
        bSubtitlesForcedOff: boolean;
        MaximumLoopIterationCount: number;
        bCanBlueprintsTickByDefault: boolean;
        bOptimizeAnimBlueprintMemberVariableAccess: boolean;
        bAllowMultiThreadedAnimationUpdate: boolean;
        bEnableEditorPSysRealtimeLOD: boolean;
        bSmoothFrameRate: boolean;
        bUseFixedFrameRate: boolean;
        FixedFrameRate: number;
        SmoothedFrameRateRange: UE.FloatRange;
        DefaultCustomTimeStep: UE.EngineCustomTimeStep;
        CurrentCustomTimeStep: UE.EngineCustomTimeStep;
        CustomTimeStepClassName: UE.SoftClassPath;
        DefaultTimecodeProvider: UE.TimecodeProvider;
        CustomTimecodeProvider: UE.TimecodeProvider;
        DefaultTimecodeProviderClassName: UE.SoftClassPath;
        TimecodeProviderClassName: UE.SoftClassPath;
        DefaultTimecodeFrameRate: UE.FrameRate;
        bCheckForMultiplePawnsSpawnedInAFrame: boolean;
        NumPawnsAllowedToBeSpawnedInAFrame: number;
        bShouldGenerateLowQualityLightmaps: boolean;
        C_WorldBox: UE.Color;
        C_BrushWire: UE.Color;
        C_AddWire: UE.Color;
        C_SubtractWire: UE.Color;
        C_SemiSolidWire: UE.Color;
        C_NonSolidWire: UE.Color;
        C_WireBackground: UE.Color;
        C_ScaleBoxHi: UE.Color;
        C_VolumeCollision: UE.Color;
        C_BSPCollision: UE.Color;
        C_OrthoBackground: UE.Color;
        C_Volume: UE.Color;
        C_BrushShape: UE.Color;
        StreamingDistanceFactor: number;
        GameScreenshotSaveDirectory: UE.DirectoryPath;
        TransitionType: UE.ETransitionType;
        TransitionDescription: string;
        TransitionGameMode: string;
        MeshLODRange: number;
        bAllowMatureLanguage: boolean;
        CameraRotationThreshold: number;
        CameraTranslationThreshold: number;
        PrimitiveProbablyVisibleTime: number;
        MaxOcclusionPixelsFraction: number;
        bPauseOnLossOfFocus: boolean;
        MaxParticleResize: number;
        MaxParticleResizeWarn: number;
        PendingDroppedNotes: TArray<UE.DropNoteInfo>;
        NetClientTicksPerSecond: number;
        DisplayGamma: number;
        MinDesiredFrameRate: number;
        DefaultSelectedMaterialColor: UE.LinearColor;
        SelectedMaterialColor: UE.LinearColor;
        SelectionOutlineColor: UE.LinearColor;
        SubduedSelectionOutlineColor: UE.LinearColor;
        SelectedMaterialColorOverride: UE.LinearColor;
        bIsOverridingSelectedColor: boolean;
        bEnableOnScreenDebugMessages: boolean;
        bEnableOnScreenDebugMessagesDisplay: boolean;
        bSuppressMapWarnings: boolean;
        bDisableAILogging: boolean;
        bEnableVisualLogRecordingOnStart: number;
        ScreenSaverInhibitorSemaphore: number;
        bLockReadOnlyLevels: boolean;
        ParticleEventManagerClassPath: string;
        SelectionHighlightIntensity: number;
        BSPSelectionHighlightIntensity: number;
        SelectionHighlightIntensityBillboards: number;
        NetDriverDefinitions: TArray<UE.NetDriverDefinition>;
        ServerActors: TArray<string>;
        RuntimeServerActors: TArray<string>;
        NetErrorLogInterval: number;
        bStartedLoadMapMovie: boolean;
        NextWorldContextHandle: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Engine;
        static Load(InName: string): Engine;
    }
    
    class Transactor extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Transactor;
        static Load(InName: string): Transactor;
    }
    
    class EditorWorldExtensionCollection extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorWorldExtensionCollection;
        static Load(InName: string): EditorWorldExtensionCollection;
    }
    
    class EditorWorldExtensionManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditorWorldExtensionCollection: TArray<UE.EditorWorldExtensionCollection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorWorldExtensionManager;
        static Load(InName: string): EditorWorldExtensionManager;
    }
    
    class EditorEngine extends UE.Engine {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TempModel: UE.Model;
        ConversionTempModel: UE.Model;
        Trans: UE.Transactor;
        Bad: UE.Texture2D;
        EditorFont: UE.Font;
        PreviewSoundCue: UE.SoundCue;
        PreviewAudioComponent: UE.AudioComponent;
        EditorCube: UE.StaticMesh;
        EditorSphere: UE.StaticMesh;
        EditorPlane: UE.StaticMesh;
        EditorCylinder: UE.StaticMesh;
        bFastRebuild: boolean;
        IsImportingT3D: boolean;
        ClickFlags: number;
        ParentContext: UE.Package;
        UnsnappedClickLocation: UE.Vector;
        ClickLocation: UE.Vector;
        ClickPlane: UE.Plane;
        MouseMovement: UE.Vector;
        DetailMode: UE.EDetailMode;
        UseSizingBox: boolean;
        UseAxisIndicator: boolean;
        GodMode: boolean;
        GameCommandLine: string;
        bShowBrushMarkerPolys: boolean;
        bEnableSocketSnapping: boolean;
        bEnableLODLocking: boolean;
        HeightMapExportClassName: string;
        ActorFactories: TArray<UE.ActorFactory>;
        UserOpenedFile: string;
        InEditorGameURLOptions: string;
        PlayWorld: UE.World;
        PlayWorldLocation: UE.Vector;
        PlayWorldRotation: UE.Rotator;
        bIsPlayWorldQueued: boolean;
        bIsToggleBetweenPIEandSIEQueued: boolean;
        bIsSimulateInEditorQueued: boolean;
        bAllowMultiplePIEWorlds: boolean;
        bRequestEndPlayMapQueued: boolean;
        bHasPlayWorldPlacement: boolean;
        bUseMobilePreviewForPlayWorld: boolean;
        bUseVRPreviewForPlayWorld: boolean;
        bIsSimulatingInEditor: boolean;
        bSquelchTransactionNotification: boolean;
        bNotifyUndoRedoSelectionChange: boolean;
        PlayFromHerePlayerStartClass: UE.Class;
        EditorWorld: UE.World;
        ActorsThatWereSelected: TArray<TWeakObjectPtr<UE.Actor>>;
        PlayWorldDestination: number;
        CurrentPlayWorldDestination: number;
        bMobilePreviewPortrait: boolean;
        BuildPlayDevice: number;
        PlayInEditorViewportIndex: number;
        UserEditedPlayWorldURL: string;
        ScratchRenderTarget2048: UE.TextureRenderTarget2D;
        ScratchRenderTarget1024: UE.TextureRenderTarget2D;
        ScratchRenderTarget512: UE.TextureRenderTarget2D;
        ScratchRenderTarget256: UE.TextureRenderTarget2D;
        PreviewMeshComp: UE.StaticMeshComponent;
        PreviewMeshIndex: number;
        bShowPreviewMesh: boolean;
        bCustomCameraAlignEmitter: boolean;
        CustomCameraAlignEmitterDistance: number;
        bDrawSocketsInGMode: boolean;
        bDrawParticleHelpers: boolean;
        BrushBuilders: TArray<UE.BrushBuilder>;
        EditorWorldExtensionsManager: UE.EditorWorldExtensionManager;
        ActorGroupingUtilsClassName: UE.SoftClassPath;
        ActorGroupingUtils: UE.ActorGroupingUtils;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorEngine;
        static Load(InName: string): EditorEngine;
    }
    
    enum EConsoleForGamepadLabels { None, XBoxOne, PS4, EConsoleForGamepadLabels_MAX}
    class EditorExperimentalSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bHDREditor: boolean;
        HDREditorNITLevel: number;
        bProceduralFoliage: boolean;
        bEnableLocalizationDashboard: boolean;
        bEnableTranslationPicker: boolean;
        bEnableFavoriteSystem: boolean;
        ConsoleForGamepadLabels: UE.EConsoleForGamepadLabels;
        bToolbarCustomization: boolean;
        bBreakOnExceptions: boolean;
        bEnableFindAndReplaceReferences: boolean;
        BaseClassesToAllowRecompilingDuringPlayInEditor: TArray<TSoftClassPtr<UE.Object>>;
        ResolvedBaseClassesToAllowRecompilingDuringPlayInEditor: TArray<UE.Class>;
        bDrawMidpointArrowsInBlueprints: boolean;
        bContextMenuChunkAssignments: boolean;
        bDisableCookInEditor: boolean;
        bSharedCookedBuilds: boolean;
        MultiProcessCooking: number;
        bEQSEditor: boolean;
        bAllowLateJoinInPIE: boolean;
        bAllowVulkanPreview: boolean;
        bEnableMultithreadedLightmapEncoding: boolean;
        bEnableMultithreadedShadowmapEncoding: boolean;
        bUseOpenCLForConvexHullDecomp: boolean;
        bAllowPotentiallyUnsafePropertyEditing: boolean;
        bFacialAnimationImporter: boolean;
        bMobilePIEPreviewDeviceLaunch: boolean;
        bTextAssetFormatSupport: boolean;
        bExampleLayersAndBlends: boolean;
        bEnableLongPathsSupport: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorExperimentalSettings;
        static Load(InName: string): EditorExperimentalSettings;
    }
    
    class EditorKeyboardShortcutSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorKeyboardShortcutSettings;
        static Load(InName: string): EditorKeyboardShortcutSettings;
    }
    
    enum ELevelVisibilityDirtyMode { ModifyOnChange, DontModify, ELevelVisibilityDirtyMode_MAX}
    class EditorLevelUtils extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CreateNewStreamingLevel(LevelStreamingClass: $Nullable<UE.Class>, NewLevelPath?: string /* = "" */, bMoveSelectedActorsIntoNewLevel?: boolean /* = false */) : UE.LevelStreaming;
        static MakeLevelCurrent(InStreamingLevel: $Nullable<UE.LevelStreaming>) : void;
        static MoveActorsToLevel(ActorsToMove: TArray<UE.Actor>, DestStreamingLevel: $Nullable<UE.LevelStreaming>, bWarnAboutReferences?: boolean /* = true */) : number;
        static MoveSelectedActorsToLevel(DestLevel: $Nullable<UE.LevelStreaming>, bWarnAboutReferences?: boolean /* = true */) : number;
        static SetLevelsVisibility(Levels: TArray<UE.Level>, bShouldBeVisible: TArray<boolean>, bForceLayersVisible: boolean, ModifyMode?: UE.ELevelVisibilityDirtyMode /* = ModifyOnChange */) : void;
        static SetLevelVisibility(Level: $Nullable<UE.Level>, bShouldBeVisible: boolean, bForceLayersVisible: boolean, ModifyMode?: UE.ELevelVisibilityDirtyMode /* = ModifyOnChange */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorLevelUtils;
        static Load(InName: string): EditorLevelUtils;
    }
    
    class EditorLoadingAndSavingUtils extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ExportScene(bExportSelectedActorsOnly: boolean) : void;
        static GetDirtyContentPackages(OutDirtyPackages: $Ref<TArray<UE.Package>>) : void;
        static GetDirtyMapPackages(OutDirtyPackages: $Ref<TArray<UE.Package>>) : void;
        static ImportScene(Filename: string) : void;
        static LoadMap(Filename: string) : UE.World;
        static LoadMapWithDialog() : UE.World;
        static NewBlankMap(bSaveExistingMap: boolean) : UE.World;
        static NewMapFromTemplate(PathToTemplateLevel: string, bSaveExistingMap: boolean) : UE.World;
        static SaveCurrentLevel() : boolean;
        static SaveDirtyPackages(bSaveMapPackages: boolean, bSaveContentPackages: boolean) : boolean;
        static SaveDirtyPackagesWithDialog(bSaveMapPackages: boolean, bSaveContentPackages: boolean) : boolean;
        static SaveMap(World: $Nullable<UE.World>, AssetPath: string) : boolean;
        static SavePackages(PackagesToSave: TArray<UE.Package>, bOnlyDirty: boolean) : boolean;
        static SavePackagesWithDialog(PackagesToSave: TArray<UE.Package>, bOnlyDirty: boolean) : boolean;
        static UnloadPackages(PackagesToUnload: TArray<UE.Package>, bOutAnyPackagesUnloaded: $Ref<boolean>, OutErrorMessage: $Ref<string>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorLoadingAndSavingUtils;
        static Load(InName: string): EditorLoadingAndSavingUtils;
    }
    
    enum ELoadLevelAtStartup { None, ProjectDefault, LastOpened, ELoadLevelAtStartup_MAX}
    class AutoReimportWildcard {
        constructor();
        constructor(Wildcard: string, bInclude: boolean);
        Wildcard: string;
        bInclude: boolean;
        static StaticClass(): Class;
    }
    
    class AutoReimportDirectoryConfig {
        constructor();
        constructor(SourceDirectory: string, MountPoint: string, Wildcards: TArray<UE.AutoReimportWildcard>);
        SourceDirectory: string;
        MountPoint: string;
        Wildcards: TArray<UE.AutoReimportWildcard>;
        static StaticClass(): Class;
    }
    
    class EditorLoadingSavingSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LoadLevelAtStartup: UE.ELoadLevelAtStartup;
        bForceCompilationAtStartup: boolean;
        bRestoreOpenAssetTabsOnRestart: boolean;
        bEnableSourceControlCompatabilityCheck: boolean;
        bMonitorContentDirectories: boolean;
        AutoReimportDirectories: TArray<string>;
        AutoReimportDirectorySettings: TArray<UE.AutoReimportDirectoryConfig>;
        AutoReimportThreshold: number;
        bAutoCreateAssets: boolean;
        bAutoDeleteAssets: boolean;
        bDetectChangesOnStartup: boolean;
        bPromptBeforeAutoImporting: boolean;
        bDeleteSourceFilesWithAssets: boolean;
        bAutoReimportTextures: boolean;
        bAutoReimportCSV: boolean;
        bDirtyMigratedBlueprints: boolean;
        bAutoSaveEnable: boolean;
        bAutoSaveMaps: boolean;
        bAutoSaveContent: boolean;
        AutoSaveTimeMinutes: number;
        AutoSaveInteractionDelayInSeconds: number;
        AutoSaveWarningInSeconds: number;
        bAutomaticallyCheckoutOnAssetModification: boolean;
        bPromptForCheckoutOnAssetModification: boolean;
        bSCCAutoAddNewFiles: boolean;
        bSCCUseGlobalSettings: boolean;
        TextDiffToolPath: UE.FilePath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorLoadingSavingSettings;
        static Load(InName: string): EditorLoadingSavingSettings;
    }
    
    class EditorMiscSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorMiscSettings;
        static Load(InName: string): EditorMiscSettings;
    }
    
    class EditorNotifyObject extends UE.EditorAnimBaseObj {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Event: UE.AnimNotifyEvent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorNotifyObject;
        static Load(InName: string): EditorNotifyObject;
    }
    
    class EditorParentPlayerListObj extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Overrides: TArray<UE.AnimParentNodeAssetOverride>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorParentPlayerListObj;
        static Load(InName: string): EditorParentPlayerListObj;
    }
    
    class EditorPerformanceSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bShowFrameRateAndMemory: boolean;
        bThrottleCPUWhenNotForeground: boolean;
        bMonitorEditorPerformance: boolean;
        bOverrideDPIBasedEditorViewportScaling: boolean;
        bEnableSharedDDCPerformanceNotifications: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorPerformanceSettings;
        static Load(InName: string): EditorPerformanceSettings;
    }
    
    class EditorPerProjectUserSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDisplayUIExtensionPoints: boolean;
        bDisplayDocumentationLink: boolean;
        bDisplayActionListItemRefIds: boolean;
        bAlwaysGatherBehaviorTreeDebuggerData: boolean;
        bDisplayBlackboardKeysInAlphabeticalOrder: boolean;
        bDisplayEngineVersionInBadge: boolean;
        bUseSimplygonSwarm: boolean;
        SimplygonServerIP: string;
        bEnableSwarmDebugging: boolean;
        SimplygonSwarmDelay: number;
        SwarmNumOfConcurrentJobs: number;
        SwarmMaxUploadChunkSizeInMB: number;
        SwarmIntermediateFolder: string;
        bAutomaticallyHotReloadNewClasses: boolean;
        bShowCompilerLogOnCompileError: boolean;
        bKeepFbxNamespace: boolean;
        bShowImportDialogAtReimport: boolean;
        DataSourceFolder: UE.DirectoryPath;
        bKeepAttachHierarchy: boolean;
        bAnimationReimportWarnings: boolean;
        bUseCurvesForDistributions: boolean;
        PropertyMatrix_NumberOfPasteOperationsBeforeWarning: number;
        bSCSEditorShowGrid: boolean;
        bSCSEditorShowFloor: boolean;
        bGetAttentionOnUATCompletion: boolean;
        SCSViewportCameraSpeed: number;
        bAutoloadCheckedOutPackages: boolean;
        bSuppressFullyLoadPrompt: boolean;
        bAllowSelectTranslucent: boolean;
        BlueprintFavorites: UE.BlueprintPaletteFavorites;
        AssetViewerProfileIndex: number;
        AssetViewerProfileName: string;
        MaterialQualityLevel: number;
        PreviewFeatureLevel: number;
        PreviewShaderFormatName: string;
        bPreviewFeatureLevelActive: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorPerProjectUserSettings;
        static Load(InName: string): EditorPerProjectUserSettings;
    }
    
    enum EUnit { Micrometers, Millimeters, Centimeters, Meters, Kilometers, Inches, Feet, Yards, Miles, Lightyears, Degrees, Radians, MetersPerSecond, KilometersPerHour, MilesPerHour, Celsius, Farenheit, Kelvin, Micrograms, Milligrams, Grams, Kilograms, MetricTons, Ounces, Pounds, Stones, Newtons, PoundsForce, KilogramsForce, Hertz, Kilohertz, Megahertz, Gigahertz, RevolutionsPerMinute, Bytes, Kilobytes, Megabytes, Gigabytes, Terabytes, Lumens, Milliseconds, Seconds, Minutes, Hours, Days, Months, Years, Multiplier, Percentage, Unspecified, EUnit_MAX}
    enum EUnitDisplay { None, Metric, Imperial, Invalid, EUnitDisplay_MAX}
    enum EDefaultLocationUnit { Micrometers, Millimeters, Centimeters, Meters, Kilometers, Inches, Feet, Yards, Miles, Invalid, EDefaultLocationUnit_MAX}
    class EditorProjectAppearanceSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDisplayUnits: boolean;
        bDisplayUnitsOnComponentTransforms: boolean;
        DistanceUnits: TArray<UE.EUnit>;
        MassUnits: TArray<UE.EUnit>;
        TimeUnits: TArray<UE.EUnit>;
        AngleUnits: UE.EUnit;
        SpeedUnits: UE.EUnit;
        TemperatureUnits: UE.EUnit;
        ForceUnits: UE.EUnit;
        UnitDisplay: UE.EUnitDisplay;
        DefaultInputUnits: UE.EDefaultLocationUnit;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorProjectAppearanceSettings;
        static Load(InName: string): EditorProjectAppearanceSettings;
    }
    
    class EditorSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bLoadTheMostRecentlyLoadedProjectAtStartup: boolean;
        bEditorAnalyticsEnabled: boolean;
        LocalDerivedDataCache: UE.DirectoryPath;
        SharedDerivedDataCache: UE.DirectoryPath;
        RecentlyOpenedProjectFiles: TArray<string>;
        CreatedProjectPaths: TArray<string>;
        bCopyStarterContentPreference: boolean;
        CompletedSurveys: TArray<UE.Guid>;
        InProgressSurveys: TArray<UE.Guid>;
        AutoScalabilityWorkScaleAmount: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorSettings;
        static Load(InName: string): EditorSettings;
    }
    
    class EditorSkeletonNotifyObj extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Name: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorSkeletonNotifyObj;
        static Load(InName: string): EditorSkeletonNotifyObj;
    }
    
    enum EColorVisionDeficiency { NormalVision, Deuteranope, Protanope, Tritanope, EColorVisionDeficiency_MAX}
    enum ELogTimes { None, UTC, SinceGStartTime, Local, ELogTimes_MAX}
    enum EAssetEditorOpenLocation { Default, NewWindow, MainWindow, ContentBrowser, LastDockedWindowOrNewWindow, LastDockedWindowOrMainWindow, LastDockedWindowOrContentBrowser, EAssetEditorOpenLocation_MAX}
    class EditorStyleSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnableHighDPIAwareness: boolean;
        bEnableUserEditorLayoutManagement: boolean;
        ColorVisionDeficiencyPreviewType: UE.EColorVisionDeficiency;
        ColorVisionDeficiencySeverity: number;
        bColorVisionDeficiencyCorrection: boolean;
        bColorVisionDeficiencyCorrectionPreviewWithDeficiency: boolean;
        SelectionColor: UE.LinearColor;
        PressedSelectionColor: UE.LinearColor;
        InactiveSelectionColor: UE.LinearColor;
        KeyboardFocusColor: UE.LinearColor;
        EditorWindowBackgroundColor: UE.LinearColor;
        EditorMainWindowBackgroundOverride: UE.SlateBrush;
        EditorChildWindowBackgroundOverride: UE.SlateBrush;
        bResetEditorWindowBackgroundSettings: boolean;
        bUseSmallToolBarIcons: boolean;
        bUseGrid: boolean;
        RegularColor: UE.LinearColor;
        RuleColor: UE.LinearColor;
        CenterColor: UE.LinearColor;
        GridSnapSize: number;
        bEnableWindowAnimations: boolean;
        bShowFriendlyNames: boolean;
        bExpandConfigurationMenus: boolean;
        bShowProjectMenus: boolean;
        bShowLaunchMenus: boolean;
        LogBackgroundColor: UE.LinearColor;
        LogSelectionBackgroundColor: UE.LinearColor;
        LogNormalColor: UE.LinearColor;
        LogCommandColor: UE.LinearColor;
        LogWarningColor: UE.LinearColor;
        LogErrorColor: UE.LinearColor;
        bShowAllAdvancedDetails: boolean;
        bShowHiddenPropertiesWhilePlaying: boolean;
        LogFontSize: number;
        LogTimestampMode: UE.ELogTimes;
        bPromoteOutputLogWarningsDuringPIE: boolean;
        AssetEditorOpenLocation: UE.EAssetEditorOpenLocation;
        bEnableColorizedEditorTabs: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorStyleSettings;
        static Load(InName: string): EditorStyleSettings;
    }
    
    class EditorSubsystemBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetEditorSubsystem(Class: $Nullable<UE.Class>) : UE.EditorSubsystem;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorSubsystemBlueprintLibrary;
        static Load(InName: string): EditorSubsystemBlueprintLibrary;
    }
    
    enum ETutorialContent { None, Text, UDNExcerpt, RichText, ETutorialContent_MAX}
    class TutorialContent {
        constructor();
        constructor(Type: UE.ETutorialContent, Content: string, ExcerptName: string, Text: string);
        Type: UE.ETutorialContent;
        Content: string;
        ExcerptName: string;
        Text: string;
        static StaticClass(): Class;
    }
    
    enum ETutorialAnchorIdentifier { None, NamedWidget, Asset, ETutorialAnchorIdentifier_MAX}
    class TutorialContentAnchor {
        constructor();
        constructor(Type: UE.ETutorialAnchorIdentifier, WrapperIdentifier: string, Asset: UE.SoftObjectPath, bDrawHighlight: boolean, TabToFocusOrOpen: string, FriendlyName: string, GUIDString: string, OuterName: string);
        Type: UE.ETutorialAnchorIdentifier;
        WrapperIdentifier: string;
        Asset: UE.SoftObjectPath;
        bDrawHighlight: boolean;
        TabToFocusOrOpen: string;
        FriendlyName: string;
        GUIDString: string;
        OuterName: string;
        static StaticClass(): Class;
    }
    
    class TutorialWidgetContent {
        constructor();
        constructor(Content: UE.TutorialContent, WidgetAnchor: UE.TutorialContentAnchor, HorizontalAlignment: UE.EHorizontalAlignment, VerticalAlignment: UE.EVerticalAlignment, Offset: UE.Vector2D, ContentWidth: number, bAutoFocus: boolean);
        Content: UE.TutorialContent;
        WidgetAnchor: UE.TutorialContentAnchor;
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        Offset: UE.Vector2D;
        ContentWidth: number;
        bAutoFocus: boolean;
        static StaticClass(): Class;
    }
    
    class TutorialStage {
        constructor();
        constructor(Name: string, Content: UE.TutorialContent, WidgetContent: TArray<UE.TutorialWidgetContent>, NextButtonText: string, BackButtonText: string, PlatformsToTest: TArray<string>, bInvertPlatformTest: boolean);
        Name: string;
        Content: UE.TutorialContent;
        WidgetContent: TArray<UE.TutorialWidgetContent>;
        NextButtonText: string;
        BackButtonText: string;
        PlatformsToTest: TArray<string>;
        bInvertPlatformTest: boolean;
        static StaticClass(): Class;
    }
    
    class EditorTutorial extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Title: string;
        SortOrder: number;
        Icon: string;
        Texture: UE.Texture2D;
        Category: string;
        SummaryContent: UE.TutorialContent;
        Stages: TArray<UE.TutorialStage>;
        PreviousTutorial: UE.SoftClassPath;
        NextTutorial: UE.SoftClassPath;
        bIsStandalone: boolean;
        AssetToUse: UE.SoftObjectPath;
        ImportPath: string;
        bHideInBrowser: boolean;
        SearchTags: string;
        GetActorReference(PathToActor: string) : UE.Actor;
        OnTutorialClosed() : void;
        OnTutorialLaunched() : void;
        OnTutorialStageEnded(StageName: string) : void;
        OnTutorialStageStarted(StageName: string) : void;
        static BeginTutorial(TutorialToStart: $Nullable<UE.EditorTutorial>, bRestart: boolean) : void;
        static GetEngineFolderVisibilty() : boolean;
        static GoToNextTutorialStage() : void;
        static GoToPreviousTutorialStage() : void;
        static OpenAsset(Asset: $Nullable<UE.Object>) : void;
        static SetEngineFolderVisibilty(bNewVisibility: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorTutorial;
        static Load(InName: string): EditorTutorial;
    }
    
    class EditorTutorialFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorTutorialFactory;
        static Load(InName: string): EditorTutorialFactory;
    }
    
    class EditorTutorialImportFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorTutorialImportFactory;
        static Load(InName: string): EditorTutorialImportFactory;
    }
    
    class TutorialCategory {
        constructor();
        constructor(Identifier: string, Title: string, SortOrder: number, Description: string, Icon: string, Texture: UE.SoftObjectPath);
        Identifier: string;
        Title: string;
        SortOrder: number;
        Description: string;
        Icon: string;
        Texture: UE.SoftObjectPath;
        static StaticClass(): Class;
    }
    
    class TutorialContext {
        constructor();
        constructor(Context: string, BrowserFilter: string, AttractTutorial: UE.SoftClassPath, LaunchTutorial: UE.SoftClassPath);
        Context: string;
        BrowserFilter: string;
        AttractTutorial: UE.SoftClassPath;
        LaunchTutorial: UE.SoftClassPath;
        static StaticClass(): Class;
    }
    
    class EditorTutorialSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDisableAllTutorialAlerts: boolean;
        Categories: TArray<UE.TutorialCategory>;
        StartupTutorial: UE.SoftClassPath;
        TutorialContexts: TArray<UE.TutorialContext>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorTutorialSettings;
        static Load(InName: string): EditorTutorialSettings;
    }
    
    class EditorUtilityActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Run() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityActor;
        static Load(InName: string): EditorUtilityActor;
    }
    
    class EditorUtilityActorComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityActorComponent;
        static Load(InName: string): EditorUtilityActorComponent;
    }
    
    class EditorUtilityBlueprint extends UE.Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityBlueprint;
        static Load(InName: string): EditorUtilityBlueprint;
    }
    
    class EditorUtilityBlueprintFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParentClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityBlueprintFactory;
        static Load(InName: string): EditorUtilityBlueprintFactory;
    }
    
    class EditorUtilityCamera extends UE.CameraActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityCamera;
        static Load(InName: string): EditorUtilityCamera;
    }
    
    class EditorUtilityExtension extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityExtension;
        static Load(InName: string): EditorUtilityExtension;
    }
    
    class EditorUtilityLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetActorReference(PathToActor: string) : UE.Actor;
        static GetSelectedAssetData() : TArray<UE.AssetData>;
        static GetSelectedAssets() : TArray<UE.Object>;
        static GetSelectedBlueprintClasses() : TArray<UE.Class>;
        static GetSelectionBounds(Origin: $Ref<UE.Vector>, BoxExtent: $Ref<UE.Vector>, SphereRadius: $Ref<number>) : void;
        static GetSelectionSet() : TArray<UE.Actor>;
        static RenameAsset(Asset: $Nullable<UE.Object>, NewName: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityLibrary;
        static Load(InName: string): EditorUtilityLibrary;
    }
    
    class EditorPropertyPathSegment {
        constructor();
        constructor(Struct: UE.Struct, MemberName: string, MemberGuid: UE.Guid, IsProperty: boolean);
        Struct: UE.Struct;
        MemberName: string;
        MemberGuid: UE.Guid;
        IsProperty: boolean;
        static StaticClass(): Class;
    }
    
    class EditorPropertyPath {
        constructor();
        constructor(Segments: TArray<UE.EditorPropertyPathSegment>);
        Segments: TArray<UE.EditorPropertyPathSegment>;
        static StaticClass(): Class;
    }
    
    enum EBindingKind { Function, Property, EBindingKind_MAX}
    class DelegateEditorBinding {
        constructor();
        constructor(ObjectName: string, PropertyName: string, FunctionName: string, SourceProperty: string, SourcePath: UE.EditorPropertyPath, MemberGuid: UE.Guid, Kind: UE.EBindingKind);
        ObjectName: string;
        PropertyName: string;
        FunctionName: string;
        SourceProperty: string;
        SourcePath: UE.EditorPropertyPath;
        MemberGuid: UE.Guid;
        Kind: UE.EBindingKind;
        static StaticClass(): Class;
    }
    
    class WidgetAnimation_DEPRECATED {
        constructor();
        constructor(MovieScene: UE.MovieScene, AnimationBindings: TArray<UE.WidgetAnimationBinding>);
        MovieScene: UE.MovieScene;
        AnimationBindings: TArray<UE.WidgetAnimationBinding>;
        static StaticClass(): Class;
    }
    
    enum EWidgetSupportsDynamicCreation { Default, Yes, No, EWidgetSupportsDynamicCreation_MAX}
    enum EWidgetCompileTimeTickPrediction { WontTick, OnDemand, WillTick, EWidgetCompileTimeTickPrediction_MAX}
    class WidgetBlueprint extends UE.BaseWidgetBlueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Bindings: TArray<UE.DelegateEditorBinding>;
        AnimationData: TArray<UE.WidgetAnimation_DEPRECATED>;
        Animations: TArray<UE.WidgetAnimation>;
        PaletteCategory: string;
        bForceSlowConstructionPath: boolean;
        SupportDynamicCreation: UE.EWidgetSupportsDynamicCreation;
        InclusiveWidgets: number;
        EstimatedTemplateSize: number;
        TickFrequency: UE.EWidgetTickFrequency;
        TickPrediction: UE.EWidgetCompileTimeTickPrediction;
        TickPredictionReason: string;
        PropertyBindings: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetBlueprint;
        static Load(InName: string): WidgetBlueprint;
    }
    
    class EditorUtilityWidget extends UE.UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HelpText: string;
        bAlwaysReregisterWithWindowsMenu: boolean;
        bAutoRunDefaultAction: boolean;
        Run() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityWidget;
        static Load(InName: string): EditorUtilityWidget;
    }
    
    class EditorUtilityWidgetBlueprint extends UE.WidgetBlueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CreatedUMGWidget: UE.EditorUtilityWidget;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityWidgetBlueprint;
        static Load(InName: string): EditorUtilityWidgetBlueprint;
    }
    
    class EditorUtilitySubsystem extends UE.EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LoadedUIs: TArray<UE.SoftObjectPath>;
        StartupObjects: TArray<UE.SoftObjectPath>;
        ObjectInstances: TMap<UE.Object, UE.Object>;
        ReleaseInstanceOfAsset(Asset: $Nullable<UE.Object>) : void;
        SpawnAndRegisterTab(InBlueprint: $Nullable<UE.EditorUtilityWidgetBlueprint>) : UE.EditorUtilityWidget;
        TryRun(Asset: $Nullable<UE.Object>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilitySubsystem;
        static Load(InName: string): EditorUtilitySubsystem;
    }
    
    class EditorUtilityWidgetBlueprintFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlueprintType: UE.EBlueprintType;
        ParentClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityWidgetBlueprintFactory;
        static Load(InName: string): EditorUtilityWidgetBlueprintFactory;
    }
    
    enum EDataValidationResult { Invalid, Valid, NotValidated, EDataValidationResult_MAX}
    class EditorValidatorBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsEnabled: boolean;
        AssetFails(InAsset: $Nullable<UE.Object>, InMessage: string, ValidationErrors: $Ref<TArray<string>>) : void;
        AssetPasses(InAsset: $Nullable<UE.Object>) : void;
        CanValidateAsset(InAsset: $Nullable<UE.Object>) : boolean;
        GetValidationResult() : UE.EDataValidationResult;
        ValidateLoadedAsset(InAsset: $Nullable<UE.Object>, ValidationErrors: $Ref<TArray<string>>) : UE.EDataValidationResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorValidatorBase;
        static Load(InName: string): EditorValidatorBase;
    }
    
    class EditorValidatorSubsystem extends UE.EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ExcludedDirectories: TArray<UE.DirectoryPath>;
        bValidateOnSave: boolean;
        Validators: TMap<UE.Class, UE.EditorValidatorBase>;
        bValidateAssetsWhileSavingForCook: boolean;
        bAllowBlueprintValidators: boolean;
        AddValidator(InValidator: $Nullable<UE.EditorValidatorBase>) : void;
        IsAssetValid(AssetData: $Ref<UE.AssetData>, ValidationErrors: $Ref<TArray<string>>) : UE.EDataValidationResult;
        IsObjectValid(InObject: $Nullable<UE.Object>, ValidationErrors: $Ref<TArray<string>>) : UE.EDataValidationResult;
        ValidateAssets(AssetDataList: TArray<UE.AssetData>, bSkipExcludedDirectories?: boolean /* = true */, bShowIfNoFailures?: boolean /* = true */) : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorValidatorSubsystem;
        static Load(InName: string): EditorValidatorSubsystem;
    }
    
    class EdMode extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StandardVertexColorMaterial: UE.MaterialInterface;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdMode;
        static Load(InName: string): EdMode;
    }
    
    class InputRouter extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoInvalidateOnHover: boolean;
        bAutoInvalidateOnCapture: boolean;
        ActiveInputBehaviors: UE.InputBehaviorSet;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputRouter;
        static Load(InName: string): InputRouter;
    }
    
    class InteractiveToolManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActiveLeftTool: UE.InteractiveTool;
        ActiveRightTool: UE.InteractiveTool;
        ToolBuilders: TMap<string, UE.InteractiveToolBuilder>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveToolManager;
        static Load(InName: string): InteractiveToolManager;
    }
    
    class ActiveGizmo {
        constructor();
        static StaticClass(): Class;
    }
    
    class InteractiveGizmoManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActiveGizmos: TArray<UE.ActiveGizmo>;
        GizmoBuilders: TMap<string, UE.InteractiveGizmoBuilder>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveGizmoManager;
        static Load(InName: string): InteractiveGizmoManager;
    }
    
    class InteractiveToolsContext extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputRouter: UE.InputRouter;
        ToolManager: UE.InteractiveToolManager;
        GizmoManager: UE.InteractiveGizmoManager;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveToolsContext;
        static Load(InName: string): InteractiveToolsContext;
    }
    
    class EdModeInteractiveToolsContext extends UE.InteractiveToolsContext {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StandardVertexColorMaterial: UE.MaterialInterface;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdModeInteractiveToolsContext;
        static Load(InName: string): EdModeInteractiveToolsContext;
    }
    
    class EllipseSplineGenerator extends UE.SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumberOfPoints: number;
        Length: number;
        Width: number;
        bReverseDir: boolean;
        bKeepFirstKeyTangent: boolean;
        bBranchRight: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EllipseSplineGenerator;
        static Load(InName: string): EllipseSplineGenerator;
    }
    
    class TurnBasedMatchInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnMatchEnded(Match: string) : void;
        OnMatchReceivedTurn(Match: string, bDidBecomeActive: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TurnBasedMatchInterface;
        static Load(InName: string): TurnBasedMatchInterface;
    }
    
    enum EMPMatchOutcome { None, Quit, Won, Lost, Tied, TimeExpired, First, Second, Third, Fourth, EMPMatchOutcome_MAX}
    class EndMatchCallbackProxy extends UE.OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;
        static EndMatch(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>, MatchActor: TurnBasedMatchInterface, MatchID: string, LocalPlayerOutcome: UE.EMPMatchOutcome, OtherPlayersOutcome: UE.EMPMatchOutcome) : UE.EndMatchCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EndMatchCallbackProxy;
        static Load(InName: string): EndMatchCallbackProxy;
    }
    
    class EndTurnCallbackProxy extends UE.OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;
        static EndTurn(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>, MatchID: string, TurnBasedMatchInterface: TurnBasedMatchInterface) : UE.EndTurnCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EndTurnCallbackProxy;
        static Load(InName: string): EndTurnCallbackProxy;
    }
    
    class EngineBaseTypes extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EngineBaseTypes;
        static Load(InName: string): EngineBaseTypes;
    }
    
    class HandlerComponentFactory extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HandlerComponentFactory;
        static Load(InName: string): HandlerComponentFactory;
    }
    
    class EngineHandlerComponentFactory extends UE.HandlerComponentFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EngineHandlerComponentFactory;
        static Load(InName: string): EngineHandlerComponentFactory;
    }
    
    class LocalMessage extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalMessage;
        static Load(InName: string): LocalMessage;
    }
    
    class EngineMessage extends UE.LocalMessage {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FailedPlaceMessage: string;
        MaxedOutMessage: string;
        EnteredMessage: string;
        LeftMessage: string;
        GlobalNameChange: string;
        SpecEnteredMessage: string;
        NewPlayerMessage: string;
        NewSpecMessage: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EngineMessage;
        static Load(InName: string): EngineMessage;
    }
    
    class EngineTypes extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EngineTypes;
        static Load(InName: string): EngineTypes;
    }
    
    class EnumFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnumFactory;
        static Load(InName: string): EnumFactory;
    }
    
    class EnumProperty extends UE.Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnumProperty;
        static Load(InName: string): EnumProperty;
    }
    
    class EnvQueryContext_BlueprintBase extends UE.EnvQueryContext {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProvideActorsSet(QuerierObject: $Nullable<UE.Object>, QuerierActor: $Nullable<UE.Actor>, ResultingActorsSet: $Ref<TArray<UE.Actor>>) : void;
        ProvideLocationsSet(QuerierObject: $Nullable<UE.Object>, QuerierActor: $Nullable<UE.Actor>, ResultingLocationSet: $Ref<TArray<UE.Vector>>) : void;
        ProvideSingleActor(QuerierObject: $Nullable<UE.Object>, QuerierActor: $Nullable<UE.Actor>, ResultingActor: $Ref<UE.Actor>) : void;
        ProvideSingleLocation(QuerierObject: $Nullable<UE.Object>, QuerierActor: $Nullable<UE.Actor>, ResultingLocation: $Ref<UE.Vector>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryContext_BlueprintBase;
        static Load(InName: string): EnvQueryContext_BlueprintBase;
    }
    
    class EnvQueryContext_Item extends UE.EnvQueryContext {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryContext_Item;
        static Load(InName: string): EnvQueryContext_Item;
    }
    
    class EnvQueryContext_Querier extends UE.EnvQueryContext {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryContext_Querier;
        static Load(InName: string): EnvQueryContext_Querier;
    }
    
    class EnvQueryDebugHelpers extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryDebugHelpers;
        static Load(InName: string): EnvQueryDebugHelpers;
    }
    
    class EnvQueryGenerator_ActorsOfClass extends UE.EnvQueryGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SearchedActorClass: UE.Class;
        GenerateOnlyActorsInRadius: UE.AIDataProviderBoolValue;
        SearchRadius: UE.AIDataProviderFloatValue;
        SearchCenter: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_ActorsOfClass;
        static Load(InName: string): EnvQueryGenerator_ActorsOfClass;
    }
    
    class EnvQueryGenerator_BlueprintBase extends UE.EnvQueryGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GeneratorsActionDescription: string;
        Context: UE.Class;
        GeneratedItemType: UE.Class;
        AddGeneratedActor(GeneratedActor: $Nullable<UE.Actor>) : void;
        AddGeneratedVector(GeneratedVector: UE.Vector) : void;
        DoItemGeneration(ContextLocations: TArray<UE.Vector>) : void;
        GetQuerier() : UE.Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_BlueprintBase;
        static Load(InName: string): EnvQueryGenerator_BlueprintBase;
    }
    
    class EnvQueryGenerator_Composite extends UE.EnvQueryGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Generators: TArray<UE.EnvQueryGenerator>;
        bAllowDifferentItemTypes: boolean;
        bHasMatchingItemType: boolean;
        ForcedItemType: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_Composite;
        static Load(InName: string): EnvQueryGenerator_Composite;
    }
    
    enum EEnvTraceShape { Line, Box, Sphere, Capsule, EEnvTraceShape_MAX}
    enum EEnvQueryTrace { None, Navigation, Geometry, NavigationOverLedges, EEnvQueryTrace_MAX}
    class EnvTraceData {
        constructor();
        constructor(VersionNum: number, NavigationFilter: UE.Class, ProjectDown: number, ProjectUp: number, ExtentX: number, ExtentY: number, ExtentZ: number, PostProjectionVerticalOffset: number, TraceChannel: UE.ETraceTypeQuery, SerializedChannel: UE.ECollisionChannel, TraceShape: UE.EEnvTraceShape, TraceMode: UE.EEnvQueryTrace, bTraceComplex: boolean, bOnlyBlockingHits: boolean, bCanTraceOnNavMesh: boolean, bCanTraceOnGeometry: boolean, bCanDisableTrace: boolean, bCanProjectDown: boolean);
        VersionNum: number;
        NavigationFilter: UE.Class;
        ProjectDown: number;
        ProjectUp: number;
        ExtentX: number;
        ExtentY: number;
        ExtentZ: number;
        PostProjectionVerticalOffset: number;
        TraceChannel: UE.ETraceTypeQuery;
        SerializedChannel: UE.ECollisionChannel;
        TraceShape: UE.EEnvTraceShape;
        TraceMode: UE.EEnvQueryTrace;
        bTraceComplex: boolean;
        bOnlyBlockingHits: boolean;
        bCanTraceOnNavMesh: boolean;
        bCanTraceOnGeometry: boolean;
        bCanDisableTrace: boolean;
        bCanProjectDown: boolean;
        static StaticClass(): Class;
    }
    
    class EnvQueryGenerator_ProjectedPoints extends UE.EnvQueryGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProjectionData: UE.EnvTraceData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_ProjectedPoints;
        static Load(InName: string): EnvQueryGenerator_ProjectedPoints;
    }
    
    class EnvQueryGenerator_Cone extends UE.EnvQueryGenerator_ProjectedPoints {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AlignedPointsDistance: UE.AIDataProviderFloatValue;
        ConeDegrees: UE.AIDataProviderFloatValue;
        AngleStep: UE.AIDataProviderFloatValue;
        Range: UE.AIDataProviderFloatValue;
        CenterActor: UE.Class;
        bIncludeContextLocation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_Cone;
        static Load(InName: string): EnvQueryGenerator_Cone;
    }
    
    class EnvQueryGenerator_CurrentLocation extends UE.EnvQueryGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        QueryContext: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_CurrentLocation;
        static Load(InName: string): EnvQueryGenerator_CurrentLocation;
    }
    
    class AIDataProviderIntValue extends UE.AIDataProviderTypedValue {
        constructor();
        constructor(DefaultValue: number);
        DefaultValue: number;
        static StaticClass(): Class;
    }
    
    enum EEnvDirection { TwoPoints, Rotation, EEnvDirection_MAX}
    class EnvDirection {
        constructor();
        constructor(LineFrom: UE.Class, LineTo: UE.Class, Rotation: UE.Class, DirMode: UE.EEnvDirection);
        LineFrom: UE.Class;
        LineTo: UE.Class;
        Rotation: UE.Class;
        DirMode: UE.EEnvDirection;
        static StaticClass(): Class;
    }
    
    class EnvQueryGenerator_Donut extends UE.EnvQueryGenerator_ProjectedPoints {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InnerRadius: UE.AIDataProviderFloatValue;
        OuterRadius: UE.AIDataProviderFloatValue;
        NumberOfRings: UE.AIDataProviderIntValue;
        PointsPerRing: UE.AIDataProviderIntValue;
        ArcDirection: UE.EnvDirection;
        ArcAngle: UE.AIDataProviderFloatValue;
        bUseSpiralPattern: boolean;
        Center: UE.Class;
        bDefineArc: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_Donut;
        static Load(InName: string): EnvQueryGenerator_Donut;
    }
    
    enum EPointOnCircleSpacingMethod { BySpaceBetween, ByNumberOfPoints, EPointOnCircleSpacingMethod_MAX}
    class EnvQueryGenerator_OnCircle extends UE.EnvQueryGenerator_ProjectedPoints {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CircleRadius: UE.AIDataProviderFloatValue;
        SpaceBetween: UE.AIDataProviderFloatValue;
        NumberOfPoints: UE.AIDataProviderIntValue;
        PointOnCircleSpacingMethod: UE.EPointOnCircleSpacingMethod;
        ArcDirection: UE.EnvDirection;
        ArcAngle: UE.AIDataProviderFloatValue;
        AngleRadians: number;
        CircleCenter: UE.Class;
        bIgnoreAnyContextActorsWhenGeneratingCircle: boolean;
        CircleCenterZOffset: UE.AIDataProviderFloatValue;
        TraceData: UE.EnvTraceData;
        bDefineArc: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_OnCircle;
        static Load(InName: string): EnvQueryGenerator_OnCircle;
    }
    
    class EnvQueryGenerator_SimpleGrid extends UE.EnvQueryGenerator_ProjectedPoints {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GridSize: UE.AIDataProviderFloatValue;
        SpaceBetween: UE.AIDataProviderFloatValue;
        GenerateAround: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_SimpleGrid;
        static Load(InName: string): EnvQueryGenerator_SimpleGrid;
    }
    
    class EnvQueryGenerator_PathingGrid extends UE.EnvQueryGenerator_SimpleGrid {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PathToItem: UE.AIDataProviderBoolValue;
        NavigationFilter: UE.Class;
        ScanRangeMultiplier: UE.AIDataProviderFloatValue;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_PathingGrid;
        static Load(InName: string): EnvQueryGenerator_PathingGrid;
    }
    
    class EnvQueryItemType extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType;
        static Load(InName: string): EnvQueryItemType;
    }
    
    class EnvQueryItemType_VectorBase extends UE.EnvQueryItemType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType_VectorBase;
        static Load(InName: string): EnvQueryItemType_VectorBase;
    }
    
    class EnvQueryItemType_ActorBase extends UE.EnvQueryItemType_VectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType_ActorBase;
        static Load(InName: string): EnvQueryItemType_ActorBase;
    }
    
    class EnvQueryItemType_Actor extends UE.EnvQueryItemType_ActorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType_Actor;
        static Load(InName: string): EnvQueryItemType_Actor;
    }
    
    class EnvQueryItemType_Direction extends UE.EnvQueryItemType_VectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType_Direction;
        static Load(InName: string): EnvQueryItemType_Direction;
    }
    
    class EnvQueryItemType_Point extends UE.EnvQueryItemType_VectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType_Point;
        static Load(InName: string): EnvQueryItemType_Point;
    }
    
    enum EEnvTestDistance { Distance3D, Distance2D, DistanceZ, DistanceAbsoluteZ, EEnvTestDistance_MAX}
    class EnvQueryTest_Distance extends UE.EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TestMode: UE.EEnvTestDistance;
        DistanceTo: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Distance;
        static Load(InName: string): EnvQueryTest_Distance;
    }
    
    enum EEnvTestDot { Dot3D, Dot2D, EEnvTestDot_MAX}
    class EnvQueryTest_Dot extends UE.EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LineA: UE.EnvDirection;
        LineB: UE.EnvDirection;
        TestMode: UE.EEnvTestDot;
        bAbsoluteValue: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Dot;
        static Load(InName: string): EnvQueryTest_Dot;
    }
    
    class EnvQueryTest_GameplayTags extends UE.EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TagQueryToMatch: UE.GameplayTagQuery;
        bUpdatedToUseQuery: boolean;
        TagsToMatch: UE.EGameplayContainerMatchType;
        GameplayTags: UE.GameplayTagContainer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_GameplayTags;
        static Load(InName: string): EnvQueryTest_GameplayTags;
    }
    
    enum EEnvOverlapShape { Box, Sphere, Capsule, EEnvOverlapShape_MAX}
    class EnvOverlapData {
        constructor();
        constructor(ExtentX: number, ExtentY: number, ExtentZ: number, ShapeOffset: UE.Vector, OverlapChannel: UE.ECollisionChannel, OverlapShape: UE.EEnvOverlapShape, bOnlyBlockingHits: boolean, bOverlapComplex: boolean, bSkipOverlapQuerier: boolean);
        ExtentX: number;
        ExtentY: number;
        ExtentZ: number;
        ShapeOffset: UE.Vector;
        OverlapChannel: UE.ECollisionChannel;
        OverlapShape: UE.EEnvOverlapShape;
        bOnlyBlockingHits: boolean;
        bOverlapComplex: boolean;
        bSkipOverlapQuerier: boolean;
        static StaticClass(): Class;
    }
    
    class EnvQueryTest_Overlap extends UE.EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OverlapData: UE.EnvOverlapData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Overlap;
        static Load(InName: string): EnvQueryTest_Overlap;
    }
    
    enum EEnvTestPathfinding { PathExist, PathCost, PathLength, EEnvTestPathfinding_MAX}
    class EnvQueryTest_Pathfinding extends UE.EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TestMode: UE.EEnvTestPathfinding;
        Context: UE.Class;
        PathFromContext: UE.AIDataProviderBoolValue;
        SkipUnreachable: UE.AIDataProviderBoolValue;
        FilterClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Pathfinding;
        static Load(InName: string): EnvQueryTest_Pathfinding;
    }
    
    class EnvQueryTest_PathfindingBatch extends UE.EnvQueryTest_Pathfinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ScanRangeMultiplier: UE.AIDataProviderFloatValue;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_PathfindingBatch;
        static Load(InName: string): EnvQueryTest_PathfindingBatch;
    }
    
    class EnvQueryTest_Project extends UE.EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProjectionData: UE.EnvTraceData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Project;
        static Load(InName: string): EnvQueryTest_Project;
    }
    
    class EnvQueryTest_Random extends UE.EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Random;
        static Load(InName: string): EnvQueryTest_Random;
    }
    
    class EnvQueryTest_Trace extends UE.EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TraceData: UE.EnvTraceData;
        TraceFromContext: UE.AIDataProviderBoolValue;
        ItemHeightOffset: UE.AIDataProviderFloatValue;
        ContextHeightOffset: UE.AIDataProviderFloatValue;
        Context: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Trace;
        static Load(InName: string): EnvQueryTest_Trace;
    }
    
    class EnvQueryTest_Volume extends UE.EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VolumeContext: UE.Class;
        VolumeClass: UE.Class;
        bDoComplexVolumeTest: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Volume;
        static Load(InName: string): EnvQueryTest_Volume;
    }
    
    class EnvQueryTypes extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTypes;
        static Load(InName: string): EnvQueryTypes;
    }
    
    class EQSQueryResultSourceInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EQSQueryResultSourceInterface;
        static Load(InName: string): EQSQueryResultSourceInterface;
    }
    
    class EQSRenderingComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EQSRenderingComponent;
        static Load(InName: string): EQSRenderingComponent;
    }
    
    enum EEnvQueryHightlightMode { All, Best5Pct, Best25Pct, EEnvQueryHightlightMode_MAX}
    class EQSTestingPawn extends UE.Character {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        QueryTemplate: UE.EnvQuery;
        QueryParams: TArray<UE.EnvNamedValue>;
        QueryConfig: TArray<UE.AIDynamicParam>;
        TimeLimitPerStep: number;
        StepToDebugDraw: number;
        HighlightMode: UE.EEnvQueryHightlightMode;
        bDrawLabels: boolean;
        bDrawFailedItems: boolean;
        bReRunQueryOnlyOnFinishedMove: boolean;
        bShouldBeVisibleInGame: boolean;
        bTickDuringGame: boolean;
        QueryingMode: UE.EEnvQueryRunMode;
        NavAgentProperties: UE.NavAgentProperties;
        EdRenderComp: UE.EQSRenderingComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EQSTestingPawn;
        static Load(InName: string): EQSTestingPawn;
    }
    
    class ExpandableAreaStyle extends UE.SlateWidgetStyle {
        constructor();
        constructor(CollapsedImage: UE.SlateBrush, ExpandedImage: UE.SlateBrush, RolloutAnimationSeconds: number);
        CollapsedImage: UE.SlateBrush;
        ExpandedImage: UE.SlateBrush;
        RolloutAnimationSeconds: number;
        static StaticClass(): Class;
    }
    
    class ExpandableArea extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Style: UE.ExpandableAreaStyle;
        BorderBrush: UE.SlateBrush;
        BorderColor: UE.SlateColor;
        bIsExpanded: boolean;
        MaxHeight: number;
        HeaderPadding: UE.Margin;
        AreaPadding: UE.Margin;
        OnExpansionChanged: $MulticastDelegate<(Area: $Nullable<UE.ExpandableArea>, bIsExpanded: boolean) => void>;
        HeaderContent: UE.Widget;
        BodyContent: UE.Widget;
        GetIsExpanded() : boolean;
        SetIsExpanded(IsExpanded: boolean) : void;
        SetIsExpanded_Animated(IsExpanded: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ExpandableArea;
        static Load(InName: string): ExpandableArea;
    }
    
    class ExponentialHeightFogData {
        constructor();
        constructor(FogDensity: number, FogHeightFalloff: number, FogHeightOffset: number);
        FogDensity: number;
        FogHeightFalloff: number;
        FogHeightOffset: number;
        static StaticClass(): Class;
    }
    
    class ExponentialHeightFogComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FogDensity: number;
        FogHeightFalloff: number;
        SecondFogData: UE.ExponentialHeightFogData;
        FogInscatteringColor: UE.LinearColor;
        InscatteringColorCubemap: UE.TextureCube;
        InscatteringColorCubemapAngle: number;
        InscatteringTextureTint: UE.LinearColor;
        FullyDirectionalInscatteringColorDistance: number;
        NonDirectionalInscatteringColorDistance: number;
        DirectionalInscatteringExponent: number;
        DirectionalInscatteringStartDistance: number;
        DirectionalInscatteringColor: UE.LinearColor;
        FogMaxOpacity: number;
        StartDistance: number;
        FogCutoffDistance: number;
        bEnableVolumetricFog: boolean;
        VolumetricFogScatteringDistribution: number;
        VolumetricFogAlbedo: UE.Color;
        VolumetricFogEmissive: UE.LinearColor;
        VolumetricFogExtinctionScale: number;
        VolumetricFogDistance: number;
        VolumetricFogStaticLightingScatteringIntensity: number;
        bOverrideLightColorsWithFogInscatteringColors: boolean;
        SetDirectionalInscatteringColor(Value: UE.LinearColor) : void;
        SetDirectionalInscatteringExponent(Value: number) : void;
        SetDirectionalInscatteringStartDistance(Value: number) : void;
        SetFogCutoffDistance(Value: number) : void;
        SetFogDensity(Value: number) : void;
        SetFogHeightFalloff(Value: number) : void;
        SetFogInscatteringColor(Value: UE.LinearColor) : void;
        SetFogMaxOpacity(Value: number) : void;
        SetFullyDirectionalInscatteringColorDistance(Value: number) : void;
        SetInscatteringColorCubemap(Value: $Nullable<UE.TextureCube>) : void;
        SetInscatteringColorCubemapAngle(Value: number) : void;
        SetInscatteringTextureTint(Value: UE.LinearColor) : void;
        SetNonDirectionalInscatteringColorDistance(Value: number) : void;
        SetStartDistance(Value: number) : void;
        SetVolumetricFog(bNewValue: boolean) : void;
        SetVolumetricFogAlbedo(NewValue: UE.Color) : void;
        SetVolumetricFogDistance(NewValue: number) : void;
        SetVolumetricFogEmissive(NewValue: UE.LinearColor) : void;
        SetVolumetricFogExtinctionScale(NewValue: number) : void;
        SetVolumetricFogScatteringDistribution(NewValue: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ExponentialHeightFogComponent;
        static Load(InName: string): ExponentialHeightFogComponent;
    }
    
    class ExponentialHeightFog extends UE.Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Component: UE.ExponentialHeightFogComponent;
        bEnabled: boolean;
        OnRep_bEnabled() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ExponentialHeightFog;
        static Load(InName: string): ExponentialHeightFog;
    }
    
    class GatherTextCommandletBase extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GatherTextCommandletBase;
        static Load(InName: string): GatherTextCommandletBase;
    }
    
    class ExportDialogueScriptCommandlet extends UE.GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ExportDialogueScriptCommandlet;
        static Load(InName: string): ExportDialogueScriptCommandlet;
    }
    
    class ExportPakDependenciesCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ExportPakDependenciesCommandlet;
        static Load(InName: string): ExportPakDependenciesCommandlet;
    }
    
    class ExportTextContainer extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ExportText: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ExportTextContainer;
        static Load(InName: string): ExportTextContainer;
    }
    
    class ExtensionMethods extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ExtensionMethods;
        static Load(InName: string): ExtensionMethods;
    }
    
    class EyeTrackerStereoGazeData {
        constructor();
        constructor(LeftEyeOrigin: UE.Vector, LeftEyeDirection: UE.Vector, RightEyeOrigin: UE.Vector, RightEyeDirection: UE.Vector, FixationPoint: UE.Vector, ConfidenceValue: number);
        LeftEyeOrigin: UE.Vector;
        LeftEyeDirection: UE.Vector;
        RightEyeOrigin: UE.Vector;
        RightEyeDirection: UE.Vector;
        FixationPoint: UE.Vector;
        ConfidenceValue: number;
        static StaticClass(): Class;
    }
    
    class EyeTrackerGazeData {
        constructor();
        constructor(GazeOrigin: UE.Vector, GazeDirection: UE.Vector, FixationPoint: UE.Vector, ConfidenceValue: number);
        GazeOrigin: UE.Vector;
        GazeDirection: UE.Vector;
        FixationPoint: UE.Vector;
        ConfidenceValue: number;
        static StaticClass(): Class;
    }
    
    class EyeTrackerFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetGazeData(OutGazeData: $Ref<UE.EyeTrackerGazeData>) : boolean;
        static GetStereoGazeData(OutGazeData: $Ref<UE.EyeTrackerStereoGazeData>) : boolean;
        static IsEyeTrackerConnected() : boolean;
        static IsStereoGazeDataAvailable() : boolean;
        static SetEyeTrackedPlayer(PlayerController: $Nullable<UE.PlayerController>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EyeTrackerFunctionLibrary;
        static Load(InName: string): EyeTrackerFunctionLibrary;
    }
    
    class FacialAnimationBulkImporterSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceImportPath: UE.DirectoryPath;
        TargetImportPath: UE.DirectoryPath;
        CurveNodeName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FacialAnimationBulkImporterSettings;
        static Load(InName: string): FacialAnimationBulkImporterSettings;
    }
    
    class FbxSceneImportData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceFbxFile: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxSceneImportData;
        static Load(InName: string): FbxSceneImportData;
    }
    
    class FbxAssetImportData extends UE.AssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportTranslation: UE.Vector;
        ImportRotation: UE.Rotator;
        ImportUniformScale: number;
        bConvertScene: boolean;
        bForceFrontXAxis: boolean;
        bConvertSceneUnit: boolean;
        bImportAsScene: boolean;
        FbxSceneImportDataReference: UE.FbxSceneImportData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxAssetImportData;
        static Load(InName: string): FbxAssetImportData;
    }
    
    enum EFBXAnimationLengthImportType { FBXALIT_ExportedTime, FBXALIT_AnimatedKey, FBXALIT_SetRange, FBXALIT_MAX}
    class Int32Interval {
        constructor();
        constructor(Min: number, Max: number);
        Min: number;
        Max: number;
        static StaticClass(): Class;
    }
    
    class FbxAnimSequenceImportData extends UE.FbxAssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bImportMeshesInBoneHierarchy: boolean;
        AnimationLength: UE.EFBXAnimationLengthImportType;
        StartFrame: number;
        EndFrame: number;
        FrameImportRange: UE.Int32Interval;
        bUseDefaultSampleRate: boolean;
        CustomSampleRate: number;
        SourceAnimationName: string;
        bImportCustomAttribute: boolean;
        bDeleteExistingCustomAttributeCurves: boolean;
        bImportBoneTracks: boolean;
        bSetMaterialDriveParameterOnCustomAttribute: boolean;
        MaterialCurveSuffixes: TArray<string>;
        bRemoveRedundantKeys: boolean;
        bDeleteExistingMorphTargetCurves: boolean;
        bDoNotImportCurveWithZero: boolean;
        bPreserveLocalTransform: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxAnimSequenceImportData;
        static Load(InName: string): FbxAnimSequenceImportData;
    }
    
    enum EFbxExportCompatibility { FBX_2011, FBX_2012, FBX_2013, FBX_2014, FBX_2016, FBX_2018, FBX_MAX}
    class FbxExportOption extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FbxExportCompatibility: UE.EFbxExportCompatibility;
        bASCII: boolean;
        bForceFrontXAxis: boolean;
        VertexColor: boolean;
        LevelOfDetail: boolean;
        Collision: boolean;
        bExportMorphTargets: boolean;
        bExportPreviewMesh: boolean;
        MapSkeletalMotionToRoot: boolean;
        bExportLocalTime: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxExportOption;
        static Load(InName: string): FbxExportOption;
    }
    
    enum EFBXImportType { FBXIT_StaticMesh, FBXIT_SkeletalMesh, FBXIT_Animation, FBXIT_MAX}
    enum EFBXNormalImportMethod { FBXNIM_ComputeNormals, FBXNIM_ImportNormals, FBXNIM_ImportNormalsAndTangents, FBXNIM_MAX}
    enum EFBXNormalGenerationMethod { BuiltIn, MikkTSpace, EFBXNormalGenerationMethod_MAX}
    class ImportMeshLodSectionsData {
        constructor();
        constructor(SectionOriginalMaterialName: TArray<string>);
        SectionOriginalMaterialName: TArray<string>;
        static StaticClass(): Class;
    }
    
    class FbxMeshImportData extends UE.FbxAssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bTransformVertexToAbsolute: boolean;
        bBakePivotInVertex: boolean;
        bImportMeshLODs: boolean;
        NormalImportMethod: UE.EFBXNormalImportMethod;
        NormalGenerationMethod: UE.EFBXNormalGenerationMethod;
        bComputeWeightedNormals: boolean;
        bReorderMaterialToFbxOrder: boolean;
        ImportMaterialOriginalNameData: TArray<string>;
        ImportMeshLodData: TArray<UE.ImportMeshLodSectionsData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxMeshImportData;
        static Load(InName: string): FbxMeshImportData;
    }
    
    enum EVertexColorImportOption { Replace, Ignore, Override, EVertexColorImportOption_MAX}
    class FbxStaticMeshImportData extends UE.FbxMeshImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StaticMeshLODGroup: string;
        VertexColorImportOption: UE.EVertexColorImportOption;
        VertexOverrideColor: UE.Color;
        bRemoveDegenerates: boolean;
        bBuildAdjacencyBuffer: boolean;
        bBuildReversedIndexBuffer: boolean;
        bGenerateLightmapUVs: boolean;
        bOneConvexHullPerUCX: boolean;
        bAutoGenerateCollision: boolean;
        bCombineMeshes: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxStaticMeshImportData;
        static Load(InName: string): FbxStaticMeshImportData;
    }
    
    enum EFBXImportContentType { FBXICT_All, FBXICT_Geometry, FBXICT_SkinningWeights, FBXICT_MAX}
    class FbxSkeletalMeshImportData extends UE.FbxMeshImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportContentType: UE.EFBXImportContentType;
        LastImportContentType: UE.EFBXImportContentType;
        VertexColorImportOption: UE.EVertexColorImportOption;
        VertexOverrideColor: UE.Color;
        bUpdateSkeletonReferencePose: boolean;
        bUseT0AsRefPose: boolean;
        bPreserveSmoothingGroups: boolean;
        bImportMeshesInBoneHierarchy: boolean;
        bImportMorphTargets: boolean;
        ThresholdPosition: number;
        ThresholdTangentNormal: number;
        ThresholdUV: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxSkeletalMeshImportData;
        static Load(InName: string): FbxSkeletalMeshImportData;
    }
    
    enum EMaterialSearchLocation { Local, UnderParent, UnderRoot, AllAssets, EMaterialSearchLocation_MAX}
    class FbxTextureImportData extends UE.FbxAssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bInvertNormalMaps: boolean;
        MaterialSearchLocation: UE.EMaterialSearchLocation;
        BaseMaterialName: UE.SoftObjectPath;
        BaseColorName: string;
        BaseDiffuseTextureName: string;
        BaseNormalTextureName: string;
        BaseEmissiveColorName: string;
        BaseEmmisiveTextureName: string;
        BaseSpecularTextureName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxTextureImportData;
        static Load(InName: string): FbxTextureImportData;
    }
    
    class FbxImportUI extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsObjImport: boolean;
        OriginalImportType: UE.EFBXImportType;
        MeshTypeToImport: UE.EFBXImportType;
        bOverrideFullName: boolean;
        bImportAsSkeletal: boolean;
        bImportMesh: boolean;
        Skeleton: UE.Skeleton;
        bCreatePhysicsAsset: boolean;
        PhysicsAsset: UE.PhysicsAsset;
        bAutoComputeLodDistances: boolean;
        LodDistance0: number;
        LodDistance1: number;
        LodDistance2: number;
        LodDistance3: number;
        LodDistance4: number;
        LodDistance5: number;
        LodDistance6: number;
        LodDistance7: number;
        MinimumLodNumber: number;
        LodNumber: number;
        bImportAnimations: boolean;
        OverrideAnimationName: string;
        bImportRigidMesh: boolean;
        bImportMaterials: boolean;
        bImportTextures: boolean;
        StaticMeshImportData: UE.FbxStaticMeshImportData;
        SkeletalMeshImportData: UE.FbxSkeletalMeshImportData;
        AnimSequenceImportData: UE.FbxAnimSequenceImportData;
        TextureImportData: UE.FbxTextureImportData;
        bAutomatedImportShouldDetectType: boolean;
        FileVersion: string;
        FileCreator: string;
        FileCreatorApplication: string;
        FileUnits: string;
        FileAxisDirection: string;
        FileSampleRate: string;
        AnimStartFrame: string;
        AnimEndFrame: string;
        ResetToDefault() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxImportUI;
        static Load(InName: string): FbxImportUI;
    }
    
    class FbxFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportUI: UE.FbxImportUI;
        OriginalImportUI: UE.FbxImportUI;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxFactory;
        static Load(InName: string): FbxFactory;
    }
    
    class SceneImportFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneImportFactory;
        static Load(InName: string): SceneImportFactory;
    }
    
    enum EFBXSceneOptionsCreateHierarchyType { FBXSOCHT_CreateLevelActors, FBXSOCHT_CreateActorComponents, FBXSOCHT_CreateBlueprint, FBXSOCHT_MAX}
    class FbxSceneImportOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCreateContentFolderHierarchy: boolean;
        bImportAsDynamic: boolean;
        HierarchyType: UE.EFBXSceneOptionsCreateHierarchyType;
        bForceFrontXAxis: boolean;
        ImportTranslation: UE.Vector;
        ImportRotation: UE.Rotator;
        ImportUniformScale: number;
        bTransformVertexToAbsolute: boolean;
        bBakePivotInVertex: boolean;
        bImportStaticMeshLODs: boolean;
        bImportSkeletalMeshLODs: boolean;
        bInvertNormalMaps: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxSceneImportOptions;
        static Load(InName: string): FbxSceneImportOptions;
    }
    
    enum EFbxSceneVertexColorImportOption { Replace, Ignore, Override, EFbxSceneVertexColorImportOption_MAX}
    enum EFBXSceneNormalImportMethod { FBXSceneNIM_ComputeNormals, FBXSceneNIM_ImportNormals, FBXSceneNIM_ImportNormalsAndTangents, FBXSceneNIM_MAX}
    enum EFBXSceneNormalGenerationMethod { BuiltIn, MikkTSpace, EFBXSceneNormalGenerationMethod_MAX}
    class FbxSceneImportOptionsStaticMesh extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StaticMeshLODGroup: string;
        bAutoGenerateCollision: boolean;
        VertexColorImportOption: UE.EFbxSceneVertexColorImportOption;
        VertexOverrideColor: UE.Color;
        bRemoveDegenerates: boolean;
        bBuildAdjacencyBuffer: boolean;
        bBuildReversedIndexBuffer: boolean;
        bGenerateLightmapUVs: boolean;
        bOneConvexHullPerUCX: boolean;
        NormalImportMethod: UE.EFBXSceneNormalImportMethod;
        NormalGenerationMethod: UE.EFBXSceneNormalGenerationMethod;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxSceneImportOptionsStaticMesh;
        static Load(InName: string): FbxSceneImportOptionsStaticMesh;
    }
    
    class FbxSceneImportOptionsSkeletalMesh extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUpdateSkeletonReferencePose: boolean;
        bCreatePhysicsAsset: boolean;
        bUseT0AsRefPose: boolean;
        bPreserveSmoothingGroups: boolean;
        bImportMeshesInBoneHierarchy: boolean;
        bImportMorphTargets: boolean;
        ThresholdPosition: number;
        ThresholdTangentNormal: number;
        ThresholdUV: number;
        bImportAnimations: boolean;
        AnimationLength: UE.EFBXAnimationLengthImportType;
        FrameImportRange: UE.Int32Interval;
        bUseDefaultSampleRate: boolean;
        CustomSampleRate: number;
        bImportCustomAttribute: boolean;
        bDeleteExistingCustomAttributeCurves: boolean;
        bPreserveLocalTransform: boolean;
        bDeleteExistingMorphTargetCurves: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxSceneImportOptionsSkeletalMesh;
        static Load(InName: string): FbxSceneImportOptionsSkeletalMesh;
    }
    
    class FbxSceneImportFactory extends UE.SceneImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SceneImportOptions: UE.FbxSceneImportOptions;
        SceneImportOptionsStaticMesh: UE.FbxSceneImportOptionsStaticMesh;
        SceneImportOptionsSkeletalMesh: UE.FbxSceneImportOptionsSkeletalMesh;
        StaticMeshImportData: UE.FbxStaticMeshImportData;
        SkeletalMeshImportData: UE.FbxSkeletalMeshImportData;
        AnimSequenceImportData: UE.FbxAnimSequenceImportData;
        TextureImportData: UE.FbxTextureImportData;
        ReimportData: UE.FbxSceneImportData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxSceneImportFactory;
        static Load(InName: string): FbxSceneImportFactory;
    }
    
    enum EFBXTestPlanActionType { Import, Reimport, AddLOD, ReimportLOD, ImportReload, EFBXTestPlanActionType_MAX}
    enum EFBXExpectedResultPreset { Error_Number, Warning_Number, Created_Staticmesh_Number, Created_Skeletalmesh_Number, Materials_Created_Number, Material_Slot_Imported_Name, Vertex_Number, Lod_Number, Vertex_Number_Lod, Mesh_Materials_Number, Mesh_LOD_Section_Number, Mesh_LOD_Section_Vertex_Number, Mesh_LOD_Section_Triangle_Number, Mesh_LOD_Section_Material_Name, Mesh_LOD_Section_Material_Index, Mesh_LOD_Section_Material_Imported_Name, Mesh_LOD_Vertex_Position, Mesh_LOD_Vertex_Normal, LOD_UV_Channel_Number, Bone_Number, Bone_Position, Animation_Frame_Number, Animation_Length, EFBXExpectedResultPreset_MAX}
    class FbxTestPlanExpectedResult {
        constructor();
        constructor(ExpectedPresetsType: UE.EFBXExpectedResultPreset, ExpectedPresetsDataInteger: TArray<number>, ExpectedPresetsDataFloat: TArray<number>, ExpectedPresetsDataDouble: TArray<number>, ExpectedPresetsDataString: TArray<string>);
        ExpectedPresetsType: UE.EFBXExpectedResultPreset;
        ExpectedPresetsDataInteger: TArray<number>;
        ExpectedPresetsDataFloat: TArray<number>;
        ExpectedPresetsDataDouble: TArray<number>;
        ExpectedPresetsDataString: TArray<string>;
        static StaticClass(): Class;
    }
    
    class FbxTestPlan extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TestPlanName: string;
        Action: UE.EFBXTestPlanActionType;
        LodIndex: number;
        bDeleteFolderAssets: boolean;
        ExpectedResult: TArray<UE.FbxTestPlanExpectedResult>;
        ImportUI: UE.FbxImportUI;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxTestPlan;
        static Load(InName: string): FbxTestPlan;
    }
    
    class FFITestGameInstance extends UE.GameInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FFITestGameInstance;
        static Load(InName: string): FFITestGameInstance;
    }
    
    class FieldNodeInt extends UE.FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldNodeInt;
        static Load(InName: string): FieldNodeInt;
    }
    
    class FieldNodeVector extends UE.FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldNodeVector;
        static Load(InName: string): FieldNodeVector;
    }
    
    class FieldSystemMetaDataIteration extends UE.FieldSystemMetaData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Iterations: number;
        SetMetaDataIteration(Iterations: number) : UE.FieldSystemMetaDataIteration;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldSystemMetaDataIteration;
        static Load(InName: string): FieldSystemMetaDataIteration;
    }
    
    enum EFieldResolutionType { Field_Resolution_Minimal, Field_Resolution_DisabledParents, Field_Resolution_Maximum, Field_Resolution_Max, Field_Resolution_MAX}
    class FieldSystemMetaDataProcessingResolution extends UE.FieldSystemMetaData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ResolutionType: UE.EFieldResolutionType;
        SetMetaDataaProcessingResolutionType(ResolutionType: UE.EFieldResolutionType) : UE.FieldSystemMetaDataProcessingResolution;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldSystemMetaDataProcessingResolution;
        static Load(InName: string): FieldSystemMetaDataProcessingResolution;
    }
    
    class FileMediaSource extends UE.BaseMediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FilePath: string;
        PrecacheFile: boolean;
        SetFilePath(Path: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FileMediaSource;
        static Load(InName: string): FileMediaSource;
    }
    
    class FileMediaSourceFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FileMediaSourceFactoryNew;
        static Load(InName: string): FileMediaSourceFactoryNew;
    }
    
    class FileServerCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FileServerCommandlet;
        static Load(InName: string): FileServerCommandlet;
    }
    
    class FileSystemOperation extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CreateDirectory(Path: string) : void;
        static DirectoryExists(Path: string) : boolean;
        static FileExists(Path: string) : boolean;
        static FileMD5Hash(Path: string) : string;
        static GetCurrentDirectory() : string;
        static GetDirectories(Path: string) : TArray<string>;
        static GetFiles(Path: string) : TArray<string>;
        static PuertsNotifyChange(Path: string, Source: string) : void;
        static ReadFile(Path: string, Data: $Ref<string>) : boolean;
        static ResolvePath(Path: string) : string;
        static WriteFile(Path: string, Data: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FileSystemOperation;
        static Load(InName: string): FileSystemOperation;
    }
    
    class BlueprintSessionResult {
        constructor();
        static StaticClass(): Class;
    }
    
    class FindSessionsCallbackProxy extends UE.OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(Results: TArray<UE.BlueprintSessionResult>) => void>;
        OnFailure: $MulticastDelegate<(Results: TArray<UE.BlueprintSessionResult>) => void>;
        static FindSessions(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>, MaxResults: number, bUseLAN: boolean) : UE.FindSessionsCallbackProxy;
        static GetCurrentPlayers(Result: UE.BlueprintSessionResult) : number;
        static GetMaxPlayers(Result: UE.BlueprintSessionResult) : number;
        static GetPingInMs(Result: UE.BlueprintSessionResult) : number;
        static GetServerName(Result: UE.BlueprintSessionResult) : string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FindSessionsCallbackProxy;
        static Load(InName: string): FindSessionsCallbackProxy;
    }
    
    class FindTurnBasedMatchCallbackProxy extends UE.OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(MatchID: string) => void>;
        OnFailure: $MulticastDelegate<(MatchID: string) => void>;
        static FindTurnBasedMatch(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>, MatchActor: TurnBasedMatchInterface, MinPlayers: number, MaxPlayers: number, PlayerGroup: number, ShowExistingMatches: boolean) : UE.FindTurnBasedMatchCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FindTurnBasedMatchCallbackProxy;
        static Load(InName: string): FindTurnBasedMatchCallbackProxy;
    }
    
    class FixConflictingLocalizationKeysCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FixConflictingLocalizationKeysCommandlet;
        static Load(InName: string): FixConflictingLocalizationKeysCommandlet;
    }
    
    class FixedFrameRateCustomTimeStep extends UE.EngineCustomTimeStep {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FixedFrameRate: UE.FrameRate;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FixedFrameRateCustomTimeStep;
        static Load(InName: string): FixedFrameRateCustomTimeStep;
    }
    
    class ResavePackagesCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ResavePackagesCommandlet;
        static Load(InName: string): ResavePackagesCommandlet;
    }
    
    class FixupNeedsLoadForEditorGameCommandlet extends UE.ResavePackagesCommandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FixupNeedsLoadForEditorGameCommandlet;
        static Load(InName: string): FixupNeedsLoadForEditorGameCommandlet;
    }
    
    class FlipbookEditorSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BackgroundColor: UE.Color;
        bShowGridByDefault: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FlipbookEditorSettings;
        static Load(InName: string): FlipbookEditorSettings;
    }
    
    class FloatBinding extends UE.PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetValue() : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FloatBinding;
        static Load(InName: string): FloatBinding;
    }
    
    class MovieSceneTangentData {
        constructor();
        constructor(ArriveTangent: number, LeaveTangent: number, TangentWeightMode: UE.ERichCurveTangentWeightMode, ArriveTangentWeight: number, LeaveTangentWeight: number);
        ArriveTangent: number;
        LeaveTangent: number;
        TangentWeightMode: UE.ERichCurveTangentWeightMode;
        ArriveTangentWeight: number;
        LeaveTangentWeight: number;
        static StaticClass(): Class;
    }
    
    class MovieSceneFloatValue {
        constructor();
        constructor(Value: number, InterpMode: UE.ERichCurveInterpMode, TangentMode: UE.ERichCurveTangentMode, Tangent: UE.MovieSceneTangentData);
        Value: number;
        InterpMode: UE.ERichCurveInterpMode;
        TangentMode: UE.ERichCurveTangentMode;
        Tangent: UE.MovieSceneTangentData;
        static StaticClass(): Class;
    }
    
    class FloatChannelKeyProxy extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Time: UE.FrameNumber;
        Value: UE.MovieSceneFloatValue;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FloatChannelKeyProxy;
        static Load(InName: string): FloatChannelKeyProxy;
    }
    
    class FloatingPawnMovement extends UE.PawnMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxSpeed: number;
        Acceleration: number;
        Deceleration: number;
        TurningBoost: number;
        bPositionCorrected: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FloatingPawnMovement;
        static Load(InName: string): FloatingPawnMovement;
    }
    
    enum EHorizTextAligment { EHTA_Left, EHTA_Center, EHTA_Right, EHTA_MAX}
    enum EVerticalTextAligment { EVRTA_TextTop, EVRTA_TextCenter, EVRTA_TextBottom, EVRTA_QuadTop, EVRTA_MAX}
    class TextRenderComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Text: string;
        TextMaterial: UE.MaterialInterface;
        Font: UE.Font;
        HorizontalAlignment: UE.EHorizTextAligment;
        VerticalAlignment: UE.EVerticalTextAligment;
        TextRenderColor: UE.Color;
        XScale: number;
        YScale: number;
        WorldSize: number;
        InvDefaultSize: number;
        HorizSpacingAdjust: number;
        VertSpacingAdjust: number;
        bAlwaysRenderAsText: boolean;
        GetTextLocalSize() : UE.Vector;
        GetTextWorldSize() : UE.Vector;
        K2_SetText(Value: string) : void;
        SetFont(Value: $Nullable<UE.Font>) : void;
        SetHorizontalAlignment(Value: UE.EHorizTextAligment) : void;
        SetHorizSpacingAdjust(Value: number) : void;
        SetText(Value: string) : void;
        SetTextMaterial(Material: $Nullable<UE.MaterialInterface>) : void;
        SetTextRenderColor(Value: UE.Color) : void;
        SetVerticalAlignment(Value: UE.EVerticalTextAligment) : void;
        SetVertSpacingAdjust(Value: number) : void;
        SetWorldSize(Value: number) : void;
        SetXScale(Value: number) : void;
        SetYScale(Value: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextRenderComponent;
        static Load(InName: string): TextRenderComponent;
    }
    
    class FloatingText extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SceneComponent: UE.SceneComponent;
        FirstLineComponent: UE.StaticMeshComponent;
        JointSphereComponent: UE.StaticMeshComponent;
        SecondLineComponent: UE.StaticMeshComponent;
        TextComponent: UE.TextRenderComponent;
        MaskedTextMaterial: UE.MaterialInterface;
        TranslucentTextMaterial: UE.MaterialInterface;
        LineMaterial: UE.MaterialInterface;
        LineMaterialMID: UE.MaterialInstanceDynamic;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FloatingText;
        static Load(InName: string): FloatingText;
    }
    
    class FloatProperty extends UE.NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FloatProperty;
        static Load(InName: string): FloatProperty;
    }
    
    class InstancedStaticMeshInstanceData {
        constructor();
        constructor(Transform: UE.Matrix);
        Transform: UE.Matrix;
        static StaticClass(): Class;
    }
    
    class InstancedStaticMeshMappingInfo {
        constructor();
        static StaticClass(): Class;
    }
    
    class InstancedStaticMeshComponent extends UE.StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PerInstanceSMData: TArray<UE.InstancedStaticMeshInstanceData>;
        InstancingRandomSeed: number;
        InstanceStartCullDistance: number;
        InstanceEndCullDistance: number;
        InstanceReorderTable: TArray<number>;
        NumPendingLightmaps: number;
        CachedMappings: TArray<UE.InstancedStaticMeshMappingInfo>;
        AddInstance(InstanceTransform: UE.Transform) : number;
        AddInstanceWorldSpace(WorldTransform: UE.Transform) : number;
        BatchUpdateInstancesTransform(StartInstanceIndex: number, NumInstances: number, NewInstancesTransform: UE.Transform, bWorldSpace?: boolean /* = false */, bMarkRenderStateDirty?: boolean /* = false */, bTeleport?: boolean /* = false */) : boolean;
        BatchUpdateInstancesTransforms(StartInstanceIndex: number, NewInstancesTransforms: TArray<UE.Transform>, bWorldSpace?: boolean /* = false */, bMarkRenderStateDirty?: boolean /* = false */, bTeleport?: boolean /* = false */) : boolean;
        ClearInstances() : void;
        GetInstanceCount() : number;
        GetInstancesOverlappingBox(Box: UE.Box, bBoxInWorldSpace?: boolean /* = true */) : TArray<number>;
        GetInstancesOverlappingSphere(Center: UE.Vector, Radius: number, bSphereInWorldSpace?: boolean /* = true */) : TArray<number>;
        GetInstanceTransform(InstanceIndex: number, OutInstanceTransform: $Ref<UE.Transform>, bWorldSpace?: boolean /* = false */) : boolean;
        RemoveInstance(InstanceIndex: number) : boolean;
        SetCullDistances(StartCullDistance: number, EndCullDistance: number) : void;
        UpdateInstanceTransform(InstanceIndex: number, NewInstanceTransform: UE.Transform, bWorldSpace?: boolean /* = false */, bMarkRenderStateDirty?: boolean /* = false */, bTeleport?: boolean /* = false */) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InstancedStaticMeshComponent;
        static Load(InName: string): InstancedStaticMeshComponent;
    }
    
    class HierarchicalInstancedStaticMeshComponent extends UE.InstancedStaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SortedInstances: TArray<number>;
        NumBuiltInstances: number;
        BuiltInstanceBounds: UE.Box;
        UnbuiltInstanceBounds: UE.Box;
        UnbuiltInstanceBoundsList: TArray<UE.Box>;
        bEnableDensityScaling: boolean;
        OcclusionLayerNumNodes: number;
        CacheMeshExtendedBounds: UE.BoxSphereBounds;
        bDisableCollision: boolean;
        InstanceCountToRender: number;
        RemoveInstances(InstancesToRemove: TArray<number>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HierarchicalInstancedStaticMeshComponent;
        static Load(InName: string): HierarchicalInstancedStaticMeshComponent;
    }
    
    class FoliageInstancedStaticMeshComponent extends UE.HierarchicalInstancedStaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnInstanceTakePointDamage: $MulticastDelegate<(InstanceIndex: number, Damage: number, InstigatedBy: $Nullable<UE.Controller>, HitLocation: UE.Vector, ShotFromDirection: UE.Vector, DamageType: $Nullable<UE.DamageType>, DamageCauser: $Nullable<UE.Actor>) => void>;
        OnInstanceTakeRadialDamage: $MulticastDelegate<(Instances: TArray<number>, Damages: TArray<number>, InstigatedBy: $Nullable<UE.Controller>, Origin: UE.Vector, MaxRadius: number, DamageType: $Nullable<UE.DamageType>, DamageCauser: $Nullable<UE.Actor>) => void>;
        FoliageHiddenEditorViews: bigint;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageInstancedStaticMeshComponent;
        static Load(InName: string): FoliageInstancedStaticMeshComponent;
    }
    
    class FoliageStatistics extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static FoliageOverlappingBoxCount(WorldContextObject: $Nullable<UE.Object>, StaticMesh: $Nullable<UE.StaticMesh>, Box: UE.Box) : number;
        static FoliageOverlappingSphereCount(WorldContextObject: $Nullable<UE.Object>, StaticMesh: $Nullable<UE.StaticMesh>, CenterPosition: UE.Vector, Radius: number) : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageStatistics;
        static Load(InName: string): FoliageStatistics;
    }
    
    enum EFoliageScaling { Uniform, Free, LockXY, LockXZ, LockYZ, EFoliageScaling_MAX}
    class FloatInterval {
        constructor();
        constructor(Min: number, Max: number);
        Min: number;
        Max: number;
        static StaticClass(): Class;
    }
    
    class FoliageVertexColorChannelMask {
        constructor();
        constructor(UseMask: boolean, MaskThreshold: number, InvertMask: boolean);
        UseMask: boolean;
        MaskThreshold: number;
        InvertMask: boolean;
        static StaticClass(): Class;
    }
    
    enum FoliageVertexColorMask { FOLIAGEVERTEXCOLORMASK_Disabled, FOLIAGEVERTEXCOLORMASK_Red, FOLIAGEVERTEXCOLORMASK_Green, FOLIAGEVERTEXCOLORMASK_Blue, FOLIAGEVERTEXCOLORMASK_Alpha, FOLIAGEVERTEXCOLORMASK_MAX}
    class FoliageType extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UpdateGuid: UE.Guid;
        Density: number;
        DensityAdjustmentFactor: number;
        Radius: number;
        bSingleInstanceModeOverrideRadius: boolean;
        SingleInstanceModeRadius: number;
        Scaling: UE.EFoliageScaling;
        ScaleX: UE.FloatInterval;
        ScaleY: UE.FloatInterval;
        ScaleZ: UE.FloatInterval;
        VertexColorMaskByChannel: FixSizeArray<UE.FoliageVertexColorChannelMask>;
        VertexColorMask: UE.FoliageVertexColorMask;
        VertexColorMaskThreshold: number;
        VertexColorMaskInvert: boolean;
        ZOffset: UE.FloatInterval;
        AlignToNormal: boolean;
        AlignMaxAngle: number;
        RandomYaw: boolean;
        RandomPitchAngle: number;
        GroundSlopeAngle: UE.FloatInterval;
        Height: UE.FloatInterval;
        LandscapeLayers: TArray<string>;
        MinimumLayerWeight: number;
        ExclusionLandscapeLayers: TArray<string>;
        MinimumExclusionLayerWeight: number;
        LandscapeLayer: string;
        CollisionWithWorld: boolean;
        CollisionScale: UE.Vector;
        MeshBounds: UE.BoxSphereBounds;
        LowBoundOriginRadius: UE.Vector;
        Mobility: UE.EComponentMobility;
        CullDistance: UE.Int32Interval;
        bEnableStaticLighting: boolean;
        CastShadow: boolean;
        bAffectDynamicIndirectLighting: boolean;
        bAffectDistanceFieldLighting: boolean;
        bCastDynamicShadow: boolean;
        bCastStaticShadow: boolean;
        bCastShadowAsTwoSided: boolean;
        bReceivesDecals: boolean;
        bOverrideLightMapRes: boolean;
        OverriddenLightMapRes: number;
        LightmapType: UE.ELightmapType;
        bUseAsOccluder: boolean;
        BodyInstance: UE.BodyInstance;
        CustomNavigableGeometry: UE.EHasCustomNavigableGeometry;
        LightingChannels: UE.LightingChannels;
        bRenderCustomDepth: boolean;
        CustomDepthStencilValue: number;
        TranslucencySortPriority: number;
        HiddenEditorViews: bigint;
        IsSelected: boolean;
        CollisionRadius: number;
        ShadeRadius: number;
        NumSteps: number;
        InitialSeedDensity: number;
        AverageSpreadDistance: number;
        SpreadVariance: number;
        SeedsPerStep: number;
        DistributionSeed: number;
        MaxInitialSeedOffset: number;
        bCanGrowInShade: boolean;
        bSpawnsInShade: boolean;
        MaxInitialAge: number;
        MaxAge: number;
        OverlapPriority: number;
        ProceduralScale: UE.FloatInterval;
        ScaleCurve: UE.RuntimeFloatCurve;
        ChangeCount: number;
        ReapplyDensity: boolean;
        ReapplyRadius: boolean;
        ReapplyAlignToNormal: boolean;
        ReapplyRandomYaw: boolean;
        ReapplyScaling: boolean;
        ReapplyScaleX: boolean;
        ReapplyScaleY: boolean;
        ReapplyScaleZ: boolean;
        ReapplyRandomPitchAngle: boolean;
        ReapplyGroundSlope: boolean;
        ReapplyHeight: boolean;
        ReapplyLandscapeLayers: boolean;
        ReapplyZOffset: boolean;
        ReapplyCollisionWithWorld: boolean;
        ReapplyVertexColorMask: boolean;
        bEnableDensityScaling: boolean;
        RuntimeVirtualTextures: TArray<UE.RuntimeVirtualTexture>;
        VirtualTextureCullMips: number;
        VirtualTextureRenderPassType: UE.ERuntimeVirtualTextureMainPassType;
        ScaleMinX: number;
        ScaleMinY: number;
        ScaleMinZ: number;
        ScaleMaxX: number;
        ScaleMaxY: number;
        ScaleMaxZ: number;
        HeightMin: number;
        HeightMax: number;
        ZOffsetMin: number;
        ZOffsetMax: number;
        StartCullDistance: number;
        EndCullDistance: number;
        UniformScale: boolean;
        LockScaleX: boolean;
        LockScaleY: boolean;
        LockScaleZ: boolean;
        GroundSlope: number;
        MinGroundSlope: number;
        MinScale: number;
        MaxScale: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageType;
        static Load(InName: string): FoliageType;
    }
    
    class FoliageType_Actor extends UE.FoliageType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActorClass: UE.Class;
        bShouldAttachToBaseComponent: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageType_Actor;
        static Load(InName: string): FoliageType_Actor;
    }
    
    class FoliageType_ActorFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageType_ActorFactory;
        static Load(InName: string): FoliageType_ActorFactory;
    }
    
    class FoliageType_ActorThumbnailRenderer extends UE.BlueprintThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageType_ActorThumbnailRenderer;
        static Load(InName: string): FoliageType_ActorThumbnailRenderer;
    }
    
    class FoliageType_InstancedStaticMesh extends UE.FoliageType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Mesh: UE.StaticMesh;
        OverrideMaterials: TArray<UE.MaterialInterface>;
        ComponentClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageType_InstancedStaticMesh;
        static Load(InName: string): FoliageType_InstancedStaticMesh;
    }
    
    class FoliageType_InstancedStaticMeshFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageType_InstancedStaticMeshFactory;
        static Load(InName: string): FoliageType_InstancedStaticMeshFactory;
    }
    
    class FoliageType_ISMThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageType_ISMThumbnailRenderer;
        static Load(InName: string): FoliageType_ISMThumbnailRenderer;
    }
    
    enum EFontLayoutMethod { Metrics, BoundingBox, EFontLayoutMethod_MAX}
    class FontFace extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceFilename: string;
        Hinting: UE.EFontHinting;
        LoadingPolicy: UE.EFontLoadingPolicy;
        LayoutMethod: UE.EFontLayoutMethod;
        FontFaceData: TArray<number>;
        SubFaces: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FontFace;
        static Load(InName: string): FontFace;
    }
    
    class FontFaceInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FontFaceInterface;
        static Load(InName: string): FontFaceInterface;
    }
    
    class FontFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FontFactory;
        static Load(InName: string): FontFactory;
    }
    
    class FontFileImportFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FontFileImportFactory;
        static Load(InName: string): FontFileImportFactory;
    }
    
    class FontImportOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Data: UE.FontImportOptionsData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FontImportOptions;
        static Load(InName: string): FontImportOptions;
    }
    
    class FontProviderInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FontProviderInterface;
        static Load(InName: string): FontProviderInterface;
    }
    
    class TextureThumbnailRenderer extends UE.ThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureThumbnailRenderer;
        static Load(InName: string): TextureThumbnailRenderer;
    }
    
    class FontThumbnailRenderer extends UE.TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FontThumbnailRenderer;
        static Load(InName: string): FontThumbnailRenderer;
    }
    
    class ForceFeedbackAttenuationSettings extends UE.BaseAttenuationSettings {
        constructor();
        static StaticClass(): Class;
    }
    
    class ForceFeedbackAttenuation extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Attenuation: UE.ForceFeedbackAttenuationSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ForceFeedbackAttenuation;
        static Load(InName: string): ForceFeedbackAttenuation;
    }
    
    class ForceFeedbackAttenuationFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ForceFeedbackAttenuationFactory;
        static Load(InName: string): ForceFeedbackAttenuationFactory;
    }
    
    class ForceFeedbackComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ForceFeedbackEffect: UE.ForceFeedbackEffect;
        bAutoDestroy: boolean;
        bStopWhenOwnerDestroyed: boolean;
        bLooping: boolean;
        bIgnoreTimeDilation: boolean;
        bOverrideAttenuation: boolean;
        IntensityMultiplier: number;
        AttenuationSettings: UE.ForceFeedbackAttenuation;
        AttenuationOverrides: UE.ForceFeedbackAttenuationSettings;
        OnForceFeedbackFinished: $MulticastDelegate<(ForceFeedbackComponent: $Nullable<UE.ForceFeedbackComponent>) => void>;
        AdjustAttenuation(InAttenuationSettings: UE.ForceFeedbackAttenuationSettings) : void;
        BP_GetAttenuationSettingsToApply(OutAttenuationSettings: $Ref<UE.ForceFeedbackAttenuationSettings>) : boolean;
        Play(StartTime?: number /* = 0.000000 */) : void;
        SetForceFeedbackEffect(NewForceFeedbackEffect: $Nullable<UE.ForceFeedbackEffect>) : void;
        SetIntensityMultiplier(NewIntensityMultiplier: number) : void;
        Stop() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ForceFeedbackComponent;
        static Load(InName: string): ForceFeedbackComponent;
    }
    
    class ForceFeedbackEffectFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ForceFeedbackEffectFactory;
        static Load(InName: string): ForceFeedbackEffectFactory;
    }
    
    class FTextCrash extends UE.ClientUnitTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FTextCrash;
        static Load(InName: string): FTextCrash;
    }
    
    class FuncTestRenderingComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FuncTestRenderingComponent;
        static Load(InName: string): FuncTestRenderingComponent;
    }
    
    enum EFunctionalTestLogHandling { ProjectDefault, OutputIsError, OutputIgnored, EFunctionalTestLogHandling_MAX}
    class RandomStream {
        constructor();
        constructor(InitialSeed: number, Seed: number);
        InitialSeed: number;
        Seed: number;
        static StaticClass(): Class;
    }
    
    enum EFunctionalTestResult { Default, Invalid, Error, Running, Failed, Succeeded, EFunctionalTestResult_MAX}
    enum EComparisonMethod { Equal_To, Not_Equal_To, Greater_Than_Or_Equal_To, Less_Than_Or_Equal_To, Greater_Than, Less_Than, EComparisonMethod_MAX}
    class TraceQueryTestNames {
        constructor();
        constructor(ComponentName: string, PhysicalMaterialName: string, ActorName: string);
        ComponentName: string;
        PhysicalMaterialName: string;
        ActorName: string;
        static StaticClass(): Class;
    }
    
    class TraceQueryTestResultsInnerMost {
        constructor();
        constructor(SingleHit: UE.HitResult, SingleNames: UE.TraceQueryTestNames, bSingleResult: boolean, MultiHits: TArray<UE.HitResult>, MultiNames: TArray<UE.TraceQueryTestNames>, bMultiResult: boolean);
        SingleHit: UE.HitResult;
        SingleNames: UE.TraceQueryTestNames;
        bSingleResult: boolean;
        MultiHits: TArray<UE.HitResult>;
        MultiNames: TArray<UE.TraceQueryTestNames>;
        bMultiResult: boolean;
        static StaticClass(): Class;
    }
    
    class TraceQueryTestResultsInner {
        constructor();
        constructor(LineResults: UE.TraceQueryTestResultsInnerMost, SphereResults: UE.TraceQueryTestResultsInnerMost, CapsuleResults: UE.TraceQueryTestResultsInnerMost, BoxResults: UE.TraceQueryTestResultsInnerMost);
        LineResults: UE.TraceQueryTestResultsInnerMost;
        SphereResults: UE.TraceQueryTestResultsInnerMost;
        CapsuleResults: UE.TraceQueryTestResultsInnerMost;
        BoxResults: UE.TraceQueryTestResultsInnerMost;
        static StaticClass(): Class;
    }
    
    class TraceChannelTestBatchOptions {
        constructor();
        constructor(bLineTrace: boolean, bSphereTrace: boolean, bCapsuleTrace: boolean, bBoxTrace: boolean, bChannelTrace: boolean, bObjectsTrace: boolean, bProfileTrace: boolean);
        bLineTrace: boolean;
        bSphereTrace: boolean;
        bCapsuleTrace: boolean;
        bBoxTrace: boolean;
        bChannelTrace: boolean;
        bObjectsTrace: boolean;
        bProfileTrace: boolean;
        static StaticClass(): Class;
    }
    
    class TraceQueryTestResults extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChannelResults: UE.TraceQueryTestResultsInner;
        ObjectResults: UE.TraceQueryTestResultsInner;
        ProfileResults: UE.TraceQueryTestResultsInner;
        BatchOptions: UE.TraceChannelTestBatchOptions;
        ToString() : string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TraceQueryTestResults;
        static Load(InName: string): TraceQueryTestResults;
    }
    
    class FunctionalTest extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpriteComponent: UE.BillboardComponent;
        bIsEnabled: boolean;
        LogErrorHandling: UE.EFunctionalTestLogHandling;
        LogWarningHandling: UE.EFunctionalTestLogHandling;
        Author: string;
        Description: string;
        ObservationPoint: UE.Actor;
        RandomNumbersStream: UE.RandomStream;
        Result: UE.EFunctionalTestResult;
        PreparationTimeLimit: number;
        TimeLimit: number;
        TimesUpMessage: string;
        TimesUpResult: UE.EFunctionalTestResult;
        OnTestPrepare: $MulticastDelegate<() => void>;
        OnTestStart: $MulticastDelegate<() => void>;
        OnTestFinished: $MulticastDelegate<() => void>;
        AutoDestroyActors: TArray<UE.Actor>;
        RenderComp: UE.FuncTestRenderingComponent;
        TestName: UE.TextRenderComponent;
        bIsRunning: boolean;
        TotalTime: number;
        AddError(Message: string) : void;
        AddRerun(Reason: string) : void;
        AddWarning(Message: string) : void;
        AssertEqual_Bool(Actual: boolean, Expected: boolean, What: string, ContextObject?: UE.Object /* = None */) : boolean;
        AssertEqual_Float(Actual: number, Expected: number, What: string, Tolerance?: number /* = 0.000100 */, ContextObject?: UE.Object /* = None */) : boolean;
        AssertEqual_Int(Actual: number, Expected: number, What: string, ContextObject?: UE.Object /* = None */) : boolean;
        AssertEqual_Name(Actual: string, Expected: string, What: string, ContextObject?: UE.Object /* = None */) : boolean;
        AssertEqual_Rotator(Actual: UE.Rotator, Expected: UE.Rotator, What: string, Tolerance?: number /* = 0.000100 */, ContextObject?: UE.Object /* = None */) : boolean;
        AssertEqual_String(Actual: string, Expected: string, What: string, ContextObject?: UE.Object /* = None */) : boolean;
        AssertEqual_TraceQueryResults(Actual: $Nullable<UE.TraceQueryTestResults>, Expected: $Nullable<UE.TraceQueryTestResults>, What: string, ContextObject?: UE.Object /* = None */) : boolean;
        AssertEqual_Transform(Actual: UE.Transform, Expected: UE.Transform, What: string, Tolerance?: number /* = 0.000100 */, ContextObject?: UE.Object /* = None */) : boolean;
        AssertEqual_Vector(Actual: UE.Vector, Expected: UE.Vector, What: string, Tolerance?: number /* = 0.000100 */, ContextObject?: UE.Object /* = None */) : boolean;
        AssertFalse(Condition: boolean, Message: string, ContextObject?: UE.Object /* = None */) : boolean;
        AssertIsValid(Object: $Nullable<UE.Object>, Message: string, ContextObject?: UE.Object /* = None */) : boolean;
        AssertNotEqual_Rotator(Actual: UE.Rotator, NotExpected: UE.Rotator, What: string, ContextObject?: UE.Object /* = None */) : boolean;
        AssertNotEqual_String(Actual: string, NotExpected: string, What: string, ContextObject?: UE.Object /* = None */) : boolean;
        AssertNotEqual_Transform(Actual: UE.Transform, NotExpected: UE.Transform, What: string, ContextObject?: UE.Object /* = None */) : boolean;
        AssertNotEqual_Vector(Actual: UE.Vector, NotExpected: UE.Vector, What: string, ContextObject?: UE.Object /* = None */) : boolean;
        AssertTrue(Condition: boolean, Message: string, ContextObject?: UE.Object /* = None */) : boolean;
        AssertValue_DateTime(Actual: UE.DateTime, ShouldBe: UE.EComparisonMethod, Expected: UE.DateTime, What: string, ContextObject?: UE.Object /* = None */) : boolean;
        AssertValue_Float(Actual: number, ShouldBe: UE.EComparisonMethod, Expected: number, What: string, ContextObject?: UE.Object /* = None */) : boolean;
        AssertValue_Int(Actual: number, ShouldBe: UE.EComparisonMethod, Expected: number, What: string, ContextObject?: UE.Object /* = None */) : boolean;
        DebugGatherRelevantActors() : TArray<UE.Actor>;
        FinishTest(TestResult: UE.EFunctionalTestResult, Message: string) : void;
        GetCurrentRerunReason() : string;
        IsEnabled() : boolean;
        IsReady() : boolean;
        IsRunning() : boolean;
        LogMessage(Message: string) : void;
        OnAdditionalTestFinishedMessageRequest(TestResult: UE.EFunctionalTestResult) : string;
        OnWantsReRunCheck() : boolean;
        ReceivePrepareTest() : void;
        ReceiveStartTest() : void;
        RegisterAutoDestroyActor(ActorToAutoDestroy: $Nullable<UE.Actor>) : void;
        SetTimeLimit(NewTimeLimit: number, ResultWhenTimeRunsOut: UE.EFunctionalTestResult) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FunctionalTest;
        static Load(InName: string): FunctionalTest;
    }
    
    class GenericTeamId {
        constructor();
        constructor(TeamID: number);
        TeamID: number;
        static StaticClass(): Class;
    }
    
    class AITestSpawnInfo {
        constructor();
        constructor(PawnClass: UE.Class, ControllerClass: UE.Class, TeamID: UE.GenericTeamId, BehaviorTree: UE.BehaviorTree, SpawnLocation: UE.Actor, NumberToSpawn: number, SpawnDelay: number, PreSpawnDelay: number);
        PawnClass: UE.Class;
        ControllerClass: UE.Class;
        TeamID: UE.GenericTeamId;
        BehaviorTree: UE.BehaviorTree;
        SpawnLocation: UE.Actor;
        NumberToSpawn: number;
        SpawnDelay: number;
        PreSpawnDelay: number;
        static StaticClass(): Class;
    }
    
    class AITestSpawnSet {
        constructor();
        constructor(SpawnInfoContainer: TArray<UE.AITestSpawnInfo>, Name: string, bEnabled: boolean, FallbackSpawnLocation: UE.Actor);
        SpawnInfoContainer: TArray<UE.AITestSpawnInfo>;
        Name: string;
        bEnabled: boolean;
        FallbackSpawnLocation: UE.Actor;
        static StaticClass(): Class;
    }
    
    class PendingDelayedSpawn extends UE.AITestSpawnInfo {
        constructor();
        static StaticClass(): Class;
    }
    
    class FunctionalAITest extends UE.FunctionalTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpawnSets: TArray<UE.AITestSpawnSet>;
        SpawnLocationRandomizationRange: number;
        SpawnedPawns: TArray<UE.Pawn>;
        PendingDelayedSpawns: TArray<UE.PendingDelayedSpawn>;
        CurrentSpawnSetIndex: number;
        CurrentSpawnSetName: string;
        OnAISpawned: $MulticastDelegate<(Controller: $Nullable<UE.AIController>, Pawn: $Nullable<UE.Pawn>) => void>;
        OnAllAISPawned: $MulticastDelegate<() => void>;
        NavMeshDebugOrigin: UE.Vector;
        NavMeshDebugExtent: UE.Vector;
        bWaitForNavMesh: boolean;
        bDebugNavMeshOnTimeout: boolean;
        IsOneOfSpawnedPawns(Actor: $Nullable<UE.Actor>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FunctionalAITest;
        static Load(InName: string): FunctionalAITest;
    }
    
    class FunctionalTestGameMode extends UE.GameModeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FunctionalTestGameMode;
        static Load(InName: string): FunctionalTestGameMode;
    }
    
    class FunctionalTestingManager extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TestsLeft: TArray<UE.FunctionalTest>;
        AllTests: TArray<UE.FunctionalTest>;
        OnSetupTests: $MulticastDelegate<() => void>;
        OnTestsComplete: $MulticastDelegate<() => void>;
        OnTestsBegin: $MulticastDelegate<() => void>;
        static RunAllFunctionalTests(WorldContextObject: $Nullable<UE.Object>, bNewLog?: boolean /* = true */, bRunLooped?: boolean /* = false */, FailedTestsReproString?: string /* = "" */) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FunctionalTestingManager;
        static Load(InName: string): FunctionalTestingManager;
    }
    
    class FunctionalTestLevelScript extends UE.LevelScriptActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FunctionalTestLevelScript;
        static Load(InName: string): FunctionalTestLevelScript;
    }
    
    enum EDrawDebugTrace { None, ForOneFrame, ForDuration, Persistent, EDrawDebugTrace_MAX}
    class FunctionalTestUtilityLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static TraceChannelTestUtil(WorldContextObject: $Nullable<UE.Object>, BatchOptions: UE.TraceChannelTestBatchOptions, Start: UE.Vector, End: UE.Vector, SphereCapsuleRadius: number, CapsuleHalfHeight: number, BoxHalfSize: UE.Vector, Orientation: UE.Rotator, TraceChannel: UE.ETraceTypeQuery, ObjectTypes: TArray<UE.EObjectTypeQuery>, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, bIgnoreSelf: boolean, DrawDebugType: UE.EDrawDebugTrace, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : UE.TraceQueryTestResults;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FunctionalTestUtilityLibrary;
        static Load(InName: string): FunctionalTestUtilityLibrary;
    }
    
    class ScreenshotFunctionalTestBase extends UE.FunctionalTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Notes: string;
        ScreenshotCamera: UE.CameraComponent;
        ScreenshotOptions: UE.AutomationScreenshotOptions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScreenshotFunctionalTestBase;
        static Load(InName: string): ScreenshotFunctionalTestBase;
    }
    
    enum EWidgetTestAppearLocation { Viewport, PlayerScreen, EWidgetTestAppearLocation_MAX}
    class FunctionalUIScreenshotTest extends UE.ScreenshotFunctionalTestBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetClass: UE.Class;
        SpawnedWidget: UE.UserWidget;
        WidgetLocation: UE.EWidgetTestAppearLocation;
        ScreenshotRT: UE.TextureRenderTarget2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FunctionalUIScreenshotTest;
        static Load(InName: string): FunctionalUIScreenshotTest;
    }
    
    class GameEngine extends UE.Engine {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxDeltaTime: number;
        ServerFlushLogInterval: number;
        GameInstance: UE.GameInstance;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameEngine;
        static Load(InName: string): GameEngine;
    }
    
    class GameInstanceSubsystem extends UE.Subsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameInstanceSubsystem;
        static Load(InName: string): GameInstanceSubsystem;
    }
    
    enum ETwoPlayerSplitScreenType { Horizontal, Vertical, ETwoPlayerSplitScreenType_MAX}
    enum EThreePlayerSplitScreenType { FavorTop, FavorBottom, Vertical, Horizontal, EThreePlayerSplitScreenType_MAX}
    enum EFourPlayerSplitScreenType { Grid, Vertical, Horizontal, EFourPlayerSplitScreenType_MAX}
    class GameModeName {
        constructor();
        constructor(Name: string, GameMode: UE.SoftClassPath);
        Name: string;
        GameMode: UE.SoftClassPath;
        static StaticClass(): Class;
    }
    
    class GameMapsSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditorStartupMap: UE.SoftObjectPath;
        LocalMapOptions: string;
        TransitionMap: UE.SoftObjectPath;
        bUseSplitscreen: boolean;
        TwoPlayerSplitscreenLayout: UE.ETwoPlayerSplitScreenType;
        ThreePlayerSplitscreenLayout: UE.EThreePlayerSplitScreenType;
        FourPlayerSplitscreenLayout: UE.EFourPlayerSplitScreenType;
        bOffsetPlayerGamepadIds: boolean;
        GameInstanceClass: UE.SoftClassPath;
        GameDefaultMap: UE.SoftObjectPath;
        ServerDefaultMap: UE.SoftObjectPath;
        GlobalDefaultGameMode: UE.SoftClassPath;
        GlobalDefaultServerGameMode: UE.SoftClassPath;
        GameModeMapPrefixes: TArray<UE.GameModeName>;
        GameModeClassAliases: TArray<UE.GameModeName>;
        GetSkipAssigningGamepadToPlayer1() : boolean;
        SetSkipAssigningGamepadToPlayer1(bSkipFirstPlayer?: boolean /* = true */) : void;
        static GetGameMapsSettings() : UE.GameMapsSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameMapsSettings;
        static Load(InName: string): GameMapsSettings;
    }
    
    class GameNetworkManagerSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MinDynamicBandwidth: number;
        MaxDynamicBandwidth: number;
        TotalNetBandwidth: number;
        BadPingThreshold: number;
        bIsStandbyCheckingEnabled: boolean;
        StandbyRxCheatTime: number;
        StandbyTxCheatTime: number;
        PercentMissingForRxStandby: number;
        PercentMissingForTxStandby: number;
        PercentForBadPing: number;
        JoinInProgressStandbyWaitTime: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameNetworkManagerSettings;
        static Load(InName: string): GameNetworkManagerSettings;
    }
    
    class GameplayDebuggerNetPack {
        constructor();
        static StaticClass(): Class;
    }
    
    class GameplayDebuggerDebugActor {
        constructor();
        constructor(Actor: UE.Actor, ActorName: string, SyncCounter: number);
        Actor: UE.Actor;
        ActorName: string;
        SyncCounter: number;
        static StaticClass(): Class;
    }
    
    class GameplayDebuggerVisLogSync {
        constructor();
        constructor(DeviceIDs: string);
        DeviceIDs: string;
        static StaticClass(): Class;
    }
    
    class GameplayDebuggerRenderingComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayDebuggerRenderingComponent;
        static Load(InName: string): GameplayDebuggerRenderingComponent;
    }
    
    class GameplayDebuggerCategoryReplicator extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OwnerPC: UE.PlayerController;
        bIsEnabled: boolean;
        ReplicatedData: UE.GameplayDebuggerNetPack;
        DebugActor: UE.GameplayDebuggerDebugActor;
        VisLogSync: UE.GameplayDebuggerVisLogSync;
        RenderingComp: UE.GameplayDebuggerRenderingComponent;
        ServerSendCategoryInputEvent(CategoryId: number, HandlerId: number) : void;
        ServerSendExtensionInputEvent(ExtensionId: number, HandlerId: number) : void;
        ServerSetCategoryEnabled(CategoryId: number, bEnable: boolean) : void;
        ServerSetDebugActor(Actor: $Nullable<UE.Actor>, bSelectInEditor: boolean) : void;
        ServerSetEnabled(bEnable: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayDebuggerCategoryReplicator;
        static Load(InName: string): GameplayDebuggerCategoryReplicator;
    }
    
    enum EGameplayDebuggerOverrideMode { Enable, Disable, UseDefault, EGameplayDebuggerOverrideMode_MAX}
    class GameplayDebuggerInputConfig {
        constructor();
        constructor(ConfigName: string, Key: UE.Key, bModShift: boolean, bModCtrl: boolean, bModAlt: boolean, bModCmd: boolean);
        ConfigName: string;
        Key: UE.Key;
        bModShift: boolean;
        bModCtrl: boolean;
        bModAlt: boolean;
        bModCmd: boolean;
        static StaticClass(): Class;
    }
    
    class GameplayDebuggerCategoryConfig {
        constructor();
        constructor(CategoryName: string, SlotIdx: number, ActiveInGame: UE.EGameplayDebuggerOverrideMode, ActiveInSimulate: UE.EGameplayDebuggerOverrideMode, Hidden: UE.EGameplayDebuggerOverrideMode, bOverrideSlotIdx: boolean, InputHandlers: TArray<UE.GameplayDebuggerInputConfig>);
        CategoryName: string;
        SlotIdx: number;
        ActiveInGame: UE.EGameplayDebuggerOverrideMode;
        ActiveInSimulate: UE.EGameplayDebuggerOverrideMode;
        Hidden: UE.EGameplayDebuggerOverrideMode;
        bOverrideSlotIdx: boolean;
        InputHandlers: TArray<UE.GameplayDebuggerInputConfig>;
        static StaticClass(): Class;
    }
    
    class GameplayDebuggerExtensionConfig {
        constructor();
        constructor(ExtensionName: string, UseExtension: UE.EGameplayDebuggerOverrideMode, InputHandlers: TArray<UE.GameplayDebuggerInputConfig>);
        ExtensionName: string;
        UseExtension: UE.EGameplayDebuggerOverrideMode;
        InputHandlers: TArray<UE.GameplayDebuggerInputConfig>;
        static StaticClass(): Class;
    }
    
    class GameplayDebuggerConfig extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActivationKey: UE.Key;
        CategoryRowNextKey: UE.Key;
        CategoryRowPrevKey: UE.Key;
        CategorySlot0: UE.Key;
        CategorySlot1: UE.Key;
        CategorySlot2: UE.Key;
        CategorySlot3: UE.Key;
        CategorySlot4: UE.Key;
        CategorySlot5: UE.Key;
        CategorySlot6: UE.Key;
        CategorySlot7: UE.Key;
        CategorySlot8: UE.Key;
        CategorySlot9: UE.Key;
        DebugCanvasPaddingLeft: number;
        DebugCanvasPaddingRight: number;
        DebugCanvasPaddingTop: number;
        DebugCanvasPaddingBottom: number;
        Categories: TArray<UE.GameplayDebuggerCategoryConfig>;
        Extensions: TArray<UE.GameplayDebuggerExtensionConfig>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayDebuggerConfig;
        static Load(InName: string): GameplayDebuggerConfig;
    }
    
    class GameplayDebuggerPlayerData {
        constructor();
        constructor(Controller: UE.GameplayDebuggerLocalController, InputComponent: UE.InputComponent, Replicator: UE.GameplayDebuggerCategoryReplicator);
        Controller: UE.GameplayDebuggerLocalController;
        InputComponent: UE.InputComponent;
        Replicator: UE.GameplayDebuggerCategoryReplicator;
        static StaticClass(): Class;
    }
    
    class GameplayDebuggerPlayerManager extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlayerData: TArray<UE.GameplayDebuggerPlayerData>;
        PendingRegistrations: TArray<UE.GameplayDebuggerCategoryReplicator>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayDebuggerPlayerManager;
        static Load(InName: string): GameplayDebuggerPlayerManager;
    }
    
    class GameplayDebuggerLocalController extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CachedReplicator: UE.GameplayDebuggerCategoryReplicator;
        CachedPlayerManager: UE.GameplayDebuggerPlayerManager;
        DebugActorCandidate: UE.Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayDebuggerLocalController;
        static Load(InName: string): GameplayDebuggerLocalController;
    }
    
    enum EPSCPoolMethod { None, AutoRelease, ManualRelease, ManualRelease_OnComplete, FreeInPool, EPSCPoolMethod_MAX}
    enum EMouseCaptureMode { NoCapture, CapturePermanently, CapturePermanently_IncludingInitialMouseDown, CaptureDuringMouseDown, CaptureDuringRightMouseDown, EMouseCaptureMode_MAX}
    enum ESuggestProjVelocityTraceOption { DoNotTrace, TraceFullPath, OnlyTraceWhileAscending, ESuggestProjVelocityTraceOption_MAX}
    class PredictProjectilePathParams {
        constructor();
        constructor(StartLocation: UE.Vector, LaunchVelocity: UE.Vector, bTraceWithCollision: boolean, ProjectileRadius: number, MaxSimTime: number, bTraceWithChannel: boolean, TraceChannel: UE.ECollisionChannel, ObjectTypes: TArray<UE.EObjectTypeQuery>, ActorsToIgnore: TArray<UE.Actor>, SimFrequency: number, OverrideGravityZ: number, DrawDebugType: UE.EDrawDebugTrace, DrawDebugTime: number, bTraceComplex: boolean);
        StartLocation: UE.Vector;
        LaunchVelocity: UE.Vector;
        bTraceWithCollision: boolean;
        ProjectileRadius: number;
        MaxSimTime: number;
        bTraceWithChannel: boolean;
        TraceChannel: UE.ECollisionChannel;
        ObjectTypes: TArray<UE.EObjectTypeQuery>;
        ActorsToIgnore: TArray<UE.Actor>;
        SimFrequency: number;
        OverrideGravityZ: number;
        DrawDebugType: UE.EDrawDebugTrace;
        DrawDebugTime: number;
        bTraceComplex: boolean;
        static StaticClass(): Class;
    }
    
    class PredictProjectilePathPointData {
        constructor();
        constructor(Location: UE.Vector, Velocity: UE.Vector, Time: number);
        Location: UE.Vector;
        Velocity: UE.Vector;
        Time: number;
        static StaticClass(): Class;
    }
    
    class PredictProjectilePathResult {
        constructor();
        constructor(PathData: TArray<UE.PredictProjectilePathPointData>, LastTraceDestination: UE.PredictProjectilePathPointData, HitResult: UE.HitResult);
        PathData: TArray<UE.PredictProjectilePathPointData>;
        LastTraceDestination: UE.PredictProjectilePathPointData;
        HitResult: UE.HitResult;
        static StaticClass(): Class;
    }
    
    class GameplayStatics extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ActivateReverbEffect(WorldContextObject: $Nullable<UE.Object>, ReverbEffect: $Nullable<UE.ReverbEffect>, TagName: string, Priority?: number /* = 0.000000 */, Volume?: number /* = 0.500000 */, FadeTime?: number /* = 2.000000 */) : void;
        static ApplyDamage(DamagedActor: $Nullable<UE.Actor>, BaseDamage: number, EventInstigator: $Nullable<UE.Controller>, DamageCauser: $Nullable<UE.Actor>, DamageTypeClass: $Nullable<UE.Class>) : number;
        static ApplyPointDamage(DamagedActor: $Nullable<UE.Actor>, BaseDamage: number, HitFromDirection: UE.Vector, HitInfo: UE.HitResult, EventInstigator: $Nullable<UE.Controller>, DamageCauser: $Nullable<UE.Actor>, DamageTypeClass: $Nullable<UE.Class>) : number;
        static ApplyRadialDamage(WorldContextObject: $Nullable<UE.Object>, BaseDamage: number, Origin: UE.Vector, DamageRadius: number, DamageTypeClass: $Nullable<UE.Class>, IgnoreActors: TArray<UE.Actor>, DamageCauser?: UE.Actor /* = None */, InstigatedByController?: UE.Controller /* = None */, bDoFullDamage?: boolean /* = false */, DamagePreventionChannel?: UE.ECollisionChannel /* = ECC_Visibility */) : boolean;
        static ApplyRadialDamageWithFalloff(WorldContextObject: $Nullable<UE.Object>, BaseDamage: number, MinimumDamage: number, Origin: UE.Vector, DamageInnerRadius: number, DamageOuterRadius: number, DamageFalloff: number, DamageTypeClass: $Nullable<UE.Class>, IgnoreActors: TArray<UE.Actor>, DamageCauser?: UE.Actor /* = None */, InstigatedByController?: UE.Controller /* = None */, DamagePreventionChannel?: UE.ECollisionChannel /* = ECC_Visibility */) : boolean;
        static AreAnyListenersWithinRange(WorldContextObject: $Nullable<UE.Object>, Location: UE.Vector, MaximumRange: number) : boolean;
        static AreSubtitlesEnabled() : boolean;
        static BeginDeferredActorSpawnFromClass(WorldContextObject: $Nullable<UE.Object>, ActorClass: $Nullable<UE.Class>, SpawnTransform: UE.Transform, CollisionHandlingOverride?: UE.ESpawnActorCollisionHandlingMethod /* = Undefined */, Owner?: UE.Actor /* = None */) : UE.Actor;
        static BeginSpawningActorFromBlueprint(WorldContextObject: $Nullable<UE.Object>, Blueprint: $Nullable<UE.Blueprint>, SpawnTransform: UE.Transform, bNoCollisionFail: boolean) : UE.Actor;
        static BeginSpawningActorFromClass(WorldContextObject: $Nullable<UE.Object>, ActorClass: $Nullable<UE.Class>, SpawnTransform: UE.Transform, bNoCollisionFail?: boolean /* = false */, Owner?: UE.Actor /* = None */) : UE.Actor;
        static Blueprint_PredictProjectilePath_Advanced(WorldContextObject: $Nullable<UE.Object>, PredictParams: UE.PredictProjectilePathParams, PredictResult: $Ref<UE.PredictProjectilePathResult>) : boolean;
        static Blueprint_PredictProjectilePath_ByObjectType(WorldContextObject: $Nullable<UE.Object>, OutHit: $Ref<UE.HitResult>, OutPathPositions: $Ref<TArray<UE.Vector>>, OutLastTraceDestination: $Ref<UE.Vector>, StartPos: UE.Vector, LaunchVelocity: UE.Vector, bTracePath: boolean, ProjectileRadius: number, ObjectTypes: TArray<UE.EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, DrawDebugTime: number, SimFrequency?: number /* = 15.000000 */, MaxSimTime?: number /* = 2.000000 */, OverrideGravityZ?: number /* = 0.000000 */) : boolean;
        static Blueprint_PredictProjectilePath_ByTraceChannel(WorldContextObject: $Nullable<UE.Object>, OutHit: $Ref<UE.HitResult>, OutPathPositions: $Ref<TArray<UE.Vector>>, OutLastTraceDestination: $Ref<UE.Vector>, StartPos: UE.Vector, LaunchVelocity: UE.Vector, bTracePath: boolean, ProjectileRadius: number, TraceChannel: UE.ECollisionChannel, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, DrawDebugTime: number, SimFrequency?: number /* = 15.000000 */, MaxSimTime?: number /* = 2.000000 */, OverrideGravityZ?: number /* = 0.000000 */) : boolean;
        static BlueprintSuggestProjectileVelocity(WorldContextObject: $Nullable<UE.Object>, TossVelocity: $Ref<UE.Vector>, StartLocation: UE.Vector, EndLocation: UE.Vector, LaunchSpeed: number, OverrideGravityZ: number, TraceOption: UE.ESuggestProjVelocityTraceOption, CollisionRadius: number, bFavorHighArc: boolean, bDrawDebug: boolean) : boolean;
        static BreakHitResult(Hit: UE.HitResult, bBlockingHit: $Ref<boolean>, bInitialOverlap: $Ref<boolean>, Time: $Ref<number>, Distance: $Ref<number>, Location: $Ref<UE.Vector>, ImpactPoint: $Ref<UE.Vector>, Normal: $Ref<UE.Vector>, ImpactNormal: $Ref<UE.Vector>, PhysMat: $Ref<UE.PhysicalMaterial>, HitActor: $Ref<UE.Actor>, HitComponent: $Ref<UE.PrimitiveComponent>, HitBoneName: $Ref<string>, HitItem: $Ref<number>, FaceIndex: $Ref<number>, TraceStart: $Ref<UE.Vector>, TraceEnd: $Ref<UE.Vector>) : void;
        static CancelAsyncLoading() : void;
        static ClearSoundMixClassOverride(WorldContextObject: $Nullable<UE.Object>, InSoundMixModifier: $Nullable<UE.SoundMix>, InSoundClass: $Nullable<UE.SoundClass>, FadeOutTime?: number /* = 1.000000 */) : void;
        static ClearSoundMixModifiers(WorldContextObject: $Nullable<UE.Object>) : void;
        static CreatePlayer(WorldContextObject: $Nullable<UE.Object>, ControllerId?: number /* = -1 */, bSpawnPlayerController?: boolean /* = true */) : UE.PlayerController;
        static CreateSaveGameObject(SaveGameClass: $Nullable<UE.Class>) : UE.SaveGame;
        static CreateSound2D(WorldContextObject: $Nullable<UE.Object>, Sound: $Nullable<UE.SoundBase>, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, ConcurrencySettings?: UE.SoundConcurrency /* = None */, bPersistAcrossLevelTransition?: boolean /* = false */, bAutoDestroy?: boolean /* = true */) : UE.AudioComponent;
        static DeactivateReverbEffect(WorldContextObject: $Nullable<UE.Object>, TagName: string) : void;
        static DeleteGameInSlot(SlotName: string, UserIndex: number) : boolean;
        static DeprojectScreenToWorld(Player: $Nullable<UE.PlayerController>, ScreenPosition: UE.Vector2D, WorldPosition: $Ref<UE.Vector>, WorldDirection: $Ref<UE.Vector>) : boolean;
        static DoesSaveGameExist(SlotName: string, UserIndex: number) : boolean;
        static EnableLiveStreaming(Enable: boolean) : void;
        static FindCollisionUV(Hit: UE.HitResult, UVChannel: number, UV: $Ref<UE.Vector2D>) : boolean;
        static FinishSpawningActor(Actor: $Nullable<UE.Actor>, SpawnTransform: UE.Transform) : UE.Actor;
        static FlushLevelStreaming(WorldContextObject: $Nullable<UE.Object>) : void;
        static GetAccurateRealTime(WorldContextObject: $Nullable<UE.Object>, Seconds: $Ref<number>, PartialSeconds: $Ref<number>) : void;
        static GetActorArrayAverageLocation(Actors: TArray<UE.Actor>) : UE.Vector;
        static GetActorArrayBounds(Actors: TArray<UE.Actor>, bOnlyCollidingComponents: boolean, Center: $Ref<UE.Vector>, BoxExtent: $Ref<UE.Vector>) : void;
        static GetActorOfClass(WorldContextObject: $Nullable<UE.Object>, ActorClass: $Nullable<UE.Class>) : UE.Actor;
        static GetAllActorsOfClass(WorldContextObject: $Nullable<UE.Object>, ActorClass: $Nullable<UE.Class>, OutActors: $Ref<TArray<UE.Actor>>) : void;
        static GetAllActorsOfClassWithTag(WorldContextObject: $Nullable<UE.Object>, ActorClass: $Nullable<UE.Class>, Tag: string, OutActors: $Ref<TArray<UE.Actor>>) : void;
        static GetAllActorsWithInterface(WorldContextObject: $Nullable<UE.Object>, Interface: $Nullable<UE.Class>, OutActors: $Ref<TArray<UE.Actor>>) : void;
        static GetAllActorsWithTag(WorldContextObject: $Nullable<UE.Object>, Tag: string, OutActors: $Ref<TArray<UE.Actor>>) : void;
        static GetAudioTimeSeconds(WorldContextObject: $Nullable<UE.Object>) : number;
        static GetCurrentLevelName(WorldContextObject: $Nullable<UE.Object>, bRemovePrefixString?: boolean /* = true */) : string;
        static GetCurrentReverbEffect(WorldContextObject: $Nullable<UE.Object>) : UE.ReverbEffect;
        static GetEnableWorldRendering(WorldContextObject: $Nullable<UE.Object>) : boolean;
        static GetGameInstance(WorldContextObject: $Nullable<UE.Object>) : UE.GameInstance;
        static GetGameMode(WorldContextObject: $Nullable<UE.Object>) : UE.GameModeBase;
        static GetGameState(WorldContextObject: $Nullable<UE.Object>) : UE.GameStateBase;
        static GetGlobalTimeDilation(WorldContextObject: $Nullable<UE.Object>) : number;
        static GetIntOption(Options: string, Key: string, DefaultValue: number) : number;
        static GetKeyValue(Pair: string, Key: $Ref<string>, Value: $Ref<string>) : void;
        static GetMaxAudioChannelCount(WorldContextObject: $Nullable<UE.Object>) : number;
        static GetObjectClass(Object: $Nullable<UE.Object>) : UE.Class;
        static GetPlatformName() : string;
        static GetPlayerCameraManager(WorldContextObject: $Nullable<UE.Object>, PlayerIndex: number) : UE.PlayerCameraManager;
        static GetPlayerCharacter(WorldContextObject: $Nullable<UE.Object>, PlayerIndex: number) : UE.Character;
        static GetPlayerController(WorldContextObject: $Nullable<UE.Object>, PlayerIndex: number) : UE.PlayerController;
        static GetPlayerControllerFromID(WorldContextObject: $Nullable<UE.Object>, ControllerID: number) : UE.PlayerController;
        static GetPlayerControllerID(Player: $Nullable<UE.PlayerController>) : number;
        static GetPlayerPawn(WorldContextObject: $Nullable<UE.Object>, PlayerIndex: number) : UE.Pawn;
        static GetRealTimeSeconds(WorldContextObject: $Nullable<UE.Object>) : number;
        static GetStreamingLevel(WorldContextObject: $Nullable<UE.Object>, PackageName: string) : UE.LevelStreaming;
        static GetSurfaceType(Hit: UE.HitResult) : UE.EPhysicalSurface;
        static GetTimeSeconds(WorldContextObject: $Nullable<UE.Object>) : number;
        static GetUnpausedTimeSeconds(WorldContextObject: $Nullable<UE.Object>) : number;
        static GetViewportMouseCaptureMode(WorldContextObject: $Nullable<UE.Object>) : UE.EMouseCaptureMode;
        static GetViewProjectionMatrix(DesiredView: UE.MinimalViewInfo, ViewMatrix: $Ref<UE.Matrix>, ProjectionMatrix: $Ref<UE.Matrix>, ViewProjectionMatrix: $Ref<UE.Matrix>) : void;
        static GetWorldDeltaSeconds(WorldContextObject: $Nullable<UE.Object>) : number;
        static GetWorldOriginLocation(WorldContextObject: $Nullable<UE.Object>) : UE.IntVector;
        static GrassOverlappingSphereCount(WorldContextObject: $Nullable<UE.Object>, StaticMesh: $Nullable<UE.StaticMesh>, CenterPosition: UE.Vector, Radius: number) : number;
        static HasLaunchOption(OptionToCheck: string) : boolean;
        static HasOption(Options: string, InKey: string) : boolean;
        static IsGamePaused(WorldContextObject: $Nullable<UE.Object>) : boolean;
        static IsSplitscreenForceDisabled(WorldContextObject: $Nullable<UE.Object>) : boolean;
        static LoadGameFromSlot(SlotName: string, UserIndex: number) : UE.SaveGame;
        static LoadStreamLevel(WorldContextObject: $Nullable<UE.Object>, LevelName: string, bMakeVisibleAfterLoad: boolean, bShouldBlockOnLoad: boolean, LatentInfo: UE.LatentActionInfo) : void;
        static MakeHitResult(bBlockingHit: boolean, bInitialOverlap: boolean, Time: number, Distance: number, Location: UE.Vector, ImpactPoint: UE.Vector, Normal: UE.Vector, ImpactNormal: UE.Vector, PhysMat: $Nullable<UE.PhysicalMaterial>, HitActor: $Nullable<UE.Actor>, HitComponent: $Nullable<UE.PrimitiveComponent>, HitBoneName: string, HitItem: number, FaceIndex: number, TraceStart: UE.Vector, TraceEnd: UE.Vector) : UE.HitResult;
        static OpenLevel(WorldContextObject: $Nullable<UE.Object>, LevelName: string, bAbsolute?: boolean /* = true */, Options?: string /* = "" */) : void;
        static ParseOption(Options: string, Key: string) : string;
        static PlayDialogue2D(WorldContextObject: $Nullable<UE.Object>, Dialogue: $Nullable<UE.DialogueWave>, Context: UE.DialogueContext, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */) : void;
        static PlayDialogueAtLocation(WorldContextObject: $Nullable<UE.Object>, Dialogue: $Nullable<UE.DialogueWave>, Context: UE.DialogueContext, Location: UE.Vector, Rotation: UE.Rotator, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, AttenuationSettings?: UE.SoundAttenuation /* = None */) : void;
        static PlaySound2D(WorldContextObject: $Nullable<UE.Object>, Sound: $Nullable<UE.SoundBase>, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, ConcurrencySettings?: UE.SoundConcurrency /* = None */, OwningActor?: UE.Actor /* = None */) : void;
        static PlaySoundAtLocation(WorldContextObject: $Nullable<UE.Object>, Sound: $Nullable<UE.SoundBase>, Location: UE.Vector, Rotation: UE.Rotator, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, AttenuationSettings?: UE.SoundAttenuation /* = None */, ConcurrencySettings?: UE.SoundConcurrency /* = None */, OwningActor?: UE.Actor /* = None */) : void;
        static PlayWorldCameraShake(WorldContextObject: $Nullable<UE.Object>, Shake: $Nullable<UE.Class>, Epicenter: UE.Vector, InnerRadius: number, OuterRadius: number, Falloff?: number /* = 1.000000 */, bOrientShakeTowardsEpicenter?: boolean /* = false */) : void;
        static PopSoundMixModifier(WorldContextObject: $Nullable<UE.Object>, InSoundMixModifier: $Nullable<UE.SoundMix>) : void;
        static PrimeSound(InSound: $Nullable<UE.SoundBase>) : void;
        static ProjectWorldToScreen(Player: $Nullable<UE.PlayerController>, WorldPosition: UE.Vector, ScreenPosition: $Ref<UE.Vector2D>, bPlayerViewportRelative?: boolean /* = false */) : boolean;
        static PushSoundMixModifier(WorldContextObject: $Nullable<UE.Object>, InSoundMixModifier: $Nullable<UE.SoundMix>) : void;
        static RebaseLocalOriginOntoZero(WorldContextObject: $Nullable<UE.Object>, WorldLocation: UE.Vector) : UE.Vector;
        static RebaseZeroOriginOntoLocal(WorldContextObject: $Nullable<UE.Object>, WorldLocation: UE.Vector) : UE.Vector;
        static RemovePlayer(Player: $Nullable<UE.PlayerController>, bDestroyPawn: boolean) : void;
        static SaveGameToSlot(SaveGameObject: $Nullable<UE.SaveGame>, SlotName: string, UserIndex: number) : boolean;
        static SetBaseSoundMix(WorldContextObject: $Nullable<UE.Object>, InSoundMix: $Nullable<UE.SoundMix>) : void;
        static SetEnableWorldRendering(WorldContextObject: $Nullable<UE.Object>, bEnable: boolean) : void;
        static SetForceDisableSplitscreen(WorldContextObject: $Nullable<UE.Object>, bDisable: boolean) : void;
        static SetGamePaused(WorldContextObject: $Nullable<UE.Object>, bPaused: boolean) : boolean;
        static SetGlobalListenerFocusParameters(WorldContextObject: $Nullable<UE.Object>, FocusAzimuthScale?: number /* = 1.000000 */, NonFocusAzimuthScale?: number /* = 1.000000 */, FocusDistanceScale?: number /* = 1.000000 */, NonFocusDistanceScale?: number /* = 1.000000 */, FocusVolumeScale?: number /* = 1.000000 */, NonFocusVolumeScale?: number /* = 1.000000 */, FocusPriorityScale?: number /* = 1.000000 */, NonFocusPriorityScale?: number /* = 1.000000 */) : void;
        static SetGlobalPitchModulation(WorldContextObject: $Nullable<UE.Object>, PitchModulation: number, TimeSec: number) : void;
        static SetGlobalTimeDilation(WorldContextObject: $Nullable<UE.Object>, TimeDilation: number) : void;
        static SetMaxAudioChannelsScaled(WorldContextObject: $Nullable<UE.Object>, MaxChannelCountScale: number) : void;
        static SetPlayerControllerID(Player: $Nullable<UE.PlayerController>, ControllerId: number) : void;
        static SetSoundMixClassOverride(WorldContextObject: $Nullable<UE.Object>, InSoundMixModifier: $Nullable<UE.SoundMix>, InSoundClass: $Nullable<UE.SoundClass>, Volume?: number /* = 1.000000 */, Pitch?: number /* = 1.000000 */, FadeInTime?: number /* = 1.000000 */, bApplyToChildren?: boolean /* = true */) : void;
        static SetSubtitlesEnabled(bEnabled: boolean) : void;
        static SetViewportMouseCaptureMode(WorldContextObject: $Nullable<UE.Object>, MouseCaptureMode: UE.EMouseCaptureMode) : void;
        static SetWorldOriginLocation(WorldContextObject: $Nullable<UE.Object>, NewLocation: UE.IntVector) : void;
        static SpawnDecalAtLocation(WorldContextObject: $Nullable<UE.Object>, DecalMaterial: $Nullable<UE.MaterialInterface>, DecalSize: UE.Vector, Location: UE.Vector, Rotation?: UE.Rotator /* = -90.000000,0.000000,0.000000 */, LifeSpan?: number /* = 0.000000 */) : UE.DecalComponent;
        static SpawnDecalAttached(DecalMaterial: $Nullable<UE.MaterialInterface>, DecalSize: UE.Vector, AttachToComponent: $Nullable<UE.SceneComponent>, AttachPointName?: string /* = "None" */, Location?: UE.Vector /* =  */, Rotation?: UE.Rotator /* =  */, LocationType?: UE.EAttachLocation /* = KeepRelativeOffset */, LifeSpan?: number /* = 0.000000 */) : UE.DecalComponent;
        static SpawnDialogue2D(WorldContextObject: $Nullable<UE.Object>, Dialogue: $Nullable<UE.DialogueWave>, Context: UE.DialogueContext, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, bAutoDestroy?: boolean /* = true */) : UE.AudioComponent;
        static SpawnDialogueAtLocation(WorldContextObject: $Nullable<UE.Object>, Dialogue: $Nullable<UE.DialogueWave>, Context: UE.DialogueContext, Location: UE.Vector, Rotation?: UE.Rotator /* =  */, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, AttenuationSettings?: UE.SoundAttenuation /* = None */, bAutoDestroy?: boolean /* = true */) : UE.AudioComponent;
        static SpawnDialogueAttached(Dialogue: $Nullable<UE.DialogueWave>, Context: UE.DialogueContext, AttachToComponent: $Nullable<UE.SceneComponent>, AttachPointName?: string /* = "None" */, Location?: UE.Vector /* =  */, Rotation?: UE.Rotator /* =  */, LocationType?: UE.EAttachLocation /* = KeepRelativeOffset */, bStopWhenAttachedToDestroyed?: boolean /* = false */, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, AttenuationSettings?: UE.SoundAttenuation /* = None */, bAutoDestroy?: boolean /* = true */) : UE.AudioComponent;
        static SpawnEmitterAtLocation(WorldContextObject: $Nullable<UE.Object>, EmitterTemplate: $Nullable<UE.ParticleSystem>, Location: UE.Vector, Rotation?: UE.Rotator /* =  */, Scale?: UE.Vector /* = 1.000000,1.000000,1.000000 */, bAutoDestroy?: boolean /* = true */, PoolingMethod?: UE.EPSCPoolMethod /* = None */, bAutoActivateSystem?: boolean /* = true */) : UE.ParticleSystemComponent;
        static SpawnEmitterAttached(EmitterTemplate: $Nullable<UE.ParticleSystem>, AttachToComponent: $Nullable<UE.SceneComponent>, AttachPointName?: string /* = "None" */, Location?: UE.Vector /* =  */, Rotation?: UE.Rotator /* =  */, Scale?: UE.Vector /* = 1.000000,1.000000,1.000000 */, LocationType?: UE.EAttachLocation /* = KeepRelativeOffset */, bAutoDestroy?: boolean /* = true */, PoolingMethod?: UE.EPSCPoolMethod /* = None */, bAutoActivate?: boolean /* = true */) : UE.ParticleSystemComponent;
        static SpawnForceFeedbackAtLocation(WorldContextObject: $Nullable<UE.Object>, ForceFeedbackEffect: $Nullable<UE.ForceFeedbackEffect>, Location: UE.Vector, Rotation?: UE.Rotator /* =  */, bLooping?: boolean /* = false */, IntensityMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, AttenuationSettings?: UE.ForceFeedbackAttenuation /* = None */, bAutoDestroy?: boolean /* = true */) : UE.ForceFeedbackComponent;
        static SpawnForceFeedbackAttached(ForceFeedbackEffect: $Nullable<UE.ForceFeedbackEffect>, AttachToComponent: $Nullable<UE.SceneComponent>, AttachPointName?: string /* = "None" */, Location?: UE.Vector /* =  */, Rotation?: UE.Rotator /* =  */, LocationType?: UE.EAttachLocation /* = KeepRelativeOffset */, bStopWhenAttachedToDestroyed?: boolean /* = false */, bLooping?: boolean /* = false */, IntensityMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, AttenuationSettings?: UE.ForceFeedbackAttenuation /* = None */, bAutoDestroy?: boolean /* = true */) : UE.ForceFeedbackComponent;
        static SpawnObject(ObjectClass: $Nullable<UE.Class>, Outer: $Nullable<UE.Object>) : UE.Object;
        static SpawnSound2D(WorldContextObject: $Nullable<UE.Object>, Sound: $Nullable<UE.SoundBase>, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, ConcurrencySettings?: UE.SoundConcurrency /* = None */, bPersistAcrossLevelTransition?: boolean /* = false */, bAutoDestroy?: boolean /* = true */) : UE.AudioComponent;
        static SpawnSoundAtLocation(WorldContextObject: $Nullable<UE.Object>, Sound: $Nullable<UE.SoundBase>, Location: UE.Vector, Rotation?: UE.Rotator /* =  */, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, AttenuationSettings?: UE.SoundAttenuation /* = None */, ConcurrencySettings?: UE.SoundConcurrency /* = None */, bAutoDestroy?: boolean /* = true */) : UE.AudioComponent;
        static SpawnSoundAttached(Sound: $Nullable<UE.SoundBase>, AttachToComponent: $Nullable<UE.SceneComponent>, AttachPointName?: string /* = "None" */, Location?: UE.Vector /* =  */, Rotation?: UE.Rotator /* =  */, LocationType?: UE.EAttachLocation /* = KeepRelativeOffset */, bStopWhenAttachedToDestroyed?: boolean /* = false */, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, AttenuationSettings?: UE.SoundAttenuation /* = None */, ConcurrencySettings?: UE.SoundConcurrency /* = None */, bAutoDestroy?: boolean /* = true */) : UE.AudioComponent;
        static SuggestProjectileVelocity_CustomArc(WorldContextObject: $Nullable<UE.Object>, OutLaunchVelocity: $Ref<UE.Vector>, StartPos: UE.Vector, EndPos: UE.Vector, OverrideGravityZ?: number /* = 0.000000 */, ArcParam?: number /* = 0.500000 */) : boolean;
        static UnloadStreamLevel(WorldContextObject: $Nullable<UE.Object>, LevelName: string, LatentInfo: UE.LatentActionInfo, bShouldBlockOnUnload: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayStatics;
        static Load(InName: string): GameplayStatics;
    }
    
    class GameplayTagsDeveloperSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DeveloperConfigName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsDeveloperSettings;
        static Load(InName: string): GameplayTagsDeveloperSettings;
    }
    
    class GameplayTagSearchFilter extends UE.ContentBrowserFrontEndFilterExtension {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagSearchFilter;
        static Load(InName: string): GameplayTagSearchFilter;
    }
    
    class GameplayTagsK2Node_LiteralGameplayTag extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_LiteralGameplayTag;
        static Load(InName: string): GameplayTagsK2Node_LiteralGameplayTag;
    }
    
    class GameplayTagsK2Node_MultiCompareBase extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumberOfPins: number;
        PinNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_MultiCompareBase;
        static Load(InName: string): GameplayTagsK2Node_MultiCompareBase;
    }
    
    class GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface extends UE.GameplayTagsK2Node_MultiCompareBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface;
        static Load(InName: string): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface;
    }
    
    class GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags extends UE.GameplayTagsK2Node_MultiCompareBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags;
        static Load(InName: string): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags;
    }
    
    class GameplayTagsK2Node_MultiCompareGameplayTagContainer extends UE.GameplayTagsK2Node_MultiCompareBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_MultiCompareGameplayTagContainer;
        static Load(InName: string): GameplayTagsK2Node_MultiCompareGameplayTagContainer;
    }
    
    class GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags extends UE.GameplayTagsK2Node_MultiCompareBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags;
        static Load(InName: string): GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags;
    }
    
    class K2Node_Switch extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bHasDefaultPin: boolean;
        FunctionName: string;
        FunctionClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Switch;
        static Load(InName: string): K2Node_Switch;
    }
    
    class GameplayTagsK2Node_SwitchGameplayTag extends UE.K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PinTags: TArray<UE.GameplayTag>;
        PinNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_SwitchGameplayTag;
        static Load(InName: string): GameplayTagsK2Node_SwitchGameplayTag;
    }
    
    class GameplayTagsK2Node_SwitchGameplayTagContainer extends UE.K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PinContainers: TArray<UE.GameplayTagContainer>;
        PinNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_SwitchGameplayTagContainer;
        static Load(InName: string): GameplayTagsK2Node_SwitchGameplayTagContainer;
    }
    
    class GameplayTagTableRow extends UE.TableRowBase {
        constructor();
        constructor(Tag: string, DevComment: string);
        Tag: string;
        DevComment: string;
        static StaticClass(): Class;
    }
    
    class GameplayTagsList extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConfigFileName: string;
        GameplayTagList: TArray<UE.GameplayTagTableRow>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsList;
        static Load(InName: string): GameplayTagsList;
    }
    
    enum EGameplayTagSourceType { Native, DefaultTagList, TagList, RestrictedTagList, DataTable, Invalid, EGameplayTagSourceType_MAX}
    class RestrictedGameplayTagTableRow extends UE.GameplayTagTableRow {
        constructor();
        constructor(bAllowNonRestrictedChildren: boolean);
        bAllowNonRestrictedChildren: boolean;
        static StaticClass(): Class;
    }
    
    class RestrictedGameplayTagsList extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConfigFileName: string;
        RestrictedGameplayTagList: TArray<UE.RestrictedGameplayTagTableRow>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RestrictedGameplayTagsList;
        static Load(InName: string): RestrictedGameplayTagsList;
    }
    
    class GameplayTagSource {
        constructor();
        constructor(SourceName: string, SourceType: UE.EGameplayTagSourceType, SourceTagList: UE.GameplayTagsList, SourceRestrictedTagList: UE.RestrictedGameplayTagsList);
        SourceName: string;
        SourceType: UE.EGameplayTagSourceType;
        SourceTagList: UE.GameplayTagsList;
        SourceRestrictedTagList: UE.RestrictedGameplayTagsList;
        static StaticClass(): Class;
    }
    
    class GameplayTagsManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TagSources: TArray<UE.GameplayTagSource>;
        GameplayTagTables: TArray<UE.DataTable>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsManager;
        static Load(InName: string): GameplayTagsManager;
    }
    
    class GameplayTagCategoryRemap {
        constructor();
        constructor(BaseCategory: string, RemapCategories: TArray<string>);
        BaseCategory: string;
        RemapCategories: TArray<string>;
        static StaticClass(): Class;
    }
    
    class GameplayTagRedirect {
        constructor();
        constructor(OldTagName: string, NewTagName: string);
        OldTagName: string;
        NewTagName: string;
        static StaticClass(): Class;
    }
    
    class RestrictedConfigInfo {
        constructor();
        constructor(RestrictedConfigName: string, Owners: TArray<string>);
        RestrictedConfigName: string;
        Owners: TArray<string>;
        static StaticClass(): Class;
    }
    
    class GameplayTagsSettings extends UE.GameplayTagsList {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportTagsFromConfig: boolean;
        WarnOnInvalidTags: boolean;
        FastReplication: boolean;
        InvalidTagCharacters: string;
        CategoryRemapping: TArray<UE.GameplayTagCategoryRemap>;
        GameplayTagTableList: TArray<UE.SoftObjectPath>;
        GameplayTagRedirects: TArray<UE.GameplayTagRedirect>;
        CommonlyReplicatedTags: TArray<string>;
        NumBitsForContainerSize: number;
        NetIndexFirstBitSegment: number;
        RestrictedConfigFiles: TArray<UE.RestrictedConfigInfo>;
        RestrictedTagList: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsSettings;
        static Load(InName: string): GameplayTagsSettings;
    }
    
    class GameplayTask_ClaimResource extends UE.GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ClaimResource(InTaskOwner: GameplayTaskOwnerInterface, ResourceClass: $Nullable<UE.Class>, Priority?: number /* = 192 */, TaskInstanceName?: string /* = "None" */) : UE.GameplayTask_ClaimResource;
        static ClaimResources(InTaskOwner: GameplayTaskOwnerInterface, ResourceClasses: TArray<UE.Class>, Priority?: number /* = 192 */, TaskInstanceName?: string /* = "None" */) : UE.GameplayTask_ClaimResource;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTask_ClaimResource;
        static Load(InName: string): GameplayTask_ClaimResource;
    }
    
    class GameplayTask_SpawnActor extends UE.GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Success: $MulticastDelegate<(SpawnedActor: $Nullable<UE.Actor>) => void>;
        DidNotSpawn: $MulticastDelegate<(SpawnedActor: $Nullable<UE.Actor>) => void>;
        ClassToSpawn: UE.Class;
        BeginSpawningActor(WorldContextObject: $Nullable<UE.Object>, SpawnedActor: $Ref<UE.Actor>) : boolean;
        FinishSpawningActor(WorldContextObject: $Nullable<UE.Object>, SpawnedActor: $Nullable<UE.Actor>) : void;
        static SpawnActor(TaskOwner: GameplayTaskOwnerInterface, SpawnLocation: UE.Vector, SpawnRotation: UE.Rotator, Class: $Nullable<UE.Class>, bSpawnOnlyOnAuthority?: boolean /* = false */) : UE.GameplayTask_SpawnActor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTask_SpawnActor;
        static Load(InName: string): GameplayTask_SpawnActor;
    }
    
    class GameplayTask_TimeLimitedExecution extends UE.GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnFinished: $MulticastDelegate<() => void>;
        OnTimeExpired: $MulticastDelegate<() => void>;
        TaskFinishDelegate__DelegateSignature() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTask_TimeLimitedExecution;
        static Load(InName: string): GameplayTask_TimeLimitedExecution;
    }
    
    class GameplayTask_WaitDelay extends UE.GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnFinish: $MulticastDelegate<() => void>;
        TaskDelayDelegate__DelegateSignature() : void;
        static TaskWaitDelay(TaskOwner: GameplayTaskOwnerInterface, Time: number, Priority?: number /* = 192 */) : UE.GameplayTask_WaitDelay;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTask_WaitDelay;
        static Load(InName: string): GameplayTask_WaitDelay;
    }
    
    class GameSessionSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxSpectators: number;
        MaxPlayers: number;
        bRequiresPushToTalk: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameSessionSettings;
        static Load(InName: string): GameSessionSettings;
    }
    
    class GarbageCollectionSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TimeBetweenPurgingPendingKillObjects: number;
        FlushStreamingOnGC: boolean;
        AllowParallelGC: boolean;
        IncrementalBeginDestroyEnabled: boolean;
        MultithreadedDestructionEnabled: boolean;
        CreateGCClusters: boolean;
        ActorClusteringEnabled: boolean;
        BlueprintClusteringEnabled: boolean;
        UseDisregardForGCOnDedicatedServers: boolean;
        MinGCClusterSize: number;
        NumRetriesBeforeForcingGC: number;
        MaxObjectsNotConsideredByGC: number;
        SizeOfPermanentObjectPool: number;
        MaxObjectsInGame: number;
        MaxObjectsInEditor: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GarbageCollectionSettings;
        static Load(InName: string): GarbageCollectionSettings;
    }
    
    class GatherTextCommandlet extends UE.GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GatherTextCommandlet;
        static Load(InName: string): GatherTextCommandlet;
    }
    
    class GatherTextFromAssetsCommandlet extends UE.GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GatherTextFromAssetsCommandlet;
        static Load(InName: string): GatherTextFromAssetsCommandlet;
    }
    
    class GatherTextFromMetaDataCommandlet extends UE.GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GatherTextFromMetaDataCommandlet;
        static Load(InName: string): GatherTextFromMetaDataCommandlet;
    }
    
    class GatherTextFromSourceCommandlet extends UE.GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GatherTextFromSourceCommandlet;
        static Load(InName: string): GatherTextFromSourceCommandlet;
    }
    
    class GCObjectReferencer extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GCObjectReferencer;
        static Load(InName: string): GCObjectReferencer;
    }
    
    class GeneralEngineSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeneralEngineSettings;
        static Load(InName: string): GeneralEngineSettings;
    }
    
    class GeneralProjectSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CompanyName: string;
        CompanyDistinguishedName: string;
        CopyrightNotice: string;
        Description: string;
        Homepage: string;
        LicensingTerms: string;
        PrivacyPolicy: string;
        ProjectID: UE.Guid;
        ProjectName: string;
        ProjectVersion: string;
        SupportContact: string;
        ProjectDisplayedTitle: string;
        ProjectDebugTitleInfo: string;
        bShouldWindowPreserveAspectRatio: boolean;
        bUseBorderlessWindow: boolean;
        bStartInVR: boolean;
        bStartInAR: boolean;
        bSupportAR: boolean;
        bAllowWindowResize: boolean;
        bAllowClose: boolean;
        bAllowMaximize: boolean;
        bAllowMinimize: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeneralProjectSettings;
        static Load(InName: string): GeneralProjectSettings;
    }
    
    class GenerateAssetManifestCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GenerateAssetManifestCommandlet;
        static Load(InName: string): GenerateAssetManifestCommandlet;
    }
    
    class GenerateBlueprintAPICommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GenerateBlueprintAPICommandlet;
        static Load(InName: string): GenerateBlueprintAPICommandlet;
    }
    
    class GenerateDistillFileSetsCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GenerateDistillFileSetsCommandlet;
        static Load(InName: string): GenerateDistillFileSetsCommandlet;
    }
    
    class LightmassPointLightSettings extends UE.LightmassLightSettings {
        constructor();
        static StaticClass(): Class;
    }
    
    class LocalLightComponent extends UE.LightComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IntensityUnits: UE.ELightUnits;
        Radius: number;
        AttenuationRadius: number;
        LightmassSettings: UE.LightmassPointLightSettings;
        SetAttenuationRadius(NewRadius: number) : void;
        SetIntensityUnits(NewIntensityUnits: UE.ELightUnits) : void;
        static GetUnitsConversionFactor(SrcUnits: UE.ELightUnits, TargetUnits: UE.ELightUnits, CosHalfConeAngle?: number /* = -1.000000 */) : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalLightComponent;
        static Load(InName: string): LocalLightComponent;
    }
    
    class PointLightComponent extends UE.LocalLightComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseInverseSquaredFalloff: boolean;
        LightFalloffExponent: number;
        SourceRadius: number;
        SoftSourceRadius: number;
        SourceLength: number;
        SetLightFalloffExponent(NewLightFalloffExponent: number) : void;
        SetSoftSourceRadius(bNewValue: number) : void;
        SetSourceLength(NewValue: number) : void;
        SetSourceRadius(bNewValue: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PointLightComponent;
        static Load(InName: string): PointLightComponent;
    }
    
    class SpotLightComponent extends UE.PointLightComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InnerConeAngle: number;
        OuterConeAngle: number;
        LightShaftConeAngle: number;
        SetInnerConeAngle(NewInnerConeAngle: number) : void;
        SetOuterConeAngle(NewOuterConeAngle: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpotLightComponent;
        static Load(InName: string): SpotLightComponent;
    }
    
    class SpotLight extends UE.Light {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpotLightComponent: UE.SpotLightComponent;
        ArrowComponent: UE.ArrowComponent;
        SetInnerConeAngle(NewInnerConeAngle: number) : void;
        SetOuterConeAngle(NewOuterConeAngle: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpotLight;
        static Load(InName: string): SpotLight;
    }
    
    class GeneratedMeshAreaLight extends UE.SpotLight {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeneratedMeshAreaLight;
        static Load(InName: string): GeneratedMeshAreaLight;
    }
    
    class GenerateGatherArchiveCommandlet extends UE.GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GenerateGatherArchiveCommandlet;
        static Load(InName: string): GenerateGatherArchiveCommandlet;
    }
    
    class GenerateGatherManifestCommandlet extends UE.GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GenerateGatherManifestCommandlet;
        static Load(InName: string): GenerateGatherManifestCommandlet;
    }
    
    class GenerateTextLocalizationReportCommandlet extends UE.GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GenerateTextLocalizationReportCommandlet;
        static Load(InName: string): GenerateTextLocalizationReportCommandlet;
    }
    
    class GenerateTextLocalizationResourceCommandlet extends UE.GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GenerateTextLocalizationResourceCommandlet;
        static Load(InName: string): GenerateTextLocalizationResourceCommandlet;
    }
    
    class GenericTeamAgentInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GenericTeamAgentInterface;
        static Load(InName: string): GenericTeamAgentInterface;
    }
    
    class GeometryCacheTrack extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Duration: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheTrack;
        static Load(InName: string): GeometryCacheTrack;
    }
    
    class GeometryCache extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssetImportData: UE.AssetImportData;
        ThumbnailInfo: UE.ThumbnailInfo;
        Materials: TArray<UE.MaterialInterface>;
        Tracks: TArray<UE.GeometryCacheTrack>;
        StartFrame: number;
        EndFrame: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCache;
        static Load(InName: string): GeometryCache;
    }
    
    class GeometryCacheComponent extends UE.MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GeometryCache: UE.GeometryCache;
        bRunning: boolean;
        bLooping: boolean;
        StartTimeOffset: number;
        PlaybackSpeed: number;
        NumTracks: number;
        ElapsedTime: number;
        Duration: number;
        bManualTick: boolean;
        GetAnimationTime() : number;
        GetDuration() : number;
        GetNumberOfFrames() : number;
        GetPlaybackDirection() : number;
        GetPlaybackSpeed() : number;
        GetStartTimeOffset() : number;
        IsLooping() : boolean;
        IsPlaying() : boolean;
        IsPlayingReversed() : boolean;
        Pause() : void;
        Play() : void;
        PlayFromStart() : void;
        PlayReversed() : void;
        PlayReversedFromEnd() : void;
        SetGeometryCache(NewGeomCache: $Nullable<UE.GeometryCache>) : boolean;
        SetLooping(bNewLooping: boolean) : void;
        SetPlaybackSpeed(NewPlaybackSpeed: number) : void;
        SetStartTimeOffset(NewStartTimeOffset: number) : void;
        Stop() : void;
        TickAtThisTime(Time: number, bInIsRunning: boolean, bInBackwards: boolean, bInIsLooping: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheComponent;
        static Load(InName: string): GeometryCacheComponent;
    }
    
    class GeometryCacheActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GeometryCacheComponent: UE.GeometryCacheComponent;
        GetGeometryCacheComponent() : UE.GeometryCacheComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheActor;
        static Load(InName: string): GeometryCacheActor;
    }
    
    class GeometryCacheCodecBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TopologyRanges: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheCodecBase;
        static Load(InName: string): GeometryCacheCodecBase;
    }
    
    class GeometryCacheCodecRaw extends UE.GeometryCacheCodecBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DummyProperty: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheCodecRaw;
        static Load(InName: string): GeometryCacheCodecRaw;
    }
    
    class GeometryCacheCodecV1 extends UE.GeometryCacheCodecBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheCodecV1;
        static Load(InName: string): GeometryCacheCodecV1;
    }
    
    class GeometryCacheThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheThumbnailRenderer;
        static Load(InName: string): GeometryCacheThumbnailRenderer;
    }
    
    class GeometryCacheMeshData {
        constructor();
        static StaticClass(): Class;
    }
    
    class GeometryCacheTrack_FlipbookAnimation extends UE.GeometryCacheTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumMeshSamples: number;
        AddMeshSample(MeshData: UE.GeometryCacheMeshData, SampleTime: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheTrack_FlipbookAnimation;
        static Load(InName: string): GeometryCacheTrack_FlipbookAnimation;
    }
    
    class GeometryCacheTrack_TransformAnimation extends UE.GeometryCacheTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetMesh(NewMeshData: UE.GeometryCacheMeshData) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheTrack_TransformAnimation;
        static Load(InName: string): GeometryCacheTrack_TransformAnimation;
    }
    
    class GeometryCacheTrack_TransformGroupAnimation extends UE.GeometryCacheTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetMesh(NewMeshData: UE.GeometryCacheMeshData) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheTrack_TransformGroupAnimation;
        static Load(InName: string): GeometryCacheTrack_TransformGroupAnimation;
    }
    
    class GeometryCacheTrackStreamable extends UE.GeometryCacheTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Codec: UE.GeometryCacheCodecBase;
        StartSampleTime: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheTrackStreamable;
        static Load(InName: string): GeometryCacheTrackStreamable;
    }
    
    class Polys extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Polys;
        static Load(InName: string): Polys;
    }
    
    class GeomModifier extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Description: string;
        Tooltip: string;
        bPushButton: boolean;
        bInitialized: boolean;
        bPendingPivotOffsetUpdate: boolean;
        CachedPolys: UE.Polys;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier;
        static Load(InName: string): GeomModifier;
    }
    
    class GeomModifier_Edit extends UE.GeomModifier {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Edit;
        static Load(InName: string): GeomModifier_Edit;
    }
    
    class GeomModifier_Clip extends UE.GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bFlipNormal: boolean;
        bSplit: boolean;
        ClipMarkers: TArray<UE.Vector>;
        SnappedMouseWorldSpacePos: UE.Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Clip;
        static Load(InName: string): GeomModifier_Clip;
    }
    
    class GeomModifier_Create extends UE.GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Create;
        static Load(InName: string): GeomModifier_Create;
    }
    
    class GeomModifier_Delete extends UE.GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Delete;
        static Load(InName: string): GeomModifier_Delete;
    }
    
    class GeomModifier_Extrude extends UE.GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Length: number;
        Segments: number;
        SaveCoordSystem: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Extrude;
        static Load(InName: string): GeomModifier_Extrude;
    }
    
    class GeomModifier_Flip extends UE.GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Flip;
        static Load(InName: string): GeomModifier_Flip;
    }
    
    class GeomModifier_Lathe extends UE.GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TotalSegments: number;
        Segments: number;
        AlignToSide: boolean;
        Axis: UE.EAxis;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Lathe;
        static Load(InName: string): GeomModifier_Lathe;
    }
    
    class GeomModifier_Triangulate extends UE.GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Triangulate;
        static Load(InName: string): GeomModifier_Triangulate;
    }
    
    class GeomModifier_Optimize extends UE.GeomModifier_Triangulate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Optimize;
        static Load(InName: string): GeomModifier_Optimize;
    }
    
    class GeomModifier_Pen extends UE.GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoExtrude: boolean;
        bCreateConvexPolygons: boolean;
        bCreateBrushShape: boolean;
        ExtrudeDepth: number;
        ShapeVertices: TArray<UE.Vector>;
        MouseWorldSpacePos: UE.Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Pen;
        static Load(InName: string): GeomModifier_Pen;
    }
    
    class GeomModifier_Split extends UE.GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Split;
        static Load(InName: string): GeomModifier_Split;
    }
    
    class GeomModifier_Turn extends UE.GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Turn;
        static Load(InName: string): GeomModifier_Turn;
    }
    
    class GeomModifier_Weld extends UE.GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Weld;
        static Load(InName: string): GeomModifier_Weld;
    }
    
    class InternalToolFrameworkActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InternalToolFrameworkActor;
        static Load(InName: string): InternalToolFrameworkActor;
    }
    
    class GizmoActor extends UE.InternalToolFrameworkActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoActor;
        static Load(InName: string): GizmoActor;
    }
    
    class GizmoBaseComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Color: UE.LinearColor;
        HoverSizeMultiplier: number;
        PixelHitDistanceThreshold: number;
        UpdateHoverState(bHoveringIn: boolean) : void;
        UpdateWorldLocalState(bWorldIn: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoBaseComponent;
        static Load(InName: string): GizmoBaseComponent;
    }
    
    class GizmoArrowComponent extends UE.GizmoBaseComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Direction: UE.Vector;
        Gap: number;
        Length: number;
        Thickness: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoArrowComponent;
        static Load(InName: string): GizmoArrowComponent;
    }
    
    class GizmoBaseFloatParameterSource extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoBaseFloatParameterSource;
        static Load(InName: string): GizmoBaseFloatParameterSource;
    }
    
    class GizmoTransformSource extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetTransform() : UE.Transform;
        SetTransform(NewTransform: UE.Transform) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoTransformSource;
        static Load(InName: string): GizmoTransformSource;
    }
    
    class GizmoFloatParameterChange {
        constructor();
        constructor(InitialValue: number, CurrentValue: number);
        InitialValue: number;
        CurrentValue: number;
        static StaticClass(): Class;
    }
    
    class GizmoAxisRotationParameterSource extends UE.GizmoBaseFloatParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisSource: GizmoAxisSource;
        TransformSource: GizmoTransformSource;
        Angle: number;
        LastChange: UE.GizmoFloatParameterChange;
        CurRotationAxis: UE.Vector;
        CurRotationOrigin: UE.Vector;
        InitialTransform: UE.Transform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoAxisRotationParameterSource;
        static Load(InName: string): GizmoAxisRotationParameterSource;
    }
    
    class GizmoAxisTranslationParameterSource extends UE.GizmoBaseFloatParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisSource: GizmoAxisSource;
        TransformSource: GizmoTransformSource;
        Parameter: number;
        LastChange: UE.GizmoFloatParameterChange;
        CurTranslationAxis: UE.Vector;
        CurTranslationOrigin: UE.Vector;
        InitialTransform: UE.Transform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoAxisTranslationParameterSource;
        static Load(InName: string): GizmoAxisTranslationParameterSource;
    }
    
    class GizmoBaseTransformSource extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoBaseTransformSource;
        static Load(InName: string): GizmoBaseTransformSource;
    }
    
    class GizmoBaseVec2ParameterSource extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoBaseVec2ParameterSource;
        static Load(InName: string): GizmoBaseVec2ParameterSource;
    }
    
    class GizmoCircleComponent extends UE.GizmoBaseComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Normal: UE.Vector;
        Radius: number;
        Thickness: number;
        NumSides: number;
        bViewAligned: boolean;
        bOnlyAllowFrontFacingHits: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoCircleComponent;
        static Load(InName: string): GizmoCircleComponent;
    }
    
    class GizmoComponentAxisSource extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Component: UE.SceneComponent;
        AxisIndex: number;
        bLocalAxes: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoComponentAxisSource;
        static Load(InName: string): GizmoComponentAxisSource;
    }
    
    class GizmoComponentHitTarget extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Component: UE.PrimitiveComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoComponentHitTarget;
        static Load(InName: string): GizmoComponentHitTarget;
    }
    
    class GizmoComponentWorldTransformSource extends UE.GizmoBaseTransformSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Component: UE.SceneComponent;
        bModifyComponentOnTransform: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoComponentWorldTransformSource;
        static Load(InName: string): GizmoComponentWorldTransformSource;
    }
    
    class GizmoConstantAxisSource extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Origin: UE.Vector;
        Direction: UE.Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoConstantAxisSource;
        static Load(InName: string): GizmoConstantAxisSource;
    }
    
    class GizmoHandleMeshComponent extends UE.StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoHandleMeshComponent;
        static Load(InName: string): GizmoHandleMeshComponent;
    }
    
    class GizmoLambdaHitTarget extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoLambdaHitTarget;
        static Load(InName: string): GizmoLambdaHitTarget;
    }
    
    class GizmoLambdaStateTarget extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoLambdaStateTarget;
        static Load(InName: string): GizmoLambdaStateTarget;
    }
    
    class GizmoLocalFloatParameterSource extends UE.GizmoBaseFloatParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Value: number;
        LastChange: UE.GizmoFloatParameterChange;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoLocalFloatParameterSource;
        static Load(InName: string): GizmoLocalFloatParameterSource;
    }
    
    class GizmoVec2ParameterChange {
        constructor();
        constructor(InitialValue: UE.Vector2D, CurrentValue: UE.Vector2D);
        InitialValue: UE.Vector2D;
        CurrentValue: UE.Vector2D;
        static StaticClass(): Class;
    }
    
    class GizmoLocalVec2ParameterSource extends UE.GizmoBaseVec2ParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Value: UE.Vector2D;
        LastChange: UE.GizmoVec2ParameterChange;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoLocalVec2ParameterSource;
        static Load(InName: string): GizmoLocalVec2ParameterSource;
    }
    
    class GizmoNilStateTarget extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoNilStateTarget;
        static Load(InName: string): GizmoNilStateTarget;
    }
    
    class GizmoObjectModifyStateTarget extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoObjectModifyStateTarget;
        static Load(InName: string): GizmoObjectModifyStateTarget;
    }
    
    class GizmoPlaneTranslationParameterSource extends UE.GizmoBaseVec2ParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisSource: GizmoAxisSource;
        TransformSource: GizmoTransformSource;
        Parameter: UE.Vector2D;
        LastChange: UE.GizmoVec2ParameterChange;
        CurTranslationOrigin: UE.Vector;
        CurTranslationNormal: UE.Vector;
        CurTranslationAxisX: UE.Vector;
        CurTranslationAxisY: UE.Vector;
        InitialTransform: UE.Transform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoPlaneTranslationParameterSource;
        static Load(InName: string): GizmoPlaneTranslationParameterSource;
    }
    
    class GizmoRectangleComponent extends UE.GizmoBaseComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DirectionX: UE.Vector;
        DirectionY: UE.Vector;
        OffsetX: number;
        OffsetY: number;
        LengthX: number;
        LengthY: number;
        Thickness: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoRectangleComponent;
        static Load(InName: string): GizmoRectangleComponent;
    }
    
    class ToolContextTransactionProvider extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolContextTransactionProvider;
        static Load(InName: string): ToolContextTransactionProvider;
    }
    
    class GizmoTransformChangeStateTarget extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TransactionManager: ToolContextTransactionProvider;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoTransformChangeStateTarget;
        static Load(InName: string): GizmoTransformChangeStateTarget;
    }
    
    class TransformProxy extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bRotatePerObject: boolean;
        bSetPivotMode: boolean;
        SharedTransform: UE.Transform;
        InitialSharedTransform: UE.Transform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TransformProxy;
        static Load(InName: string): TransformProxy;
    }
    
    class GizmoTransformProxyTransformSource extends UE.GizmoBaseTransformSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Proxy: UE.TransformProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoTransformProxyTransformSource;
        static Load(InName: string): GizmoTransformProxyTransformSource;
    }
    
    class GizmoVec2ParameterSource extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BeginModify() : void;
        EndModify() : void;
        GetParameter() : UE.Vector2D;
        SetParameter(NewValue: UE.Vector2D) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoVec2ParameterSource;
        static Load(InName: string): GizmoVec2ParameterSource;
    }
    
    class GizmoWorldAxisSource extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Origin: UE.Vector;
        AxisIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoWorldAxisSource;
        static Load(InName: string): GizmoWorldAxisSource;
    }
    
    class GlobalEditorUtilityBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HelpText: string;
        bDirtiedSelectionSet: boolean;
        bAutoRunDefaultAction: boolean;
        OnEachSelectedActor: $MulticastDelegate<(Actor: $Nullable<UE.Actor>, Index: number) => void>;
        OnEachSelectedAsset: $MulticastDelegate<(Asset: $Nullable<UE.Object>, Index: number) => void>;
        ClearActorSelectionSet() : void;
        ForEachSelectedActor() : void;
        ForEachSelectedAsset() : void;
        GetActorReference(PathToActor: string) : UE.Actor;
        GetEditorUserSettings() : UE.EditorPerProjectUserSettings;
        GetSelectedAssets() : TArray<UE.Object>;
        GetSelectionBounds(Origin: $Ref<UE.Vector>, BoxExtent: $Ref<UE.Vector>, SphereRadius: $Ref<number>) : void;
        GetSelectionSet() : TArray<UE.Actor>;
        OnDefaultActionClicked() : void;
        RenameAsset(Asset: $Nullable<UE.Object>, NewName: string) : void;
        SelectNothing() : void;
        SetActorSelectionState(Actor: $Nullable<UE.Actor>, bShouldBeSelected: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GlobalEditorUtilityBase;
        static Load(InName: string): GlobalEditorUtilityBase;
    }
    
    enum EBlueprintPinStyleType { BPST_Original, BPST_VariantA, BPST_MAX}
    enum EGraphPanningMouseButton { Right, Middle, Both, EGraphPanningMouseButton_MAX}
    class GraphEditorSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DataPinStyle: UE.EBlueprintPinStyleType;
        PanningMouseButton: UE.EGraphPanningMouseButton;
        PaddingAbovePin: number;
        PaddingBelowPin: number;
        PaddingRightOfInput: number;
        PaddingLeftOfOutput: number;
        PaddingTowardsNodeEdge: number;
        bTreatSplinesLikePins: boolean;
        SplineHoverTolerance: number;
        ForwardSplineHorizontalDeltaRange: number;
        ForwardSplineVerticalDeltaRange: number;
        ForwardSplineTangentFromHorizontalDelta: UE.Vector2D;
        ForwardSplineTangentFromVerticalDelta: UE.Vector2D;
        BackwardSplineHorizontalDeltaRange: number;
        BackwardSplineVerticalDeltaRange: number;
        BackwardSplineTangentFromHorizontalDelta: UE.Vector2D;
        BackwardSplineTangentFromVerticalDelta: UE.Vector2D;
        DefaultPinTypeColor: UE.LinearColor;
        ExecutionPinTypeColor: UE.LinearColor;
        BooleanPinTypeColor: UE.LinearColor;
        BytePinTypeColor: UE.LinearColor;
        ClassPinTypeColor: UE.LinearColor;
        IntPinTypeColor: UE.LinearColor;
        Int64PinTypeColor: UE.LinearColor;
        FloatPinTypeColor: UE.LinearColor;
        NamePinTypeColor: UE.LinearColor;
        SoftObjectPinTypeColor: UE.LinearColor;
        SoftClassPinTypeColor: UE.LinearColor;
        DelegatePinTypeColor: UE.LinearColor;
        ObjectPinTypeColor: UE.LinearColor;
        InterfacePinTypeColor: UE.LinearColor;
        StringPinTypeColor: UE.LinearColor;
        TextPinTypeColor: UE.LinearColor;
        StructPinTypeColor: UE.LinearColor;
        WildcardPinTypeColor: UE.LinearColor;
        VectorPinTypeColor: UE.LinearColor;
        RotatorPinTypeColor: UE.LinearColor;
        TransformPinTypeColor: UE.LinearColor;
        IndexPinTypeColor: UE.LinearColor;
        EventNodeTitleColor: UE.LinearColor;
        FunctionCallNodeTitleColor: UE.LinearColor;
        PureFunctionCallNodeTitleColor: UE.LinearColor;
        ParentFunctionCallNodeTitleColor: UE.LinearColor;
        FunctionTerminatorNodeTitleColor: UE.LinearColor;
        ExecBranchNodeTitleColor: UE.LinearColor;
        ExecSequenceNodeTitleColor: UE.LinearColor;
        ResultNodeTitleColor: UE.LinearColor;
        DefaultCommentNodeTitleColor: UE.LinearColor;
        PreviewNodeTitleColor: UE.LinearColor;
        DefaultDataWireThickness: number;
        DefaultExecutionWireThickness: number;
        TraceAttackColor: UE.LinearColor;
        TraceAttackWireThickness: number;
        TraceAttackHoldPeriod: number;
        TraceDecayPeriod: number;
        TraceDecayExponent: number;
        TraceSustainColor: UE.LinearColor;
        TraceSustainWireThickness: number;
        TraceSustainHoldPeriod: number;
        TraceReleaseColor: UE.LinearColor;
        TraceReleaseWireThickness: number;
        TraceReleasePeriod: number;
        TraceReleaseExponent: number;
        TracePositionBonusPeriod: number;
        TracePositionExponent: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GraphEditorSettings;
        static Load(InName: string): GraphEditorSettings;
    }
    
    class GraphNodeContextMenuContext extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Blueprint: UE.Blueprint;
        Graph: UE.EdGraph;
        Node: UE.EdGraphNode;
        bIsDebugging: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GraphNodeContextMenuContext;
        static Load(InName: string): GraphNodeContextMenuContext;
    }
    
    class GridSlot extends UE.PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: UE.Margin;
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        Row: number;
        RowSpan: number;
        Column: number;
        ColumnSpan: number;
        Layer: number;
        Nudge: UE.Vector2D;
        SetColumn(InColumn: number) : void;
        SetColumnSpan(InColumnSpan: number) : void;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetLayer(InLayer: number) : void;
        SetNudge(InNudge: UE.Vector2D) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetRow(InRow: number) : void;
        SetRowSpan(InRowSpan: number) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GridSlot;
        static Load(InName: string): GridSlot;
    }
    
    class GridPanel extends UE.PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ColumnFill: TArray<number>;
        RowFill: TArray<number>;
        AddChildToGrid(Content: $Nullable<UE.Widget>, InRow?: number /* = 0 */, InColumn?: number /* = 0 */) : UE.GridSlot;
        SetColumnFill(ColumnIndex: number, Coefficient: number) : void;
        SetRowFill(ColumnIndex: number, Coefficient: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GridPanel;
        static Load(InName: string): GridPanel;
    }
    
    class GridPathAIController extends UE.AIController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GridPathAIController;
        static Load(InName: string): GridPathAIController;
    }
    
    class GridPathFollowingComponent extends UE.PathFollowingComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GridManager: UE.NavLocalGridManager;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GridPathFollowingComponent;
        static Load(InName: string): GridPathFollowingComponent;
    }
    
    class GroundTruthData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bResetGroundTruth: boolean;
        ObjectData: UE.Object;
        CanModify() : boolean;
        LoadObject() : UE.Object;
        SaveObject(GroundTruth: $Nullable<UE.Object>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GroundTruthData;
        static Load(InName: string): GroundTruthData;
    }
    
    class GroupActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bLocked: boolean;
        GroupActors: TArray<UE.Actor>;
        SubGroups: TArray<UE.GroupActor>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GroupActor;
        static Load(InName: string): GroupActor;
    }
    
    class HapticFeedbackEffect_Buffer extends UE.HapticFeedbackEffect_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Amplitudes: TArray<number>;
        SampleRate: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffect_Buffer;
        static Load(InName: string): HapticFeedbackEffect_Buffer;
    }
    
    class HapticFeedbackDetails_Curve {
        constructor();
        constructor(Frequency: UE.RuntimeFloatCurve, Amplitude: UE.RuntimeFloatCurve);
        Frequency: UE.RuntimeFloatCurve;
        Amplitude: UE.RuntimeFloatCurve;
        static StaticClass(): Class;
    }
    
    class HapticFeedbackEffect_Curve extends UE.HapticFeedbackEffect_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HapticDetails: UE.HapticFeedbackDetails_Curve;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffect_Curve;
        static Load(InName: string): HapticFeedbackEffect_Curve;
    }
    
    class HapticFeedbackEffect_SoundWave extends UE.HapticFeedbackEffect_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundWave: UE.SoundWave;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffect_SoundWave;
        static Load(InName: string): HapticFeedbackEffect_SoundWave;
    }
    
    class HapticFeedbackEffectBufferFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffectBufferFactory;
        static Load(InName: string): HapticFeedbackEffectBufferFactory;
    }
    
    class HapticFeedbackEffectCurveFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffectCurveFactory;
        static Load(InName: string): HapticFeedbackEffectCurveFactory;
    }
    
    class HapticFeedbackEffectSoundWaveFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffectSoundWaveFactory;
        static Load(InName: string): HapticFeedbackEffectSoundWaveFactory;
    }
    
    enum EHardwareClass { Unspecified, Desktop, Mobile, EHardwareClass_MAX}
    enum EGraphicsPreset { Unspecified, Maximum, Scalable, EGraphicsPreset_MAX}
    class HardwareTargetingSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetedHardwareClass: UE.EHardwareClass;
        AppliedTargetedHardwareClass: UE.EHardwareClass;
        DefaultGraphicsPerformance: UE.EGraphicsPreset;
        AppliedDefaultGraphicsPerformance: UE.EGraphicsPreset;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HardwareTargetingSettings;
        static Load(InName: string): HardwareTargetingSettings;
    }
    
    enum EHMDTrackingOrigin { Floor, Eye, Stage, EHMDTrackingOrigin_MAX}
    enum ESpectatorScreenMode { Disabled, SingleEyeLetterboxed, Undistorted, Distorted, SingleEye, SingleEyeCroppedToFill, Texture, TexturePlusEye, ESpectatorScreenMode_MAX}
    enum EOrientPositionSelector { Orientation, Position, OrientationAndPosition, EOrientPositionSelector_MAX}
    enum EHMDWornState { Unknown, Worn, NotWorn, EHMDWornState_MAX}
    enum EXRTrackedDeviceType { HeadMountedDisplay, Controller, TrackingReference, Other, Invalid, Any, EXRTrackedDeviceType_MAX}
    class HeadMountedDisplayFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CalibrateExternalTrackingToHMD(ExternalTrackingTransform: UE.Transform) : void;
        static EnableHMD(bEnable: boolean) : boolean;
        static EnableLowPersistenceMode(bEnable: boolean) : void;
        static EnumerateTrackedDevices(SystemId?: string /* = "None" */, DeviceType?: UE.EXRTrackedDeviceType /* = Any */) : TArray<UE.XRDeviceId>;
        static GetDevicePose(XRDeviceId: UE.XRDeviceId, bIsTracked: $Ref<boolean>, Orientation: $Ref<UE.Rotator>, bHasPositionalTracking: $Ref<boolean>, Position: $Ref<UE.Vector>) : void;
        static GetDeviceWorldPose(WorldContext: $Nullable<UE.Object>, XRDeviceId: UE.XRDeviceId, bIsTracked: $Ref<boolean>, Orientation: $Ref<UE.Rotator>, bHasPositionalTracking: $Ref<boolean>, Position: $Ref<UE.Vector>) : void;
        static GetHMDDeviceName() : string;
        static GetHMDWornState() : UE.EHMDWornState;
        static GetNumOfTrackingSensors() : number;
        static GetOrientationAndPosition(DeviceRotation: $Ref<UE.Rotator>, DevicePosition: $Ref<UE.Vector>) : void;
        static GetPixelDensity() : number;
        static GetPositionalTrackingCameraParameters(CameraOrigin: $Ref<UE.Vector>, CameraRotation: $Ref<UE.Rotator>, HFOV: $Ref<number>, VFOV: $Ref<number>, CameraDistance: $Ref<number>, NearPlane: $Ref<number>, FarPlane: $Ref<number>) : void;
        static GetScreenPercentage() : number;
        static GetTrackingOrigin() : UE.EHMDTrackingOrigin;
        static GetTrackingSensorParameters(Origin: $Ref<UE.Vector>, Rotation: $Ref<UE.Rotator>, LeftFOV: $Ref<number>, RightFOV: $Ref<number>, TopFOV: $Ref<number>, BottomFOV: $Ref<number>, Distance: $Ref<number>, NearPlane: $Ref<number>, FarPlane: $Ref<number>, IsActive: $Ref<boolean>, Index?: number /* = 0 */) : void;
        static GetTrackingToWorldTransform(WorldContext: $Nullable<UE.Object>) : UE.Transform;
        static GetVRFocusState(bUseFocus: $Ref<boolean>, bHasFocus: $Ref<boolean>) : void;
        static GetWorldToMetersScale(WorldContext: $Nullable<UE.Object>) : number;
        static HasValidTrackingPosition() : boolean;
        static IsDeviceTracking(XRDeviceId: UE.XRDeviceId) : boolean;
        static IsHeadMountedDisplayConnected() : boolean;
        static IsHeadMountedDisplayEnabled() : boolean;
        static IsInLowPersistenceMode() : boolean;
        static IsSpectatorScreenModeControllable() : boolean;
        static ResetOrientationAndPosition(Yaw?: number /* = 0.000000 */, Options?: UE.EOrientPositionSelector /* = OrientationAndPosition */) : void;
        static SetClippingPlanes(Near: number, Far: number) : void;
        static SetSpectatorScreenMode(Mode: UE.ESpectatorScreenMode) : void;
        static SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMin: UE.Vector2D, EyeRectMax: UE.Vector2D, TextureRectMin: UE.Vector2D, TextureRectMax: UE.Vector2D, bDrawEyeFirst?: boolean /* = true */, bClearBlack?: boolean /* = false */, bUseAlpha?: boolean /* = false */) : void;
        static SetSpectatorScreenTexture(InTexture: $Nullable<UE.Texture>) : void;
        static SetTrackingOrigin(Origin: UE.EHMDTrackingOrigin) : void;
        static SetWorldToMetersScale(WorldContext: $Nullable<UE.Object>, NewScale?: number /* = 100.000000 */) : void;
        static UpdateExternalTrackingHMDPosition(ExternalTrackingTransform: UE.Transform) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HeadMountedDisplayFunctionLibrary;
        static Load(InName: string): HeadMountedDisplayFunctionLibrary;
    }
    
    class HealthSnapshotBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static LogPerformanceSnapshot(SnapshotTitle: string, bResetStats?: boolean /* = true */) : void;
        static StartPerformanceSnapshots() : void;
        static StopPerformanceSnapshots() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HealthSnapshotBlueprintLibrary;
        static Load(InName: string): HealthSnapshotBlueprintLibrary;
    }
    
    class HierarchicalLODSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bForceSettingsInAllMaps: boolean;
        DefaultSetup: TSoftClassPtr<UE.HierarchicalLODSetup>;
        DirectoriesForHLODCommandlet: TArray<UE.DirectoryPath>;
        MapsToBuild: TArray<UE.FilePath>;
        bInvalidateHLODClusters: boolean;
        bDeleteHLODAssets: boolean;
        BaseMaterial: TSoftObjectPtr<UE.MaterialInterface>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HierarchicalLODSettings;
        static Load(InName: string): HierarchicalLODSettings;
    }
    
    class HierarchicalLODSetup extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HierarchicalLODSetup: TArray<UE.HierarchicalSimplification>;
        OverrideBaseMaterial: TSoftObjectPtr<UE.MaterialInterface>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HierarchicalLODSetup;
        static Load(InName: string): HierarchicalLODSetup;
    }
    
    class HierarchicalLODVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIncludeOverlappingActors: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HierarchicalLODVolume;
        static Load(InName: string): HierarchicalLODVolume;
    }
    
    class LODActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StaticMeshComponent: UE.StaticMeshComponent;
        ImpostersStaticMeshComponents: TMap<UE.MaterialInterface, UE.InstancedStaticMeshComponent>;
        Proxy: UE.HLODProxy;
        Key: string;
        LODDrawDistance: number;
        LODLevel: number;
        SubActors: TArray<UE.Actor>;
        CachedNumHLODLevels: number;
        NumTrianglesInSubActors: number;
        NumTrianglesInMergedMesh: number;
        bOverrideMaterialMergeSettings: boolean;
        MaterialSettings: UE.MaterialProxySettings;
        bOverrideTransitionScreenSize: boolean;
        TransitionScreenSize: number;
        bOverrideScreenSize: boolean;
        ScreenSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LODActor;
        static Load(InName: string): LODActor;
    }
    
    class HLODProxyMesh {
        constructor();
        constructor(LODActor: TLazyObjectPtr<UE.LODActor>, StaticMesh: UE.StaticMesh, Key: string);
        LODActor: TLazyObjectPtr<UE.LODActor>;
        StaticMesh: UE.StaticMesh;
        Key: string;
        static StaticClass(): Class;
    }
    
    class HLODProxy extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OwningMap: TSoftObjectPtr<UE.World>;
        ProxyMeshes: TArray<UE.HLODProxyMesh>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HLODProxy;
        static Load(InName: string): HLODProxy;
    }
    
    class HorizontalBoxSlot extends UE.PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: UE.Margin;
        Size: UE.SlateChildSize;
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetSize(InSize: UE.SlateChildSize) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HorizontalBoxSlot;
        static Load(InName: string): HorizontalBoxSlot;
    }
    
    class HorizontalBox extends UE.PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddChildToHorizontalBox(Content: $Nullable<UE.Widget>) : UE.HorizontalBoxSlot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HorizontalBox;
        static Load(InName: string): HorizontalBox;
    }
    
    class HudSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bShowHUD: boolean;
        DebugDisplay: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HudSettings;
        static Load(InName: string): HudSettings;
    }
    
    class SlateTextureAtlasInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateTextureAtlasInterface;
        static Load(InName: string): SlateTextureAtlasInterface;
    }
    
    class Image extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Image: UE.SlateBrushAsset;
        Brush: UE.SlateBrush;
        BrushDelegate: $Delegate<() => UE.SlateBrush>;
        ColorAndOpacity: UE.LinearColor;
        ColorAndOpacityDelegate: $Delegate<() => UE.LinearColor>;
        bFlipForRightToLeftFlowDirection: boolean;
        OnMouseButtonDownEvent: $Delegate<(MyGeometry: UE.Geometry, MouseEvent: UE.PointerEvent) => UE.EventReply>;
        GetDynamicMaterial() : UE.MaterialInstanceDynamic;
        SetBrush(InBrush: UE.SlateBrush) : void;
        SetBrushFromAsset(Asset: $Nullable<UE.SlateBrushAsset>) : void;
        SetBrushFromAtlasInterface(AtlasRegion: SlateTextureAtlasInterface, bMatchSize?: boolean /* = false */) : void;
        SetBrushFromMaterial(Material: $Nullable<UE.MaterialInterface>) : void;
        SetBrushFromSoftMaterial(SoftMaterial: TSoftObjectPtr<UE.MaterialInterface>) : void;
        SetBrushFromSoftTexture(SoftTexture: TSoftObjectPtr<UE.Texture2D>, bMatchSize?: boolean /* = false */) : void;
        SetBrushFromTexture(Texture: $Nullable<UE.Texture2D>, bMatchSize?: boolean /* = false */) : void;
        SetBrushFromTextureDynamic(Texture: $Nullable<UE.Texture2DDynamic>, bMatchSize?: boolean /* = false */) : void;
        SetBrushResourceObject(ResourceObject: $Nullable<UE.Object>) : void;
        SetBrushSize(DesiredSize: UE.Vector2D) : void;
        SetBrushTintColor(TintColor: UE.SlateColor) : void;
        SetColorAndOpacity(InColorAndOpacity: UE.LinearColor) : void;
        SetOpacity(InOpacity: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Image;
        static Load(InName: string): Image;
    }
    
    class ImageSequenceProtocol_BMP extends UE.ImageSequenceProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImageSequenceProtocol_BMP;
        static Load(InName: string): ImageSequenceProtocol_BMP;
    }
    
    class ImageSequenceProtocol_EXR extends UE.ImageSequenceProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCompressed: boolean;
        CaptureGamut: UE.EHDRCaptureGamut;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImageSequenceProtocol_EXR;
        static Load(InName: string): ImageSequenceProtocol_EXR;
    }
    
    class ImageSequenceProtocol_JPG extends UE.CompressedImageSequenceProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImageSequenceProtocol_JPG;
        static Load(InName: string): ImageSequenceProtocol_JPG;
    }
    
    class ImageSequenceProtocol_PNG extends UE.CompressedImageSequenceProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImageSequenceProtocol_PNG;
        static Load(InName: string): ImageSequenceProtocol_PNG;
    }
    
    enum EDesiredImageFormat { PNG, JPG, BMP, EXR, EDesiredImageFormat_MAX}
    class ImageWriteOptions {
        constructor();
        constructor(Format: UE.EDesiredImageFormat, OnComplete: $Delegate<(bSuccess: boolean) => void>, CompressionQuality: number, bOverwriteFile: boolean, bAsync: boolean);
        Format: UE.EDesiredImageFormat;
        OnComplete: $Delegate<(bSuccess: boolean) => void>;
        CompressionQuality: number;
        bOverwriteFile: boolean;
        bAsync: boolean;
        static StaticClass(): Class;
    }
    
    class ImageWriteBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ExportToDisk(Texture: $Nullable<UE.Texture>, Filename: string, Options: UE.ImageWriteOptions) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImageWriteBlueprintLibrary;
        static Load(InName: string): ImageWriteBlueprintLibrary;
    }
    
    class ImgMediaSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultFrameRate: UE.FrameRate;
        CacheBehindPercentage: number;
        CacheSizeGB: number;
        CacheThreads: number;
        CacheThreadStackSizeKB: number;
        GlobalCacheSizeGB: number;
        UseGlobalCache: boolean;
        ExrDecoderThreads: number;
        DefaultProxy: string;
        UseDefaultProxy: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImgMediaSettings;
        static Load(InName: string): ImgMediaSettings;
    }
    
    class ImgMediaSource extends UE.BaseMediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FrameRateOverride: UE.FrameRate;
        ProxyOverride: string;
        SequencePath: UE.DirectoryPath;
        GetProxies(OutProxies: $Ref<TArray<string>>) : void;
        GetSequencePath() : string;
        SetSequencePath(Path: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImgMediaSource;
        static Load(InName: string): ImgMediaSource;
    }
    
    class ImgMediaSourceFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImgMediaSourceFactory;
        static Load(InName: string): ImgMediaSourceFactory;
    }
    
    class ImgMediaSourceFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImgMediaSourceFactoryNew;
        static Load(InName: string): ImgMediaSourceFactoryNew;
    }
    
    enum EImportanceWeight { Luminance, Red, Green, Blue, Alpha, EImportanceWeight_MAX}
    class ImportanceTexture {
        constructor();
        constructor(Size: UE.IntPoint, NumMips: number, MarginalCDF: TArray<number>, ConditionalCDF: TArray<number>, TextureData: TArray<UE.Color>, Texture: TWeakObjectPtr<UE.Texture2D>, Weighting: UE.EImportanceWeight);
        Size: UE.IntPoint;
        NumMips: number;
        MarginalCDF: TArray<number>;
        ConditionalCDF: TArray<number>;
        TextureData: TArray<UE.Color>;
        Texture: TWeakObjectPtr<UE.Texture2D>;
        Weighting: UE.EImportanceWeight;
        static StaticClass(): Class;
    }
    
    class ImportanceSamplingLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static BreakImportanceTexture(ImportanceTexture: UE.ImportanceTexture, Texture: $Ref<UE.Texture2D>, WeightingFunc: $Ref<UE.EImportanceWeight>) : void;
        static ImportanceSample(Texture: UE.ImportanceTexture, Rand: UE.Vector2D, Samples: number, Intensity: number, SamplePosition: $Ref<UE.Vector2D>, SampleColor: $Ref<UE.LinearColor>, SampleIntensity: $Ref<number>, SampleSize: $Ref<number>) : void;
        static MakeImportanceTexture(Texture: $Nullable<UE.Texture2D>, WeightingFunc: UE.EImportanceWeight) : UE.ImportanceTexture;
        static NextSobolCell2D(Index: number, NumCells?: number /* = 1 */, PreviousValue?: UE.Vector2D /* = (X=0.000,Y=0.000) */) : UE.Vector2D;
        static NextSobolCell3D(Index: number, NumCells?: number /* = 1 */, PreviousValue?: UE.Vector /* = 0.000000,0.000000,0.000000 */) : UE.Vector;
        static NextSobolFloat(Index: number, Dimension: number, PreviousValue: number) : number;
        static RandomSobolCell2D(Index: number, NumCells?: number /* = 1 */, Cell?: UE.Vector2D /* = (X=0.000,Y=0.000) */, Seed?: UE.Vector2D /* = (X=0.000,Y=0.000) */) : UE.Vector2D;
        static RandomSobolCell3D(Index: number, NumCells?: number /* = 1 */, Cell?: UE.Vector /* = 0.000000,0.000000,0.000000 */, Seed?: UE.Vector /* = 0.000000,0.000000,0.000000 */) : UE.Vector;
        static RandomSobolFloat(Index: number, Dimension: number, Seed: number) : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImportanceSamplingLibrary;
        static Load(InName: string): ImportanceSamplingLibrary;
    }
    
    class ImportantToggleSettingInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImportantToggleSettingInterface;
        static Load(InName: string): ImportantToggleSettingInterface;
    }
    
    class ImportAssetsCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GlobalImportData: UE.AutomatedAssetImportData;
        ImportDataList: TArray<UE.AutomatedAssetImportData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImportAssetsCommandlet;
        static Load(InName: string): ImportAssetsCommandlet;
    }
    
    class ImportDialogueScriptCommandlet extends UE.GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImportDialogueScriptCommandlet;
        static Load(InName: string): ImportDialogueScriptCommandlet;
    }
    
    class ImportLocalizedDialogueCommandlet extends UE.GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImportLocalizedDialogueCommandlet;
        static Load(InName: string): ImportLocalizedDialogueCommandlet;
    }
    
    class ImportSubsystem extends UE.EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnAssetPreImport_BP: $MulticastDelegate<(InFactory: $Nullable<UE.Factory>, InClass: $Nullable<UE.Class>, InParent: $Nullable<UE.Object>, Name: string, Type: string) => void>;
        OnAssetPostImport_BP: $MulticastDelegate<(InFactory: $Nullable<UE.Factory>, InCreatedObject: $Nullable<UE.Object>) => void>;
        OnAssetReimport_BP: $MulticastDelegate<(InCreatedObject: $Nullable<UE.Object>) => void>;
        OnAssetPostLODImport_BP: $MulticastDelegate<(InObject: $Nullable<UE.Object>, InLODIndex: number) => void>;
        OnAssetPostImport_Dyn__DelegateSignature(InFactory: $Nullable<UE.Factory>, InCreatedObject: $Nullable<UE.Object>) : void;
        OnAssetPostLODImport_Dyn__DelegateSignature(InObject: $Nullable<UE.Object>, InLODIndex: number) : void;
        OnAssetPreImport_Dyn__DelegateSignature(InFactory: $Nullable<UE.Factory>, InClass: $Nullable<UE.Class>, InParent: $Nullable<UE.Object>, Name: string, Type: string) : void;
        OnAssetReimport_Dyn__DelegateSignature(InCreatedObject: $Nullable<UE.Object>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImportSubsystem;
        static Load(InName: string): ImportSubsystem;
    }
    
    enum EInAppPurchaseState { Unknown, Success, Failed, Cancelled, Invalid, NotAllowed, Restored, AlreadyOwned, EInAppPurchaseState_MAX}
    class InAppPurchaseProductInfo {
        constructor();
        constructor(Identifier: string, TransactionIdentifier: string, DisplayName: string, DisplayDescription: string, DisplayPrice: string, RawPrice: number, CurrencyCode: string, CurrencySymbol: string, DecimalSeparator: string, GroupingSeparator: string, ReceiptData: string);
        Identifier: string;
        TransactionIdentifier: string;
        DisplayName: string;
        DisplayDescription: string;
        DisplayPrice: string;
        RawPrice: number;
        CurrencyCode: string;
        CurrencySymbol: string;
        DecimalSeparator: string;
        GroupingSeparator: string;
        ReceiptData: string;
        static StaticClass(): Class;
    }
    
    class InAppPurchaseProductRequest {
        constructor();
        constructor(ProductIdentifier: string, bIsConsumable: boolean);
        ProductIdentifier: string;
        bIsConsumable: boolean;
        static StaticClass(): Class;
    }
    
    class InAppPurchaseCallbackProxy extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(CompletionStatus: UE.EInAppPurchaseState, InAppPurchaseInformation: UE.InAppPurchaseProductInfo) => void>;
        OnFailure: $MulticastDelegate<(CompletionStatus: UE.EInAppPurchaseState, InAppPurchaseInformation: UE.InAppPurchaseProductInfo) => void>;
        static CreateProxyObjectForInAppPurchase(PlayerController: $Nullable<UE.PlayerController>, ProductRequest: UE.InAppPurchaseProductRequest) : UE.InAppPurchaseCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InAppPurchaseCallbackProxy;
        static Load(InName: string): InAppPurchaseCallbackProxy;
    }
    
    enum PurchaseType { Consumable, Nonconsumable, Undefined, PurchaseType_MAX}
    class PurchaseItemDetails {
        constructor();
        constructor(Price: string, Name: string, Type: UE.PurchaseType);
        Price: string;
        Name: string;
        Type: UE.PurchaseType;
        static StaticClass(): Class;
    }
    
    class PurchaseConfirmation {
        constructor();
        constructor(PackageName: string, Type: UE.PurchaseType);
        PackageName: string;
        Type: UE.PurchaseType;
        static StaticClass(): Class;
    }
    
    class InAppPurchaseComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InAppPurchaseLogMessage: $MulticastDelegate<(LogMessage: string) => void>;
        GetItemsDetailsSuccess: $MulticastDelegate<(ItemsDetails: TArray<UE.PurchaseItemDetails>) => void>;
        GetItemsDetailsFailure: $MulticastDelegate<() => void>;
        PurchaseConfirmationSuccess: $MulticastDelegate<(PurchaseConfirmations: UE.PurchaseConfirmation) => void>;
        PurchaseConfirmationFailure: $MulticastDelegate<() => void>;
        GetPurchaseHistorySuccess: $MulticastDelegate<(PurchaseHistory: TArray<UE.PurchaseConfirmation>) => void>;
        GetPurchaseHistoryFailure: $MulticastDelegate<() => void>;
        GetItemsDetailsFailure__DelegateSignature() : void;
        GetItemsDetailsSuccess__DelegateSignature(ItemsDetails: TArray<UE.PurchaseItemDetails>) : void;
        GetPurchaseHistoryFailure__DelegateSignature() : void;
        GetPurchaseHistorySuccess__DelegateSignature(PurchaseHistory: TArray<UE.PurchaseConfirmation>) : void;
        InAppPurchaseLogMessage__DelegateSignature(LogMessage: string) : void;
        PurchaseConfirmationFailure__DelegateSignature() : void;
        PurchaseConfirmationSuccess__DelegateSignature(PurchaseConfirmations: UE.PurchaseConfirmation) : void;
        TryGetItemsDetailsAsync(ItemIDs: TArray<string>) : boolean;
        TryGetPurchaseHistoryAsync(InNumPages: number) : boolean;
        TryPurchaseItemAsync(ItemDetails: UE.PurchaseItemDetails) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InAppPurchaseComponent;
        static Load(InName: string): InAppPurchaseComponent;
    }
    
    class InAppPurchaseQueryCallbackProxy extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(InAppPurchaseInformation: TArray<UE.InAppPurchaseProductInfo>) => void>;
        OnFailure: $MulticastDelegate<(InAppPurchaseInformation: TArray<UE.InAppPurchaseProductInfo>) => void>;
        static CreateProxyObjectForInAppPurchaseQuery(PlayerController: $Nullable<UE.PlayerController>, ProductIdentifiers: TArray<string>) : UE.InAppPurchaseQueryCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InAppPurchaseQueryCallbackProxy;
        static Load(InName: string): InAppPurchaseQueryCallbackProxy;
    }
    
    class InAppPurchaseRestoreInfo {
        constructor();
        constructor(Identifier: string, ReceiptData: string, TransactionIdentifier: string);
        Identifier: string;
        ReceiptData: string;
        TransactionIdentifier: string;
        static StaticClass(): Class;
    }
    
    class InAppPurchaseRestoreCallbackProxy extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(CompletionStatus: UE.EInAppPurchaseState, InAppRestorePurchaseInformation: TArray<UE.InAppPurchaseRestoreInfo>) => void>;
        OnFailure: $MulticastDelegate<(CompletionStatus: UE.EInAppPurchaseState, InAppRestorePurchaseInformation: TArray<UE.InAppPurchaseRestoreInfo>) => void>;
        static CreateProxyObjectForInAppPurchaseRestore(ConsumableProductFlags: TArray<UE.InAppPurchaseProductRequest>, PlayerController: $Nullable<UE.PlayerController>) : UE.InAppPurchaseRestoreCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InAppPurchaseRestoreCallbackProxy;
        static Load(InName: string): InAppPurchaseRestoreCallbackProxy;
    }
    
    class InGameAdManager extends UE.PlatformInterfaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bShouldPauseWhileAdOpen: boolean;
        ClickedBannerDelegates: TArray<$Delegate<() => void>>;
        ClosedAdDelegates: TArray<$Delegate<() => void>>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InGameAdManager;
        static Load(InName: string): InGameAdManager;
    }
    
    class InputDelegateBinding extends UE.DynamicBlueprintBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputDelegateBinding;
        static Load(InName: string): InputDelegateBinding;
    }
    
    class BlueprintInputDelegateBinding {
        constructor();
        constructor(bConsumeInput: boolean, bExecuteWhenPaused: boolean, bOverrideParentBinding: boolean);
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        static StaticClass(): Class;
    }
    
    class BlueprintInputActionDelegateBinding extends UE.BlueprintInputDelegateBinding {
        constructor();
        constructor(InputActionName: string, InputKeyEvent: UE.EInputEvent, FunctionNameToBind: string);
        InputActionName: string;
        InputKeyEvent: UE.EInputEvent;
        FunctionNameToBind: string;
        static StaticClass(): Class;
    }
    
    class InputActionDelegateBinding extends UE.InputDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputActionDelegateBindings: TArray<UE.BlueprintInputActionDelegateBinding>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputActionDelegateBinding;
        static Load(InName: string): InputActionDelegateBinding;
    }
    
    class BlueprintInputAxisDelegateBinding extends UE.BlueprintInputDelegateBinding {
        constructor();
        constructor(InputAxisName: string, FunctionNameToBind: string);
        InputAxisName: string;
        FunctionNameToBind: string;
        static StaticClass(): Class;
    }
    
    class InputAxisDelegateBinding extends UE.InputDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputAxisDelegateBindings: TArray<UE.BlueprintInputAxisDelegateBinding>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputAxisDelegateBinding;
        static Load(InName: string): InputAxisDelegateBinding;
    }
    
    class BlueprintInputAxisKeyDelegateBinding extends UE.BlueprintInputDelegateBinding {
        constructor();
        constructor(AxisKey: UE.Key, FunctionNameToBind: string);
        AxisKey: UE.Key;
        FunctionNameToBind: string;
        static StaticClass(): Class;
    }
    
    class InputAxisKeyDelegateBinding extends UE.InputDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputAxisKeyDelegateBindings: TArray<UE.BlueprintInputAxisKeyDelegateBinding>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputAxisKeyDelegateBinding;
        static Load(InName: string): InputAxisKeyDelegateBinding;
    }
    
    class InputBehaviorSource extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputBehaviorSource;
        static Load(InName: string): InputBehaviorSource;
    }
    
    class InputCoreTypes extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputCoreTypes;
        static Load(InName: string): InputCoreTypes;
    }
    
    class InputChord {
        constructor();
        constructor(Key: UE.Key, bShift: boolean, bCtrl: boolean, bAlt: boolean, bCmd: boolean);
        Key: UE.Key;
        bShift: boolean;
        bCtrl: boolean;
        bAlt: boolean;
        bCmd: boolean;
        static StaticClass(): Class;
    }
    
    class BlueprintInputKeyDelegateBinding extends UE.BlueprintInputDelegateBinding {
        constructor();
        constructor(InputChord: UE.InputChord, InputKeyEvent: UE.EInputEvent, FunctionNameToBind: string);
        InputChord: UE.InputChord;
        InputKeyEvent: UE.EInputEvent;
        FunctionNameToBind: string;
        static StaticClass(): Class;
    }
    
    class InputKeyDelegateBinding extends UE.InputDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputKeyDelegateBindings: TArray<UE.BlueprintInputKeyDelegateBinding>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputKeyDelegateBinding;
        static Load(InName: string): InputKeyDelegateBinding;
    }
    
    class TextBlockStyle extends UE.SlateWidgetStyle {
        constructor();
        constructor(Font: UE.SlateFontInfo, ColorAndOpacity: UE.SlateColor, ShadowOffset: UE.Vector2D, ShadowColorAndOpacity: UE.LinearColor, SelectedBackgroundColor: UE.SlateColor, HighlightColor: UE.LinearColor, HighlightShape: UE.SlateBrush, StrikeBrush: UE.SlateBrush, UnderlineBrush: UE.SlateBrush);
        Font: UE.SlateFontInfo;
        ColorAndOpacity: UE.SlateColor;
        ShadowOffset: UE.Vector2D;
        ShadowColorAndOpacity: UE.LinearColor;
        SelectedBackgroundColor: UE.SlateColor;
        HighlightColor: UE.LinearColor;
        HighlightShape: UE.SlateBrush;
        StrikeBrush: UE.SlateBrush;
        UnderlineBrush: UE.SlateBrush;
        static StaticClass(): Class;
    }
    
    class InputKeySelector extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetStyle: UE.ButtonStyle;
        TextStyle: UE.TextBlockStyle;
        SelectedKey: UE.InputChord;
        Font: UE.SlateFontInfo;
        Margin: UE.Margin;
        ColorAndOpacity: UE.LinearColor;
        KeySelectionText: string;
        NoKeySpecifiedText: string;
        bAllowModifierKeys: boolean;
        bAllowGamepadKeys: boolean;
        EscapeKeys: TArray<UE.Key>;
        OnKeySelected: $MulticastDelegate<(SelectedKey: UE.InputChord) => void>;
        OnIsSelectingKeyChanged: $MulticastDelegate<() => void>;
        GetIsSelectingKey() : boolean;
        OnIsSelectingKeyChanged__DelegateSignature() : void;
        OnKeySelected__DelegateSignature(SelectedKey: UE.InputChord) : void;
        SetAllowGamepadKeys(bInAllowGamepadKeys: boolean) : void;
        SetAllowModifierKeys(bInAllowModifierKeys: boolean) : void;
        SetEscapeKeys(InKeys: TArray<UE.Key>) : void;
        SetKeySelectionText(InKeySelectionText: string) : void;
        SetNoKeySpecifiedText(InNoKeySpecifiedText: string) : void;
        SetSelectedKey(InSelectedKey: UE.InputChord) : void;
        SetTextBlockVisibility(InVisibility: UE.ESlateVisibility) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputKeySelector;
        static Load(InName: string): InputKeySelector;
    }
    
    class InputAxisProperties {
        constructor();
        constructor(DeadZone: number, Sensitivity: number, Exponent: number, bInvert: boolean);
        DeadZone: number;
        Sensitivity: number;
        Exponent: number;
        bInvert: boolean;
        static StaticClass(): Class;
    }
    
    class InputAxisConfigEntry {
        constructor();
        constructor(AxisKeyName: string, AxisProperties: UE.InputAxisProperties);
        AxisKeyName: string;
        AxisProperties: UE.InputAxisProperties;
        static StaticClass(): Class;
    }
    
    enum EMouseLockMode { DoNotLock, LockOnCapture, LockAlways, LockInFullscreen, EMouseLockMode_MAX}
    class InputActionKeyMapping {
        constructor();
        constructor(ActionName: string, bShift: boolean, bCtrl: boolean, bAlt: boolean, bCmd: boolean, Key: UE.Key);
        ActionName: string;
        bShift: boolean;
        bCtrl: boolean;
        bAlt: boolean;
        bCmd: boolean;
        Key: UE.Key;
        static StaticClass(): Class;
    }
    
    class InputAxisKeyMapping {
        constructor();
        constructor(AxisName: string, Scale: number, Key: UE.Key);
        AxisName: string;
        Scale: number;
        Key: UE.Key;
        static StaticClass(): Class;
    }
    
    class InputActionSpeechMapping {
        constructor();
        constructor(ActionName: string, SpeechKeyword: string);
        ActionName: string;
        SpeechKeyword: string;
        static StaticClass(): Class;
    }
    
    class InputSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisConfig: TArray<UE.InputAxisConfigEntry>;
        bAltEnterTogglesFullscreen: boolean;
        bF11TogglesFullscreen: boolean;
        bUseMouseForTouch: boolean;
        bEnableMouseSmoothing: boolean;
        bEnableFOVScaling: boolean;
        bCaptureMouseOnLaunch: boolean;
        bDefaultViewportMouseLock: boolean;
        bAlwaysShowTouchInterface: boolean;
        bShowConsoleOnFourFingerTap: boolean;
        bEnableGestureRecognizer: boolean;
        bUseAutocorrect: boolean;
        ExcludedAutocorrectOS: TArray<string>;
        ExcludedAutocorrectCultures: TArray<string>;
        ExcludedAutocorrectDeviceModels: TArray<string>;
        DefaultViewportMouseCaptureMode: UE.EMouseCaptureMode;
        DefaultViewportMouseLockMode: UE.EMouseLockMode;
        FOVScale: number;
        DoubleClickTime: number;
        ActionMappings: TArray<UE.InputActionKeyMapping>;
        AxisMappings: TArray<UE.InputAxisKeyMapping>;
        SpeechMappings: TArray<UE.InputActionSpeechMapping>;
        DefaultTouchInterface: UE.SoftObjectPath;
        ConsoleKey: UE.Key;
        ConsoleKeys: TArray<UE.Key>;
        AddActionMapping(KeyMapping: UE.InputActionKeyMapping, bForceRebuildKeymaps?: boolean /* = true */) : void;
        AddAxisMapping(KeyMapping: UE.InputAxisKeyMapping, bForceRebuildKeymaps?: boolean /* = true */) : void;
        ForceRebuildKeymaps() : void;
        GetActionMappingByName(InActionName: string, OutMappings: $Ref<TArray<UE.InputActionKeyMapping>>) : void;
        GetActionNames(ActionNames: $Ref<TArray<string>>) : void;
        GetAxisMappingByName(InAxisName: string, OutMappings: $Ref<TArray<UE.InputAxisKeyMapping>>) : void;
        GetAxisNames(AxisNames: $Ref<TArray<string>>) : void;
        RemoveActionMapping(KeyMapping: UE.InputActionKeyMapping, bForceRebuildKeymaps?: boolean /* = true */) : void;
        RemoveAxisMapping(KeyMapping: UE.InputAxisKeyMapping, bForceRebuildKeymaps?: boolean /* = true */) : void;
        SaveKeyMappings() : void;
        static GetInputSettings() : UE.InputSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputSettings;
        static Load(InName: string): InputSettings;
    }
    
    class BlueprintInputTouchDelegateBinding extends UE.BlueprintInputDelegateBinding {
        constructor();
        constructor(InputKeyEvent: UE.EInputEvent, FunctionNameToBind: string);
        InputKeyEvent: UE.EInputEvent;
        FunctionNameToBind: string;
        static StaticClass(): Class;
    }
    
    class InputTouchDelegateBinding extends UE.InputDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputTouchDelegateBindings: TArray<UE.BlueprintInputTouchDelegateBinding>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputTouchDelegateBinding;
        static Load(InName: string): InputTouchDelegateBinding;
    }
    
    class InputVectorAxisDelegateBinding extends UE.InputAxisKeyDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputVectorAxisDelegateBinding;
        static Load(InName: string): InputVectorAxisDelegateBinding;
    }
    
    class InstancedFoliageActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InstancedFoliageActor;
        static Load(InName: string): InstancedFoliageActor;
    }
    
    class Int16Property extends UE.NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Int16Property;
        static Load(InName: string): Int16Property;
    }
    
    class Int32Binding extends UE.PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetValue() : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Int32Binding;
        static Load(InName: string): Int32Binding;
    }
    
    class Int64Property extends UE.NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Int64Property;
        static Load(InName: string): Int64Property;
    }
    
    class Int8Property extends UE.NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Int8Property;
        static Load(InName: string): Int8Property;
    }
    
    enum ENavDataGatheringMode { Default, Instant, Lazy, ENavDataGatheringMode_MAX}
    class StaticMeshActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StaticMeshComponent: UE.StaticMeshComponent;
        bStaticMeshReplicateMovement: boolean;
        NavigationGeometryGatheringMode: UE.ENavDataGatheringMode;
        SetMobility(InMobility: UE.EComponentMobility) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshActor;
        static Load(InName: string): StaticMeshActor;
    }
    
    class InteractiveFoliageActor extends UE.StaticMeshActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CapsuleComponent: UE.CapsuleComponent;
        TouchingActorEntryPosition: UE.Vector;
        FoliageVelocity: UE.Vector;
        FoliageForce: UE.Vector;
        FoliagePosition: UE.Vector;
        FoliageDamageImpulseScale: number;
        FoliageTouchImpulseScale: number;
        FoliageStiffness: number;
        FoliageStiffnessQuadratic: number;
        FoliageDamping: number;
        MaxDamageImpulse: number;
        MaxTouchImpulse: number;
        MaxForce: number;
        Mass: number;
        CapsuleTouched(OverlappedComp: $Nullable<UE.PrimitiveComponent>, Other: $Nullable<UE.Actor>, OtherComp: $Nullable<UE.PrimitiveComponent>, OtherBodyIndex: number, bFromSweep: boolean, OverlapInfo: UE.HitResult) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveFoliageActor;
        static Load(InName: string): InteractiveFoliageActor;
    }
    
    class InteractiveFoliageComponent extends UE.StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveFoliageComponent;
        static Load(InName: string): InteractiveFoliageComponent;
    }
    
    class InteractiveToolPropertySet extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CachedProperties: UE.Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveToolPropertySet;
        static Load(InName: string): InteractiveToolPropertySet;
    }
    
    class Interface_AssetUserData extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Interface_AssetUserData;
        static Load(InName: string): Interface_AssetUserData;
    }
    
    class Interface_CollisionDataProvider extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Interface_CollisionDataProvider;
        static Load(InName: string): Interface_CollisionDataProvider;
    }
    
    class Interface_PostProcessVolume extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Interface_PostProcessVolume;
        static Load(InName: string): Interface_PostProcessVolume;
    }
    
    class Interface_PreviewMeshProvider extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Interface_PreviewMeshProvider;
        static Load(InName: string): Interface_PreviewMeshProvider;
    }
    
    class InterfaceProperty extends UE.Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterfaceProperty;
        static Load(InName: string): InterfaceProperty;
    }
    
    class InternationalizationConditioningCommandlet extends UE.GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InternationalizationConditioningCommandlet;
        static Load(InName: string): InternationalizationConditioningCommandlet;
    }
    
    class InternationalizationExportCommandlet extends UE.GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InternationalizationExportCommandlet;
        static Load(InName: string): InternationalizationExportCommandlet;
    }
    
    class InternationalizationExportSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CulturesToGenerate: TArray<string>;
        CommandletClass: string;
        SourcePath: string;
        DestinationPath: string;
        PortableObjectName: string;
        ManifestName: string;
        ArchiveName: string;
        bExportLoc: boolean;
        bImportLoc: boolean;
        bUseCultureDirectory: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InternationalizationExportSettings;
        static Load(InName: string): InternationalizationExportSettings;
    }
    
    enum ETimezoneSetting { InternationalDateLineWest, CoordinatedUniversalTimeNeg11, Samoa, Hawaii, Alaska, PacificTime_USCAN, BajaCalifornia, MountainTime_USCAN, Chihuahua_LaPaz_Mazatlan, Arizona, Saskatchewan, CentralAmerica, CentralTime_USCAN, Guadalajara_MexicoCity_Monterrey, EasternTime_USCAN, Bogota_Lima_Quito, Indiana_US, Caracas, AtlanticTime_Canada, Cuiaba, Santiago, Georgetown_LaPaz_Manaus_SanJuan, Asuncion, Newfoundland, Brasilia, Greenland, Montevideo, Cayenne_Fortaleza, BuenosAires, MidAtlantic, CoordinatedUniversalTimeNeg02, Azores, CaboVerdeIs, Dublin_Edinburgh_Lisbon_London, Monrovia_Reykjavik, Casablanca, UTC, Belgrade_Bratislava_Budapest_Ljubljana_Prague, Sarajevo_Skopje_Warsaw_Zagreb, Brussels_Copenhagen_Madrid_Paris, WestCentralAfrica, Amsterdam_Berlin_Bern_Rome_Stockholm_Vienna, Windhoek, Minsk, Cairo, Helsinki_Kyiv_Riga_Sofia_Tallinn_Vilnius, Athens_Bucharest, Jerusalem, Amman, Beirut, Harare_Pretoria, Damascus, Istanbul, Kuwait_Riyadh, Baghdad, Nairobi, Kaliningrad, Tehran, Moscow_StPetersburg_Volgograd, AbuDhabi_Muscat, Baku, Yerevan, Tbilisi, PortLouis, Kabul, Tashkent, Islamabad_Karachi, Chennai_Kolkata_Mumbai_NewDelhi, SriJayawardenepura, Kathmandu, Ekaterinburg, Astana, Dhaka, Yangon_Rangoon, Novosibirsk, Bangkok_Hanoi_Jakarta, Krasnoyarsk, Beijing_Chongqing_HongKong_Urumqi, KualaLumpur_Singapore, Taipei, Perth, Ulaanbaatar, Irkutsk, Seoul, Osaka_Sapporo_Tokyo, Darwin, Adelaide, Yakutsk, Canberra_Melbourne_Sydney, Brisbane, Hobart, Guam_PortMoresby, Vladivostok, SolomonIs_NewCaledonia, Magadan, Fiji, Auckland_Wellington, CoordinatedUniversalTime12, Nukualofa, LocalTime, ETimezoneSetting_MAX}
    class InternationalizationSettingsModel extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DisplayTimezone: UE.ETimezoneSetting;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InternationalizationSettingsModel;
        static Load(InName: string): InternationalizationSettingsModel;
    }
    
    class InterpDataFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpDataFactoryNew;
        static Load(InName: string): InterpDataFactoryNew;
    }
    
    class InterpFilter_Classes extends UE.InterpFilter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ClassToFilterBy: UE.Class;
        TrackClasses: TArray<UE.Class>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpFilter_Classes;
        static Load(InName: string): InterpFilter_Classes;
    }
    
    class InterpFilter_Custom extends UE.InterpFilter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GroupsToInclude: TArray<UE.InterpGroup>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpFilter_Custom;
        static Load(InName: string): InterpFilter_Custom;
    }
    
    class CameraPreviewInfo {
        constructor();
        constructor(PawnClass: UE.Class, AnimSeq: UE.AnimSequence, Location: UE.Vector, Rotation: UE.Rotator, PawnInst: UE.Pawn);
        PawnClass: UE.Class;
        AnimSeq: UE.AnimSequence;
        Location: UE.Vector;
        Rotation: UE.Rotator;
        PawnInst: UE.Pawn;
        static StaticClass(): Class;
    }
    
    class InterpGroupCamera extends UE.InterpGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CameraAnimInst: UE.CameraAnim;
        Target: UE.CameraPreviewInfo;
        CompressTolerance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpGroupCamera;
        static Load(InName: string): InterpGroupCamera;
    }
    
    class InterpGroupInstCamera extends UE.InterpGroupInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpGroupInstCamera;
        static Load(InName: string): InterpGroupInstCamera;
    }
    
    class InterpGroupInstDirector extends UE.InterpGroupInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpGroupInstDirector;
        static Load(InName: string): InterpGroupInstDirector;
    }
    
    enum EInterpToBehaviourType { OneShot, OneShot_Reverse, Loop_Reset, PingPong, EInterpToBehaviourType_MAX}
    class InterpControlPoint {
        constructor();
        constructor(PositionControlPoint: UE.Vector, bPositionIsRelative: boolean);
        PositionControlPoint: UE.Vector;
        bPositionIsRelative: boolean;
        static StaticClass(): Class;
    }
    
    class InterpToMovementComponent extends UE.MovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Duration: number;
        bPauseOnImpact: boolean;
        bSweep: boolean;
        TeleportType: UE.ETeleportType;
        BehaviourType: UE.EInterpToBehaviourType;
        bCheckIfStillInWorld: boolean;
        bForceSubStepping: boolean;
        OnInterpToReverse: $MulticastDelegate<(ImpactResult: UE.HitResult, Time: number) => void>;
        OnInterpToStop: $MulticastDelegate<(ImpactResult: UE.HitResult, Time: number) => void>;
        OnWaitBeginDelegate: $MulticastDelegate<(ImpactResult: UE.HitResult, Time: number) => void>;
        OnWaitEndDelegate: $MulticastDelegate<(ImpactResult: UE.HitResult, Time: number) => void>;
        OnResetDelegate: $MulticastDelegate<(ImpactResult: UE.HitResult, Time: number) => void>;
        MaxSimulationTimeStep: number;
        MaxSimulationIterations: number;
        ControlPoints: TArray<UE.InterpControlPoint>;
        FinaliseControlPoints() : void;
        OnInterpToResetDelegate__DelegateSignature(ImpactResult: UE.HitResult, Time: number) : void;
        OnInterpToReverseDelegate__DelegateSignature(ImpactResult: UE.HitResult, Time: number) : void;
        OnInterpToStopDelegate__DelegateSignature(ImpactResult: UE.HitResult, Time: number) : void;
        OnInterpToWaitBeginDelegate__DelegateSignature(ImpactResult: UE.HitResult, Time: number) : void;
        OnInterpToWaitEndDelegate__DelegateSignature(ImpactResult: UE.HitResult, Time: number) : void;
        RestartMovement(InitialDirection?: number /* = 1.000000 */) : void;
        StopSimulating(HitResult: UE.HitResult) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpToMovementComponent;
        static Load(InName: string): InterpToMovementComponent;
    }
    
    class InterpTrackFloatBase extends UE.InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FloatTrack: UE.InterpCurveFloat;
        CurveTension: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackFloatBase;
        static Load(InName: string): InterpTrackFloatBase;
    }
    
    class AnimControlTrackKey {
        constructor();
        constructor(StartTime: number, AnimSeq: UE.AnimSequence, AnimStartOffset: number, AnimEndOffset: number, AnimPlayRate: number, bLooping: boolean, bReverse: boolean);
        StartTime: number;
        AnimSeq: UE.AnimSequence;
        AnimStartOffset: number;
        AnimEndOffset: number;
        AnimPlayRate: number;
        bLooping: boolean;
        bReverse: boolean;
        static StaticClass(): Class;
    }
    
    class InterpTrackAnimControl extends UE.InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SlotName: string;
        AnimSeqs: TArray<UE.AnimControlTrackKey>;
        bSkipAnimNotifiers: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackAnimControl;
        static Load(InName: string): InterpTrackAnimControl;
    }
    
    class InterpTrackVectorBase extends UE.InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VectorTrack: UE.InterpCurveVector;
        CurveTension: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackVectorBase;
        static Load(InName: string): InterpTrackVectorBase;
    }
    
    class InterpTrackAudioMaster extends UE.InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackAudioMaster;
        static Load(InName: string): InterpTrackAudioMaster;
    }
    
    class BoolTrackKey {
        constructor();
        constructor(Time: number, Value: boolean);
        Time: number;
        Value: boolean;
        static StaticClass(): Class;
    }
    
    class InterpTrackBoolProp extends UE.InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoolTrack: TArray<UE.BoolTrackKey>;
        PropertyName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackBoolProp;
        static Load(InName: string): InterpTrackBoolProp;
    }
    
    class InterpTrackColorProp extends UE.InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PropertyName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackColorProp;
        static Load(InName: string): InterpTrackColorProp;
    }
    
    class InterpTrackColorScale extends UE.InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackColorScale;
        static Load(InName: string): InterpTrackColorScale;
    }
    
    class DirectorTrackCut {
        constructor();
        constructor(Time: number, TransitionTime: number, TargetCamGroup: string, ShotNumber: number);
        Time: number;
        TransitionTime: number;
        TargetCamGroup: string;
        ShotNumber: number;
        static StaticClass(): Class;
    }
    
    class InterpTrackDirector extends UE.InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CutTrack: TArray<UE.DirectorTrackCut>;
        bSimulateCameraCutsOnClients: boolean;
        PreviewCamera: UE.CameraActor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackDirector;
        static Load(InName: string): InterpTrackDirector;
    }
    
    class EventTrackKey {
        constructor();
        constructor(Time: number, EventName: string);
        Time: number;
        EventName: string;
        static StaticClass(): Class;
    }
    
    class InterpTrackEvent extends UE.InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EventTrack: TArray<UE.EventTrackKey>;
        bFireEventsWhenForwards: boolean;
        bFireEventsWhenBackwards: boolean;
        bFireEventsWhenJumpingForwards: boolean;
        bUseCustomEventName: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackEvent;
        static Load(InName: string): InterpTrackEvent;
    }
    
    class InterpTrackFade extends UE.InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bPersistFade: boolean;
        bFadeAudio: boolean;
        FadeColor: UE.LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackFade;
        static Load(InName: string): InterpTrackFade;
    }
    
    class InterpTrackFloatAnimBPParam extends UE.InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimBlueprintClass: UE.AnimBlueprintGeneratedClass;
        AnimClass: UE.Class;
        ParamName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackFloatAnimBPParam;
        static Load(InName: string): InterpTrackFloatAnimBPParam;
    }
    
    class InterpTrackFloatMaterialParam extends UE.InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetMaterials: TArray<UE.MaterialInterface>;
        ParamName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackFloatMaterialParam;
        static Load(InName: string): InterpTrackFloatMaterialParam;
    }
    
    class InterpTrackFloatParticleParam extends UE.InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParamName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackFloatParticleParam;
        static Load(InName: string): InterpTrackFloatParticleParam;
    }
    
    class InterpTrackFloatProp extends UE.InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PropertyName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackFloatProp;
        static Load(InName: string): InterpTrackFloatProp;
    }
    
    class InterpTrackInstAnimControl extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LastUpdatePosition: number;
        InitPosition: UE.Vector;
        InitRotation: UE.Rotator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstAnimControl;
        static Load(InName: string): InterpTrackInstAnimControl;
    }
    
    class InterpTrackInstAudioMaster extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstAudioMaster;
        static Load(InName: string): InterpTrackInstAudioMaster;
    }
    
    class InterpTrackInstProperty extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InterpProperty: UE.Property;
        PropertyOuterObjectInst: UE.Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstProperty;
        static Load(InName: string): InterpTrackInstProperty;
    }
    
    class InterpTrackInstBoolProp extends UE.InterpTrackInstProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoolProperty: UE.BoolProperty;
        ResetBool: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstBoolProp;
        static Load(InName: string): InterpTrackInstBoolProp;
    }
    
    class InterpTrackInstColorProp extends UE.InterpTrackInstProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ResetColor: UE.Color;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstColorProp;
        static Load(InName: string): InterpTrackInstColorProp;
    }
    
    class InterpTrackInstColorScale extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstColorScale;
        static Load(InName: string): InterpTrackInstColorScale;
    }
    
    class InterpTrackInstEvent extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LastUpdatePosition: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstEvent;
        static Load(InName: string): InterpTrackInstEvent;
    }
    
    class InterpTrackInstFade extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstFade;
        static Load(InName: string): InterpTrackInstFade;
    }
    
    class InterpTrackInstFloatAnimBPParam extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimScriptInstance: UE.AnimInstance;
        ResetFloat: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstFloatAnimBPParam;
        static Load(InName: string): InterpTrackInstFloatAnimBPParam;
    }
    
    class PrimitiveMaterialRef {
        constructor();
        constructor(Primitive: UE.PrimitiveComponent, Decal: UE.DecalComponent, ElementIndex: number);
        Primitive: UE.PrimitiveComponent;
        Decal: UE.DecalComponent;
        ElementIndex: number;
        static StaticClass(): Class;
    }
    
    class InterpTrackInstFloatMaterialParam extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialInstances: TArray<UE.MaterialInstanceDynamic>;
        ResetFloats: TArray<number>;
        PrimitiveMaterialRefs: TArray<UE.PrimitiveMaterialRef>;
        InstancedTrack: UE.InterpTrackFloatMaterialParam;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstFloatMaterialParam;
        static Load(InName: string): InterpTrackInstFloatMaterialParam;
    }
    
    class InterpTrackInstFloatParticleParam extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ResetFloat: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstFloatParticleParam;
        static Load(InName: string): InterpTrackInstFloatParticleParam;
    }
    
    class InterpTrackInstFloatProp extends UE.InterpTrackInstProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ResetFloat: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstFloatProp;
        static Load(InName: string): InterpTrackInstFloatProp;
    }
    
    class InterpTrackInstLinearColorProp extends UE.InterpTrackInstProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ResetColor: UE.LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstLinearColorProp;
        static Load(InName: string): InterpTrackInstLinearColorProp;
    }
    
    class InterpTrackInstParticleReplay extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LastUpdatePosition: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstParticleReplay;
        static Load(InName: string): InterpTrackInstParticleReplay;
    }
    
    class InterpTrackInstSlomo extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OldTimeDilation: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstSlomo;
        static Load(InName: string): InterpTrackInstSlomo;
    }
    
    class InterpTrackInstSound extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LastUpdatePosition: number;
        PlayAudioComp: UE.AudioComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstSound;
        static Load(InName: string): InterpTrackInstSound;
    }
    
    enum ETrackToggleAction { ETTA_Off, ETTA_On, ETTA_Toggle, ETTA_Trigger, ETTA_MAX}
    class InterpTrackInstToggle extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Action: UE.ETrackToggleAction;
        LastUpdatePosition: number;
        bSavedActiveState: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstToggle;
        static Load(InName: string): InterpTrackInstToggle;
    }
    
    class InterpTrackVectorMaterialParam extends UE.InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetMaterials: TArray<UE.MaterialInterface>;
        ParamName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackVectorMaterialParam;
        static Load(InName: string): InterpTrackVectorMaterialParam;
    }
    
    class InterpTrackInstVectorMaterialParam extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialInstances: TArray<UE.MaterialInstanceDynamic>;
        ResetVectors: TArray<UE.Vector>;
        PrimitiveMaterialRefs: TArray<UE.PrimitiveMaterialRef>;
        InstancedTrack: UE.InterpTrackVectorMaterialParam;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstVectorMaterialParam;
        static Load(InName: string): InterpTrackInstVectorMaterialParam;
    }
    
    class InterpTrackInstVectorProp extends UE.InterpTrackInstProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ResetVector: UE.Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstVectorProp;
        static Load(InName: string): InterpTrackInstVectorProp;
    }
    
    enum EVisibilityTrackAction { EVTA_Hide, EVTA_Show, EVTA_Toggle, EVTA_MAX}
    class InterpTrackInstVisibility extends UE.InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Action: UE.EVisibilityTrackAction;
        LastUpdatePosition: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstVisibility;
        static Load(InName: string): InterpTrackInstVisibility;
    }
    
    class InterpCurvePointLinearColor {
        constructor();
        constructor(InVal: number, OutVal: UE.LinearColor, ArriveTangent: UE.LinearColor, LeaveTangent: UE.LinearColor, InterpMode: UE.EInterpCurveMode);
        InVal: number;
        OutVal: UE.LinearColor;
        ArriveTangent: UE.LinearColor;
        LeaveTangent: UE.LinearColor;
        InterpMode: UE.EInterpCurveMode;
        static StaticClass(): Class;
    }
    
    class InterpCurveLinearColor {
        constructor();
        constructor(Points: TArray<UE.InterpCurvePointLinearColor>, bIsLooped: boolean, LoopKeyOffset: number);
        Points: TArray<UE.InterpCurvePointLinearColor>;
        bIsLooped: boolean;
        LoopKeyOffset: number;
        static StaticClass(): Class;
    }
    
    class InterpTrackLinearColorBase extends UE.InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LinearColorTrack: UE.InterpCurveLinearColor;
        CurveTension: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackLinearColorBase;
        static Load(InName: string): InterpTrackLinearColorBase;
    }
    
    class InterpTrackLinearColorProp extends UE.InterpTrackLinearColorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PropertyName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackLinearColorProp;
        static Load(InName: string): InterpTrackLinearColorProp;
    }
    
    enum EInterpMoveAxis { AXIS_TranslationX, AXIS_TranslationY, AXIS_TranslationZ, AXIS_RotationX, AXIS_RotationY, AXIS_RotationZ, AXIS_MAX}
    class InterpTrackMoveAxis extends UE.InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MoveAxis: UE.EInterpMoveAxis;
        LookupTrack: UE.InterpLookupTrack;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackMoveAxis;
        static Load(InName: string): InterpTrackMoveAxis;
    }
    
    class ParticleReplayTrackKey {
        constructor();
        constructor(Time: number, Duration: number, ClipIDNumber: number);
        Time: number;
        Duration: number;
        ClipIDNumber: number;
        static StaticClass(): Class;
    }
    
    class InterpTrackParticleReplay extends UE.InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TrackKeys: TArray<UE.ParticleReplayTrackKey>;
        bIsCapturingReplay: boolean;
        FixedTimeStep: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackParticleReplay;
        static Load(InName: string): InterpTrackParticleReplay;
    }
    
    class InterpTrackSlomo extends UE.InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackSlomo;
        static Load(InName: string): InterpTrackSlomo;
    }
    
    class SoundTrackKey {
        constructor();
        constructor(Time: number, Volume: number, Pitch: number, Sound: UE.SoundBase);
        Time: number;
        Volume: number;
        Pitch: number;
        Sound: UE.SoundBase;
        static StaticClass(): Class;
    }
    
    class InterpTrackSound extends UE.InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sounds: TArray<UE.SoundTrackKey>;
        bPlayOnReverse: boolean;
        bContinueSoundOnMatineeEnd: boolean;
        bSuppressSubtitles: boolean;
        bTreatAsDialogue: boolean;
        bAttach: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackSound;
        static Load(InName: string): InterpTrackSound;
    }
    
    class ToggleTrackKey {
        constructor();
        constructor(Time: number, ToggleAction: UE.ETrackToggleAction);
        Time: number;
        ToggleAction: UE.ETrackToggleAction;
        static StaticClass(): Class;
    }
    
    class InterpTrackToggle extends UE.InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ToggleTrack: TArray<UE.ToggleTrackKey>;
        bActivateSystemEachUpdate: boolean;
        bActivateWithJustAttachedFlag: boolean;
        bFireEventsWhenForwards: boolean;
        bFireEventsWhenBackwards: boolean;
        bFireEventsWhenJumpingForwards: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackToggle;
        static Load(InName: string): InterpTrackToggle;
    }
    
    class InterpTrackVectorProp extends UE.InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PropertyName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackVectorProp;
        static Load(InName: string): InterpTrackVectorProp;
    }
    
    enum EVisibilityTrackCondition { EVTC_Always, EVTC_GoreEnabled, EVTC_GoreDisabled, EVTC_MAX}
    class VisibilityTrackKey {
        constructor();
        constructor(Time: number, Action: UE.EVisibilityTrackAction, ActiveCondition: UE.EVisibilityTrackCondition);
        Time: number;
        Action: UE.EVisibilityTrackAction;
        ActiveCondition: UE.EVisibilityTrackCondition;
        static StaticClass(): Class;
    }
    
    class InterpTrackVisibility extends UE.InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VisibilityTrack: TArray<UE.VisibilityTrackKey>;
        bFireEventsWhenForwards: boolean;
        bFireEventsWhenBackwards: boolean;
        bFireEventsWhenJumpingForwards: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackVisibility;
        static Load(InName: string): InterpTrackVisibility;
    }
    
    class IntProperty extends UE.NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): IntProperty;
        static Load(InName: string): IntProperty;
    }
    
    class IntSerialization extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UnsignedInt16Variable: number;
        UnsignedInt32Variable: number;
        UnsignedInt64Variable: bigint;
        SignedInt8Variable: number;
        SignedInt16Variable: number;
        SignedInt64Variable: bigint;
        UnsignedInt8Variable: number;
        SignedInt32Variable: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): IntSerialization;
        static Load(InName: string): IntSerialization;
    }
    
    class InvalidationBox extends UE.ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCanCache: boolean;
        CacheRelativeTransforms: boolean;
        GetCanCache() : boolean;
        InvalidateCache() : void;
        SetCanCache(CanCache: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InvalidationBox;
        static Load(InName: string): InvalidationBox;
    }
    
    enum EIOSCloudKitSyncStrategy { None, OnlyAtGameStart, Always, EIOSCloudKitSyncStrategy_MAX}
    class IOSBuildResourceDirectory {
        constructor();
        constructor(Path: string);
        Path: string;
        static StaticClass(): Class;
    }
    
    class IOSBuildResourceFilePath {
        constructor();
        constructor(FilePath: string);
        FilePath: string;
        static StaticClass(): Class;
    }
    
    enum EIOSLandscapeOrientation { LandscapeLeft, LandscapeRight, EIOSLandscapeOrientation_MAX}
    enum EPowerUsageFrameRateLock { PUFRL_None, PUFRL_20, PUFRL_30, PUFRL_60, PUFRL_MAX}
    enum EIOSVersion { IOS_61, IOS_7, IOS_8, IOS_9, IOS_10, IOS_11, IOS_12, IOS_MAX}
    class IOSRuntimeSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnableGameCenterSupport: boolean;
        bEnableCloudKitSupport: boolean;
        IOSCloudKitSyncStrategy: UE.EIOSCloudKitSyncStrategy;
        bEnableRemoteNotificationsSupport: boolean;
        bEnableBackgroundFetch: boolean;
        bSupportsMetal: boolean;
        bSupportsMetalMRT: boolean;
        bCookPVRTCTextures: boolean;
        bCookASTCTextures: boolean;
        bBuildAsFramework: boolean;
        EnableRemoteShaderCompile: boolean;
        bGeneratedSYMFile: boolean;
        bGeneratedSYMBundle: boolean;
        bGenerateCrashReportSymbols: boolean;
        bGenerateXCArchive: boolean;
        bDevForArmV7: boolean;
        bDevForArm64: boolean;
        bDevForArmV7S: boolean;
        bShipForArmV7: boolean;
        bShipForArm64: boolean;
        bShipForArmV7S: boolean;
        bShipForBitcode: boolean;
        bEnableAdvertisingIdentifier: boolean;
        AdditionalLinkerFlags: string;
        AdditionalShippingLinkerFlags: string;
        RemoteServerName: string;
        bUseRSync: boolean;
        RSyncUsername: string;
        DeltaCopyInstallPath: UE.IOSBuildResourceDirectory;
        SSHPrivateKeyLocation: string;
        SSHPrivateKeyOverridePath: UE.IOSBuildResourceFilePath;
        bTreatRemoteAsSeparateController: boolean;
        bAllowRemoteRotation: boolean;
        bUseRemoteAsVirtualJoystick: boolean;
        bUseRemoteAbsoluteDpadValues: boolean;
        bAllowControllers: boolean;
        bDisableMotionData: boolean;
        bSupportsPortraitOrientation: boolean;
        bSupportsUpsideDownOrientation: boolean;
        bSupportsLandscapeLeftOrientation: boolean;
        bSupportsLandscapeRightOrientation: boolean;
        bSupportsITunesFileSharing: boolean;
        PreferredLandscapeOrientation: UE.EIOSLandscapeOrientation;
        BundleDisplayName: string;
        BundleName: string;
        BundleIdentifier: string;
        VersionInfo: string;
        FrameRateLock: UE.EPowerUsageFrameRateLock;
        MinimumiOSVersion: UE.EIOSVersion;
        bSupportsIPad: boolean;
        bSupportsIPhone: boolean;
        AdditionalPlistData: string;
        bEnableFacebookSupport: boolean;
        FacebookAppID: string;
        MobileProvision: string;
        SigningCertificate: string;
        bAutomaticSigning: boolean;
        IOSTeamID: string;
        bDisableHTTPS: boolean;
        MaxShaderLanguageVersion: number;
        UseFastIntrinsics: boolean;
        ForceFloats: boolean;
        EnableMathOptimisations: boolean;
        IndirectArgumentTier: number;
        bUseIntegratedKeyboard: boolean;
        AudioSampleRate: number;
        AudioCallbackBufferFrameSize: number;
        AudioNumBuffersToEnqueue: number;
        AudioMaxChannels: number;
        AudioNumSourceWorkers: number;
        SpatializationPlugin: string;
        ReverbPlugin: string;
        OcclusionPlugin: string;
        CompressionOverrides: UE.PlatformRuntimeAudioCompressionOverrides;
        ChunkSizeKB: number;
        bUseAudioStreamCaching: boolean;
        CacheSizeKB: number;
        bResampleForDevice: boolean;
        SoundCueCookQualityIndex: number;
        MaxSampleRate: number;
        HighSampleRate: number;
        MedSampleRate: number;
        LowSampleRate: number;
        MinSampleRate: number;
        CompressionQualityModifier: number;
        AutoStreamingThreshold: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): IOSRuntimeSettings;
        static Load(InName: string): IOSRuntimeSettings;
    }
    
    class IPClient extends UE.ClientUnitTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): IPClient;
        static Load(InName: string): IPClient;
    }
    
    class IpConnection extends UE.NetConnection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SocketErrorDisconnectDelay: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): IpConnection;
        static Load(InName: string): IpConnection;
    }
    
    class IpNetDriver extends UE.NetDriver {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LogPortUnreach: boolean;
        AllowPlayerPortUnreach: boolean;
        MaxPortCountToTry: number;
        ServerDesiredSocketReceiveBufferBytes: number;
        ServerDesiredSocketSendBufferBytes: number;
        ClientDesiredSocketReceiveBufferBytes: number;
        ClientDesiredSocketSendBufferBytes: number;
        MaxSecondsInReceive: number;
        NbPacketsBetweenReceiveTimeTest: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): IpNetDriver;
        static Load(InName: string): IpNetDriver;
    }
    
    class JoinSessionCallbackProxy extends UE.OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;
        static JoinSession(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>, SearchResult: UE.BlueprintSessionResult) : UE.JoinSessionCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): JoinSessionCallbackProxy;
        static Load(InName: string): JoinSessionCallbackProxy;
    }
    
    class JSAnimGeneratedClass extends UE.AnimBlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): JSAnimGeneratedClass;
        static Load(InName: string): JSAnimGeneratedClass;
    }
    
    class JSBlueprintFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static Concat(First: string, Second: string) : string;
        static GetName() : string;
        static Hello(To: string) : string;
        static Info(To: $Nullable<UE.Class>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): JSBlueprintFunctionLibrary;
        static Load(InName: string): JSBlueprintFunctionLibrary;
    }
    
    class JSGeneratedClass extends UE.BlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): JSGeneratedClass;
        static Load(InName: string): JSGeneratedClass;
    }
    
    class JSGeneratedFunction extends UE.Function {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): JSGeneratedFunction;
        static Load(InName: string): JSGeneratedFunction;
    }
    
    class JsonUtilitiesDummyObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): JsonUtilitiesDummyObject;
        static Load(InName: string): JsonUtilitiesDummyObject;
    }
    
    class DelegateRuntimeBinding {
        constructor();
        constructor(ObjectName: string, PropertyName: string, FunctionName: string, SourcePath: UE.DynamicPropertyPath, Kind: UE.EBindingKind);
        ObjectName: string;
        PropertyName: string;
        FunctionName: string;
        SourcePath: UE.DynamicPropertyPath;
        Kind: UE.EBindingKind;
        static StaticClass(): Class;
    }
    
    class WidgetBlueprintGeneratedClass extends UE.BlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetTree: UE.WidgetTree;
        bCookSlowConstructionWidgetTree: boolean;
        bCanCallPreConstruct: boolean;
        bAllowTemplate: boolean;
        bAllowDynamicCreation: boolean;
        bValidTemplate: boolean;
        bTemplateInitialized: boolean;
        bCookedTemplate: boolean;
        bClassRequiresNativeTick: boolean;
        Bindings: TArray<UE.DelegateRuntimeBinding>;
        Animations: TArray<UE.WidgetAnimation>;
        NamedSlots: TArray<string>;
        TemplateAsset: TSoftObjectPtr<UE.UserWidget>;
        Template: UE.UserWidget;
        EditorTemplate: UE.UserWidget;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetBlueprintGeneratedClass;
        static Load(InName: string): WidgetBlueprintGeneratedClass;
    }
    
    class JSWidgetGeneratedClass extends UE.WidgetBlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): JSWidgetGeneratedClass;
        static Load(InName: string): JSWidgetGeneratedClass;
    }
    
    class K2Node_EditablePinBase extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsEditable: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_EditablePinBase;
        static Load(InName: string): K2Node_EditablePinBase;
    }
    
    class K2Node_Event extends UE.K2Node_EditablePinBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EventSignatureName: string;
        EventSignatureClass: UE.Class;
        EventReference: UE.MemberReference;
        bOverrideFunction: boolean;
        bInternalEvent: boolean;
        CustomFunctionName: string;
        FunctionFlags: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Event;
        static Load(InName: string): K2Node_Event;
    }
    
    class K2Node_ActorBoundEvent extends UE.K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DelegatePropertyName: string;
        DelegateOwnerClass: UE.Class;
        EventOwner: UE.Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ActorBoundEvent;
        static Load(InName: string): K2Node_ActorBoundEvent;
    }
    
    class K2Node_CallFunction extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsPureFunc: boolean;
        bIsConstFunc: boolean;
        bWantsEnumToExecExpansion: boolean;
        bIsInterfaceCall: boolean;
        bIsFinalFunction: boolean;
        bIsBeadFunction: boolean;
        FunctionReference: UE.MemberReference;
        CallFunctionName: string;
        CallFunctionClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CallFunction;
        static Load(InName: string): K2Node_CallFunction;
    }
    
    class K2Node_AddComponent extends UE.K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bHasExposedVariable: boolean;
        TemplateBlueprint: string;
        TemplateType: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_AddComponent;
        static Load(InName: string): K2Node_AddComponent;
    }
    
    class K2Node_BaseMCDelegate extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DelegateReference: UE.MemberReference;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_BaseMCDelegate;
        static Load(InName: string): K2Node_BaseMCDelegate;
    }
    
    class K2Node_AddDelegate extends UE.K2Node_BaseMCDelegate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_AddDelegate;
        static Load(InName: string): K2Node_AddDelegate;
    }
    
    class K2Node_AddPinInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_AddPinInterface;
        static Load(InName: string): K2Node_AddPinInterface;
    }
    
    class K2Node_BaseAsyncTask extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProxyFactoryFunctionName: string;
        ProxyFactoryClass: UE.Class;
        ProxyClass: UE.Class;
        ProxyActivateFunctionName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_BaseAsyncTask;
        static Load(InName: string): K2Node_BaseAsyncTask;
    }
    
    class K2Node_AIMoveTo extends UE.K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_AIMoveTo;
        static Load(InName: string): K2Node_AIMoveTo;
    }
    
    class K2Node_AnimGetter extends UE.K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceNode: UE.AnimGraphNode_Base;
        SourceStateNode: UE.AnimStateNodeBase;
        GetterClass: UE.Class;
        SourceAnimBlueprint: UE.AnimBlueprint;
        CachedTitle: string;
        Contexts: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_AnimGetter;
        static Load(InName: string): K2Node_AnimGetter;
    }
    
    class K2Node_AssignDelegate extends UE.K2Node_AddDelegate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_AssignDelegate;
        static Load(InName: string): K2Node_AssignDelegate;
    }
    
    class K2Node_AssignmentStatement extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_AssignmentStatement;
        static Load(InName: string): K2Node_AssignmentStatement;
    }
    
    class K2Node_AsyncAction extends UE.K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_AsyncAction;
        static Load(InName: string): K2Node_AsyncAction;
    }
    
    class K2Node_BitmaskLiteral extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BitflagsEnum: UE.Enum;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_BitmaskLiteral;
        static Load(InName: string): K2Node_BitmaskLiteral;
    }
    
    enum ESelfContextInfo { Unspecified, NotSelfContext, ESelfContextInfo_MAX}
    class K2Node_Variable extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VariableReference: UE.MemberReference;
        SelfContextInfo: UE.ESelfContextInfo;
        VariableSourceClass: UE.Class;
        VariableName: string;
        bSelfContext: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Variable;
        static Load(InName: string): K2Node_Variable;
    }
    
    class K2Node_StructOperation extends UE.K2Node_Variable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StructType: UE.ScriptStruct;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_StructOperation;
        static Load(InName: string): K2Node_StructOperation;
    }
    
    class K2Node_StructMemberGet extends UE.K2Node_StructOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShowPinForProperties: TArray<UE.OptionalPinFromProperty>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_StructMemberGet;
        static Load(InName: string): K2Node_StructMemberGet;
    }
    
    class K2Node_BreakStruct extends UE.K2Node_StructMemberGet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bMadeAfterOverridePinRemoval: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_BreakStruct;
        static Load(InName: string): K2Node_BreakStruct;
    }
    
    class K2Node_CallArrayFunction extends UE.K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CallArrayFunction;
        static Load(InName: string): K2Node_CallArrayFunction;
    }
    
    class K2Node_CallDataTableFunction extends UE.K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CallDataTableFunction;
        static Load(InName: string): K2Node_CallDataTableFunction;
    }
    
    class K2Node_CallDelegate extends UE.K2Node_BaseMCDelegate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CallDelegate;
        static Load(InName: string): K2Node_CallDelegate;
    }
    
    class K2Node_CallFunctionOnMember extends UE.K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MemberVariableToCallOn: UE.MemberReference;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CallFunctionOnMember;
        static Load(InName: string): K2Node_CallFunctionOnMember;
    }
    
    class K2Node_CallMaterialParameterCollectionFunction extends UE.K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CallMaterialParameterCollectionFunction;
        static Load(InName: string): K2Node_CallMaterialParameterCollectionFunction;
    }
    
    class K2Node_CallParentFunction extends UE.K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CallParentFunction;
        static Load(InName: string): K2Node_CallParentFunction;
    }
    
    class K2Node_CastByteToEnum extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Enum: UE.Enum;
        bSafe: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CastByteToEnum;
        static Load(InName: string): K2Node_CastByteToEnum;
    }
    
    class K2Node_DynamicCast extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetType: UE.Class;
        bIsPureCast: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_DynamicCast;
        static Load(InName: string): K2Node_DynamicCast;
    }
    
    class K2Node_ClassDynamicCast extends UE.K2Node_DynamicCast {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ClassDynamicCast;
        static Load(InName: string): K2Node_ClassDynamicCast;
    }
    
    class K2Node_ClearDelegate extends UE.K2Node_BaseMCDelegate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ClearDelegate;
        static Load(InName: string): K2Node_ClearDelegate;
    }
    
    class K2Node_CommutativeAssociativeBinaryOperator extends UE.K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumAdditionalInputs: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CommutativeAssociativeBinaryOperator;
        static Load(InName: string): K2Node_CommutativeAssociativeBinaryOperator;
    }
    
    class K2Node_ComponentBoundEvent extends UE.K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DelegatePropertyName: string;
        DelegateOwnerClass: UE.Class;
        ComponentPropertyName: string;
        DelegatePropertyDisplayName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ComponentBoundEvent;
        static Load(InName: string): K2Node_ComponentBoundEvent;
    }
    
    class KismetUserDeclaredFunctionMetadata {
        constructor();
        constructor(ToolTip: string, Category: string, Keywords: string, CompactNodeTitle: string, InstanceTitleColor: UE.LinearColor, DeprecationMessage: string, bIsDeprecated: boolean, bCallInEditor: boolean, HasLatentFunctions: number);
        ToolTip: string;
        Category: string;
        Keywords: string;
        CompactNodeTitle: string;
        InstanceTitleColor: UE.LinearColor;
        DeprecationMessage: string;
        bIsDeprecated: boolean;
        bCallInEditor: boolean;
        HasLatentFunctions: number;
        static StaticClass(): Class;
    }
    
    class K2Node_Tunnel extends UE.K2Node_EditablePinBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OutputSourceNode: UE.K2Node_Tunnel;
        InputSinkNode: UE.K2Node_Tunnel;
        bCanHaveInputs: boolean;
        bCanHaveOutputs: boolean;
        MetaData: UE.KismetUserDeclaredFunctionMetadata;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Tunnel;
        static Load(InName: string): K2Node_Tunnel;
    }
    
    class K2Node_Composite extends UE.K2Node_Tunnel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoundGraph: UE.EdGraph;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Composite;
        static Load(InName: string): K2Node_Composite;
    }
    
    class K2Node_ConstructObjectFromClass extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ConstructObjectFromClass;
        static Load(InName: string): K2Node_ConstructObjectFromClass;
    }
    
    class K2Node_ConvertAsset extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ConvertAsset;
        static Load(InName: string): K2Node_ConvertAsset;
    }
    
    class K2Node_ConvertToHEIF extends UE.K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ConvertToHEIF;
        static Load(InName: string): K2Node_ConvertToHEIF;
    }
    
    class K2Node_ConvertToJPEG extends UE.K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ConvertToJPEG;
        static Load(InName: string): K2Node_ConvertToJPEG;
    }
    
    class K2Node_ConvertToPNG extends UE.K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ConvertToPNG;
        static Load(InName: string): K2Node_ConvertToPNG;
    }
    
    class K2Node_ConvertToTIFF extends UE.K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ConvertToTIFF;
        static Load(InName: string): K2Node_ConvertToTIFF;
    }
    
    class K2Node_Copy extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Copy;
        static Load(InName: string): K2Node_Copy;
    }
    
    class K2Node_CreateDelegate extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SelectedFunctionName: string;
        SelectedFunctionGuid: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CreateDelegate;
        static Load(InName: string): K2Node_CreateDelegate;
    }
    
    class K2Node_CreateDragDropOperation extends UE.K2Node_ConstructObjectFromClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CreateDragDropOperation;
        static Load(InName: string): K2Node_CreateDragDropOperation;
    }
    
    class K2Node_CreateWidget extends UE.K2Node_ConstructObjectFromClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CreateWidget;
        static Load(InName: string): K2Node_CreateWidget;
    }
    
    class K2Node_CustomEvent extends UE.K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DeprecationMessage: string;
        bIsDeprecated: boolean;
        bCallInEditor: boolean;
        MetaData: UE.KismetUserDeclaredFunctionMetadata;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CustomEvent;
        static Load(InName: string): K2Node_CustomEvent;
    }
    
    class K2Node_DeadClass extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_DeadClass;
        static Load(InName: string): K2Node_DeadClass;
    }
    
    class K2Node_DelegateSet extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DelegatePropertyName: string;
        DelegatePropertyClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_DelegateSet;
        static Load(InName: string): K2Node_DelegateSet;
    }
    
    class K2Node_TemporaryVariable extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VariableType: UE.EdGraphPinType;
        bIsPersistent: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_TemporaryVariable;
        static Load(InName: string): K2Node_TemporaryVariable;
    }
    
    class K2Node_DoOnceMultiInput extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumAdditionalInputs: number;
        DataNode: UE.K2Node_TemporaryVariable;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_DoOnceMultiInput;
        static Load(InName: string): K2Node_DoOnceMultiInput;
    }
    
    class K2Node_EaseFunction extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EaseFunctionName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_EaseFunction;
        static Load(InName: string): K2Node_EaseFunction;
    }
    
    class K2Node_EnumEquality extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_EnumEquality;
        static Load(InName: string): K2Node_EnumEquality;
    }
    
    class K2Node_EnumInequality extends UE.K2Node_EnumEquality {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_EnumInequality;
        static Load(InName: string): K2Node_EnumInequality;
    }
    
    class K2Node_EnumLiteral extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Enum: UE.Enum;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_EnumLiteral;
        static Load(InName: string): K2Node_EnumLiteral;
    }
    
    class K2Node_EventNodeInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_EventNodeInterface;
        static Load(InName: string): K2Node_EventNodeInterface;
    }
    
    class K2Node_ExecutionSequence extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ExecutionSequence;
        static Load(InName: string): K2Node_ExecutionSequence;
    }
    
    class K2Node_ForEachElementInEnum extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Enum: UE.Enum;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ForEachElementInEnum;
        static Load(InName: string): K2Node_ForEachElementInEnum;
    }
    
    class K2Node_FormatText extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PinNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_FormatText;
        static Load(InName: string): K2Node_FormatText;
    }
    
    class K2Node_FunctionTerminator extends UE.K2Node_EditablePinBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FunctionReference: UE.MemberReference;
        SignatureClass: UE.Class;
        SignatureName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_FunctionTerminator;
        static Load(InName: string): K2Node_FunctionTerminator;
    }
    
    class K2Node_FunctionEntry extends UE.K2Node_FunctionTerminator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CustomGeneratedFunctionName: string;
        MetaData: UE.KismetUserDeclaredFunctionMetadata;
        LocalVariables: TArray<UE.BPVariableDescription>;
        bEnforceConstCorrectness: boolean;
        ExtraFlags: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_FunctionEntry;
        static Load(InName: string): K2Node_FunctionEntry;
    }
    
    class K2Node_FunctionResult extends UE.K2Node_FunctionTerminator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_FunctionResult;
        static Load(InName: string): K2Node_FunctionResult;
    }
    
    class K2Node_GenericCreateObject extends UE.K2Node_ConstructObjectFromClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GenericCreateObject;
        static Load(InName: string): K2Node_GenericCreateObject;
    }
    
    class K2Node_GetArrayItem extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bReturnByRefDesired: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetArrayItem;
        static Load(InName: string): K2Node_GetArrayItem;
    }
    
    class K2Node_GetClassDefaults extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlueprintSubscribedTo: UE.Blueprint;
        ShowPinForProperties: TArray<UE.OptionalPinFromProperty>;
        bExcludeObjectContainers: boolean;
        bExcludeObjectArrays: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetClassDefaults;
        static Load(InName: string): K2Node_GetClassDefaults;
    }
    
    class K2Node_GetDataTableRow extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetDataTableRow;
        static Load(InName: string): K2Node_GetDataTableRow;
    }
    
    class K2Node_GetSubsystem extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CustomClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetSubsystem;
        static Load(InName: string): K2Node_GetSubsystem;
    }
    
    class K2Node_GetEditorSubsystem extends UE.K2Node_GetSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetEditorSubsystem;
        static Load(InName: string): K2Node_GetEditorSubsystem;
    }
    
    class K2Node_GetEngineSubsystem extends UE.K2Node_GetSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetEngineSubsystem;
        static Load(InName: string): K2Node_GetEngineSubsystem;
    }
    
    class K2Node_GetEnumeratorName extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetEnumeratorName;
        static Load(InName: string): K2Node_GetEnumeratorName;
    }
    
    class K2Node_GetEnumeratorNameAsString extends UE.K2Node_GetEnumeratorName {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetEnumeratorNameAsString;
        static Load(InName: string): K2Node_GetEnumeratorNameAsString;
    }
    
    class K2Node_GetInputAxisKeyValue extends UE.K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputAxisKey: UE.Key;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetInputAxisKeyValue;
        static Load(InName: string): K2Node_GetInputAxisKeyValue;
    }
    
    class K2Node_GetInputAxisValue extends UE.K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputAxisName: string;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetInputAxisValue;
        static Load(InName: string): K2Node_GetInputAxisValue;
    }
    
    class K2Node_GetInputVectorAxisValue extends UE.K2Node_GetInputAxisKeyValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetInputVectorAxisValue;
        static Load(InName: string): K2Node_GetInputVectorAxisValue;
    }
    
    class K2Node_GetNumEnumEntries extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Enum: UE.Enum;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetNumEnumEntries;
        static Load(InName: string): K2Node_GetNumEnumEntries;
    }
    
    class K2Node_GetSequenceBinding extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceSequence: UE.SoftObjectPath;
        Binding: UE.MovieSceneObjectBindingID;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetSequenceBinding;
        static Load(InName: string): K2Node_GetSequenceBinding;
    }
    
    class K2Node_GetSubsystemFromPC extends UE.K2Node_GetSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetSubsystemFromPC;
        static Load(InName: string): K2Node_GetSubsystemFromPC;
    }
    
    class K2Node_IfThenElse extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_IfThenElse;
        static Load(InName: string): K2Node_IfThenElse;
    }
    
    class K2Node_InAppPurchase extends UE.K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InAppPurchase;
        static Load(InName: string): K2Node_InAppPurchase;
    }
    
    class K2Node_InAppPurchaseQuery extends UE.K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InAppPurchaseQuery;
        static Load(InName: string): K2Node_InAppPurchaseQuery;
    }
    
    class K2Node_InAppPurchaseRestore extends UE.K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InAppPurchaseRestore;
        static Load(InName: string): K2Node_InAppPurchaseRestore;
    }
    
    class K2Node_InputAction extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputActionName: string;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputAction;
        static Load(InName: string): K2Node_InputAction;
    }
    
    class K2Node_InputActionEvent extends UE.K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputActionName: string;
        InputKeyEvent: UE.EInputEvent;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputActionEvent;
        static Load(InName: string): K2Node_InputActionEvent;
    }
    
    class K2Node_InputAxisEvent extends UE.K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputAxisName: string;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputAxisEvent;
        static Load(InName: string): K2Node_InputAxisEvent;
    }
    
    class K2Node_InputAxisKeyEvent extends UE.K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisKey: UE.Key;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputAxisKeyEvent;
        static Load(InName: string): K2Node_InputAxisKeyEvent;
    }
    
    class K2Node_InputKey extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputKey: UE.Key;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        bControl: boolean;
        bAlt: boolean;
        bShift: boolean;
        bCommand: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputKey;
        static Load(InName: string): K2Node_InputKey;
    }
    
    class K2Node_InputKeyEvent extends UE.K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputChord: UE.InputChord;
        InputKeyEvent: UE.EInputEvent;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputKeyEvent;
        static Load(InName: string): K2Node_InputKeyEvent;
    }
    
    class K2Node_InputTouch extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputTouch;
        static Load(InName: string): K2Node_InputTouch;
    }
    
    class K2Node_InputTouchEvent extends UE.K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputKeyEvent: UE.EInputEvent;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputTouchEvent;
        static Load(InName: string): K2Node_InputTouchEvent;
    }
    
    class K2Node_InputVectorAxisEvent extends UE.K2Node_InputAxisKeyEvent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputVectorAxisEvent;
        static Load(InName: string): K2Node_InputVectorAxisEvent;
    }
    
    class K2Node_Knot extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Knot;
        static Load(InName: string): K2Node_Knot;
    }
    
    class K2Node_LatentGameplayTaskCall extends UE.K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpawnParamPins: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_LatentGameplayTaskCall;
        static Load(InName: string): K2Node_LatentGameplayTaskCall;
    }
    
    class K2Node_LatentOnlineCall extends UE.K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_LatentOnlineCall;
        static Load(InName: string): K2Node_LatentOnlineCall;
    }
    
    class K2Node_LeaderboardFlush extends UE.K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_LeaderboardFlush;
        static Load(InName: string): K2Node_LeaderboardFlush;
    }
    
    class K2Node_LeaderboardQuery extends UE.K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_LeaderboardQuery;
        static Load(InName: string): K2Node_LeaderboardQuery;
    }
    
    class K2Node_Literal extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ObjectRef: UE.Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Literal;
        static Load(InName: string): K2Node_Literal;
    }
    
    class K2Node_LoadAsset extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_LoadAsset;
        static Load(InName: string): K2Node_LoadAsset;
    }
    
    class K2Node_LoadAssetClass extends UE.K2Node_LoadAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_LoadAssetClass;
        static Load(InName: string): K2Node_LoadAssetClass;
    }
    
    class K2Node_LocalVariable extends UE.K2Node_TemporaryVariable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CustomVariableName: string;
        VariableTooltip: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_LocalVariable;
        static Load(InName: string): K2Node_LocalVariable;
    }
    
    class GraphReference {
        constructor();
        constructor(MacroGraph: UE.EdGraph, GraphBlueprint: UE.Blueprint, GraphGuid: UE.Guid);
        MacroGraph: UE.EdGraph;
        GraphBlueprint: UE.Blueprint;
        GraphGuid: UE.Guid;
        static StaticClass(): Class;
    }
    
    class K2Node_MacroInstance extends UE.K2Node_Tunnel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MacroGraph: UE.EdGraph;
        MacroGraphReference: UE.GraphReference;
        ResolvedWildcardType: UE.EdGraphPinType;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MacroInstance;
        static Load(InName: string): K2Node_MacroInstance;
    }
    
    class K2Node_MakeContainer extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumInputs: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MakeContainer;
        static Load(InName: string): K2Node_MakeContainer;
    }
    
    class K2Node_MakeArray extends UE.K2Node_MakeContainer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MakeArray;
        static Load(InName: string): K2Node_MakeArray;
    }
    
    class K2Node_MakeMap extends UE.K2Node_MakeContainer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MakeMap;
        static Load(InName: string): K2Node_MakeMap;
    }
    
    class K2Node_MakeSet extends UE.K2Node_MakeContainer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MakeSet;
        static Load(InName: string): K2Node_MakeSet;
    }
    
    class K2Node_StructMemberSet extends UE.K2Node_StructOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShowPinForProperties: TArray<UE.OptionalPinFromProperty>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_StructMemberSet;
        static Load(InName: string): K2Node_StructMemberSet;
    }
    
    class K2Node_MakeStruct extends UE.K2Node_StructMemberSet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bMadeAfterOverridePinRemoval: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MakeStruct;
        static Load(InName: string): K2Node_MakeStruct;
    }
    
    class K2Node_MakeVariable extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VariableType: UE.BPVariableDescription;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MakeVariable;
        static Load(InName: string): K2Node_MakeVariable;
    }
    
    class K2Node_MathExpression extends UE.K2Node_Composite {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Expression: string;
        bMadeAfterRotChange: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MathExpression;
        static Load(InName: string): K2Node_MathExpression;
    }
    
    class K2Node_MatineeController extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MatineeActor: UE.MatineeActor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MatineeController;
        static Load(InName: string): K2Node_MatineeController;
    }
    
    class K2Node_Message extends UE.K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Message;
        static Load(InName: string): K2Node_Message;
    }
    
    class K2Node_MultiGate extends UE.K2Node_ExecutionSequence {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DataNode: UE.K2Node_TemporaryVariable;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MultiGate;
        static Load(InName: string): K2Node_MultiGate;
    }
    
    class K2Node_PlayAnimation extends UE.K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_PlayAnimation;
        static Load(InName: string): K2Node_PlayAnimation;
    }
    
    class K2Node_PlayAnimationTimeRange extends UE.K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_PlayAnimationTimeRange;
        static Load(InName: string): K2Node_PlayAnimationTimeRange;
    }
    
    class K2Node_PlayMontage extends UE.K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_PlayMontage;
        static Load(InName: string): K2Node_PlayMontage;
    }
    
    class K2Node_PureAssignmentStatement extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_PureAssignmentStatement;
        static Load(InName: string): K2Node_PureAssignmentStatement;
    }
    
    class K2Node_RemoveDelegate extends UE.K2Node_BaseMCDelegate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_RemoveDelegate;
        static Load(InName: string): K2Node_RemoveDelegate;
    }
    
    class K2Node_Select extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumOptionPins: number;
        IndexPinType: UE.EdGraphPinType;
        Enum: UE.Enum;
        EnumEntries: TArray<string>;
        EnumEntryFriendlyNames: TArray<string>;
        bReconstructNode: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Select;
        static Load(InName: string): K2Node_Select;
    }
    
    class K2Node_Self extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Self;
        static Load(InName: string): K2Node_Self;
    }
    
    class K2Node_SetFieldsInStruct extends UE.K2Node_MakeStruct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_SetFieldsInStruct;
        static Load(InName: string): K2Node_SetFieldsInStruct;
    }
    
    class K2Node_SetVariableOnPersistentFrame extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_SetVariableOnPersistentFrame;
        static Load(InName: string): K2Node_SetVariableOnPersistentFrame;
    }
    
    class K2Node_SpawnActor extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_SpawnActor;
        static Load(InName: string): K2Node_SpawnActor;
    }
    
    class K2Node_SpawnActorFromClass extends UE.K2Node_ConstructObjectFromClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_SpawnActorFromClass;
        static Load(InName: string): K2Node_SpawnActorFromClass;
    }
    
    class K2Node_SwitchEnum extends UE.K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Enum: UE.Enum;
        EnumEntries: TArray<string>;
        EnumFriendlyNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_SwitchEnum;
        static Load(InName: string): K2Node_SwitchEnum;
    }
    
    class K2Node_SwitchInteger extends UE.K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_SwitchInteger;
        static Load(InName: string): K2Node_SwitchInteger;
    }
    
    class K2Node_SwitchName extends UE.K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PinNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_SwitchName;
        static Load(InName: string): K2Node_SwitchName;
    }
    
    class K2Node_SwitchString extends UE.K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PinNames: TArray<string>;
        bIsCaseSensitive: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_SwitchString;
        static Load(InName: string): K2Node_SwitchString;
    }
    
    class K2Node_Timeline extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TimelineName: string;
        bAutoPlay: boolean;
        TimelineGuid: UE.Guid;
        bLoop: boolean;
        bReplicated: boolean;
        bIgnoreTimeDilation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Timeline;
        static Load(InName: string): K2Node_Timeline;
    }
    
    enum ETransitionGetter { AnimationAsset_GetCurrentTime, AnimationAsset_GetLength, AnimationAsset_GetCurrentTimeFraction, AnimationAsset_GetTimeFromEnd, AnimationAsset_GetTimeFromEndFraction, CurrentState_ElapsedTime, CurrentState_GetBlendWeight, CurrentTransitionDuration, ArbitraryState_GetBlendWeight, ETransitionGetter_MAX}
    class K2Node_TransitionRuleGetter extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetterType: UE.ETransitionGetter;
        AssociatedAnimAssetPlayerNode: UE.AnimGraphNode_Base;
        AssociatedStateNode: UE.AnimStateNode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_TransitionRuleGetter;
        static Load(InName: string): K2Node_TransitionRuleGetter;
    }
    
    enum ETunnelBoundaryType { Unknown, EntrySite, InputSite, OutputSite, ETunnelBoundaryType_MAX}
    class K2Node_TunnelBoundary extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseName: string;
        TunnelBoundaryType: UE.ETunnelBoundaryType;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_TunnelBoundary;
        static Load(InName: string): K2Node_TunnelBoundary;
    }
    
    class K2Node_VariableGet extends UE.K2Node_Variable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsPureGet: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_VariableGet;
        static Load(InName: string): K2Node_VariableGet;
    }
    
    class K2Node_VariableSet extends UE.K2Node_Variable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_VariableSet;
        static Load(InName: string): K2Node_VariableSet;
    }
    
    class K2Node_VariableSetRef extends UE.K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_VariableSetRef;
        static Load(InName: string): K2Node_VariableSetRef;
    }
    
    class K2Node_WidgetAnimationEvent extends UE.K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Action: UE.EWidgetAnimationEvent;
        AnimationPropertyName: string;
        UserTag: string;
        SourceWidgetBlueprint: UE.WidgetBlueprint;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_WidgetAnimationEvent;
        static Load(InName: string): K2Node_WidgetAnimationEvent;
    }
    
    class KeyAsModifierInputBehavior extends UE.InputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KeyAsModifierInputBehavior;
        static Load(InName: string): KeyAsModifierInputBehavior;
    }
    
    class KillZVolume extends UE.PhysicsVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KillZVolume;
        static Load(InName: string): KillZVolume;
    }
    
    class PositionHistory {
        constructor();
        constructor(Positions: TArray<UE.Vector>, Range: number);
        Positions: TArray<UE.Vector>;
        Range: number;
        static StaticClass(): Class;
    }
    
    class KismetAnimationLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static K2_CalculateVelocityFromPositionHistory(DeltaSeconds: number, Position: UE.Vector, History: $Ref<UE.PositionHistory>, NumberOfSamples: number, VelocityMin: number, VelocityMax: number) : number;
        static K2_CalculateVelocityFromSockets(DeltaSeconds: number, Component: $Nullable<UE.SkeletalMeshComponent>, SocketOrBoneName: string, ReferenceSocketOrBone: string, SocketSpace: UE.ERelativeTransformSpace, OffsetInBoneSpace: UE.Vector, History: $Ref<UE.PositionHistory>, NumberOfSamples: number, VelocityMin: number, VelocityMax: number, EasingType: UE.EEasingFuncType, CustomCurve: UE.RuntimeFloatCurve) : number;
        static K2_DirectionBetweenSockets(Component: $Nullable<UE.SkeletalMeshComponent>, SocketOrBoneNameFrom: string, SocketOrBoneNameTo: string) : UE.Vector;
        static K2_DistanceBetweenTwoSocketsAndMapRange(Component: $Nullable<UE.SkeletalMeshComponent>, SocketOrBoneNameA: string, SocketSpaceA: UE.ERelativeTransformSpace, SocketOrBoneNameB: string, SocketSpaceB: UE.ERelativeTransformSpace, bRemapRange: boolean, InRangeMin: number, InRangeMax: number, OutRangeMin: number, OutRangeMax: number) : number;
        static K2_EndProfilingTimer(bLog?: boolean /* = true */, LogPrefix?: string /* = "" */) : number;
        static K2_LookAt(CurrentTransform: UE.Transform, TargetPosition: UE.Vector, LookAtVector: UE.Vector, bUseUpVector: boolean, UpVector: UE.Vector, ClampConeInDegree: number) : UE.Transform;
        static K2_MakePerlinNoiseAndRemap(Value: number, RangeOutMin: number, RangeOutMax: number) : number;
        static K2_MakePerlinNoiseVectorAndRemap(X: number, Y: number, Z: number, RangeOutMinX: number, RangeOutMaxX: number, RangeOutMinY: number, RangeOutMaxY: number, RangeOutMinZ: number, RangeOutMaxZ: number) : UE.Vector;
        static K2_StartProfilingTimer() : void;
        static K2_TwoBoneIK(RootPos: UE.Vector, JointPos: UE.Vector, EndPos: UE.Vector, JointTarget: UE.Vector, Effector: UE.Vector, OutJointPos: $Ref<UE.Vector>, OutEndPos: $Ref<UE.Vector>, bAllowStretching: boolean, StartStretchRatio: number, MaxStretchScale: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetAnimationLibrary;
        static Load(InName: string): KismetAnimationLibrary;
    }
    
    class KismetArrayLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static Array_Add(TargetArray: TArray<number>, NewItem: number) : number;
        static Array_AddUnique(TargetArray: TArray<number>, NewItem: number) : number;
        static Array_Append(TargetArray: TArray<number>, SourceArray: TArray<number>) : void;
        static Array_Clear(TargetArray: TArray<number>) : void;
        static Array_Contains(TargetArray: TArray<number>, ItemToFind: number) : boolean;
        static Array_Find(TargetArray: TArray<number>, ItemToFind: number) : number;
        static Array_Get(TargetArray: TArray<number>, Index: number, Item: $Ref<number>) : void;
        static Array_Identical(ArrayA: TArray<number>, ArrayB: TArray<number>) : boolean;
        static Array_Insert(TargetArray: TArray<number>, NewItem: number, Index: number) : void;
        static Array_IsValidIndex(TargetArray: TArray<number>, IndexToTest: number) : boolean;
        static Array_LastIndex(TargetArray: TArray<number>) : number;
        static Array_Length(TargetArray: TArray<number>) : number;
        static Array_Remove(TargetArray: TArray<number>, IndexToRemove: number) : void;
        static Array_RemoveItem(TargetArray: TArray<number>, Item: number) : boolean;
        static Array_Resize(TargetArray: TArray<number>, Size: number) : void;
        static Array_Set(TargetArray: TArray<number>, Index: number, Item: number, bSizeToFit: boolean) : void;
        static Array_Shuffle(TargetArray: TArray<number>) : void;
        static Array_Swap(TargetArray: TArray<number>, FirstIndex: number, SecondIndex: number) : void;
        static FilterArray(TargetArray: TArray<UE.Actor>, FilterClass: $Nullable<UE.Class>, FilteredArray: $Ref<TArray<UE.Actor>>) : void;
        static SetArrayPropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: TArray<number>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetArrayLibrary;
        static Load(InName: string): KismetArrayLibrary;
    }
    
    class KismetGuidLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static Conv_GuidToString(InGuid: UE.Guid) : string;
        static EqualEqual_GuidGuid(A: UE.Guid, B: UE.Guid) : boolean;
        static Invalidate_Guid(InGuid: $Ref<UE.Guid>) : void;
        static IsValid_Guid(InGuid: UE.Guid) : boolean;
        static NewGuid() : UE.Guid;
        static NotEqual_GuidGuid(A: UE.Guid, B: UE.Guid) : boolean;
        static Parse_StringToGuid(GuidString: string, OutGuid: $Ref<UE.Guid>, Success: $Ref<boolean>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetGuidLibrary;
        static Load(InName: string): KismetGuidLibrary;
    }
    
    enum ESlateGesture { None, Scroll, Magnify, Swipe, Rotate, LongPress, ESlateGesture_MAX}
    enum EUINavigationAction { Accept, Back, Num, Invalid, EUINavigationAction_MAX}
    class KismetInputLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CalibrateTilt() : void;
        static EqualEqual_InputChordInputChord(A: UE.InputChord, B: UE.InputChord) : boolean;
        static EqualEqual_KeyKey(A: UE.Key, B: UE.Key) : boolean;
        static GetAnalogValue(Input: UE.AnalogInputEvent) : number;
        static GetKey(Input: UE.KeyEvent) : UE.Key;
        static GetUserIndex(Input: UE.KeyEvent) : number;
        static InputChord_GetDisplayName(Key: UE.InputChord) : string;
        static InputEvent_IsAltDown(Input: UE.InputEvent) : boolean;
        static InputEvent_IsCommandDown(Input: UE.InputEvent) : boolean;
        static InputEvent_IsControlDown(Input: UE.InputEvent) : boolean;
        static InputEvent_IsLeftAltDown(Input: UE.InputEvent) : boolean;
        static InputEvent_IsLeftCommandDown(Input: UE.InputEvent) : boolean;
        static InputEvent_IsLeftControlDown(Input: UE.InputEvent) : boolean;
        static InputEvent_IsLeftShiftDown(Input: UE.InputEvent) : boolean;
        static InputEvent_IsRepeat(Input: UE.InputEvent) : boolean;
        static InputEvent_IsRightAltDown(Input: UE.InputEvent) : boolean;
        static InputEvent_IsRightCommandDown(Input: UE.InputEvent) : boolean;
        static InputEvent_IsRightControlDown(Input: UE.InputEvent) : boolean;
        static InputEvent_IsRightShiftDown(Input: UE.InputEvent) : boolean;
        static InputEvent_IsShiftDown(Input: UE.InputEvent) : boolean;
        static Key_GetDisplayName(Key: UE.Key) : string;
        static Key_GetNavigationAction(InKey: UE.Key) : UE.EUINavigationAction;
        static Key_GetNavigationActionFromKey(InKeyEvent: UE.KeyEvent) : UE.EUINavigationAction;
        static Key_GetNavigationDirectionFromAnalog(InAnalogEvent: UE.AnalogInputEvent) : UE.EUINavigation;
        static Key_GetNavigationDirectionFromKey(InKeyEvent: UE.KeyEvent) : UE.EUINavigation;
        static Key_IsFloatAxis(Key: UE.Key) : boolean;
        static Key_IsGamepadKey(Key: UE.Key) : boolean;
        static Key_IsKeyboardKey(Key: UE.Key) : boolean;
        static Key_IsModifierKey(Key: UE.Key) : boolean;
        static Key_IsMouseButton(Key: UE.Key) : boolean;
        static Key_IsValid(Key: UE.Key) : boolean;
        static Key_IsVectorAxis(Key: UE.Key) : boolean;
        static PointerEvent_GetCursorDelta(Input: UE.PointerEvent) : UE.Vector2D;
        static PointerEvent_GetEffectingButton(Input: UE.PointerEvent) : UE.Key;
        static PointerEvent_GetGestureDelta(Input: UE.PointerEvent) : UE.Vector2D;
        static PointerEvent_GetGestureType(Input: UE.PointerEvent) : UE.ESlateGesture;
        static PointerEvent_GetLastScreenSpacePosition(Input: UE.PointerEvent) : UE.Vector2D;
        static PointerEvent_GetPointerIndex(Input: UE.PointerEvent) : number;
        static PointerEvent_GetScreenSpacePosition(Input: UE.PointerEvent) : UE.Vector2D;
        static PointerEvent_GetTouchpadIndex(Input: UE.PointerEvent) : number;
        static PointerEvent_GetUserIndex(Input: UE.PointerEvent) : number;
        static PointerEvent_GetWheelDelta(Input: UE.PointerEvent) : number;
        static PointerEvent_IsMouseButtonDown(Input: UE.PointerEvent, MouseButton: UE.Key) : boolean;
        static PointerEvent_IsTouchEvent(Input: UE.PointerEvent) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetInputLibrary;
        static Load(InName: string): KismetInputLibrary;
    }
    
    enum ELocalizedTextSourceCategory { Game, Engine, Editor, ELocalizedTextSourceCategory_MAX}
    class KismetInternationalizationLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ClearCurrentAssetGroupCulture(AssetGroup: string, SaveToConfig?: boolean /* = false */) : void;
        static GetCultureDisplayName(Culture: string, Localized?: boolean /* = true */) : string;
        static GetCurrentAssetGroupCulture(AssetGroup: string) : string;
        static GetCurrentCulture() : string;
        static GetCurrentLanguage() : string;
        static GetCurrentLocale() : string;
        static GetLocalizedCultures(IncludeGame?: boolean /* = true */, IncludeEngine?: boolean /* = false */, IncludeEditor?: boolean /* = false */, IncludeAdditional?: boolean /* = false */) : TArray<string>;
        static GetNativeCulture(TextCategory: UE.ELocalizedTextSourceCategory) : string;
        static GetSuitableCulture(AvailableCultures: TArray<string>, CultureToMatch: string, FallbackCulture?: string /* = "en" */) : string;
        static SetCurrentAssetGroupCulture(AssetGroup: string, Culture: string, SaveToConfig?: boolean /* = false */) : boolean;
        static SetCurrentCulture(Culture: string, SaveToConfig?: boolean /* = false */) : boolean;
        static SetCurrentLanguage(Culture: string, SaveToConfig?: boolean /* = false */) : boolean;
        static SetCurrentLanguageAndLocale(Culture: string, SaveToConfig?: boolean /* = false */) : boolean;
        static SetCurrentLocale(Culture: string, SaveToConfig?: boolean /* = false */) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetInternationalizationLibrary;
        static Load(InName: string): KismetInternationalizationLibrary;
    }
    
    class KismetMaterialLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CreateDynamicMaterialInstance(WorldContextObject: $Nullable<UE.Object>, Parent: $Nullable<UE.MaterialInterface>, OptionalName?: string /* = "None" */) : UE.MaterialInstanceDynamic;
        static GetScalarParameterValue(WorldContextObject: $Nullable<UE.Object>, Collection: $Nullable<UE.MaterialParameterCollection>, ParameterName: string) : number;
        static GetVectorParameterValue(WorldContextObject: $Nullable<UE.Object>, Collection: $Nullable<UE.MaterialParameterCollection>, ParameterName: string) : UE.LinearColor;
        static SetScalarParameterValue(WorldContextObject: $Nullable<UE.Object>, Collection: $Nullable<UE.MaterialParameterCollection>, ParameterName: string, ParameterValue: number) : void;
        static SetVectorParameterValue(WorldContextObject: $Nullable<UE.Object>, Collection: $Nullable<UE.MaterialParameterCollection>, ParameterName: string, ParameterValue: UE.LinearColor) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetMaterialLibrary;
        static Load(InName: string): KismetMaterialLibrary;
    }
    
    class VectorSpringState {
        constructor();
        static StaticClass(): Class;
    }
    
    enum EEasingFunc { Linear, Step, SinusoidalIn, SinusoidalOut, SinusoidalInOut, EaseIn, EaseOut, EaseInOut, ExpoIn, ExpoOut, ExpoInOut, CircularIn, CircularOut, CircularInOut, EEasingFunc_MAX}
    enum ELerpInterpolationMode { QuatInterp, EulerInterp, DualQuatInterp, ELerpInterpolationMode_MAX}
    class FloatSpringState {
        constructor();
        static StaticClass(): Class;
    }
    
    enum EMatrixColumns { First, Second, Third, Fourth, EMatrixColumns_MAX}
    class KismetMathLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static Abs(A: number) : number;
        static Abs_Int(A: number) : number;
        static Abs_Int64(A: bigint) : bigint;
        static Acos(A: number) : number;
        static Add_ByteByte(A: number, B?: number /* = 1 */) : number;
        static Add_DateTimeDateTime(A: UE.DateTime, B: UE.DateTime) : UE.DateTime;
        static Add_DateTimeTimespan(A: UE.DateTime, B: UE.Timespan) : UE.DateTime;
        static Add_FloatFloat(A: number, B?: number /* = 1.000000 */) : number;
        static Add_Int64Int64(A: bigint, B?: bigint /* = 1 */) : bigint;
        static Add_IntInt(A: number, B?: number /* = 1 */) : number;
        static Add_LinearColorLinearColor(A: UE.LinearColor, B: UE.LinearColor) : UE.LinearColor;
        static Add_MatrixMatrix(A: UE.Matrix, B: UE.Matrix) : UE.Matrix;
        static Add_QuatQuat(A: UE.Quat, B: UE.Quat) : UE.Quat;
        static Add_TimespanTimespan(A: UE.Timespan, B: UE.Timespan) : UE.Timespan;
        static Add_Vector2DFloat(A: UE.Vector2D, B: number) : UE.Vector2D;
        static Add_Vector2DVector2D(A: UE.Vector2D, B: UE.Vector2D) : UE.Vector2D;
        static Add_Vector4Vector4(A: UE.Vector4, B: UE.Vector4) : UE.Vector4;
        static Add_VectorFloat(A: UE.Vector, B: number) : UE.Vector;
        static Add_VectorInt(A: UE.Vector, B: number) : UE.Vector;
        static Add_VectorVector(A: UE.Vector, B: UE.Vector) : UE.Vector;
        static And_Int64Int64(A: bigint, B: bigint) : bigint;
        static And_IntInt(A: number, B: number) : number;
        static Asin(A: number) : number;
        static Atan(A: number) : number;
        static Atan2(Y: number, X: number) : number;
        static BMax(A: number, B: number) : number;
        static BMin(A: number, B: number) : number;
        static BooleanAND(A: boolean, B: boolean) : boolean;
        static BooleanNAND(A: boolean, B: boolean) : boolean;
        static BooleanNOR(A: boolean, B: boolean) : boolean;
        static BooleanOR(A: boolean, B: boolean) : boolean;
        static BooleanXOR(A: boolean, B: boolean) : boolean;
        static BreakColor(InColor: UE.LinearColor, R: $Ref<number>, G: $Ref<number>, B: $Ref<number>, A: $Ref<number>) : void;
        static BreakDateTime(InDateTime: UE.DateTime, Year: $Ref<number>, Month: $Ref<number>, Day: $Ref<number>, Hour: $Ref<number>, Minute: $Ref<number>, Second: $Ref<number>, Millisecond: $Ref<number>) : void;
        static BreakFrameRate(InFrameRate: UE.FrameRate, Numerator: $Ref<number>, Denominator: $Ref<number>) : void;
        static BreakQualifiedFrameTime(InFrameTime: UE.QualifiedFrameTime, Frame: $Ref<UE.FrameNumber>, FrameRate: $Ref<UE.FrameRate>, SubFrame: $Ref<number>) : void;
        static BreakRandomStream(InRandomStream: UE.RandomStream, InitialSeed: $Ref<number>) : void;
        static BreakRotator(InRot: UE.Rotator, Roll: $Ref<number>, Pitch: $Ref<number>, Yaw: $Ref<number>) : void;
        static BreakRotIntoAxes(InRot: UE.Rotator, X: $Ref<UE.Vector>, Y: $Ref<UE.Vector>, Z: $Ref<UE.Vector>) : void;
        static BreakTimespan(InTimespan: UE.Timespan, Days: $Ref<number>, Hours: $Ref<number>, Minutes: $Ref<number>, Seconds: $Ref<number>, Milliseconds: $Ref<number>) : void;
        static BreakTimespan2(InTimespan: UE.Timespan, Days: $Ref<number>, Hours: $Ref<number>, Minutes: $Ref<number>, Seconds: $Ref<number>, FractionNano: $Ref<number>) : void;
        static BreakTransform(InTransform: UE.Transform, Location: $Ref<UE.Vector>, Rotation: $Ref<UE.Rotator>, Scale: $Ref<UE.Vector>) : void;
        static BreakVector(InVec: UE.Vector, X: $Ref<number>, Y: $Ref<number>, Z: $Ref<number>) : void;
        static BreakVector2D(InVec: UE.Vector2D, X: $Ref<number>, Y: $Ref<number>) : void;
        static BreakVector4(InVec: UE.Vector4, X: $Ref<number>, Y: $Ref<number>, Z: $Ref<number>, W: $Ref<number>) : void;
        static CInterpTo(Current: UE.LinearColor, Target: UE.LinearColor, DeltaTime: number, InterpSpeed: number) : UE.LinearColor;
        static Clamp(Value: number, Min: number, Max: number) : number;
        static ClampAngle(AngleDegrees: number, MinAngleDegrees: number, MaxAngleDegrees: number) : number;
        static ClampAxes2D(A: UE.Vector2D, MinAxisVal: number, MaxAxisVal: number) : UE.Vector2D;
        static ClampAxis(Angle: number) : number;
        static ClampInt64(Value: bigint, Min: bigint, Max: bigint) : bigint;
        static ClampVectorSize(A: UE.Vector, Min: number, Max: number) : UE.Vector;
        static ClassIsChildOf(TestClass: $Nullable<UE.Class>, ParentClass: $Nullable<UE.Class>) : boolean;
        static ComposeRotators(A: UE.Rotator, B: UE.Rotator) : UE.Rotator;
        static ComposeTransforms(A: UE.Transform, B: UE.Transform) : UE.Transform;
        static Conv_BoolToByte(InBool: boolean) : number;
        static Conv_BoolToFloat(InBool: boolean) : number;
        static Conv_BoolToInt(InBool: boolean) : number;
        static Conv_ByteToFloat(InByte: number) : number;
        static Conv_ByteToInt(InByte: number) : number;
        static Conv_ColorToLinearColor(InColor: UE.Color) : UE.LinearColor;
        static Conv_FloatToLinearColor(InFloat: number) : UE.LinearColor;
        static Conv_FloatToVector(InFloat: number) : UE.Vector;
        static Conv_IntToBool(InInt: number) : boolean;
        static Conv_IntToByte(InInt: number) : number;
        static Conv_IntToFloat(InInt: number) : number;
        static Conv_IntToInt64(InInt: number) : bigint;
        static Conv_IntToIntVector(InInt: number) : UE.IntVector;
        static Conv_IntVectorToVector(InIntVector: UE.IntVector) : UE.Vector;
        static Conv_LinearColorToColor(InLinearColor: UE.LinearColor, InUseSRGB?: boolean /* = true */) : UE.Color;
        static Conv_LinearColorToVector(InLinearColor: UE.LinearColor) : UE.Vector;
        static Conv_MatrixToRotator(InMatrix: UE.Matrix) : UE.Rotator;
        static Conv_MatrixToTransform(InMatrix: UE.Matrix) : UE.Transform;
        static Conv_RotatorToTransform(InRotator: UE.Rotator) : UE.Transform;
        static Conv_RotatorToVector(InRot: UE.Rotator) : UE.Vector;
        static Conv_TransformToMatrix(Transform: UE.Transform) : UE.Matrix;
        static Conv_Vector2DToIntPoint(InVector2D: UE.Vector2D) : UE.IntPoint;
        static Conv_Vector2DToVector(InVector2D: UE.Vector2D, Z?: number /* = 0.000000 */) : UE.Vector;
        static Conv_Vector4ToQuaterion(InVec: UE.Vector4) : UE.Quat;
        static Conv_Vector4ToRotator(InVec: UE.Vector4) : UE.Rotator;
        static Conv_Vector4ToVector(InVector4: UE.Vector4) : UE.Vector;
        static Conv_VectorToLinearColor(InVec: UE.Vector) : UE.LinearColor;
        static Conv_VectorToQuaterion(InVec: UE.Vector) : UE.Quat;
        static Conv_VectorToRotator(InVec: UE.Vector) : UE.Rotator;
        static Conv_VectorToTransform(InLocation: UE.Vector) : UE.Transform;
        static Conv_VectorToVector2D(InVector: UE.Vector) : UE.Vector2D;
        static ConvertTransformToRelative(Transform: UE.Transform, ParentTransform: UE.Transform) : UE.Transform;
        static Cos(A: number) : number;
        static CreateVectorFromYawPitch(Yaw: number, Pitch: number, Length?: number /* = 1.000000 */) : UE.Vector;
        static Cross_VectorVector(A: UE.Vector, B: UE.Vector) : UE.Vector;
        static CrossProduct2D(A: UE.Vector2D, B: UE.Vector2D) : number;
        static DateTimeFromIsoString(IsoString: string, Result: $Ref<UE.DateTime>) : boolean;
        static DateTimeFromString(DateTimeString: string, Result: $Ref<UE.DateTime>) : boolean;
        static DateTimeMaxValue() : UE.DateTime;
        static DateTimeMinValue() : UE.DateTime;
        static DaysInMonth(Year: number, Month: number) : number;
        static DaysInYear(Year: number) : number;
        static DegAcos(A: number) : number;
        static DegAsin(A: number) : number;
        static DegAtan(A: number) : number;
        static DegAtan2(Y: number, X: number) : number;
        static DegCos(A: number) : number;
        static DegreesToRadians(A: number) : number;
        static DegSin(A: number) : number;
        static DegTan(A: number) : number;
        static Distance2D(V1: UE.Vector2D, V2: UE.Vector2D) : number;
        static DistanceSquared2D(V1: UE.Vector2D, V2: UE.Vector2D) : number;
        static Divide_ByteByte(A: number, B?: number /* = 1 */) : number;
        static Divide_FloatFloat(A: number, B?: number /* = 1.000000 */) : number;
        static Divide_Int64Int64(A: bigint, B?: bigint /* = 1 */) : bigint;
        static Divide_IntInt(A: number, B?: number /* = 1 */) : number;
        static Divide_LinearColorLinearColor(A: UE.LinearColor, B: UE.LinearColor) : UE.LinearColor;
        static Divide_TimespanFloat(A: UE.Timespan, Scalar: number) : UE.Timespan;
        static Divide_Vector2DFloat(A: UE.Vector2D, B?: number /* = 1.000000 */) : UE.Vector2D;
        static Divide_Vector2DVector2D(A: UE.Vector2D, B: UE.Vector2D) : UE.Vector2D;
        static Divide_Vector4Vector4(A: UE.Vector4, B: UE.Vector4) : UE.Vector4;
        static Divide_VectorFloat(A: UE.Vector, B?: number /* = 1.000000 */) : UE.Vector;
        static Divide_VectorInt(A: UE.Vector, B?: number /* = 1 */) : UE.Vector;
        static Divide_VectorVector(A: UE.Vector, B?: UE.Vector /* = 1.000000,1.000000,1.000000 */) : UE.Vector;
        static Dot_VectorVector(A: UE.Vector, B: UE.Vector) : number;
        static DotProduct2D(A: UE.Vector2D, B: UE.Vector2D) : number;
        static DynamicWeightedMovingAverage_Float(CurrentSample: number, PreviousSample: number, MaxDistance: number, MinWeight: number, MaxWeight: number) : number;
        static DynamicWeightedMovingAverage_FRotator(CurrentSample: UE.Rotator, PreviousSample: UE.Rotator, MaxDistance: number, MinWeight: number, MaxWeight: number) : UE.Rotator;
        static DynamicWeightedMovingAverage_FVector(CurrentSample: UE.Vector, PreviousSample: UE.Vector, MaxDistance: number, MinWeight: number, MaxWeight: number) : UE.Vector;
        static Ease(A: number, B: number, Alpha: number, EasingFunc: UE.EEasingFunc, BlendExp?: number /* = 2.000000 */, Steps?: number /* = 2 */) : number;
        static EqualEqual_BoolBool(A: boolean, B: boolean) : boolean;
        static EqualEqual_ByteByte(A: number, B: number) : boolean;
        static EqualEqual_ClassClass(A: $Nullable<UE.Class>, B: $Nullable<UE.Class>) : boolean;
        static EqualEqual_DateTimeDateTime(A: UE.DateTime, B: UE.DateTime) : boolean;
        static EqualEqual_FloatFloat(A: number, B: number) : boolean;
        static EqualEqual_Int64Int64(A: bigint, B: bigint) : boolean;
        static EqualEqual_IntInt(A: number, B: number) : boolean;
        static EqualEqual_LinearColorLinearColor(A: UE.LinearColor, B: UE.LinearColor) : boolean;
        static EqualEqual_MatrixMatrix(A: UE.Matrix, B: UE.Matrix, Tolerance?: number /* = 0.000100 */) : boolean;
        static EqualEqual_NameName(A: string, B: string) : boolean;
        static EqualEqual_ObjectObject(A: $Nullable<UE.Object>, B: $Nullable<UE.Object>) : boolean;
        static EqualEqual_QuatQuat(A: UE.Quat, B: UE.Quat, Tolerance?: number /* = 0.000100 */) : boolean;
        static EqualEqual_RotatorRotator(A: UE.Rotator, B: UE.Rotator, ErrorTolerance?: number /* = 0.000100 */) : boolean;
        static EqualEqual_TimespanTimespan(A: UE.Timespan, B: UE.Timespan) : boolean;
        static EqualEqual_TransformTransform(A: UE.Transform, B: UE.Transform) : boolean;
        static EqualEqual_Vector2DVector2D(A: UE.Vector2D, B: UE.Vector2D, ErrorTolerance?: number /* = 0.000100 */) : boolean;
        static EqualEqual_Vector4Vector4(A: UE.Vector4, B: UE.Vector4, ErrorTolerance?: number /* = 0.000100 */) : boolean;
        static EqualEqual_VectorVector(A: UE.Vector, B: UE.Vector, ErrorTolerance?: number /* = 0.000100 */) : boolean;
        static EqualExactly_Vector2DVector2D(A: UE.Vector2D, B: UE.Vector2D) : boolean;
        static EqualExactly_Vector4Vector4(A: UE.Vector4, B: UE.Vector4) : boolean;
        static EqualExactly_VectorVector(A: UE.Vector, B: UE.Vector) : boolean;
        static Exp(A: number) : number;
        static FCeil(A: number) : number;
        static FCeil64(A: number) : bigint;
        static FClamp(Value: number, Min: number, Max: number) : number;
        static FFloor(A: number) : number;
        static FFloor64(A: number) : bigint;
        static FindClosestPointOnLine(Point: UE.Vector, LineOrigin: UE.Vector, LineDirection: UE.Vector) : UE.Vector;
        static FindClosestPointOnSegment(Point: UE.Vector, SegmentStart: UE.Vector, SegmentEnd: UE.Vector) : UE.Vector;
        static FindLookAtRotation(Start: UE.Vector, Target: UE.Vector) : UE.Rotator;
        static FindNearestPointsOnLineSegments(Segment1Start: UE.Vector, Segment1End: UE.Vector, Segment2Start: UE.Vector, Segment2End: UE.Vector, Segment1Point: $Ref<UE.Vector>, Segment2Point: $Ref<UE.Vector>) : void;
        static FInterpEaseInOut(A: number, B: number, Alpha: number, Exponent: number) : number;
        static FInterpTo(Current: number, Target: number, DeltaTime: number, InterpSpeed: number) : number;
        static FInterpTo_Constant(Current: number, Target: number, DeltaTime: number, InterpSpeed: number) : number;
        static FixedTurn(InCurrent: number, InDesired: number, InDeltaRate: number) : number;
        static FloatSpringInterp(Current: number, Target: number, SpringState: $Ref<UE.FloatSpringState>, Stiffness: number, CriticalDampingFactor: number, DeltaTime: number, Mass?: number /* = 1.000000 */) : number;
        static FMax(A: number, B: number) : number;
        static FMin(A: number, B: number) : number;
        static FMod(Dividend: number, Divisor: number, Remainder: $Ref<number>) : number;
        static Fraction(A: number) : number;
        static FromDays(Days: number) : UE.Timespan;
        static FromHours(Hours: number) : UE.Timespan;
        static FromMilliseconds(Milliseconds: number) : UE.Timespan;
        static FromMinutes(Minutes: number) : UE.Timespan;
        static FromSeconds(Seconds: number) : UE.Timespan;
        static FTrunc(A: number) : number;
        static FTrunc64(A: number) : bigint;
        static FTruncVector(InVector: UE.Vector) : UE.IntVector;
        static GetAbs2D(A: UE.Vector2D) : UE.Vector2D;
        static GetAbsMax2D(A: UE.Vector2D) : number;
        static GetAxes(A: UE.Rotator, X: $Ref<UE.Vector>, Y: $Ref<UE.Vector>, Z: $Ref<UE.Vector>) : void;
        static GetAzimuthAndElevation(InDirection: UE.Vector, ReferenceFrame: UE.Transform, Azimuth: $Ref<number>, Elevation: $Ref<number>) : void;
        static GetDate(A: UE.DateTime) : UE.DateTime;
        static GetDay(A: UE.DateTime) : number;
        static GetDayOfYear(A: UE.DateTime) : number;
        static GetDays(A: UE.Timespan) : number;
        static GetDirectionUnitVector(From: UE.Vector, To: UE.Vector) : UE.Vector;
        static GetDuration(A: UE.Timespan) : UE.Timespan;
        static GetForwardVector(InRot: UE.Rotator) : UE.Vector;
        static GetHour(A: UE.DateTime) : number;
        static GetHour12(A: UE.DateTime) : number;
        static GetHours(A: UE.Timespan) : number;
        static GetMax2D(A: UE.Vector2D) : number;
        static GetMaxElement(A: UE.Vector) : number;
        static GetMillisecond(A: UE.DateTime) : number;
        static GetMilliseconds(A: UE.Timespan) : number;
        static GetMin2D(A: UE.Vector2D) : number;
        static GetMinElement(A: UE.Vector) : number;
        static GetMinute(A: UE.DateTime) : number;
        static GetMinutes(A: UE.Timespan) : number;
        static GetMonth(A: UE.DateTime) : number;
        static GetPI() : number;
        static GetPointDistanceToLine(Point: UE.Vector, LineOrigin: UE.Vector, LineDirection: UE.Vector) : number;
        static GetPointDistanceToSegment(Point: UE.Vector, SegmentStart: UE.Vector, SegmentEnd: UE.Vector) : number;
        static GetReflectionVector(Direction: UE.Vector, SurfaceNormal: UE.Vector) : UE.Vector;
        static GetRightVector(InRot: UE.Rotator) : UE.Vector;
        static GetRotated2D(A: UE.Vector2D, AngleDeg: number) : UE.Vector2D;
        static GetSecond(A: UE.DateTime) : number;
        static GetSeconds(A: UE.Timespan) : number;
        static GetSlopeDegreeAngles(MyRightYAxis: UE.Vector, FloorNormal: UE.Vector, UpVector: UE.Vector, OutSlopePitchDegreeAngle: $Ref<number>, OutSlopeRollDegreeAngle: $Ref<number>) : void;
        static GetTAU() : number;
        static GetTimeOfDay(A: UE.DateTime) : UE.Timespan;
        static GetTotalDays(A: UE.Timespan) : number;
        static GetTotalHours(A: UE.Timespan) : number;
        static GetTotalMilliseconds(A: UE.Timespan) : number;
        static GetTotalMinutes(A: UE.Timespan) : number;
        static GetTotalSeconds(A: UE.Timespan) : number;
        static GetUpVector(InRot: UE.Rotator) : UE.Vector;
        static GetVectorArrayAverage(Vectors: TArray<UE.Vector>) : UE.Vector;
        static GetYawPitchFromVector(InVec: UE.Vector, Yaw: $Ref<number>, Pitch: $Ref<number>) : void;
        static GetYear(A: UE.DateTime) : number;
        static Greater_ByteByte(A: number, B: number) : boolean;
        static Greater_DateTimeDateTime(A: UE.DateTime, B: UE.DateTime) : boolean;
        static Greater_FloatFloat(A: number, B: number) : boolean;
        static Greater_Int64Int64(A: bigint, B: bigint) : boolean;
        static Greater_IntInt(A: number, B: number) : boolean;
        static Greater_TimespanTimespan(A: UE.Timespan, B: UE.Timespan) : boolean;
        static GreaterEqual_ByteByte(A: number, B: number) : boolean;
        static GreaterEqual_DateTimeDateTime(A: UE.DateTime, B: UE.DateTime) : boolean;
        static GreaterEqual_FloatFloat(A: number, B: number) : boolean;
        static GreaterEqual_Int64Int64(A: bigint, B: bigint) : boolean;
        static GreaterEqual_IntInt(A: number, B: number) : boolean;
        static GreaterEqual_TimespanTimespan(A: UE.Timespan, B: UE.Timespan) : boolean;
        static GreaterGreater_VectorRotator(A: UE.Vector, B: UE.Rotator) : UE.Vector;
        static GridSnap_Float(Location: number, GridSize: number) : number;
        static HSVToRGB(H: number, S: number, V: number, A?: number /* = 1.000000 */) : UE.LinearColor;
        static HSVToRGB_Vector(HSV: UE.LinearColor, RGB: $Ref<UE.LinearColor>) : void;
        static HSVToRGBLinear(HSV: UE.LinearColor) : UE.LinearColor;
        static Hypotenuse(Width: number, Height: number) : number;
        static InRange_FloatFloat(Value: number, Min: number, Max: number, InclusiveMin?: boolean /* = true */, InclusiveMax?: boolean /* = true */) : boolean;
        static InRange_Int64Int64(Value: bigint, Min: bigint, Max: bigint, InclusiveMin?: boolean /* = true */, InclusiveMax?: boolean /* = true */) : boolean;
        static InRange_IntInt(Value: number, Min: number, Max: number, InclusiveMin?: boolean /* = true */, InclusiveMax?: boolean /* = true */) : boolean;
        static InverseTransformDirection(T: UE.Transform, Direction: UE.Vector) : UE.Vector;
        static InverseTransformLocation(T: UE.Transform, Location: UE.Vector) : UE.Vector;
        static InverseTransformRotation(T: UE.Transform, Rotation: UE.Rotator) : UE.Rotator;
        static InvertTransform(T: UE.Transform) : UE.Transform;
        static IsAfternoon(A: UE.DateTime) : boolean;
        static IsLeapYear(Year: number) : boolean;
        static IsMorning(A: UE.DateTime) : boolean;
        static IsNearlyZero2D(A: UE.Vector2D, Tolerance?: number /* = 0.000100 */) : boolean;
        static IsPointInBox(Point: UE.Vector, BoxOrigin: UE.Vector, BoxExtent: UE.Vector) : boolean;
        static IsPointInBoxWithTransform(Point: UE.Vector, BoxWorldTransform: UE.Transform, BoxExtent: UE.Vector) : boolean;
        static IsZero2D(A: UE.Vector2D) : boolean;
        static Lerp(A: number, B: number, Alpha: number) : number;
        static Less_ByteByte(A: number, B: number) : boolean;
        static Less_DateTimeDateTime(A: UE.DateTime, B: UE.DateTime) : boolean;
        static Less_FloatFloat(A: number, B: number) : boolean;
        static Less_Int64Int64(A: bigint, B: bigint) : boolean;
        static Less_IntInt(A: number, B: number) : boolean;
        static Less_TimespanTimespan(A: UE.Timespan, B: UE.Timespan) : boolean;
        static LessEqual_ByteByte(A: number, B: number) : boolean;
        static LessEqual_DateTimeDateTime(A: UE.DateTime, B: UE.DateTime) : boolean;
        static LessEqual_FloatFloat(A: number, B: number) : boolean;
        static LessEqual_Int64Int64(A: bigint, B: bigint) : boolean;
        static LessEqual_IntInt(A: number, B: number) : boolean;
        static LessEqual_TimespanTimespan(A: UE.Timespan, B: UE.Timespan) : boolean;
        static LessLess_VectorRotator(A: UE.Vector, B: UE.Rotator) : UE.Vector;
        static LinearColor_Black() : UE.LinearColor;
        static LinearColor_Blue() : UE.LinearColor;
        static LinearColor_Desaturated(InColor: UE.LinearColor, InDesaturation: number) : UE.LinearColor;
        static LinearColor_Distance(C1: UE.LinearColor, C2: UE.LinearColor) : number;
        static LinearColor_GetLuminance(InColor: UE.LinearColor) : number;
        static LinearColor_GetMax(InColor: UE.LinearColor) : number;
        static LinearColor_GetMin(InColor: UE.LinearColor) : number;
        static LinearColor_Gray() : UE.LinearColor;
        static LinearColor_Green() : UE.LinearColor;
        static LinearColor_IsNearEqual(A: UE.LinearColor, B: UE.LinearColor, Tolerance?: number /* = 0.000100 */) : boolean;
        static LinearColor_Quantize(InColor: UE.LinearColor) : UE.Color;
        static LinearColor_QuantizeRound(InColor: UE.LinearColor) : UE.Color;
        static LinearColor_Red() : UE.LinearColor;
        static LinearColor_Set(InOutColor: $Ref<UE.LinearColor>, InColor: UE.LinearColor) : void;
        static LinearColor_SetFromHSV(InOutColor: $Ref<UE.LinearColor>, H: number, S: number, V: number, A?: number /* = 1.000000 */) : void;
        static LinearColor_SetFromPow22(InOutColor: $Ref<UE.LinearColor>, InColor: UE.Color) : void;
        static LinearColor_SetFromSRGB(InOutColor: $Ref<UE.LinearColor>, InSRGB: UE.Color) : void;
        static LinearColor_SetRandomHue(InOutColor: $Ref<UE.LinearColor>) : void;
        static LinearColor_SetRGBA(InOutColor: $Ref<UE.LinearColor>, R: number, G: number, B: number, A?: number /* = 1.000000 */) : void;
        static LinearColor_SetTemperature(InOutColor: $Ref<UE.LinearColor>, InTemperature: number) : void;
        static LinearColor_ToNewOpacity(InColor: UE.LinearColor, InOpacity: number) : UE.LinearColor;
        static LinearColor_ToRGBE(InLinearColor: UE.LinearColor) : UE.Color;
        static LinearColor_Transparent() : UE.LinearColor;
        static LinearColor_White() : UE.LinearColor;
        static LinearColor_Yellow() : UE.LinearColor;
        static LinearColorLerp(A: UE.LinearColor, B: UE.LinearColor, Alpha: number) : UE.LinearColor;
        static LinearColorLerpUsingHSV(A: UE.LinearColor, B: UE.LinearColor, Alpha: number) : UE.LinearColor;
        static LinePlaneIntersection(LineStart: UE.Vector, LineEnd: UE.Vector, APlane: UE.Plane, T: $Ref<number>, Intersection: $Ref<UE.Vector>) : boolean;
        static LinePlaneIntersection_OriginNormal(LineStart: UE.Vector, LineEnd: UE.Vector, PlaneOrigin: UE.Vector, PlaneNormal: UE.Vector, T: $Ref<number>, Intersection: $Ref<UE.Vector>) : boolean;
        static Log(A: number, Base?: number /* = 1.000000 */) : number;
        static Loge(A: number) : number;
        static MakeBox(Min: UE.Vector, Max: UE.Vector) : UE.Box;
        static MakeBox2D(Min: UE.Vector2D, Max: UE.Vector2D) : UE.Box2D;
        static MakeColor(R: number, G: number, B: number, A?: number /* = 1.000000 */) : UE.LinearColor;
        static MakeDateTime(Year: number, Month: number, Day: number, Hour?: number /* = 0 */, Minute?: number /* = 0 */, Second?: number /* = 0 */, Millisecond?: number /* = 0 */) : UE.DateTime;
        static MakeFrameRate(Numerator: number, Denominator?: number /* = 1 */) : UE.FrameRate;
        static MakePlaneFromPointAndNormal(Point: UE.Vector, Normal: UE.Vector) : UE.Plane;
        static MakePulsatingValue(InCurrentTime: number, InPulsesPerSecond?: number /* = 1.000000 */, InPhase?: number /* = 0.000000 */) : number;
        static MakeQualifiedFrameTime(Frame: UE.FrameNumber, FrameRate: UE.FrameRate, SubFrame?: number /* = 0.000000 */) : UE.QualifiedFrameTime;
        static MakeRandomStream(InitialSeed: number) : UE.RandomStream;
        static MakeRelativeTransform(A: UE.Transform, RelativeTo: UE.Transform) : UE.Transform;
        static MakeRotationFromAxes(Forward: UE.Vector, Right: UE.Vector, Up: UE.Vector) : UE.Rotator;
        static MakeRotator(Roll: number, Pitch: number, Yaw: number) : UE.Rotator;
        static MakeRotFromX(X: UE.Vector) : UE.Rotator;
        static MakeRotFromXY(X: UE.Vector, Y: UE.Vector) : UE.Rotator;
        static MakeRotFromXZ(X: UE.Vector, Z: UE.Vector) : UE.Rotator;
        static MakeRotFromY(Y: UE.Vector) : UE.Rotator;
        static MakeRotFromYX(Y: UE.Vector, X: UE.Vector) : UE.Rotator;
        static MakeRotFromYZ(Y: UE.Vector, Z: UE.Vector) : UE.Rotator;
        static MakeRotFromZ(Z: UE.Vector) : UE.Rotator;
        static MakeRotFromZX(Z: UE.Vector, X: UE.Vector) : UE.Rotator;
        static MakeRotFromZY(Z: UE.Vector, Y: UE.Vector) : UE.Rotator;
        static MakeTimespan(Days: number, Hours: number, Minutes: number, Seconds: number, Milliseconds: number) : UE.Timespan;
        static MakeTimespan2(Days: number, Hours: number, Minutes: number, Seconds: number, FractionNano: number) : UE.Timespan;
        static MakeTransform(Location: UE.Vector, Rotation: UE.Rotator, Scale: UE.Vector) : UE.Transform;
        static MakeVector(X: number, Y: number, Z: number) : UE.Vector;
        static MakeVector2D(X: number, Y: number) : UE.Vector2D;
        static MakeVector4(X: number, Y: number, Z: number, W: number) : UE.Vector4;
        static MapRangeClamped(Value: number, InRangeA: number, InRangeB: number, OutRangeA: number, OutRangeB: number) : number;
        static MapRangeUnclamped(Value: number, InRangeA: number, InRangeB: number, OutRangeA: number, OutRangeB: number) : number;
        static Matrix_ApplyScale(M: UE.Matrix, Scale: number) : UE.Matrix;
        static Matrix_ConcatenateTranslation(M: UE.Matrix, Translation: UE.Vector) : UE.Matrix;
        static Matrix_ContainsNaN(M: UE.Matrix) : boolean;
        static Matrix_GetColumn(M: UE.Matrix, Column: UE.EMatrixColumns) : UE.Vector;
        static Matrix_GetDeterminant(M: UE.Matrix) : number;
        static Matrix_GetFrustumBottomPlane(M: UE.Matrix, OutPlane: $Ref<UE.Plane>) : boolean;
        static Matrix_GetFrustumFarPlane(M: UE.Matrix, OutPlane: $Ref<UE.Plane>) : boolean;
        static Matrix_GetFrustumLeftPlane(M: UE.Matrix, OutPlane: $Ref<UE.Plane>) : boolean;
        static Matrix_GetFrustumNearPlane(M: UE.Matrix, OutPlane: $Ref<UE.Plane>) : boolean;
        static Matrix_GetFrustumRightPlane(M: UE.Matrix, OutPlane: $Ref<UE.Plane>) : boolean;
        static Matrix_GetFrustumTopPlane(M: UE.Matrix, OutPlane: $Ref<UE.Plane>) : boolean;
        static Matrix_GetInverse(M: UE.Matrix) : UE.Matrix;
        static Matrix_GetMatrixWithoutScale(M: UE.Matrix, Tolerance?: number /* = 0.000000 */) : UE.Matrix;
        static Matrix_GetMaximumAxisScale(M: UE.Matrix) : number;
        static Matrix_GetOrigin(InMatrix: UE.Matrix) : UE.Vector;
        static Matrix_GetRotator(M: UE.Matrix) : UE.Rotator;
        static Matrix_GetRotDeterminant(M: UE.Matrix) : number;
        static Matrix_GetScaledAxes(M: UE.Matrix, X: $Ref<UE.Vector>, Y: $Ref<UE.Vector>, Z: $Ref<UE.Vector>) : void;
        static Matrix_GetScaledAxis(M: UE.Matrix, Axis: UE.EAxis) : UE.Vector;
        static Matrix_GetScaleVector(M: UE.Matrix, Tolerance?: number /* = 0.000000 */) : UE.Vector;
        static Matrix_GetTransposeAdjoint(M: UE.Matrix) : UE.Matrix;
        static Matrix_GetTransposed(M: UE.Matrix) : UE.Matrix;
        static Matrix_GetUnitAxes(M: UE.Matrix, X: $Ref<UE.Vector>, Y: $Ref<UE.Vector>, Z: $Ref<UE.Vector>) : void;
        static Matrix_GetUnitAxis(M: UE.Matrix, Axis: UE.EAxis) : UE.Vector;
        static Matrix_Identity() : UE.Matrix;
        static Matrix_InverseTransformPosition(M: UE.Matrix, V: UE.Vector) : UE.Vector;
        static Matrix_InverseTransformVector(M: UE.Matrix, V: UE.Vector) : UE.Vector;
        static Matrix_Mirror(M: UE.Matrix, MirrorAxis: UE.EAxis, FlipAxis: UE.EAxis) : UE.Matrix;
        static Matrix_RemoveScaling(M: $Ref<UE.Matrix>, Tolerance?: number /* = 0.000000 */) : void;
        static Matrix_RemoveTranslation(M: UE.Matrix) : UE.Matrix;
        static Matrix_ScaleTranslation(M: UE.Matrix, Scale3D: UE.Vector) : UE.Matrix;
        static Matrix_SetAxis(M: $Ref<UE.Matrix>, Axis: UE.EAxis, AxisVector: UE.Vector) : void;
        static Matrix_SetColumn(M: $Ref<UE.Matrix>, Column: UE.EMatrixColumns, Value: UE.Vector) : void;
        static Matrix_SetOrigin(M: $Ref<UE.Matrix>, NewOrigin: UE.Vector) : void;
        static Matrix_ToQuat(M: UE.Matrix) : UE.Quat;
        static Matrix_TransformPosition(M: UE.Matrix, V: UE.Vector) : UE.Vector4;
        static Matrix_TransformVector(M: UE.Matrix, V: UE.Vector) : UE.Vector4;
        static Matrix_TransformVector4(M: UE.Matrix, V: UE.Vector4) : UE.Vector4;
        static Max(A: number, B: number) : number;
        static MaxInt64(A: bigint, B: bigint) : bigint;
        static MaxOfByteArray(ByteArray: TArray<number>, IndexOfMaxValue: $Ref<number>, MaxValue: $Ref<number>) : void;
        static MaxOfFloatArray(FloatArray: TArray<number>, IndexOfMaxValue: $Ref<number>, MaxValue: $Ref<number>) : void;
        static MaxOfIntArray(IntArray: TArray<number>, IndexOfMaxValue: $Ref<number>, MaxValue: $Ref<number>) : void;
        static Min(A: number, B: number) : number;
        static MinimumAreaRectangle(WorldContextObject: $Nullable<UE.Object>, InVerts: TArray<UE.Vector>, SampleSurfaceNormal: UE.Vector, OutRectCenter: $Ref<UE.Vector>, OutRectRotation: $Ref<UE.Rotator>, OutSideLengthX: $Ref<number>, OutSideLengthY: $Ref<number>, bDebugDraw?: boolean /* = false */) : void;
        static MinInt64(A: bigint, B: bigint) : bigint;
        static MinOfByteArray(ByteArray: TArray<number>, IndexOfMinValue: $Ref<number>, MinValue: $Ref<number>) : void;
        static MinOfFloatArray(FloatArray: TArray<number>, IndexOfMinValue: $Ref<number>, MinValue: $Ref<number>) : void;
        static MinOfIntArray(IntArray: TArray<number>, IndexOfMinValue: $Ref<number>, MinValue: $Ref<number>) : void;
        static MirrorVectorByNormal(InVect: UE.Vector, InNormal: UE.Vector) : UE.Vector;
        static Multiply_ByteByte(A: number, B: number) : number;
        static Multiply_FloatFloat(A: number, B: number) : number;
        static Multiply_Int64Int64(A: bigint, B: bigint) : bigint;
        static Multiply_IntFloat(A: number, B: number) : number;
        static Multiply_IntInt(A: number, B: number) : number;
        static Multiply_LinearColorFloat(A: UE.LinearColor, B: number) : UE.LinearColor;
        static Multiply_LinearColorLinearColor(A: UE.LinearColor, B: UE.LinearColor) : UE.LinearColor;
        static Multiply_MatrixFloat(A: UE.Matrix, B: number) : UE.Matrix;
        static Multiply_MatrixMatrix(A: UE.Matrix, B: UE.Matrix) : UE.Matrix;
        static Multiply_QuatQuat(A: UE.Quat, B: UE.Quat) : UE.Quat;
        static Multiply_RotatorFloat(A: UE.Rotator, B: number) : UE.Rotator;
        static Multiply_RotatorInt(A: UE.Rotator, B: number) : UE.Rotator;
        static Multiply_TimespanFloat(A: UE.Timespan, Scalar: number) : UE.Timespan;
        static Multiply_Vector2DFloat(A: UE.Vector2D, B: number) : UE.Vector2D;
        static Multiply_Vector2DVector2D(A: UE.Vector2D, B: UE.Vector2D) : UE.Vector2D;
        static Multiply_Vector4Vector4(A: UE.Vector4, B: UE.Vector4) : UE.Vector4;
        static Multiply_VectorFloat(A: UE.Vector, B: number) : UE.Vector;
        static Multiply_VectorInt(A: UE.Vector, B: number) : UE.Vector;
        static Multiply_VectorVector(A: UE.Vector, B: UE.Vector) : UE.Vector;
        static MultiplyByPi(Value: number) : number;
        static MultiplyMultiply_FloatFloat(Base: number, Exp: number) : number;
        static NearlyEqual_FloatFloat(A: number, B: number, ErrorTolerance?: number /* = 0.000001 */) : boolean;
        static NearlyEqual_TransformTransform(A: UE.Transform, B: UE.Transform, LocationTolerance?: number /* = 0.000100 */, RotationTolerance?: number /* = 0.000100 */, Scale3DTolerance?: number /* = 0.000100 */) : boolean;
        static Negated2D(A: UE.Vector2D) : UE.Vector2D;
        static NegateRotator(A: UE.Rotator) : UE.Rotator;
        static NegateVector(A: UE.Vector) : UE.Vector;
        static Normal(A: UE.Vector, Tolerance?: number /* = 0.000100 */) : UE.Vector;
        static Normal2D(A: UE.Vector2D) : UE.Vector2D;
        static Normalize2D(A: $Ref<UE.Vector2D>, Tolerance?: number /* = 0.000000 */) : void;
        static NormalizeAxis(Angle: number) : number;
        static NormalizedDeltaRotator(A: UE.Rotator, B: UE.Rotator) : UE.Rotator;
        static NormalizeToRange(Value: number, RangeMin: number, RangeMax: number) : number;
        static NormalSafe2D(A: UE.Vector2D, Tolerance?: number /* = 0.000000 */) : UE.Vector2D;
        static Not_Int(A: number) : number;
        static Not_Int64(A: bigint) : bigint;
        static Not_PreBool(A: boolean) : boolean;
        static NotEqual_BoolBool(A: boolean, B: boolean) : boolean;
        static NotEqual_ByteByte(A: number, B: number) : boolean;
        static NotEqual_ClassClass(A: $Nullable<UE.Class>, B: $Nullable<UE.Class>) : boolean;
        static NotEqual_DateTimeDateTime(A: UE.DateTime, B: UE.DateTime) : boolean;
        static NotEqual_FloatFloat(A: number, B: number) : boolean;
        static NotEqual_Int64Int64(A: bigint, B: bigint) : boolean;
        static NotEqual_IntInt(A: number, B: number) : boolean;
        static NotEqual_LinearColorLinearColor(A: UE.LinearColor, B: UE.LinearColor) : boolean;
        static NotEqual_MatrixMatrix(A: UE.Matrix, B: UE.Matrix, Tolerance?: number /* = 0.000100 */) : boolean;
        static NotEqual_NameName(A: string, B: string) : boolean;
        static NotEqual_ObjectObject(A: $Nullable<UE.Object>, B: $Nullable<UE.Object>) : boolean;
        static NotEqual_QuatQuat(A: UE.Quat, B: UE.Quat, ErrorTolerance?: number /* = 0.000100 */) : boolean;
        static NotEqual_RotatorRotator(A: UE.Rotator, B: UE.Rotator, ErrorTolerance?: number /* = 0.000100 */) : boolean;
        static NotEqual_TimespanTimespan(A: UE.Timespan, B: UE.Timespan) : boolean;
        static NotEqual_Vector2DVector2D(A: UE.Vector2D, B: UE.Vector2D, ErrorTolerance?: number /* = 0.000100 */) : boolean;
        static NotEqual_Vector4Vector4(A: UE.Vector4, B: UE.Vector4, ErrorTolerance?: number /* = 0.000100 */) : boolean;
        static NotEqual_VectorVector(A: UE.Vector, B: UE.Vector, ErrorTolerance?: number /* = 0.000100 */) : boolean;
        static NotEqualExactly_Vector2DVector2D(A: UE.Vector2D, B: UE.Vector2D) : boolean;
        static NotEqualExactly_Vector4Vector4(A: UE.Vector4, B: UE.Vector4) : boolean;
        static NotEqualExactly_VectorVector(A: UE.Vector, B: UE.Vector) : boolean;
        static Now() : UE.DateTime;
        static Or_Int64Int64(A: bigint, B: bigint) : bigint;
        static Or_IntInt(A: number, B: number) : number;
        static Percent_ByteByte(A: number, B?: number /* = 1 */) : number;
        static Percent_FloatFloat(A: number, B?: number /* = 1.000000 */) : number;
        static Percent_IntInt(A: number, B?: number /* = 1 */) : number;
        static PerlinNoise1D(Value: number) : number;
        static PointsAreCoplanar(Points: TArray<UE.Vector>, Tolerance?: number /* = 0.100000 */) : boolean;
        static ProjectPointOnToPlane(Point: UE.Vector, PlaneBase: UE.Vector, PlaneNormal: UE.Vector) : UE.Vector;
        static ProjectVectorOnToPlane(V: UE.Vector, PlaneNormal: UE.Vector) : UE.Vector;
        static ProjectVectorOnToVector(V: UE.Vector, Target: UE.Vector) : UE.Vector;
        static Quat_AngularDistance(A: UE.Quat, B: UE.Quat) : number;
        static Quat_EnforceShortestArcWith(A: $Ref<UE.Quat>, B: UE.Quat) : void;
        static Quat_Euler(Q: UE.Quat) : UE.Vector;
        static Quat_Exp(Q: UE.Quat) : UE.Quat;
        static Quat_GetAngle(Q: UE.Quat) : number;
        static Quat_GetAxisX(Q: UE.Quat) : UE.Vector;
        static Quat_GetAxisY(Q: UE.Quat) : UE.Vector;
        static Quat_GetAxisZ(Q: UE.Quat) : UE.Vector;
        static Quat_GetRotationAxis(Q: UE.Quat) : UE.Vector;
        static Quat_Identity() : UE.Quat;
        static Quat_Inversed(Q: UE.Quat) : UE.Quat;
        static Quat_IsFinite(Q: UE.Quat) : boolean;
        static Quat_IsIdentity(Q: UE.Quat, Tolerance?: number /* = 0.000100 */) : boolean;
        static Quat_IsNonFinite(Q: UE.Quat) : boolean;
        static Quat_IsNormalized(Q: UE.Quat) : boolean;
        static Quat_Log(Q: UE.Quat) : UE.Quat;
        static Quat_MakeFromEuler(Euler: UE.Vector) : UE.Quat;
        static Quat_Normalize(Q: $Ref<UE.Quat>, Tolerance?: number /* = 0.000100 */) : void;
        static Quat_Normalized(Q: UE.Quat, Tolerance?: number /* = 0.000100 */) : UE.Quat;
        static Quat_RotateVector(Q: UE.Quat, V: UE.Vector) : UE.Vector;
        static Quat_Rotator(Q: UE.Quat) : UE.Rotator;
        static Quat_SetComponents(Q: $Ref<UE.Quat>, X: number, Y: number, Z: number, W: number) : void;
        static Quat_SetFromEuler(Q: $Ref<UE.Quat>, Euler: UE.Vector) : void;
        static Quat_Size(Q: UE.Quat) : number;
        static Quat_SizeSquared(Q: UE.Quat) : number;
        static Quat_UnrotateVector(Q: UE.Quat, V: UE.Vector) : UE.Vector;
        static Quat_VectorForward(Q: UE.Quat) : UE.Vector;
        static Quat_VectorRight(Q: UE.Quat) : UE.Vector;
        static Quat_VectorUp(Q: UE.Quat) : UE.Vector;
        static RadiansToDegrees(A: number) : number;
        static RandomBool() : boolean;
        static RandomBoolFromStream(Stream: UE.RandomStream) : boolean;
        static RandomBoolWithWeight(Weight: number) : boolean;
        static RandomBoolWithWeightFromStream(Weight: number, RandomStream: UE.RandomStream) : boolean;
        static RandomFloat() : number;
        static RandomFloatFromStream(Stream: UE.RandomStream) : number;
        static RandomFloatInRange(Min: number, Max: number) : number;
        static RandomFloatInRangeFromStream(Min: number, Max: number, Stream: UE.RandomStream) : number;
        static RandomInteger(Max: number) : number;
        static RandomInteger64(Max: bigint) : bigint;
        static RandomInteger64InRange(Min: bigint, Max: bigint) : bigint;
        static RandomIntegerFromStream(Max: number, Stream: UE.RandomStream) : number;
        static RandomIntegerInRange(Min: number, Max: number) : number;
        static RandomIntegerInRangeFromStream(Min: number, Max: number, Stream: UE.RandomStream) : number;
        static RandomPointInBoundingBox(Origin: UE.Vector, BoxExtent: UE.Vector) : UE.Vector;
        static RandomRotator(bRoll?: boolean /* = false */) : UE.Rotator;
        static RandomRotatorFromStream(bRoll: boolean, Stream: UE.RandomStream) : UE.Rotator;
        static RandomUnitVector() : UE.Vector;
        static RandomUnitVectorFromStream(Stream: UE.RandomStream) : UE.Vector;
        static RandomUnitVectorInConeInDegrees(ConeDir: UE.Vector, ConeHalfAngleInDegrees: number) : UE.Vector;
        static RandomUnitVectorInConeInDegreesFromStream(ConeDir: UE.Vector, ConeHalfAngleInDegrees: number, Stream: UE.RandomStream) : UE.Vector;
        static RandomUnitVectorInConeInRadians(ConeDir: UE.Vector, ConeHalfAngleInRadians: number) : UE.Vector;
        static RandomUnitVectorInConeInRadiansFromStream(ConeDir: UE.Vector, ConeHalfAngleInRadians: number, Stream: UE.RandomStream) : UE.Vector;
        static RandomUnitVectorInEllipticalConeInDegrees(ConeDir: UE.Vector, MaxYawInDegrees: number, MaxPitchInDegrees: number) : UE.Vector;
        static RandomUnitVectorInEllipticalConeInDegreesFromStream(ConeDir: UE.Vector, MaxYawInDegrees: number, MaxPitchInDegrees: number, Stream: UE.RandomStream) : UE.Vector;
        static RandomUnitVectorInEllipticalConeInRadians(ConeDir: UE.Vector, MaxYawInRadians: number, MaxPitchInRadians: number) : UE.Vector;
        static RandomUnitVectorInEllipticalConeInRadiansFromStream(ConeDir: UE.Vector, MaxYawInRadians: number, MaxPitchInRadians: number, Stream: UE.RandomStream) : UE.Vector;
        static REase(A: UE.Rotator, B: UE.Rotator, Alpha: number, bShortestPath: boolean, EasingFunc: UE.EEasingFunc, BlendExp?: number /* = 2.000000 */, Steps?: number /* = 2 */) : UE.Rotator;
        static ResetFloatSpringState(SpringState: $Ref<UE.FloatSpringState>) : void;
        static ResetRandomStream(Stream: UE.RandomStream) : void;
        static ResetVectorSpringState(SpringState: $Ref<UE.VectorSpringState>) : void;
        static RGBLinearToHSV(RGB: UE.LinearColor) : UE.LinearColor;
        static RGBToHSV(InColor: UE.LinearColor, H: $Ref<number>, S: $Ref<number>, V: $Ref<number>, A: $Ref<number>) : void;
        static RGBToHSV_Vector(RGB: UE.LinearColor, HSV: $Ref<UE.LinearColor>) : void;
        static RInterpTo(Current: UE.Rotator, Target: UE.Rotator, DeltaTime: number, InterpSpeed: number) : UE.Rotator;
        static RInterpTo_Constant(Current: UE.Rotator, Target: UE.Rotator, DeltaTime: number, InterpSpeed: number) : UE.Rotator;
        static RLerp(A: UE.Rotator, B: UE.Rotator, Alpha: number, bShortestPath: boolean) : UE.Rotator;
        static RotateAngleAxis(InVect: UE.Vector, AngleDeg: number, Axis: UE.Vector) : UE.Vector;
        static RotatorFromAxisAndAngle(Axis: UE.Vector, Angle: number) : UE.Rotator;
        static Round(A: number) : number;
        static Round64(A: number) : bigint;
        static SafeDivide(A: number, B: number) : number;
        static SeedRandomStream(Stream: $Ref<UE.RandomStream>) : void;
        static SelectClass(A: $Nullable<UE.Class>, B: $Nullable<UE.Class>, bSelectA: boolean) : UE.Class;
        static SelectColor(A: UE.LinearColor, B: UE.LinearColor, bPickA: boolean) : UE.LinearColor;
        static SelectFloat(A: number, B: number, bPickA: boolean) : number;
        static SelectInt(A: number, B: number, bPickA: boolean) : number;
        static SelectObject(A: $Nullable<UE.Object>, B: $Nullable<UE.Object>, bSelectA: boolean) : UE.Object;
        static SelectRotator(A: UE.Rotator, B: UE.Rotator, bPickA: boolean) : UE.Rotator;
        static SelectString(A: string, B: string, bPickA: boolean) : string;
        static SelectTransform(A: UE.Transform, B: UE.Transform, bPickA: boolean) : UE.Transform;
        static SelectVector(A: UE.Vector, B: UE.Vector, bPickA: boolean) : UE.Vector;
        static Set2D(A: $Ref<UE.Vector2D>, X: number, Y: number) : void;
        static SetRandomStreamSeed(Stream: $Ref<UE.RandomStream>, NewSeed: number) : void;
        static SignOfFloat(A: number) : number;
        static SignOfInteger(A: number) : number;
        static SignOfInteger64(A: bigint) : bigint;
        static Sin(A: number) : number;
        static Spherical2DToUnitCartesian(A: UE.Vector2D) : UE.Vector;
        static Sqrt(A: number) : number;
        static Square(A: number) : number;
        static Subtract_ByteByte(A: number, B?: number /* = 1 */) : number;
        static Subtract_DateTimeDateTime(A: UE.DateTime, B: UE.DateTime) : UE.Timespan;
        static Subtract_DateTimeTimespan(A: UE.DateTime, B: UE.Timespan) : UE.DateTime;
        static Subtract_FloatFloat(A: number, B?: number /* = 1.000000 */) : number;
        static Subtract_Int64Int64(A: bigint, B?: bigint /* = 1 */) : bigint;
        static Subtract_IntInt(A: number, B?: number /* = 1 */) : number;
        static Subtract_LinearColorLinearColor(A: UE.LinearColor, B: UE.LinearColor) : UE.LinearColor;
        static Subtract_QuatQuat(A: UE.Quat, B: UE.Quat) : UE.Quat;
        static Subtract_TimespanTimespan(A: UE.Timespan, B: UE.Timespan) : UE.Timespan;
        static Subtract_Vector2DFloat(A: UE.Vector2D, B: number) : UE.Vector2D;
        static Subtract_Vector2DVector2D(A: UE.Vector2D, B: UE.Vector2D) : UE.Vector2D;
        static Subtract_Vector4Vector4(A: UE.Vector4, B: UE.Vector4) : UE.Vector4;
        static Subtract_VectorFloat(A: UE.Vector, B: number) : UE.Vector;
        static Subtract_VectorInt(A: UE.Vector, B: number) : UE.Vector;
        static Subtract_VectorVector(A: UE.Vector, B: UE.Vector) : UE.Vector;
        static Tan(A: number) : number;
        static TEase(A: UE.Transform, B: UE.Transform, Alpha: number, EasingFunc: UE.EEasingFunc, BlendExp?: number /* = 2.000000 */, Steps?: number /* = 2 */) : UE.Transform;
        static TimespanFromString(TimespanString: string, Result: $Ref<UE.Timespan>) : boolean;
        static TimespanMaxValue() : UE.Timespan;
        static TimespanMinValue() : UE.Timespan;
        static TimespanRatio(A: UE.Timespan, B: UE.Timespan) : number;
        static TimespanZeroValue() : UE.Timespan;
        static TInterpTo(Current: UE.Transform, Target: UE.Transform, DeltaTime: number, InterpSpeed: number) : UE.Transform;
        static TLerp(A: UE.Transform, B: UE.Transform, Alpha: number, InterpMode?: UE.ELerpInterpolationMode /* = QuatInterp */) : UE.Transform;
        static Today() : UE.DateTime;
        static ToDirectionAndLength2D(A: UE.Vector2D, OutDir: $Ref<UE.Vector2D>, OutLength: $Ref<number>) : void;
        static ToRounded2D(A: UE.Vector2D) : UE.Vector2D;
        static ToSign2D(A: UE.Vector2D) : UE.Vector2D;
        static Transform_Determinant(Transform: UE.Transform) : number;
        static TransformDirection(T: UE.Transform, Direction: UE.Vector) : UE.Vector;
        static TransformLocation(T: UE.Transform, Location: UE.Vector) : UE.Vector;
        static TransformRotation(T: UE.Transform, Rotation: UE.Rotator) : UE.Rotator;
        static UtcNow() : UE.DateTime;
        static VEase(A: UE.Vector, B: UE.Vector, Alpha: number, EasingFunc: UE.EEasingFunc, BlendExp?: number /* = 2.000000 */, Steps?: number /* = 2 */) : UE.Vector;
        static Vector2D_One() : UE.Vector2D;
        static Vector2D_Unit45Deg() : UE.Vector2D;
        static Vector2D_Zero() : UE.Vector2D;
        static Vector2DInterpTo(Current: UE.Vector2D, Target: UE.Vector2D, DeltaTime: number, InterpSpeed: number) : UE.Vector2D;
        static Vector2DInterpTo_Constant(Current: UE.Vector2D, Target: UE.Vector2D, DeltaTime: number, InterpSpeed: number) : UE.Vector2D;
        static Vector4_Assign(A: $Ref<UE.Vector4>, InVector: UE.Vector4) : void;
        static Vector4_CrossProduct3(A: UE.Vector4, B: UE.Vector4) : UE.Vector4;
        static Vector4_DotProduct(A: UE.Vector4, B: UE.Vector4) : number;
        static Vector4_DotProduct3(A: UE.Vector4, B: UE.Vector4) : number;
        static Vector4_IsNAN(A: UE.Vector4) : boolean;
        static Vector4_IsNearlyZero3(A: UE.Vector4, Tolerance?: number /* = 0.000100 */) : boolean;
        static Vector4_IsNormal3(A: UE.Vector4) : boolean;
        static Vector4_IsUnit3(A: UE.Vector4, SquaredLenthTolerance?: number /* = 0.000100 */) : boolean;
        static Vector4_IsZero(A: UE.Vector4) : boolean;
        static Vector4_MirrorByVector3(Direction: UE.Vector4, SurfaceNormal: UE.Vector4) : UE.Vector4;
        static Vector4_Negated(A: UE.Vector4) : UE.Vector4;
        static Vector4_Normal3(A: UE.Vector4, Tolerance?: number /* = 0.000100 */) : UE.Vector4;
        static Vector4_Normalize3(A: $Ref<UE.Vector4>, Tolerance?: number /* = 0.000000 */) : void;
        static Vector4_NormalUnsafe3(A: UE.Vector4) : UE.Vector4;
        static Vector4_Set(A: $Ref<UE.Vector4>, X: number, Y: number, Z: number, W: number) : void;
        static Vector4_Size(A: UE.Vector4) : number;
        static Vector4_Size3(A: UE.Vector4) : number;
        static Vector4_SizeSquared(A: UE.Vector4) : number;
        static Vector4_SizeSquared3(A: UE.Vector4) : number;
        static Vector4_Zero() : UE.Vector4;
        static Vector_AddBounded(A: $Ref<UE.Vector>, InAddVect: UE.Vector, InRadius: number) : void;
        static Vector_Assign(A: $Ref<UE.Vector>, InVector: UE.Vector) : void;
        static Vector_Backward() : UE.Vector;
        static Vector_BoundedToBox(InVect: UE.Vector, InBoxMin: UE.Vector, InBoxMax: UE.Vector) : UE.Vector;
        static Vector_BoundedToCube(InVect: UE.Vector, InRadius: number) : UE.Vector;
        static Vector_ClampSize2D(A: UE.Vector, Min: number, Max: number) : UE.Vector;
        static Vector_ClampSizeMax(A: UE.Vector, Max: number) : UE.Vector;
        static Vector_ClampSizeMax2D(A: UE.Vector, Max: number) : UE.Vector;
        static Vector_ComponentMax(A: UE.Vector, B: UE.Vector) : UE.Vector;
        static Vector_ComponentMin(A: UE.Vector, B: UE.Vector) : UE.Vector;
        static Vector_CosineAngle2D(A: UE.Vector, B: UE.Vector) : number;
        static Vector_Distance(V1: UE.Vector, V2: UE.Vector) : number;
        static Vector_Distance2D(V1: UE.Vector, V2: UE.Vector) : number;
        static Vector_Distance2DSquared(V1: UE.Vector, V2: UE.Vector) : number;
        static Vector_DistanceSquared(V1: UE.Vector, V2: UE.Vector) : number;
        static Vector_Down() : UE.Vector;
        static Vector_Forward() : UE.Vector;
        static Vector_GetAbs(A: UE.Vector) : UE.Vector;
        static Vector_GetAbsMax(A: UE.Vector) : number;
        static Vector_GetAbsMin(A: UE.Vector) : number;
        static Vector_GetProjection(A: UE.Vector) : UE.Vector;
        static Vector_GetSignVector(A: UE.Vector) : UE.Vector;
        static Vector_HeadingAngle(A: UE.Vector) : number;
        static Vector_IsNAN(A: UE.Vector) : boolean;
        static Vector_IsNearlyZero(A: UE.Vector, Tolerance?: number /* = 0.000100 */) : boolean;
        static Vector_IsNormal(A: UE.Vector) : boolean;
        static Vector_IsUniform(A: UE.Vector, Tolerance?: number /* = 0.000100 */) : boolean;
        static Vector_IsUnit(A: UE.Vector, SquaredLenthTolerance?: number /* = 0.000100 */) : boolean;
        static Vector_IsZero(A: UE.Vector) : boolean;
        static Vector_Left() : UE.Vector;
        static Vector_MirrorByPlane(A: UE.Vector, InPlane: UE.Plane) : UE.Vector;
        static Vector_Normal2D(A: UE.Vector, Tolerance?: number /* = 0.000100 */) : UE.Vector;
        static Vector_Normalize(A: $Ref<UE.Vector>, Tolerance?: number /* = 0.000000 */) : void;
        static Vector_NormalUnsafe(A: UE.Vector) : UE.Vector;
        static Vector_One() : UE.Vector;
        static Vector_ProjectOnToNormal(V: UE.Vector, InNormal: UE.Vector) : UE.Vector;
        static Vector_Reciprocal(A: UE.Vector) : UE.Vector;
        static Vector_Right() : UE.Vector;
        static Vector_Set(A: $Ref<UE.Vector>, X: number, Y: number, Z: number) : void;
        static Vector_SnappedToGrid(InVect: UE.Vector, InGridSize: number) : UE.Vector;
        static Vector_ToDegrees(A: UE.Vector) : UE.Vector;
        static Vector_ToRadians(A: UE.Vector) : UE.Vector;
        static Vector_UnitCartesianToSpherical(A: UE.Vector) : UE.Vector2D;
        static Vector_UnwindEuler(A: $Ref<UE.Vector>) : void;
        static Vector_Up() : UE.Vector;
        static Vector_Zero() : UE.Vector;
        static VectorSpringInterp(Current: UE.Vector, Target: UE.Vector, SpringState: $Ref<UE.VectorSpringState>, Stiffness: number, CriticalDampingFactor: number, DeltaTime: number, Mass?: number /* = 1.000000 */) : UE.Vector;
        static VInterpTo(Current: UE.Vector, Target: UE.Vector, DeltaTime: number, InterpSpeed: number) : UE.Vector;
        static VInterpTo_Constant(Current: UE.Vector, Target: UE.Vector, DeltaTime: number, InterpSpeed: number) : UE.Vector;
        static VLerp(A: UE.Vector, B: UE.Vector, Alpha: number) : UE.Vector;
        static VSize(A: UE.Vector) : number;
        static VSize2D(A: UE.Vector2D) : number;
        static VSize2DSquared(A: UE.Vector2D) : number;
        static VSizeSquared(A: UE.Vector) : number;
        static VSizeXY(A: UE.Vector) : number;
        static VSizeXYSquared(A: UE.Vector) : number;
        static WeightedMovingAverage_Float(CurrentSample: number, PreviousSample: number, Weight: number) : number;
        static WeightedMovingAverage_FRotator(CurrentSample: UE.Rotator, PreviousSample: UE.Rotator, Weight: number) : UE.Rotator;
        static WeightedMovingAverage_FVector(CurrentSample: UE.Vector, PreviousSample: UE.Vector, Weight: number) : UE.Vector;
        static Xor_Int64Int64(A: bigint, B: bigint) : bigint;
        static Xor_IntInt(A: number, B: number) : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetMathLibrary;
        static Load(InName: string): KismetMathLibrary;
    }
    
    class KismetNodeHelperLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static BitIsMarked(Data: number, Index: number) : boolean;
        static ClearAllBits(Data: $Ref<number>) : void;
        static ClearBit(Data: $Ref<number>, Index: number) : void;
        static GetEnumeratorName(Enum: $Nullable<UE.Enum>, EnumeratorValue: number) : string;
        static GetEnumeratorUserFriendlyName(Enum: $Nullable<UE.Enum>, EnumeratorValue: number) : string;
        static GetEnumeratorValueFromIndex(Enum: $Nullable<UE.Enum>, EnumeratorIndex: number) : number;
        static GetFirstUnmarkedBit(Data: number, StartIdx: number, NumBits: number) : number;
        static GetRandomUnmarkedBit(Data: number, StartIdx: number, NumBits: number) : number;
        static GetUnmarkedBit(Data: number, StartIdx: number, NumBits: number, bRandom: boolean) : number;
        static GetValidValue(Enum: $Nullable<UE.Enum>, EnumeratorValue: number) : number;
        static HasMarkedBit(Data: number, NumBits: number) : boolean;
        static HasUnmarkedBit(Data: number, NumBits: number) : boolean;
        static MarkBit(Data: $Ref<number>, Index: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetNodeHelperLibrary;
        static Load(InName: string): KismetNodeHelperLibrary;
    }
    
    class ProcMeshTangent {
        constructor();
        constructor(TangentX: UE.Vector, bFlipTangentY: boolean);
        TangentX: UE.Vector;
        bFlipTangentY: boolean;
        static StaticClass(): Class;
    }
    
    class ProcMeshVertex {
        constructor();
        constructor(Position: UE.Vector, Normal: UE.Vector, Tangent: UE.ProcMeshTangent, Color: UE.Color, UV0: UE.Vector2D, UV1: UE.Vector2D, UV2: UE.Vector2D, UV3: UE.Vector2D);
        Position: UE.Vector;
        Normal: UE.Vector;
        Tangent: UE.ProcMeshTangent;
        Color: UE.Color;
        UV0: UE.Vector2D;
        UV1: UE.Vector2D;
        UV2: UE.Vector2D;
        UV3: UE.Vector2D;
        static StaticClass(): Class;
    }
    
    class ProcMeshSection {
        constructor();
        constructor(ProcVertexBuffer: TArray<UE.ProcMeshVertex>, ProcIndexBuffer: TArray<number>, SectionLocalBox: UE.Box, bEnableCollision: boolean, bSectionVisible: boolean);
        ProcVertexBuffer: TArray<UE.ProcMeshVertex>;
        ProcIndexBuffer: TArray<number>;
        SectionLocalBox: UE.Box;
        bEnableCollision: boolean;
        bSectionVisible: boolean;
        static StaticClass(): Class;
    }
    
    class ProceduralMeshComponent extends UE.MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseComplexAsSimpleCollision: boolean;
        bUseAsyncCooking: boolean;
        ProcMeshBodySetup: UE.BodySetup;
        ProcMeshSections: TArray<UE.ProcMeshSection>;
        CollisionConvexElems: TArray<UE.KConvexElem>;
        LocalBounds: UE.BoxSphereBounds;
        AsyncBodySetupQueue: TArray<UE.BodySetup>;
        AddCollisionConvexMesh(ConvexVerts: TArray<UE.Vector>) : void;
        ClearAllMeshSections() : void;
        ClearCollisionConvexMeshes() : void;
        ClearMeshSection(SectionIndex: number) : void;
        CreateMeshSection(SectionIndex: number, Vertices: TArray<UE.Vector>, Triangles: TArray<number>, Normals: TArray<UE.Vector>, UV0: TArray<UE.Vector2D>, VertexColors: TArray<UE.Color>, Tangents: TArray<UE.ProcMeshTangent>, bCreateCollision: boolean) : void;
        CreateMeshSection_LinearColor(SectionIndex: number, Vertices: TArray<UE.Vector>, Triangles: TArray<number>, Normals: TArray<UE.Vector>, UV0: TArray<UE.Vector2D>, UV1: TArray<UE.Vector2D>, UV2: TArray<UE.Vector2D>, UV3: TArray<UE.Vector2D>, VertexColors: TArray<UE.LinearColor>, Tangents: TArray<UE.ProcMeshTangent>, bCreateCollision: boolean) : void;
        GetNumSections() : number;
        IsMeshSectionVisible(SectionIndex: number) : boolean;
        SetMeshSectionVisible(SectionIndex: number, bNewVisibility: boolean) : void;
        UpdateMeshSection(SectionIndex: number, Vertices: TArray<UE.Vector>, Normals: TArray<UE.Vector>, UV0: TArray<UE.Vector2D>, VertexColors: TArray<UE.Color>, Tangents: TArray<UE.ProcMeshTangent>) : void;
        UpdateMeshSection_LinearColor(SectionIndex: number, Vertices: TArray<UE.Vector>, Normals: TArray<UE.Vector>, UV0: TArray<UE.Vector2D>, UV1: TArray<UE.Vector2D>, UV2: TArray<UE.Vector2D>, UV3: TArray<UE.Vector2D>, VertexColors: TArray<UE.LinearColor>, Tangents: TArray<UE.ProcMeshTangent>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProceduralMeshComponent;
        static Load(InName: string): ProceduralMeshComponent;
    }
    
    enum EProcMeshSliceCapOption { NoCap, CreateNewSectionForCap, UseLastSectionForCap, EProcMeshSliceCapOption_MAX}
    class KismetProceduralMeshLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CalculateTangentsForMesh(Vertices: TArray<UE.Vector>, Triangles: TArray<number>, UVs: TArray<UE.Vector2D>, Normals: $Ref<TArray<UE.Vector>>, Tangents: $Ref<TArray<UE.ProcMeshTangent>>) : void;
        static ConvertQuadToTriangles(Triangles: $Ref<TArray<number>>, Vert0: number, Vert1: number, Vert2: number, Vert3: number) : void;
        static CopyProceduralMeshFromStaticMeshComponent(StaticMeshComponent: $Nullable<UE.StaticMeshComponent>, LODIndex: number, ProcMeshComponent: $Nullable<UE.ProceduralMeshComponent>, bCreateCollision: boolean) : void;
        static CreateGridMeshSplit(NumX: number, NumY: number, Triangles: $Ref<TArray<number>>, Vertices: $Ref<TArray<UE.Vector>>, UVs: $Ref<TArray<UE.Vector2D>>, UV1s: $Ref<TArray<UE.Vector2D>>, GridSpacing?: number /* = 16.000000 */) : void;
        static CreateGridMeshTriangles(NumX: number, NumY: number, bWinding: boolean, Triangles: $Ref<TArray<number>>) : void;
        static CreateGridMeshWelded(NumX: number, NumY: number, Triangles: $Ref<TArray<number>>, Vertices: $Ref<TArray<UE.Vector>>, UVs: $Ref<TArray<UE.Vector2D>>, GridSpacing?: number /* = 16.000000 */) : void;
        static GenerateBoxMesh(BoxRadius: UE.Vector, Vertices: $Ref<TArray<UE.Vector>>, Triangles: $Ref<TArray<number>>, Normals: $Ref<TArray<UE.Vector>>, UVs: $Ref<TArray<UE.Vector2D>>, Tangents: $Ref<TArray<UE.ProcMeshTangent>>) : void;
        static GetSectionFromProceduralMesh(InProcMesh: $Nullable<UE.ProceduralMeshComponent>, SectionIndex: number, Vertices: $Ref<TArray<UE.Vector>>, Triangles: $Ref<TArray<number>>, Normals: $Ref<TArray<UE.Vector>>, UVs: $Ref<TArray<UE.Vector2D>>, Tangents: $Ref<TArray<UE.ProcMeshTangent>>) : void;
        static GetSectionFromStaticMesh(InMesh: $Nullable<UE.StaticMesh>, LODIndex: number, SectionIndex: number, Vertices: $Ref<TArray<UE.Vector>>, Triangles: $Ref<TArray<number>>, Normals: $Ref<TArray<UE.Vector>>, UVs: $Ref<TArray<UE.Vector2D>>, Tangents: $Ref<TArray<UE.ProcMeshTangent>>) : void;
        static SliceProceduralMesh(InProcMesh: $Nullable<UE.ProceduralMeshComponent>, PlanePosition: UE.Vector, PlaneNormal: UE.Vector, bCreateOtherHalf: boolean, OutOtherHalfProcMesh: $Ref<UE.ProceduralMeshComponent>, CapOption: UE.EProcMeshSliceCapOption, CapMaterial: $Nullable<UE.MaterialInterface>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetProceduralMeshLibrary;
        static Load(InName: string): KismetProceduralMeshLibrary;
    }
    
    class DrawToRenderTargetContext {
        constructor();
        constructor(RenderTarget: UE.TextureRenderTarget2D);
        RenderTarget: UE.TextureRenderTarget2D;
        static StaticClass(): Class;
    }
    
    class KismetRenderingLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static BeginDrawCanvasToRenderTarget(WorldContextObject: $Nullable<UE.Object>, TextureRenderTarget: $Nullable<UE.TextureRenderTarget2D>, Canvas: $Ref<UE.Canvas>, Size: $Ref<UE.Vector2D>, Context: $Ref<UE.DrawToRenderTargetContext>) : void;
        static BreakSkinWeightInfo(InWeight: UE.SkelMeshSkinWeightInfo, Bone0: $Ref<number>, Weight0: $Ref<number>, Bone1: $Ref<number>, Weight1: $Ref<number>, Bone2: $Ref<number>, Weight2: $Ref<number>, Bone3: $Ref<number>, Weight3: $Ref<number>) : void;
        static ClearRenderTarget2D(WorldContextObject: $Nullable<UE.Object>, TextureRenderTarget: $Nullable<UE.TextureRenderTarget2D>, ClearColor?: UE.LinearColor /* = (R=0.000000,G=0.000000,B=0.000000,A=1.000000) */) : void;
        static ConvertRenderTargetToTexture2DEditorOnly(WorldContextObject: $Nullable<UE.Object>, RenderTarget: $Nullable<UE.TextureRenderTarget2D>, Texture: $Nullable<UE.Texture2D>) : void;
        static CreateRenderTarget2D(WorldContextObject: $Nullable<UE.Object>, Width?: number /* = 256 */, Height?: number /* = 256 */, Format?: UE.ETextureRenderTargetFormat /* = RTF_RGBA16f */, ClearColor?: UE.LinearColor /* = (R=0.000000,G=0.000000,B=0.000000,A=1.000000) */, bAutoGenerateMipMaps?: boolean /* = false */) : UE.TextureRenderTarget2D;
        static DrawMaterialToRenderTarget(WorldContextObject: $Nullable<UE.Object>, TextureRenderTarget: $Nullable<UE.TextureRenderTarget2D>, Material: $Nullable<UE.MaterialInterface>) : void;
        static EndDrawCanvasToRenderTarget(WorldContextObject: $Nullable<UE.Object>, Context: UE.DrawToRenderTargetContext) : void;
        static ExportRenderTarget(WorldContextObject: $Nullable<UE.Object>, TextureRenderTarget: $Nullable<UE.TextureRenderTarget2D>, FilePath: string, FileName: string) : void;
        static ExportTexture2D(WorldContextObject: $Nullable<UE.Object>, Texture: $Nullable<UE.Texture2D>, FilePath: string, FileName: string) : void;
        static ImportBufferAsTexture2D(WorldContextObject: $Nullable<UE.Object>, Buffer: TArray<number>) : UE.Texture2D;
        static ImportFileAsTexture2D(WorldContextObject: $Nullable<UE.Object>, Filename: string) : UE.Texture2D;
        static MakeSkinWeightInfo(Bone0: number, Weight0: number, Bone1: number, Weight1: number, Bone2: number, Weight2: number, Bone3: number, Weight3: number) : UE.SkelMeshSkinWeightInfo;
        static ReadRenderTargetPixel(WorldContextObject: $Nullable<UE.Object>, TextureRenderTarget: $Nullable<UE.TextureRenderTarget2D>, X: number, Y: number) : UE.Color;
        static ReadRenderTargetRawPixel(WorldContextObject: $Nullable<UE.Object>, TextureRenderTarget: $Nullable<UE.TextureRenderTarget2D>, X: number, Y: number) : UE.LinearColor;
        static ReadRenderTargetRawUV(WorldContextObject: $Nullable<UE.Object>, TextureRenderTarget: $Nullable<UE.TextureRenderTarget2D>, U: number, V: number) : UE.LinearColor;
        static ReadRenderTargetUV(WorldContextObject: $Nullable<UE.Object>, TextureRenderTarget: $Nullable<UE.TextureRenderTarget2D>, U: number, V: number) : UE.Color;
        static ReleaseRenderTarget2D(TextureRenderTarget: $Nullable<UE.TextureRenderTarget2D>) : void;
        static RenderTargetCreateStaticTexture2DEditorOnly(RenderTarget: $Nullable<UE.TextureRenderTarget2D>, Name?: string /* = "Texture" */, CompressionSettings?: UE.TextureCompressionSettings /* = TC_Default */, MipSettings?: UE.TextureMipGenSettings /* = TMGS_FromTextureGroup */) : UE.Texture2D;
        static SetCastInsetShadowForAllAttachments(PrimitiveComponent: $Nullable<UE.PrimitiveComponent>, bCastInsetShadow: boolean, bLightAttachmentsAsGroup: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetRenderingLibrary;
        static Load(InName: string): KismetRenderingLibrary;
    }
    
    enum ESearchCase { CaseSensitive, IgnoreCase, ESearchCase_MAX}
    enum ESearchDir { FromStart, FromEnd, ESearchDir_MAX}
    class KismetStringLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static BuildString_Bool(AppendTo: string, Prefix: string, InBool: boolean, Suffix: string) : string;
        static BuildString_Color(AppendTo: string, Prefix: string, InColor: UE.LinearColor, Suffix: string) : string;
        static BuildString_Float(AppendTo: string, Prefix: string, InFloat: number, Suffix: string) : string;
        static BuildString_Int(AppendTo: string, Prefix: string, InInt: number, Suffix: string) : string;
        static BuildString_IntVector(AppendTo: string, Prefix: string, InIntVector: UE.IntVector, Suffix: string) : string;
        static BuildString_Name(AppendTo: string, Prefix: string, InName: string, Suffix: string) : string;
        static BuildString_Object(AppendTo: string, Prefix: string, InObj: $Nullable<UE.Object>, Suffix: string) : string;
        static BuildString_Rotator(AppendTo: string, Prefix: string, InRot: UE.Rotator, Suffix: string) : string;
        static BuildString_Vector(AppendTo: string, Prefix: string, InVector: UE.Vector, Suffix: string) : string;
        static BuildString_Vector2d(AppendTo: string, Prefix: string, InVector2d: UE.Vector2D, Suffix: string) : string;
        static Concat_StrStr(A: string, B: string) : string;
        static Contains(SearchIn: string, Substring: string, bUseCase?: boolean /* = false */, bSearchFromEnd?: boolean /* = false */) : boolean;
        static Conv_BoolToString(InBool: boolean) : string;
        static Conv_ByteToString(InByte: number) : string;
        static Conv_ColorToString(InColor: UE.LinearColor) : string;
        static Conv_FloatToString(InFloat: number) : string;
        static Conv_IntToString(InInt: number) : string;
        static Conv_IntVectorToString(InIntVec: UE.IntVector) : string;
        static Conv_MatrixToString(InMatrix: UE.Matrix) : string;
        static Conv_NameToString(InName: string) : string;
        static Conv_ObjectToString(InObj: $Nullable<UE.Object>) : string;
        static Conv_RotatorToString(InRot: UE.Rotator) : string;
        static Conv_StringToColor(InString: string, OutConvertedColor: $Ref<UE.LinearColor>, OutIsValid: $Ref<boolean>) : void;
        static Conv_StringToFloat(InString: string) : number;
        static Conv_StringToInt(InString: string) : number;
        static Conv_StringToName(InString: string) : string;
        static Conv_StringToRotator(InString: string, OutConvertedRotator: $Ref<UE.Rotator>, OutIsValid: $Ref<boolean>) : void;
        static Conv_StringToVector(InString: string, OutConvertedVector: $Ref<UE.Vector>, OutIsValid: $Ref<boolean>) : void;
        static Conv_StringToVector2D(InString: string, OutConvertedVector2D: $Ref<UE.Vector2D>, OutIsValid: $Ref<boolean>) : void;
        static Conv_TransformToString(InTrans: UE.Transform) : string;
        static Conv_Vector2dToString(InVec: UE.Vector2D) : string;
        static Conv_VectorToString(InVec: UE.Vector) : string;
        static CullArray(SourceString: string, InArray: $Ref<TArray<string>>) : number;
        static EndsWith(SourceString: string, InSuffix: string, SearchCase?: UE.ESearchCase /* = IgnoreCase */) : boolean;
        static EqualEqual_StriStri(A: string, B: string) : boolean;
        static EqualEqual_StrStr(A: string, B: string) : boolean;
        static FindSubstring(SearchIn: string, Substring: string, bUseCase?: boolean /* = false */, bSearchFromEnd?: boolean /* = false */, StartPosition?: number /* = -1 */) : number;
        static GetCharacterArrayFromString(SourceString: string) : TArray<string>;
        static GetCharacterAsNumber(SourceString: string, Index?: number /* = 0 */) : number;
        static GetSubstring(SourceString: string, StartIndex?: number /* = 0 */, Length?: number /* = 1 */) : string;
        static IsNumeric(SourceString: string) : boolean;
        static JoinStringArray(SourceArray: TArray<string>, Separator?: string /* = " " */) : string;
        static Left(SourceString: string, Count: number) : string;
        static LeftChop(SourceString: string, Count: number) : string;
        static LeftPad(SourceString: string, ChCount: number) : string;
        static Len(S: string) : number;
        static MatchesWildcard(SourceString: string, Wildcard: string, SearchCase?: UE.ESearchCase /* = IgnoreCase */) : boolean;
        static Mid(SourceString: string, Start: number, Count: number) : string;
        static NotEqual_StriStri(A: string, B: string) : boolean;
        static NotEqual_StrStr(A: string, B: string) : boolean;
        static ParseIntoArray(SourceString: string, Delimiter?: string /* = " " */, CullEmptyStrings?: boolean /* = true */) : TArray<string>;
        static Replace(SourceString: string, From: string, To: string, SearchCase?: UE.ESearchCase /* = IgnoreCase */) : string;
        static ReplaceInline(SourceString: $Ref<string>, SearchText: string, ReplacementText: string, SearchCase?: UE.ESearchCase /* = IgnoreCase */) : number;
        static Reverse(SourceString: string) : string;
        static Right(SourceString: string, Count: number) : string;
        static RightChop(SourceString: string, Count: number) : string;
        static RightPad(SourceString: string, ChCount: number) : string;
        static Split(SourceString: string, InStr: string, LeftS: $Ref<string>, RightS: $Ref<string>, SearchCase?: UE.ESearchCase /* = IgnoreCase */, SearchDir?: UE.ESearchDir /* = FromStart */) : boolean;
        static StartsWith(SourceString: string, InPrefix: string, SearchCase?: UE.ESearchCase /* = IgnoreCase */) : boolean;
        static TimeSecondsToString(InSeconds: number) : string;
        static ToLower(SourceString: string) : string;
        static ToUpper(SourceString: string) : string;
        static Trim(SourceString: string) : string;
        static TrimTrailing(SourceString: string) : string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetStringLibrary;
        static Load(InName: string): KismetStringLibrary;
    }
    
    class KismetStringTableLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetKeysFromStringTable(TableId: string) : TArray<string>;
        static GetMetaDataIdsFromStringTableEntry(TableId: string, Key: string) : TArray<string>;
        static GetRegisteredStringTables() : TArray<string>;
        static GetTableEntryMetaData(TableId: string, Key: string, MetaDataId: string) : string;
        static GetTableEntrySourceString(TableId: string, Key: string) : string;
        static GetTableNamespace(TableId: string) : string;
        static IsRegisteredTableEntry(TableId: string, Key: string) : boolean;
        static IsRegisteredTableId(TableId: string) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetStringTableLibrary;
        static Load(InName: string): KismetStringTableLibrary;
    }
    
    class UserActivity {
        constructor();
        constructor(ActionName: string);
        ActionName: string;
        static StaticClass(): Class;
    }
    
    class GenericStruct {
        constructor();
        constructor(Data: number);
        Data: number;
        static StaticClass(): Class;
    }
    
    class CollisionProfileName {
        constructor();
        constructor(Name: string);
        Name: string;
        static StaticClass(): Class;
    }
    
    enum EQuitPreference { Quit, Background, EQuitPreference_MAX}
    enum EMoveComponentAction { Move, Stop, Return, EMoveComponentAction_MAX}
    class TimerHandle {
        constructor();
        constructor(Handle: bigint);
        Handle: bigint;
        static StaticClass(): Class;
    }
    
    class DebugFloatHistory {
        constructor();
        constructor(Samples: TArray<number>, MaxSamples: number, MinValue: number, MaxValue: number, bAutoAdjustMinMax: boolean);
        Samples: TArray<number>;
        MaxSamples: number;
        MinValue: number;
        MaxValue: number;
        bAutoAdjustMinMax: boolean;
        static StaticClass(): Class;
    }
    
    class KismetSystemLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnAssetClassLoaded__DelegateSignature(Loaded: $Nullable<UE.Class>) : void;
        OnAssetLoaded__DelegateSignature(Loaded: $Nullable<UE.Object>) : void;
        static AddFloatHistorySample(Value: number, FloatHistory: UE.DebugFloatHistory) : UE.DebugFloatHistory;
        static BeginTransaction(Context: string, Description: string, PrimaryObject: $Nullable<UE.Object>) : number;
        static BoxOverlapActors(WorldContextObject: $Nullable<UE.Object>, BoxPos: UE.Vector, BoxExtent: UE.Vector, ObjectTypes: TArray<UE.EObjectTypeQuery>, ActorClassFilter: $Nullable<UE.Class>, ActorsToIgnore: TArray<UE.Actor>, OutActors: $Ref<TArray<UE.Actor>>) : boolean;
        static BoxOverlapComponents(WorldContextObject: $Nullable<UE.Object>, BoxPos: UE.Vector, Extent: UE.Vector, ObjectTypes: TArray<UE.EObjectTypeQuery>, ComponentClassFilter: $Nullable<UE.Class>, ActorsToIgnore: TArray<UE.Actor>, OutComponents: $Ref<TArray<UE.PrimitiveComponent>>) : boolean;
        static BoxTraceMulti(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, HalfSize: UE.Vector, Orientation: UE.Rotator, TraceChannel: UE.ETraceTypeQuery, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHits: $Ref<TArray<UE.HitResult>>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static BoxTraceMultiByProfile(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, HalfSize: UE.Vector, Orientation: UE.Rotator, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHits: $Ref<TArray<UE.HitResult>>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static BoxTraceMultiForObjects(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, HalfSize: UE.Vector, Orientation: UE.Rotator, ObjectTypes: TArray<UE.EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHits: $Ref<TArray<UE.HitResult>>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static BoxTraceSingle(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, HalfSize: UE.Vector, Orientation: UE.Rotator, TraceChannel: UE.ETraceTypeQuery, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHit: $Ref<UE.HitResult>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static BoxTraceSingleByProfile(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, HalfSize: UE.Vector, Orientation: UE.Rotator, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHit: $Ref<UE.HitResult>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static BoxTraceSingleForObjects(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, HalfSize: UE.Vector, Orientation: UE.Rotator, ObjectTypes: TArray<UE.EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHit: $Ref<UE.HitResult>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static BreakSoftClassPath(InSoftClassPath: UE.SoftClassPath, PathString: $Ref<string>) : void;
        static BreakSoftObjectPath(InSoftObjectPath: UE.SoftObjectPath, PathString: $Ref<string>) : void;
        static CancelTransaction(Index: number) : void;
        static CanLaunchURL(URL: string) : boolean;
        static CapsuleOverlapActors(WorldContextObject: $Nullable<UE.Object>, CapsulePos: UE.Vector, Radius: number, HalfHeight: number, ObjectTypes: TArray<UE.EObjectTypeQuery>, ActorClassFilter: $Nullable<UE.Class>, ActorsToIgnore: TArray<UE.Actor>, OutActors: $Ref<TArray<UE.Actor>>) : boolean;
        static CapsuleOverlapComponents(WorldContextObject: $Nullable<UE.Object>, CapsulePos: UE.Vector, Radius: number, HalfHeight: number, ObjectTypes: TArray<UE.EObjectTypeQuery>, ComponentClassFilter: $Nullable<UE.Class>, ActorsToIgnore: TArray<UE.Actor>, OutComponents: $Ref<TArray<UE.PrimitiveComponent>>) : boolean;
        static CapsuleTraceMulti(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, Radius: number, HalfHeight: number, TraceChannel: UE.ETraceTypeQuery, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHits: $Ref<TArray<UE.HitResult>>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static CapsuleTraceMultiByProfile(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, Radius: number, HalfHeight: number, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHits: $Ref<TArray<UE.HitResult>>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static CapsuleTraceMultiForObjects(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, Radius: number, HalfHeight: number, ObjectTypes: TArray<UE.EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHits: $Ref<TArray<UE.HitResult>>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static CapsuleTraceSingle(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, Radius: number, HalfHeight: number, TraceChannel: UE.ETraceTypeQuery, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHit: $Ref<UE.HitResult>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static CapsuleTraceSingleByProfile(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, Radius: number, HalfHeight: number, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHit: $Ref<UE.HitResult>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static CapsuleTraceSingleForObjects(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, Radius: number, HalfHeight: number, ObjectTypes: TArray<UE.EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHit: $Ref<UE.HitResult>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static CollectGarbage() : void;
        static ComponentOverlapActors(Component: $Nullable<UE.PrimitiveComponent>, ComponentTransform: UE.Transform, ObjectTypes: TArray<UE.EObjectTypeQuery>, ActorClassFilter: $Nullable<UE.Class>, ActorsToIgnore: TArray<UE.Actor>, OutActors: $Ref<TArray<UE.Actor>>) : boolean;
        static ComponentOverlapComponents(Component: $Nullable<UE.PrimitiveComponent>, ComponentTransform: UE.Transform, ObjectTypes: TArray<UE.EObjectTypeQuery>, ComponentClassFilter: $Nullable<UE.Class>, ActorsToIgnore: TArray<UE.Actor>, OutComponents: $Ref<TArray<UE.PrimitiveComponent>>) : boolean;
        static ControlScreensaver(bAllowScreenSaver: boolean) : void;
        static Conv_ClassToSoftClassReference(Class: UE.Class) : TSoftClassPtr<UE.Object>;
        static Conv_InterfaceToObject(Interface: Interface) : UE.Object;
        static Conv_ObjectToSoftObjectReference(Object: $Nullable<UE.Object>) : TSoftObjectPtr<UE.Object>;
        static Conv_PrimaryAssetIdToString(PrimaryAssetId: UE.PrimaryAssetId) : string;
        static Conv_PrimaryAssetTypeToString(PrimaryAssetType: UE.PrimaryAssetType) : string;
        static Conv_SoftClassPathToSoftClassRef(SoftClassPath: UE.SoftClassPath) : TSoftClassPtr<UE.Object>;
        static Conv_SoftClassReferenceToClass(SoftClass: TSoftClassPtr<UE.Object>) : UE.Class;
        static Conv_SoftClassReferenceToString(SoftClassReference: TSoftClassPtr<UE.Object>) : string;
        static Conv_SoftObjectReferenceToObject(SoftObject: TSoftObjectPtr<UE.Object>) : UE.Object;
        static Conv_SoftObjectReferenceToString(SoftObjectReference: TSoftObjectPtr<UE.Object>) : string;
        static Conv_SoftObjPathToSoftObjRef(SoftObjectPath: UE.SoftObjectPath) : TSoftObjectPtr<UE.Object>;
        static ConvertToAbsolutePath(Filename: string) : string;
        static ConvertToRelativePath(Filename: string) : string;
        static CreateCopyForUndoBuffer(ObjectToModify: $Nullable<UE.Object>) : void;
        static Delay(WorldContextObject: $Nullable<UE.Object>, Duration: number, LatentInfo: UE.LatentActionInfo) : void;
        static DoesImplementInterface(TestObject: $Nullable<UE.Object>, Interface: $Nullable<UE.Class>) : boolean;
        static DrawDebugArrow(WorldContextObject: $Nullable<UE.Object>, LineStart: UE.Vector, LineEnd: UE.Vector, ArrowSize: number, LineColor: UE.LinearColor, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */) : void;
        static DrawDebugBox(WorldContextObject: $Nullable<UE.Object>, Center: UE.Vector, Extent: UE.Vector, LineColor: UE.LinearColor, Rotation?: UE.Rotator /* =  */, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */) : void;
        static DrawDebugCamera(CameraActor: $Nullable<UE.CameraActor>, CameraColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */) : void;
        static DrawDebugCapsule(WorldContextObject: $Nullable<UE.Object>, Center: UE.Vector, HalfHeight: number, Radius: number, Rotation: UE.Rotator, LineColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */) : void;
        static DrawDebugCircle(WorldContextObject: $Nullable<UE.Object>, Center: UE.Vector, Radius: number, NumSegments?: number /* = 12 */, LineColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */, YAxis?: UE.Vector /* = 0.000000,1.000000,0.000000 */, ZAxis?: UE.Vector /* = 0.000000,0.000000,1.000000 */, bDrawAxis?: boolean /* = false */) : void;
        static DrawDebugCone(WorldContextObject: $Nullable<UE.Object>, Origin: UE.Vector, Direction: UE.Vector, Length: number, AngleWidth: number, AngleHeight: number, NumSides: number, LineColor: UE.LinearColor, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */) : void;
        static DrawDebugConeInDegrees(WorldContextObject: $Nullable<UE.Object>, Origin: UE.Vector, Direction: UE.Vector, Length?: number /* = 100.000000 */, AngleWidth?: number /* = 45.000000 */, AngleHeight?: number /* = 45.000000 */, NumSides?: number /* = 12 */, LineColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */) : void;
        static DrawDebugCoordinateSystem(WorldContextObject: $Nullable<UE.Object>, AxisLoc: UE.Vector, AxisRot: UE.Rotator, Scale?: number /* = 1.000000 */, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */) : void;
        static DrawDebugCylinder(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, Radius?: number /* = 100.000000 */, Segments?: number /* = 12 */, LineColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */) : void;
        static DrawDebugFloatHistoryLocation(WorldContextObject: $Nullable<UE.Object>, FloatHistory: UE.DebugFloatHistory, DrawLocation: UE.Vector, DrawSize: UE.Vector2D, DrawColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */) : void;
        static DrawDebugFloatHistoryTransform(WorldContextObject: $Nullable<UE.Object>, FloatHistory: UE.DebugFloatHistory, DrawTransform: UE.Transform, DrawSize: UE.Vector2D, DrawColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */) : void;
        static DrawDebugFrustum(WorldContextObject: $Nullable<UE.Object>, FrustumTransform: UE.Transform, FrustumColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */) : void;
        static DrawDebugLine(WorldContextObject: $Nullable<UE.Object>, LineStart: UE.Vector, LineEnd: UE.Vector, LineColor: UE.LinearColor, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */) : void;
        static DrawDebugPlane(WorldContextObject: $Nullable<UE.Object>, PlaneCoordinates: UE.Plane, Location: UE.Vector, Size: number, PlaneColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */) : void;
        static DrawDebugPoint(WorldContextObject: $Nullable<UE.Object>, Position: UE.Vector, Size: number, PointColor: UE.LinearColor, Duration?: number /* = 0.000000 */) : void;
        static DrawDebugSphere(WorldContextObject: $Nullable<UE.Object>, Center: UE.Vector, Radius?: number /* = 100.000000 */, Segments?: number /* = 12 */, LineColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */) : void;
        static DrawDebugString(WorldContextObject: $Nullable<UE.Object>, TextLocation: UE.Vector, Text: string, TestBaseActor?: UE.Actor /* = None */, TextColor?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */) : void;
        static EndTransaction() : number;
        static EqualEqual_PrimaryAssetId(A: UE.PrimaryAssetId, B: UE.PrimaryAssetId) : boolean;
        static EqualEqual_PrimaryAssetType(A: UE.PrimaryAssetType, B: UE.PrimaryAssetType) : boolean;
        static EqualEqual_SoftClassReference(A: TSoftClassPtr<UE.Object>, B: TSoftClassPtr<UE.Object>) : boolean;
        static EqualEqual_SoftObjectReference(A: TSoftObjectPtr<UE.Object>, B: TSoftObjectPtr<UE.Object>) : boolean;
        static ExecuteConsoleCommand(WorldContextObject: $Nullable<UE.Object>, Command: string, SpecificPlayer?: UE.PlayerController /* = None */) : void;
        static FlushDebugStrings(WorldContextObject: $Nullable<UE.Object>) : void;
        static FlushPersistentDebugLines(WorldContextObject: $Nullable<UE.Object>) : void;
        static ForceCloseAdBanner() : void;
        static GetActorBounds(Actor: $Nullable<UE.Actor>, Origin: $Ref<UE.Vector>, BoxExtent: $Ref<UE.Vector>) : void;
        static GetActorListFromComponentList(ComponentList: TArray<UE.PrimitiveComponent>, ActorClassFilter: $Nullable<UE.Class>, OutActorList: $Ref<TArray<UE.Actor>>) : void;
        static GetAdIDCount() : number;
        static GetClassDisplayName(Class: $Nullable<UE.Class>) : string;
        static GetClassFromPrimaryAssetId(PrimaryAssetId: UE.PrimaryAssetId) : UE.Class;
        static GetCommandLine() : string;
        static GetComponentBounds(Component: $Nullable<UE.SceneComponent>, Origin: $Ref<UE.Vector>, BoxExtent: $Ref<UE.Vector>, SphereRadius: $Ref<number>) : void;
        static GetConsoleVariableBoolValue(VariableName: string) : boolean;
        static GetConsoleVariableFloatValue(VariableName: string) : number;
        static GetConsoleVariableIntValue(VariableName: string) : number;
        static GetConvenientWindowedResolutions(Resolutions: $Ref<TArray<UE.IntPoint>>) : boolean;
        static GetCurrentBundleState(PrimaryAssetId: UE.PrimaryAssetId, bForceCurrentState: boolean, OutBundles: $Ref<TArray<string>>) : boolean;
        static GetDefaultLanguage() : string;
        static GetDefaultLocale() : string;
        static GetDeviceId() : string;
        static GetDisplayName(Object: $Nullable<UE.Object>) : string;
        static GetEngineVersion() : string;
        static GetFrameCount() : bigint;
        static GetGameBundleId() : string;
        static GetGameName() : string;
        static GetGamepadControllerName(ControllerId: number) : string;
        static GetGameTimeInSeconds(WorldContextObject: $Nullable<UE.Object>) : number;
        static GetLocalCurrencyCode() : string;
        static GetLocalCurrencySymbol() : string;
        static GetMinYResolutionFor3DView() : number;
        static GetMinYResolutionForUI() : number;
        static GetObjectFromPrimaryAssetId(PrimaryAssetId: UE.PrimaryAssetId) : UE.Object;
        static GetObjectName(Object: $Nullable<UE.Object>) : string;
        static GetOuterObject(Object: $Nullable<UE.Object>) : UE.Object;
        static GetPathName(Object: $Nullable<UE.Object>) : string;
        static GetPlatformUserName() : string;
        static GetPreferredLanguages() : TArray<string>;
        static GetPrimaryAssetIdFromClass(Class: $Nullable<UE.Class>) : UE.PrimaryAssetId;
        static GetPrimaryAssetIdFromObject(Object: $Nullable<UE.Object>) : UE.PrimaryAssetId;
        static GetPrimaryAssetIdFromSoftClassReference(SoftClassReference: TSoftClassPtr<UE.Object>) : UE.PrimaryAssetId;
        static GetPrimaryAssetIdFromSoftObjectReference(SoftObjectReference: TSoftObjectPtr<UE.Object>) : UE.PrimaryAssetId;
        static GetPrimaryAssetIdList(PrimaryAssetType: UE.PrimaryAssetType, OutPrimaryAssetIdList: $Ref<TArray<UE.PrimaryAssetId>>) : void;
        static GetPrimaryAssetsWithBundleState(RequiredBundles: TArray<string>, ExcludedBundles: TArray<string>, ValidTypes: TArray<UE.PrimaryAssetType>, bForceCurrentState: boolean, OutPrimaryAssetIdList: $Ref<TArray<UE.PrimaryAssetId>>) : void;
        static GetProjectContentDirectory() : string;
        static GetProjectDirectory() : string;
        static GetProjectSavedDirectory() : string;
        static GetRenderingDetailMode() : number;
        static GetRenderingMaterialQualityLevel() : number;
        static GetSoftClassReferenceFromPrimaryAssetId(PrimaryAssetId: UE.PrimaryAssetId) : TSoftClassPtr<UE.Object>;
        static GetSoftObjectReferenceFromPrimaryAssetId(PrimaryAssetId: UE.PrimaryAssetId) : TSoftObjectPtr<UE.Object>;
        static GetSupportedFullscreenResolutions(Resolutions: $Ref<TArray<UE.IntPoint>>) : boolean;
        static GetUniqueDeviceId() : string;
        static GetVolumeButtonsHandledBySystem() : boolean;
        static HideAdBanner() : void;
        static IsControllerAssignedToGamepad(ControllerId: number) : boolean;
        static IsDedicatedServer(WorldContextObject: $Nullable<UE.Object>) : boolean;
        static IsInterstitialAdAvailable() : boolean;
        static IsInterstitialAdRequested() : boolean;
        static IsLoggedIn(SpecificPlayer: $Nullable<UE.PlayerController>) : boolean;
        static IsPackagedForDistribution() : boolean;
        static IsScreensaverEnabled() : boolean;
        static IsServer(WorldContextObject: $Nullable<UE.Object>) : boolean;
        static IsStandalone(WorldContextObject: $Nullable<UE.Object>) : boolean;
        static IsUnattended() : boolean;
        static IsValid(Object: $Nullable<UE.Object>) : boolean;
        static IsValidClass(Class: $Nullable<UE.Class>) : boolean;
        static IsValidPrimaryAssetId(PrimaryAssetId: UE.PrimaryAssetId) : boolean;
        static IsValidPrimaryAssetType(PrimaryAssetType: UE.PrimaryAssetType) : boolean;
        static IsValidSoftClassReference(SoftClassReference: TSoftClassPtr<UE.Object>) : boolean;
        static IsValidSoftObjectReference(SoftObjectReference: TSoftObjectPtr<UE.Object>) : boolean;
        static K2_ClearAndInvalidateTimerHandle(WorldContextObject: $Nullable<UE.Object>, Handle: $Ref<UE.TimerHandle>) : void;
        static K2_ClearTimer(Object: $Nullable<UE.Object>, FunctionName: string) : void;
        static K2_ClearTimerDelegate(Delegate: $Delegate<() => void>) : void;
        static K2_ClearTimerHandle(WorldContextObject: $Nullable<UE.Object>, Handle: UE.TimerHandle) : void;
        static K2_GetTimerElapsedTime(Object: $Nullable<UE.Object>, FunctionName: string) : number;
        static K2_GetTimerElapsedTimeDelegate(Delegate: $Delegate<() => void>) : number;
        static K2_GetTimerElapsedTimeHandle(WorldContextObject: $Nullable<UE.Object>, Handle: UE.TimerHandle) : number;
        static K2_GetTimerRemainingTime(Object: $Nullable<UE.Object>, FunctionName: string) : number;
        static K2_GetTimerRemainingTimeDelegate(Delegate: $Delegate<() => void>) : number;
        static K2_GetTimerRemainingTimeHandle(WorldContextObject: $Nullable<UE.Object>, Handle: UE.TimerHandle) : number;
        static K2_InvalidateTimerHandle(Handle: $Ref<UE.TimerHandle>) : UE.TimerHandle;
        static K2_IsTimerActive(Object: $Nullable<UE.Object>, FunctionName: string) : boolean;
        static K2_IsTimerActiveDelegate(Delegate: $Delegate<() => void>) : boolean;
        static K2_IsTimerActiveHandle(WorldContextObject: $Nullable<UE.Object>, Handle: UE.TimerHandle) : boolean;
        static K2_IsTimerPaused(Object: $Nullable<UE.Object>, FunctionName: string) : boolean;
        static K2_IsTimerPausedDelegate(Delegate: $Delegate<() => void>) : boolean;
        static K2_IsTimerPausedHandle(WorldContextObject: $Nullable<UE.Object>, Handle: UE.TimerHandle) : boolean;
        static K2_IsValidTimerHandle(Handle: UE.TimerHandle) : boolean;
        static K2_PauseTimer(Object: $Nullable<UE.Object>, FunctionName: string) : void;
        static K2_PauseTimerDelegate(Delegate: $Delegate<() => void>) : void;
        static K2_PauseTimerHandle(WorldContextObject: $Nullable<UE.Object>, Handle: UE.TimerHandle) : void;
        static K2_SetTimer(Object: $Nullable<UE.Object>, FunctionName: string, Time: number, bLooping: boolean, InitialStartDelay?: number /* = 0.000000 */, InitialStartDelayVariance?: number /* = 0.000000 */) : UE.TimerHandle;
        static K2_SetTimerDelegate(Delegate: $Delegate<() => void>, Time: number, bLooping: boolean, InitialStartDelay?: number /* = 0.000000 */, InitialStartDelayVariance?: number /* = 0.000000 */) : UE.TimerHandle;
        static K2_TimerExists(Object: $Nullable<UE.Object>, FunctionName: string) : boolean;
        static K2_TimerExistsDelegate(Delegate: $Delegate<() => void>) : boolean;
        static K2_TimerExistsHandle(WorldContextObject: $Nullable<UE.Object>, Handle: UE.TimerHandle) : boolean;
        static K2_UnPauseTimer(Object: $Nullable<UE.Object>, FunctionName: string) : void;
        static K2_UnPauseTimerDelegate(Delegate: $Delegate<() => void>) : void;
        static K2_UnPauseTimerHandle(WorldContextObject: $Nullable<UE.Object>, Handle: UE.TimerHandle) : void;
        static LaunchURL(URL: string) : void;
        static LineTraceMulti(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, TraceChannel: UE.ETraceTypeQuery, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHits: $Ref<TArray<UE.HitResult>>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static LineTraceMultiByProfile(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHits: $Ref<TArray<UE.HitResult>>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static LineTraceMultiForObjects(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, ObjectTypes: TArray<UE.EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHits: $Ref<TArray<UE.HitResult>>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static LineTraceSingle(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, TraceChannel: UE.ETraceTypeQuery, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHit: $Ref<UE.HitResult>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static LineTraceSingleByProfile(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHit: $Ref<UE.HitResult>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static LineTraceSingleForObjects(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, ObjectTypes: TArray<UE.EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHit: $Ref<UE.HitResult>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static LoadAsset(WorldContextObject: $Nullable<UE.Object>, Asset: TSoftObjectPtr<UE.Object>, OnLoaded: $Delegate<(Loaded: $Nullable<UE.Object>) => void>, LatentInfo: UE.LatentActionInfo) : void;
        static LoadAsset_Blocking(Asset: TSoftObjectPtr<UE.Object>) : UE.Object;
        static LoadAssetClass(WorldContextObject: $Nullable<UE.Object>, AssetClass: TSoftClassPtr<UE.Object>, OnLoaded: $Delegate<(Loaded: $Nullable<UE.Class>) => void>, LatentInfo: UE.LatentActionInfo) : void;
        static LoadClassAsset_Blocking(AssetClass: TSoftClassPtr<UE.Object>) : UE.Class;
        static LoadInterstitialAd(AdIdIndex: number) : void;
        static MakeLiteralBool(Value: boolean) : boolean;
        static MakeLiteralByte(Value: number) : number;
        static MakeLiteralFloat(Value: number) : number;
        static MakeLiteralInt(Value: number) : number;
        static MakeLiteralName(Value: string) : string;
        static MakeLiteralString(Value: string) : string;
        static MakeLiteralText(Value: string) : string;
        static MakeSoftClassPath(PathString: string) : UE.SoftClassPath;
        static MakeSoftObjectPath(PathString: string) : UE.SoftObjectPath;
        static MoveComponentTo(Component: $Nullable<UE.SceneComponent>, TargetRelativeLocation: UE.Vector, TargetRelativeRotation: UE.Rotator, bEaseOut: boolean, bEaseIn: boolean, OverTime: number, bForceShortestRotationPath: boolean, MoveAction: UE.EMoveComponentAction, LatentInfo: UE.LatentActionInfo) : void;
        static NormalizeFilename(InFilename: string) : string;
        static NotEqual_PrimaryAssetId(A: UE.PrimaryAssetId, B: UE.PrimaryAssetId) : boolean;
        static NotEqual_PrimaryAssetType(A: UE.PrimaryAssetType, B: UE.PrimaryAssetType) : boolean;
        static NotEqual_SoftClassReference(A: TSoftClassPtr<UE.Object>, B: TSoftClassPtr<UE.Object>) : boolean;
        static NotEqual_SoftObjectReference(A: TSoftObjectPtr<UE.Object>, B: TSoftObjectPtr<UE.Object>) : boolean;
        static PrintString(WorldContextObject: $Nullable<UE.Object>, InString?: string /* = "Hello" */, bPrintToScreen?: boolean /* = true */, bPrintToLog?: boolean /* = true */, TextColor?: UE.LinearColor /* = (R=0.000000,G=0.660000,B=1.000000,A=1.000000) */, Duration?: number /* = 2.000000 */) : void;
        static PrintText(WorldContextObject: $Nullable<UE.Object>, InText?: string /* = "INVTEXT("Hello")" */, bPrintToScreen?: boolean /* = true */, bPrintToLog?: boolean /* = true */, TextColor?: UE.LinearColor /* = (R=0.000000,G=0.660000,B=1.000000,A=1.000000) */, Duration?: number /* = 2.000000 */) : void;
        static PrintWarning(InString: string) : void;
        static QuitEditor() : void;
        static QuitGame(WorldContextObject: $Nullable<UE.Object>, SpecificPlayer: $Nullable<UE.PlayerController>, QuitPreference: UE.EQuitPreference, bIgnorePlatformRestrictions: boolean) : void;
        static RegisterForRemoteNotifications() : void;
        static ResetGamepadAssignments() : void;
        static ResetGamepadAssignmentToController(ControllerId: number) : void;
        static RetriggerableDelay(WorldContextObject: $Nullable<UE.Object>, Duration: number, LatentInfo: UE.LatentActionInfo) : void;
        static SetBoolPropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: boolean) : void;
        static SetBytePropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: number) : void;
        static SetClassPropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: $Nullable<UE.Class>) : void;
        static SetCollisionProfileNameProperty(Object: $Nullable<UE.Object>, PropertyName: string, Value: UE.CollisionProfileName) : void;
        static SetFloatPropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: number) : void;
        static SetInt64PropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: bigint) : void;
        static SetInterfacePropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: Interface) : void;
        static SetIntPropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: number) : void;
        static SetLinearColorPropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: UE.LinearColor) : void;
        static SetNamePropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: string) : void;
        static SetObjectPropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: $Nullable<UE.Object>) : void;
        static SetRotatorPropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: UE.Rotator) : void;
        static SetSoftClassPropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: TSoftClassPtr<UE.Object>) : void;
        static SetSoftObjectPropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: TSoftObjectPtr<UE.Object>) : void;
        static SetStringPropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: string) : void;
        static SetStructurePropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: UE.GenericStruct) : void;
        static SetSuppressViewportTransitionMessage(WorldContextObject: $Nullable<UE.Object>, bState: boolean) : void;
        static SetTextPropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: string) : void;
        static SetTransformPropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: UE.Transform) : void;
        static SetUserActivity(UserActivity: UE.UserActivity) : void;
        static SetVectorPropertyByName(Object: $Nullable<UE.Object>, PropertyName: string, Value: UE.Vector) : void;
        static SetVolumeButtonsHandledBySystem(bEnabled: boolean) : void;
        static SetWindowTitle(Title: string) : void;
        static ShowAdBanner(AdIdIndex: number, bShowOnBottomOfScreen: boolean) : void;
        static ShowInterstitialAd() : void;
        static ShowPlatformSpecificAchievementsScreen(SpecificPlayer: $Nullable<UE.PlayerController>) : void;
        static ShowPlatformSpecificLeaderboardScreen(CategoryName: string) : void;
        static SnapshotObject(Object: $Nullable<UE.Object>) : void;
        static SphereOverlapActors(WorldContextObject: $Nullable<UE.Object>, SpherePos: UE.Vector, SphereRadius: number, ObjectTypes: TArray<UE.EObjectTypeQuery>, ActorClassFilter: $Nullable<UE.Class>, ActorsToIgnore: TArray<UE.Actor>, OutActors: $Ref<TArray<UE.Actor>>) : boolean;
        static SphereOverlapComponents(WorldContextObject: $Nullable<UE.Object>, SpherePos: UE.Vector, SphereRadius: number, ObjectTypes: TArray<UE.EObjectTypeQuery>, ComponentClassFilter: $Nullable<UE.Class>, ActorsToIgnore: TArray<UE.Actor>, OutComponents: $Ref<TArray<UE.PrimitiveComponent>>) : boolean;
        static SphereTraceMulti(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, Radius: number, TraceChannel: UE.ETraceTypeQuery, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHits: $Ref<TArray<UE.HitResult>>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static SphereTraceMultiByProfile(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, Radius: number, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHits: $Ref<TArray<UE.HitResult>>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static SphereTraceMultiForObjects(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, Radius: number, ObjectTypes: TArray<UE.EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHits: $Ref<TArray<UE.HitResult>>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static SphereTraceSingle(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, Radius: number, TraceChannel: UE.ETraceTypeQuery, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHit: $Ref<UE.HitResult>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static SphereTraceSingleByProfile(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, Radius: number, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHit: $Ref<UE.HitResult>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static SphereTraceSingleForObjects(WorldContextObject: $Nullable<UE.Object>, Start: UE.Vector, End: UE.Vector, Radius: number, ObjectTypes: TArray<UE.EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<UE.Actor>, DrawDebugType: UE.EDrawDebugTrace, OutHit: $Ref<UE.HitResult>, bIgnoreSelf: boolean, TraceColor?: UE.LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: UE.LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */) : boolean;
        static StackTrace() : void;
        static TransactObject(Object: $Nullable<UE.Object>) : void;
        static UnloadPrimaryAsset(PrimaryAssetId: UE.PrimaryAssetId) : void;
        static UnloadPrimaryAssetList(PrimaryAssetIdList: TArray<UE.PrimaryAssetId>) : void;
        static UnregisterForRemoteNotifications() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetSystemLibrary;
        static Load(InName: string): KismetSystemLibrary;
    }
    
    class PolyglotTextData {
        constructor();
        constructor(Category: UE.ELocalizedTextSourceCategory, NativeCulture: string, Namespace: string, Key: string, NativeString: string, LocalizedStrings: TMap<string, string>, bIsMinimalPatch: boolean, CachedText: string);
        Category: UE.ELocalizedTextSourceCategory;
        NativeCulture: string;
        Namespace: string;
        Key: string;
        NativeString: string;
        LocalizedStrings: TMap<string, string>;
        bIsMinimalPatch: boolean;
        CachedText: string;
        static StaticClass(): Class;
    }
    
    enum EFormatArgumentType { Int, UInt, Float, Double, Text, Gender, EFormatArgumentType_MAX}
    enum ETextGender { Masculine, Feminine, Neuter, ETextGender_MAX}
    class FormatArgumentData {
        constructor();
        constructor(ArgumentName: string, ArgumentValueType: UE.EFormatArgumentType, ArgumentValue: string, ArgumentValueInt: number, ArgumentValueFloat: number, ArgumentValueGender: UE.ETextGender);
        ArgumentName: string;
        ArgumentValueType: UE.EFormatArgumentType;
        ArgumentValue: string;
        ArgumentValueInt: number;
        ArgumentValueFloat: number;
        ArgumentValueGender: UE.ETextGender;
        static StaticClass(): Class;
    }
    
    enum ERoundingMode { HalfToEven, HalfFromZero, HalfToZero, FromZero, ToZero, ToNegativeInfinity, ToPositiveInfinity, ERoundingMode_MAX}
    class KismetTextLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AsCurrency_Float(Value: number, RoundingMode: UE.ERoundingMode, bAlwaysSign?: boolean /* = false */, bUseGrouping?: boolean /* = true */, MinimumIntegralDigits?: number /* = 1 */, MaximumIntegralDigits?: number /* = 324 */, MinimumFractionalDigits?: number /* = 0 */, MaximumFractionalDigits?: number /* = 3 */, CurrencyCode?: string /* = "" */) : string;
        static AsCurrency_Integer(Value: number, RoundingMode: UE.ERoundingMode, bAlwaysSign?: boolean /* = false */, bUseGrouping?: boolean /* = true */, MinimumIntegralDigits?: number /* = 1 */, MaximumIntegralDigits?: number /* = 324 */, MinimumFractionalDigits?: number /* = 0 */, MaximumFractionalDigits?: number /* = 3 */, CurrencyCode?: string /* = "" */) : string;
        static AsCurrencyBase(BaseValue: number, CurrencyCode: string) : string;
        static AsDate_DateTime(InDateTime: UE.DateTime) : string;
        static AsDateTime_DateTime(In: UE.DateTime) : string;
        static AsPercent_Float(Value: number, RoundingMode: UE.ERoundingMode, bAlwaysSign?: boolean /* = false */, bUseGrouping?: boolean /* = true */, MinimumIntegralDigits?: number /* = 1 */, MaximumIntegralDigits?: number /* = 324 */, MinimumFractionalDigits?: number /* = 0 */, MaximumFractionalDigits?: number /* = 3 */) : string;
        static AsTime_DateTime(In: UE.DateTime) : string;
        static AsTimespan_Timespan(InTimespan: UE.Timespan) : string;
        static AsTimeZoneDate_DateTime(InDateTime: UE.DateTime, InTimeZone?: string /* = "" */) : string;
        static AsTimeZoneDateTime_DateTime(InDateTime: UE.DateTime, InTimeZone?: string /* = "" */) : string;
        static AsTimeZoneTime_DateTime(InDateTime: UE.DateTime, InTimeZone?: string /* = "" */) : string;
        static Conv_BoolToText(InBool: boolean) : string;
        static Conv_ByteToText(Value: number) : string;
        static Conv_ColorToText(InColor: UE.LinearColor) : string;
        static Conv_FloatToText(Value: number, RoundingMode: UE.ERoundingMode, bAlwaysSign?: boolean /* = false */, bUseGrouping?: boolean /* = true */, MinimumIntegralDigits?: number /* = 1 */, MaximumIntegralDigits?: number /* = 324 */, MinimumFractionalDigits?: number /* = 0 */, MaximumFractionalDigits?: number /* = 3 */) : string;
        static Conv_Int64ToText(Value: bigint, bAlwaysSign?: boolean /* = false */, bUseGrouping?: boolean /* = true */, MinimumIntegralDigits?: number /* = 1 */, MaximumIntegralDigits?: number /* = 324 */) : string;
        static Conv_IntToText(Value: number, bAlwaysSign?: boolean /* = false */, bUseGrouping?: boolean /* = true */, MinimumIntegralDigits?: number /* = 1 */, MaximumIntegralDigits?: number /* = 324 */) : string;
        static Conv_NameToText(InName: string) : string;
        static Conv_ObjectToText(InObj: $Nullable<UE.Object>) : string;
        static Conv_RotatorToText(InRot: UE.Rotator) : string;
        static Conv_StringToText(InString: string) : string;
        static Conv_TextToString(InText: string) : string;
        static Conv_TransformToText(InTrans: UE.Transform) : string;
        static Conv_Vector2dToText(InVec: UE.Vector2D) : string;
        static Conv_VectorToText(InVec: UE.Vector) : string;
        static EqualEqual_IgnoreCase_TextText(A: string, B: string) : boolean;
        static EqualEqual_TextText(A: string, B: string) : boolean;
        static FindTextInLocalizationTable(Namespace: string, Key: string, OutText: $Ref<string>) : boolean;
        static Format(InPattern: string, InArgs: TArray<UE.FormatArgumentData>) : string;
        static GetEmptyText() : string;
        static IsPolyglotDataValid(PolyglotData: UE.PolyglotTextData, IsValid: $Ref<boolean>, ErrorMessage: $Ref<string>) : void;
        static NotEqual_IgnoreCase_TextText(A: string, B: string) : boolean;
        static NotEqual_TextText(A: string, B: string) : boolean;
        static PolyglotDataToText(PolyglotData: UE.PolyglotTextData) : string;
        static StringTableIdAndKeyFromText(Text: string, OutTableId: $Ref<string>, OutKey: $Ref<string>) : boolean;
        static TextFromStringTable(TableId: string, Key: string) : string;
        static TextIsCultureInvariant(InText: string) : boolean;
        static TextIsEmpty(InText: string) : boolean;
        static TextIsFromStringTable(Text: string) : boolean;
        static TextIsTransient(InText: string) : boolean;
        static TextToLower(InText: string) : string;
        static TextToUpper(InText: string) : string;
        static TextTrimPreceding(InText: string) : string;
        static TextTrimPrecedingAndTrailing(InText: string) : string;
        static TextTrimTrailing(InText: string) : string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetTextLibrary;
        static Load(InName: string): KismetTextLibrary;
    }
    
    class LandscapeSplineSegmentConnection {
        constructor();
        constructor(ControlPoint: UE.LandscapeSplineControlPoint, TangentLen: number, SocketName: string);
        ControlPoint: UE.LandscapeSplineControlPoint;
        TangentLen: number;
        SocketName: string;
        static StaticClass(): Class;
    }
    
    enum LandscapeSplineMeshOrientation { LSMO_XUp, LSMO_YUp, LSMO_MAX}
    class LandscapeSplineMeshEntry {
        constructor();
        constructor(Mesh: UE.StaticMesh, MaterialOverrides: TArray<UE.MaterialInterface>, bCenterH: boolean, CenterAdjust: UE.Vector2D, bScaleToWidth: boolean, Scale: UE.Vector, Orientation: UE.LandscapeSplineMeshOrientation, ForwardAxis: UE.ESplineMeshAxis, UpAxis: UE.ESplineMeshAxis);
        Mesh: UE.StaticMesh;
        MaterialOverrides: TArray<UE.MaterialInterface>;
        bCenterH: boolean;
        CenterAdjust: UE.Vector2D;
        bScaleToWidth: boolean;
        Scale: UE.Vector;
        Orientation: UE.LandscapeSplineMeshOrientation;
        ForwardAxis: UE.ESplineMeshAxis;
        UpAxis: UE.ESplineMeshAxis;
        static StaticClass(): Class;
    }
    
    class LandscapeSplineInterpPoint {
        constructor();
        constructor(Center: UE.Vector, Left: UE.Vector, Right: UE.Vector, FalloffLeft: UE.Vector, FalloffRight: UE.Vector, LayerLeft: UE.Vector, LayerRight: UE.Vector, LayerFalloffLeft: UE.Vector, LayerFalloffRight: UE.Vector, StartEndFalloff: number);
        Center: UE.Vector;
        Left: UE.Vector;
        Right: UE.Vector;
        FalloffLeft: UE.Vector;
        FalloffRight: UE.Vector;
        LayerLeft: UE.Vector;
        LayerRight: UE.Vector;
        LayerFalloffLeft: UE.Vector;
        LayerFalloffRight: UE.Vector;
        StartEndFalloff: number;
        static StaticClass(): Class;
    }
    
    class LandscapeSplineSegment extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Connections: FixSizeArray<UE.LandscapeSplineSegmentConnection>;
        LayerName: string;
        bRaiseTerrain: boolean;
        bLowerTerrain: boolean;
        SplineMeshes: TArray<UE.LandscapeSplineMeshEntry>;
        bEnableCollision: boolean;
        CollisionProfileName: string;
        bCastShadow: boolean;
        RandomSeed: number;
        LDMaxDrawDistance: number;
        TranslucencySortPriority: number;
        bHiddenInGame: boolean;
        bPlaceSplineMeshesInStreamingLevels: boolean;
        RuntimeVirtualTextures: TArray<UE.RuntimeVirtualTexture>;
        VirtualTextureLodBias: number;
        VirtualTextureCullMips: number;
        VirtualTextureMainPassMaxDrawDistance: number;
        VirtualTextureRenderPassType: UE.ERuntimeVirtualTextureMainPassType;
        BodyInstance: UE.BodyInstance;
        bSelected: boolean;
        bNavDirty: boolean;
        SplineInfo: UE.InterpCurveVector;
        Points: TArray<UE.LandscapeSplineInterpPoint>;
        Bounds: UE.Box;
        LocalMeshComponents: TArray<UE.SplineMeshComponent>;
        ForeignWorlds: TArray<TSoftObjectPtr<UE.World>>;
        ModificationKey: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeSplineSegment;
        static Load(InName: string): LandscapeSplineSegment;
    }
    
    class LandscapeSplineConnection {
        constructor();
        constructor(Segment: UE.LandscapeSplineSegment, End: boolean);
        Segment: UE.LandscapeSplineSegment;
        End: boolean;
        static StaticClass(): Class;
    }
    
    class LandscapeSplineControlPoint extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Location: UE.Vector;
        Rotation: UE.Rotator;
        Width: number;
        LayerWidthRatio: number;
        SideFalloff: number;
        LeftSideFalloffFactor: number;
        RightSideFalloffFactor: number;
        LeftSideLayerFalloffFactor: number;
        RightSideLayerFalloffFactor: number;
        EndFalloff: number;
        SegmentMeshOffset: number;
        LayerName: string;
        bRaiseTerrain: boolean;
        bLowerTerrain: boolean;
        Mesh: UE.StaticMesh;
        MaterialOverrides: TArray<UE.MaterialInterface>;
        MeshScale: UE.Vector;
        bHiddenInGame: boolean;
        bEnableCollision: boolean;
        CollisionProfileName: string;
        bCastShadow: boolean;
        LDMaxDrawDistance: number;
        TranslucencySortPriority: number;
        bPlaceSplineMeshesInStreamingLevels: boolean;
        RuntimeVirtualTextures: TArray<UE.RuntimeVirtualTexture>;
        VirtualTextureLodBias: number;
        VirtualTextureCullMips: number;
        VirtualTextureMainPassMaxDrawDistance: number;
        VirtualTextureRenderPassType: UE.ERuntimeVirtualTextureMainPassType;
        BodyInstance: UE.BodyInstance;
        bSelected: boolean;
        bNavDirty: boolean;
        ConnectedSegments: TArray<UE.LandscapeSplineConnection>;
        Points: TArray<UE.LandscapeSplineInterpPoint>;
        Bounds: UE.Box;
        LocalMeshComponent: UE.ControlPointMeshComponent;
        ForeignWorld: TSoftObjectPtr<UE.World>;
        ModificationKey: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeSplineControlPoint;
        static Load(InName: string): LandscapeSplineControlPoint;
    }
    
    class ForeignControlPointData {
        constructor();
        constructor(ModificationKey: UE.Guid, MeshComponent: UE.ControlPointMeshComponent, Identifier: TLazyObjectPtr<UE.LandscapeSplineControlPoint>);
        ModificationKey: UE.Guid;
        MeshComponent: UE.ControlPointMeshComponent;
        Identifier: TLazyObjectPtr<UE.LandscapeSplineControlPoint>;
        static StaticClass(): Class;
    }
    
    class ForeignSplineSegmentData {
        constructor();
        constructor(ModificationKey: UE.Guid, MeshComponents: TArray<UE.SplineMeshComponent>, Identifier: TLazyObjectPtr<UE.LandscapeSplineSegment>);
        ModificationKey: UE.Guid;
        MeshComponents: TArray<UE.SplineMeshComponent>;
        Identifier: TLazyObjectPtr<UE.LandscapeSplineSegment>;
        static StaticClass(): Class;
    }
    
    class ForeignWorldSplineData {
        constructor();
        constructor(ForeignControlPointDataMap: TMap<TLazyObjectPtr<UE.LandscapeSplineControlPoint>, UE.ForeignControlPointData>, ForeignControlPointData: TArray<UE.ForeignControlPointData>, ForeignSplineSegmentDataMap: TMap<TLazyObjectPtr<UE.LandscapeSplineSegment>, UE.ForeignSplineSegmentData>, ForeignSplineSegmentData: TArray<UE.ForeignSplineSegmentData>);
        ForeignControlPointDataMap: TMap<TLazyObjectPtr<UE.LandscapeSplineControlPoint>, UE.ForeignControlPointData>;
        ForeignControlPointData: TArray<UE.ForeignControlPointData>;
        ForeignSplineSegmentDataMap: TMap<TLazyObjectPtr<UE.LandscapeSplineSegment>, UE.ForeignSplineSegmentData>;
        ForeignSplineSegmentData: TArray<UE.ForeignSplineSegmentData>;
        static StaticClass(): Class;
    }
    
    class LandscapeSplinesComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SplineResolution: number;
        SplineColor: UE.Color;
        ControlPointSprite: UE.Texture2D;
        SplineEditorMesh: UE.StaticMesh;
        bShowSplineEditorMesh: boolean;
        ControlPoints: TArray<UE.LandscapeSplineControlPoint>;
        Segments: TArray<UE.LandscapeSplineSegment>;
        ForeignWorldSplineDataMap: TMap<TSoftObjectPtr<UE.World>, UE.ForeignWorldSplineData>;
        CookedForeignMeshComponents: TArray<UE.MeshComponent>;
        GetSplineMeshComponents() : TArray<UE.SplineMeshComponent>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeSplinesComponent;
        static Load(InName: string): LandscapeSplinesComponent;
    }
    
    enum ELandscapeLODFalloff { Linear, SquareRoot, ELandscapeLODFalloff_MAX}
    enum ELandscapeLayerDisplayMode { Default, Alphabetical, UserSpecific, ELandscapeLayerDisplayMode_MAX}
    class LandscapeProxyMaterialOverride {
        constructor();
        constructor(LODIndex: UE.PerPlatformInt, Material: UE.MaterialInterface);
        LODIndex: UE.PerPlatformInt;
        Material: UE.MaterialInterface;
        static StaticClass(): Class;
    }
    
    class LandscapeComponentMaterialOverride {
        constructor();
        constructor(LODIndex: UE.PerPlatformInt, Material: UE.MaterialInterface);
        LODIndex: UE.PerPlatformInt;
        Material: UE.MaterialInterface;
        static StaticClass(): Class;
    }
    
    class MaterialInstanceConstant extends UE.MaterialInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterStateId: UE.Guid;
        K2_GetScalarParameterValue(ParameterName: string) : number;
        K2_GetTextureParameterValue(ParameterName: string) : UE.Texture;
        K2_GetVectorParameterValue(ParameterName: string) : UE.LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialInstanceConstant;
        static Load(InName: string): MaterialInstanceConstant;
    }
    
    enum ESplineModulationColorMask { Red, Green, Blue, Alpha, ESplineModulationColorMask_MAX}
    class LandscapeLayerInfoObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LayerName: string;
        PhysMaterial: UE.PhysicalMaterial;
        Hardness: number;
        bNoWeightBlend: boolean;
        SplineFalloffModulationTexture: UE.Texture2D;
        SplineFalloffModulationColorMask: UE.ESplineModulationColorMask;
        SplineFalloffModulationTiling: number;
        SplineFalloffModulationBias: number;
        SplineFalloffModulationScale: number;
        IsReferencedFromLoadedData: boolean;
        LayerUsageDebugColor: UE.LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeLayerInfoObject;
        static Load(InName: string): LandscapeLayerInfoObject;
    }
    
    class LandscapeHeightfieldCollisionComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ComponentLayerInfos: TArray<UE.LandscapeLayerInfoObject>;
        SectionBaseX: number;
        SectionBaseY: number;
        CollisionSizeQuads: number;
        CollisionScale: number;
        SimpleCollisionSizeQuads: number;
        CollisionQuadFlags: TArray<number>;
        HeightfieldGuid: UE.Guid;
        CachedLocalBox: UE.Box;
        RenderComponent: TLazyObjectPtr<UE.LandscapeComponent>;
        CookedPhysicalMaterials: TArray<UE.PhysicalMaterial>;
        GetRenderComponent() : UE.LandscapeComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeHeightfieldCollisionComponent;
        static Load(InName: string): LandscapeHeightfieldCollisionComponent;
    }
    
    class HeightmapData {
        constructor();
        constructor(Texture: UE.Texture2D);
        Texture: UE.Texture2D;
        static StaticClass(): Class;
    }
    
    class WeightmapLayerAllocationInfo {
        constructor();
        constructor(LayerInfo: UE.LandscapeLayerInfoObject, WeightmapTextureIndex: number, WeightmapTextureChannel: number);
        LayerInfo: UE.LandscapeLayerInfoObject;
        WeightmapTextureIndex: number;
        WeightmapTextureChannel: number;
        static StaticClass(): Class;
    }
    
    class LandscapeWeightmapUsage extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChannelUsage: FixSizeArray<UE.LandscapeComponent>;
        LayerGuid: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeWeightmapUsage;
        static Load(InName: string): LandscapeWeightmapUsage;
    }
    
    class WeightmapData {
        constructor();
        constructor(Textures: TArray<UE.Texture2D>, LayerAllocations: TArray<UE.WeightmapLayerAllocationInfo>, TextureUsages: TArray<UE.LandscapeWeightmapUsage>);
        Textures: TArray<UE.Texture2D>;
        LayerAllocations: TArray<UE.WeightmapLayerAllocationInfo>;
        TextureUsages: TArray<UE.LandscapeWeightmapUsage>;
        static StaticClass(): Class;
    }
    
    class LandscapeLayerComponentData {
        constructor();
        constructor(HeightmapData: UE.HeightmapData, WeightmapData: UE.WeightmapData);
        HeightmapData: UE.HeightmapData;
        WeightmapData: UE.WeightmapData;
        static StaticClass(): Class;
    }
    
    class LandscapeEditToolRenderData {
        constructor();
        constructor(ToolMaterial: UE.MaterialInterface, GizmoMaterial: UE.MaterialInterface, SelectedType: number, DebugChannelR: number, DebugChannelG: number, DebugChannelB: number, DataTexture: UE.Texture2D, LayerContributionTexture: UE.Texture2D, DirtyTexture: UE.Texture2D);
        ToolMaterial: UE.MaterialInterface;
        GizmoMaterial: UE.MaterialInterface;
        SelectedType: number;
        DebugChannelR: number;
        DebugChannelG: number;
        DebugChannelB: number;
        DataTexture: UE.Texture2D;
        LayerContributionTexture: UE.Texture2D;
        DirtyTexture: UE.Texture2D;
        static StaticClass(): Class;
    }
    
    class LandscapeComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SectionBaseX: number;
        SectionBaseY: number;
        ComponentSizeQuads: number;
        SubsectionSizeQuads: number;
        NumSubsections: number;
        OverrideMaterial: UE.MaterialInterface;
        OverrideHoleMaterial: UE.MaterialInterface;
        OverrideMaterials: TArray<UE.LandscapeComponentMaterialOverride>;
        MaterialInstance: UE.MaterialInstanceConstant;
        MaterialInstances: TArray<UE.MaterialInstanceConstant>;
        MaterialInstancesDynamic: TArray<UE.MaterialInstanceDynamic>;
        LODIndexToMaterialIndex: TArray<number>;
        MaterialIndexToDisabledTessellationMaterial: TArray<number>;
        XYOffsetmapTexture: UE.Texture2D;
        WeightmapScaleBias: UE.Vector4;
        WeightmapSubsectionOffset: number;
        HeightmapScaleBias: UE.Vector4;
        CachedLocalBox: UE.Box;
        CollisionComponent: TLazyObjectPtr<UE.LandscapeHeightfieldCollisionComponent>;
        LightingGuid: UE.Guid;
        LayersData: TMap<UE.Guid, UE.LandscapeLayerComponentData>;
        WeightmapTexturesUsage: TArray<UE.LandscapeWeightmapUsage>;
        LayerUpdateFlagPerMode: number;
        HeightmapTexture: UE.Texture2D;
        WeightmapLayerAllocations: TArray<UE.WeightmapLayerAllocationInfo>;
        WeightmapTextures: TArray<UE.Texture2D>;
        MapBuildDataId: UE.Guid;
        IrrelevantLights: TArray<UE.Guid>;
        CollisionMipLevel: number;
        SimpleCollisionMipLevel: number;
        NegativeZBoundsExtension: number;
        PositiveZBoundsExtension: number;
        StaticLightingResolution: number;
        ForcedLOD: number;
        LODBias: number;
        StateId: UE.Guid;
        BakedTextureMaterialGuid: UE.Guid;
        GIBakedBaseColorTexture: UE.Texture2D;
        LightingLODBias: number;
        LayerWhitelist: TArray<UE.LandscapeLayerInfoObject>;
        EditToolRenderData: UE.LandscapeEditToolRenderData;
        MobileDataSourceHash: UE.Guid;
        MaterialPerLOD: TMap<UE.MaterialInterface, number>;
        SplineHash: number;
        MobileBlendableLayerMask: number;
        MobileMaterialInterface: UE.MaterialInterface;
        MobileMaterialInterfaces: TArray<UE.MaterialInterface>;
        MobileWeightmapTextures: TArray<UE.Texture2D>;
        MobileCombinationMaterialInstances: TArray<UE.MaterialInstanceConstant>;
        MobileCombinationMaterialInstance: UE.MaterialInstanceConstant;
        EditorGetPaintLayerWeightAtLocation(InLocation: UE.Vector, PaintLayer: $Nullable<UE.LandscapeLayerInfoObject>) : number;
        EditorGetPaintLayerWeightByNameAtLocation(InLocation: UE.Vector, InPaintLayerName: string) : number;
        GetMaterialInstanceDynamic(InIndex: number) : UE.MaterialInstanceDynamic;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeComponent;
        static Load(InName: string): LandscapeComponent;
    }
    
    class LandscapeEditorLayerSettings {
        constructor();
        constructor(LayerInfoObj: UE.LandscapeLayerInfoObject, ReimportLayerFilePath: string);
        LayerInfoObj: UE.LandscapeLayerInfoObject;
        ReimportLayerFilePath: string;
        static StaticClass(): Class;
    }
    
    class LandscapeProxy extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SplineComponent: UE.LandscapeSplinesComponent;
        LandscapeGuid: UE.Guid;
        LandscapeSectionOffset: UE.IntPoint;
        MaxLODLevel: number;
        LODDistanceFactor: number;
        LODFalloff: UE.ELandscapeLODFalloff;
        ComponentScreenSizeToUseSubSections: number;
        LOD0ScreenSize: number;
        LOD0DistributionSetting: number;
        LODDistributionSetting: number;
        TessellationComponentScreenSize: number;
        UseTessellationComponentScreenSizeFalloff: boolean;
        TessellationComponentScreenSizeFalloff: number;
        OccluderGeometryLOD: number;
        ExportLOD: number;
        TargetDisplayOrderList: TArray<string>;
        TargetDisplayOrder: UE.ELandscapeLayerDisplayMode;
        StaticLightingLOD: number;
        DefaultPhysMaterial: UE.PhysicalMaterial;
        StreamingDistanceMultiplier: number;
        LandscapeMaterial: UE.MaterialInterface;
        LandscapeHoleMaterial: UE.MaterialInterface;
        LandscapeMaterialsOverride: TArray<UE.LandscapeProxyMaterialOverride>;
        PreEditLandscapeMaterial: UE.MaterialInterface;
        PreEditLandscapeHoleMaterial: UE.MaterialInterface;
        PreEditLandscapeMaterialsOverride: TArray<UE.LandscapeProxyMaterialOverride>;
        bIsPerformingInteractiveActionOnLandscapeMaterialOverride: boolean;
        RuntimeVirtualTextures: TArray<UE.RuntimeVirtualTexture>;
        VirtualTextureNumLods: number;
        VirtualTextureLodBias: number;
        VirtualTextureRenderPassType: UE.ERuntimeVirtualTextureMainPassType;
        NegativeZBoundsExtension: number;
        PositiveZBoundsExtension: number;
        LandscapeComponents: TArray<UE.LandscapeComponent>;
        CollisionComponents: TArray<UE.LandscapeHeightfieldCollisionComponent>;
        FoliageComponents: TArray<UE.HierarchicalInstancedStaticMeshComponent>;
        bHasLandscapeGrass: boolean;
        StaticLightingResolution: number;
        bCastStaticShadow: boolean;
        bCastShadowAsTwoSided: boolean;
        bCastFarShadow: boolean;
        bAffectDistanceFieldLighting: boolean;
        LightingChannels: UE.LightingChannels;
        bUseMaterialPositionOffsetInStaticLighting: boolean;
        bRenderCustomDepth: boolean;
        CustomDepthStencilValue: number;
        LDMaxDrawDistance: number;
        bIsMovingToLevel: boolean;
        LightmassSettings: UE.LightmassPrimitiveSettings;
        CollisionMipLevel: number;
        SimpleCollisionMipLevel: number;
        CollisionThickness: number;
        BodyInstance: UE.BodyInstance;
        bGenerateOverlapEvents: boolean;
        bBakeMaterialPositionOffsetIntoCollision: boolean;
        EditorCachedLayerInfos: TArray<UE.LandscapeLayerInfoObject>;
        ReimportHeightmapFilePath: string;
        EditorLayerSettings: TArray<UE.LandscapeEditorLayerSettings>;
        ComponentSizeQuads: number;
        SubsectionSizeQuads: number;
        NumSubsections: number;
        bUsedForNavigation: boolean;
        bUseDynamicMaterialInstance: boolean;
        NavigationGeometryGatheringMode: UE.ENavDataGatheringMode;
        MaxPaintedLayersPerComponent: number;
        bUseLandscapeForCullingInvisibleHLODVertices: boolean;
        bHasLayersContent: boolean;
        WeightmapUsageMap: TMap<UE.Texture2D, UE.LandscapeWeightmapUsage>;
        ChangeComponentScreenSizeToUseSubSections(InComponentScreenSizeToUseSubSections: number) : void;
        ChangeLODDistanceFactor(InLODDistanceFactor: number) : void;
        ChangeTessellationComponentScreenSize(InTessellationComponentScreenSize: number) : void;
        ChangeTessellationComponentScreenSizeFalloff(InUseTessellationComponentScreenSizeFalloff: number) : void;
        ChangeUseTessellationComponentScreenSizeFalloff(InComponentScreenSizeToUseSubSections: boolean) : void;
        EditorApplySpline(InSplineComponent: $Nullable<UE.SplineComponent>, StartWidth?: number /* = 200.000000 */, EndWidth?: number /* = 200.000000 */, StartSideFalloff?: number /* = 200.000000 */, EndSideFalloff?: number /* = 200.000000 */, StartRoll?: number /* = 0.000000 */, EndRoll?: number /* = 0.000000 */, NumSubdivisions?: number /* = 20 */, bRaiseHeights?: boolean /* = true */, bLowerHeights?: boolean /* = true */, PaintLayer?: UE.LandscapeLayerInfoObject /* = None */) : void;
        EditorSetLandscapeMaterial(NewLandscapeMaterial: $Nullable<UE.MaterialInterface>) : void;
        LandscapeExportHeightmapToRenderTarget(InRenderTarget: $Nullable<UE.TextureRenderTarget2D>, InExportHeightIntoRGChannel?: boolean /* = false */) : boolean;
        LandscapeExportWeightmapToRenderTarget(InRenderTarget: $Nullable<UE.TextureRenderTarget2D>, InLayerName: string) : boolean;
        LandscapeImportHeightmapFromRenderTarget(InRenderTarget: $Nullable<UE.TextureRenderTarget2D>, InImportHeightFromRGChannel?: boolean /* = false */) : boolean;
        LandscapeImportWeightmapFromRenderTarget(InRenderTarget: $Nullable<UE.TextureRenderTarget2D>, InLayerName: string) : boolean;
        SetLandscapeMaterialScalarParameterValue(ParameterName: string, Value: number) : void;
        SetLandscapeMaterialTextureParameterValue(ParameterName: string, Value: $Nullable<UE.Texture>) : void;
        SetLandscapeMaterialVectorParameterValue(ParameterName: string, Value: UE.LinearColor) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeProxy;
        static Load(InName: string): LandscapeProxy;
    }
    
    enum ELandscapeBlendMode { LSBM_AdditiveBlend, LSBM_AlphaBlend, LSBM_MAX}
    class LandscapeBlueprintBrushBase extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OwningLandscape: UE.Landscape;
        AffectHeightmap: boolean;
        AffectWeightmap: boolean;
        AffectedWeightmapLayers: TArray<string>;
        bIsVisible: boolean;
        GetBlueprintRenderDependencies(OutStreamableAssets: $Ref<TArray<UE.Texture2D>>) : void;
        Initialize(InLandscapeTransform: UE.Transform, InLandscapeSize: UE.IntPoint, InLandscapeRenderTargetSize: UE.IntPoint) : void;
        Render(InIsHeightmap: boolean, InCombinedResult: $Nullable<UE.TextureRenderTarget2D>, InWeightmapLayerName: string) : UE.TextureRenderTarget2D;
        RequestLandscapeUpdate() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeBlueprintBrushBase;
        static Load(InName: string): LandscapeBlueprintBrushBase;
    }
    
    class LandscapeLayerBrush {
        constructor();
        constructor(BlueprintBrush: UE.LandscapeBlueprintBrushBase);
        BlueprintBrush: UE.LandscapeBlueprintBrushBase;
        static StaticClass(): Class;
    }
    
    class LandscapeLayer {
        constructor();
        constructor(Guid: UE.Guid, Name: string, bVisible: boolean, bLocked: boolean, HeightmapAlpha: number, WeightmapAlpha: number, BlendMode: UE.ELandscapeBlendMode, Brushes: TArray<UE.LandscapeLayerBrush>, WeightmapLayerAllocationBlend: TMap<UE.LandscapeLayerInfoObject, boolean>);
        Guid: UE.Guid;
        Name: string;
        bVisible: boolean;
        bLocked: boolean;
        HeightmapAlpha: number;
        WeightmapAlpha: number;
        BlendMode: UE.ELandscapeBlendMode;
        Brushes: TArray<UE.LandscapeLayerBrush>;
        WeightmapLayerAllocationBlend: TMap<UE.LandscapeLayerInfoObject, boolean>;
        static StaticClass(): Class;
    }
    
    class Landscape extends UE.LandscapeProxy {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCanHaveLayersContent: boolean;
        LandscapeSplinesTargetLayerGuid: UE.Guid;
        LandscapeLayers: TArray<UE.LandscapeLayer>;
        HeightmapRTList: TArray<UE.TextureRenderTarget2D>;
        WeightmapRTList: TArray<UE.TextureRenderTarget2D>;
        LandscapeSplinesAffectedComponents: TSet<UE.LandscapeComponent>;
        bLandscapeLayersAreInitialized: boolean;
        WasCompilingShaders: boolean;
        LayerContentUpdateModes: number;
        bSplineLayerUpdateRequested: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Landscape;
        static Load(InName: string): Landscape;
    }
    
    class LandscapeBlueprintBrush extends UE.LandscapeBlueprintBrushBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeBlueprintBrush;
        static Load(InName: string): LandscapeBlueprintBrush;
    }
    
    enum ELandscapeToolFlattenMode { Invalid, Both, Raise, Lower, Interval, Terrace, ELandscapeToolFlattenMode_MAX}
    enum ELandscapeToolErosionMode { Invalid, Both, Raise, Lower, ELandscapeToolErosionMode_MAX}
    enum ELandscapeToolHydroErosionMode { Invalid, Both, Positive, ELandscapeToolHydroErosionMode_MAX}
    enum ELandscapeToolNoiseMode { Invalid, Both, Add, Sub, ELandscapeToolNoiseMode_MAX}
    enum ELandscapeToolPasteMode { Invalid, Both, Raise, Lower, ELandscapeToolPasteMode_MAX}
    class GizmoImportLayer {
        constructor();
        constructor(LayerFilename: string, LayerName: string, bNoImport: boolean);
        LayerFilename: string;
        LayerName: string;
        bNoImport: boolean;
        static StaticClass(): Class;
    }
    
    enum ELandscapeMirrorOperation { MinusXToPlusX, PlusXToMinusX, MinusYToPlusY, PlusYToMinusY, RotateMinusXToPlusX, RotatePlusXToMinusX, RotateMinusYToPlusY, RotatePlusYToMinusY, ELandscapeMirrorOperation_MAX}
    enum ELandscapeConvertMode { Invalid, Expand, Clip, Resample, ELandscapeConvertMode_MAX}
    enum ELandscapeImportResult { Success, Warning, Error, ELandscapeImportResult_MAX}
    enum ELandscapeImportAlphamapType { Additive, Layered, ELandscapeImportAlphamapType_MAX}
    class LandscapeImportLayerInfo {
        constructor();
        constructor(LayerName: string, LayerInfo: UE.LandscapeLayerInfoObject, SourceFilePath: string);
        LayerName: string;
        LayerInfo: UE.LandscapeLayerInfoObject;
        SourceFilePath: string;
        static StaticClass(): Class;
    }
    
    class LandscapeMaterialInstanceConstant extends UE.MaterialInstanceConstant {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsLayerThumbnail: boolean;
        bDisableTessellation: boolean;
        bMobile: boolean;
        bEditorToolUsage: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeMaterialInstanceConstant;
        static Load(InName: string): LandscapeMaterialInstanceConstant;
    }
    
    class LandscapeImportLayer extends UE.LandscapeImportLayerInfo {
        constructor();
        constructor(ThumbnailMIC: UE.LandscapeMaterialInstanceConstant, ImportResult: UE.ELandscapeImportResult, ErrorMessage: string);
        ThumbnailMIC: UE.LandscapeMaterialInstanceConstant;
        ImportResult: UE.ELandscapeImportResult;
        ErrorMessage: string;
        static StaticClass(): Class;
    }
    
    class LandscapePatternBrushWorldSpaceSettings {
        constructor();
        constructor(Origin: UE.Vector2D, Rotation: number, bCenterTextureOnOrigin: boolean, RepeatSize: number);
        Origin: UE.Vector2D;
        Rotation: number;
        bCenterTextureOnOrigin: boolean;
        RepeatSize: number;
        static StaticClass(): Class;
    }
    
    enum EColorChannel { Red, Green, Blue, Alpha, EColorChannel_MAX}
    enum ELandscapeLayerPaintingRestriction { None, UseMaxLayers, ExistingOnly, UseComponentWhitelist, ELandscapeLayerPaintingRestriction_MAX}
    class LandscapeEditorObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ToolStrength: number;
        bUseWeightTargetValue: boolean;
        WeightTargetValue: number;
        MaximumValueRadius: number;
        bCombinedLayersOperation: boolean;
        FlattenMode: UE.ELandscapeToolFlattenMode;
        bUseSlopeFlatten: boolean;
        bPickValuePerApply: boolean;
        bUseFlattenTarget: boolean;
        FlattenTarget: number;
        bShowFlattenTargetPreview: boolean;
        TerraceInterval: number;
        TerraceSmooth: number;
        bFlattenEyeDropperModeActivated: boolean;
        FlattenEyeDropperModeDesiredTarget: number;
        RampWidth: number;
        RampSideFalloff: number;
        SmoothFilterKernelSize: number;
        bDetailSmooth: boolean;
        DetailScale: number;
        ErodeThresh: number;
        ErodeSurfaceThickness: number;
        ErodeIterationNum: number;
        ErosionNoiseMode: UE.ELandscapeToolErosionMode;
        ErosionNoiseScale: number;
        RainAmount: number;
        SedimentCapacity: number;
        HErodeIterationNum: number;
        RainDistMode: UE.ELandscapeToolHydroErosionMode;
        RainDistScale: number;
        bHErosionDetailSmooth: boolean;
        HErosionDetailScale: number;
        NoiseMode: UE.ELandscapeToolNoiseMode;
        NoiseScale: number;
        bUseSelectedRegion: boolean;
        bUseNegativeMask: boolean;
        PasteMode: UE.ELandscapeToolPasteMode;
        bApplyToAllTargets: boolean;
        bSnapGizmo: boolean;
        bSmoothGizmoBrush: boolean;
        GizmoHeightmapFilenameString: string;
        GizmoImportSize: UE.IntPoint;
        GizmoImportLayers: TArray<UE.GizmoImportLayer>;
        MirrorPoint: UE.Vector2D;
        MirrorOp: UE.ELandscapeMirrorOperation;
        MirrorSmoothingWidth: number;
        BlueprintBrush: UE.Class;
        ResizeLandscape_QuadsPerSection: number;
        ResizeLandscape_SectionsPerComponent: number;
        ResizeLandscape_ComponentCount: UE.IntPoint;
        ResizeLandscape_ConvertMode: UE.ELandscapeConvertMode;
        NewLandscape_Material: TWeakObjectPtr<UE.MaterialInterface>;
        NewLandscape_QuadsPerSection: number;
        NewLandscape_SectionsPerComponent: number;
        NewLandscape_ComponentCount: UE.IntPoint;
        NewLandscape_Location: UE.Vector;
        NewLandscape_Rotation: UE.Rotator;
        NewLandscape_Scale: UE.Vector;
        ImportLandscape_HeightmapImportResult: UE.ELandscapeImportResult;
        ImportLandscape_HeightmapErrorMessage: string;
        ImportLandscape_HeightmapFilename: string;
        ImportLandscape_Width: number;
        ImportLandscape_Height: number;
        ImportLandscape_Data: TArray<number>;
        bCanHaveLayersContent: boolean;
        ImportLandscape_AlphamapType: UE.ELandscapeImportAlphamapType;
        ImportLandscape_Layers: TArray<UE.LandscapeImportLayer>;
        BrushRadius: number;
        BrushFalloff: number;
        bUseClayBrush: boolean;
        AlphaBrushScale: number;
        bAlphaBrushAutoRotate: boolean;
        AlphaBrushRotation: number;
        AlphaBrushPanU: number;
        AlphaBrushPanV: number;
        bUseWorldSpacePatternBrush: boolean;
        WorldSpacePatternBrushSettings: UE.LandscapePatternBrushWorldSpaceSettings;
        AlphaTexture: UE.Texture2D;
        AlphaTextureChannel: UE.EColorChannel;
        AlphaTextureSizeX: number;
        AlphaTextureSizeY: number;
        AlphaTextureData: TArray<number>;
        BrushComponentSize: number;
        PaintingRestriction: UE.ELandscapeLayerPaintingRestriction;
        TargetDisplayOrder: UE.ELandscapeLayerDisplayMode;
        ShowUnusedLayers: boolean;
        CurrentLayerIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeEditorObject;
        static Load(InName: string): LandscapeEditorObject;
    }
    
    class LandscapeInfoLayerSettings {
        constructor();
        constructor(LayerInfoObj: UE.LandscapeLayerInfoObject, LayerName: string, ThumbnailMIC: UE.MaterialInstanceConstant, Owner: UE.LandscapeProxy, DebugColorChannel: number, bValid: boolean);
        LayerInfoObj: UE.LandscapeLayerInfoObject;
        LayerName: string;
        ThumbnailMIC: UE.MaterialInstanceConstant;
        Owner: UE.LandscapeProxy;
        DebugColorChannel: number;
        bValid: boolean;
        static StaticClass(): Class;
    }
    
    class LandscapeStreamingProxy extends UE.LandscapeProxy {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LandscapeActor: TLazyObjectPtr<UE.Landscape>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeStreamingProxy;
        static Load(InName: string): LandscapeStreamingProxy;
    }
    
    class LandscapeInfo extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LandscapeActor: TLazyObjectPtr<UE.Landscape>;
        LandscapeGuid: UE.Guid;
        ComponentSizeQuads: number;
        SubsectionSizeQuads: number;
        ComponentNumSubsections: number;
        DrawScale: UE.Vector;
        Layers: TArray<UE.LandscapeInfoLayerSettings>;
        Proxies: TArray<UE.LandscapeStreamingProxy>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeInfo;
        static Load(InName: string): LandscapeInfo;
    }
    
    class LandscapeGizmoActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Width: number;
        Height: number;
        LengthZ: number;
        MarginZ: number;
        MinRelativeZ: number;
        RelativeScaleZ: number;
        TargetLandscapeInfo: UE.LandscapeInfo;
        SpriteComponent: UE.BillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeGizmoActor;
        static Load(InName: string): LandscapeGizmoActor;
    }
    
    enum ELandscapeGizmoType { LGT_None, LGT_Height, LGT_Weight, LGT_MAX}
    class LandscapeGizmoActiveActor extends UE.LandscapeGizmoActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DataType: UE.ELandscapeGizmoType;
        GizmoTexture: UE.Texture2D;
        TextureScale: UE.Vector2D;
        SampledHeight: TArray<UE.Vector>;
        SampledNormal: TArray<UE.Vector>;
        SampleSizeX: number;
        SampleSizeY: number;
        CachedWidth: number;
        CachedHeight: number;
        CachedScaleXY: number;
        FrustumVerts: FixSizeArray<UE.Vector>;
        GizmoMaterial: UE.Material;
        GizmoDataMaterial: UE.MaterialInstance;
        GizmoMeshMaterial: UE.Material;
        LayerInfos: TArray<UE.LandscapeLayerInfoObject>;
        bSnapToLandscapeGrid: boolean;
        UnsnappedRotation: UE.Rotator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeGizmoActiveActor;
        static Load(InName: string): LandscapeGizmoActiveActor;
    }
    
    class LandscapeGizmoRenderComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeGizmoRenderComponent;
        static Load(InName: string): LandscapeGizmoRenderComponent;
    }
    
    enum EGrassScaling { Uniform, Free, LockXY, EGrassScaling_MAX}
    class GrassVariety {
        constructor();
        constructor(GrassMesh: UE.StaticMesh, GrassDensity: UE.PerPlatformFloat, bUseGrid: boolean, PlacementJitter: number, StartCullDistance: UE.PerPlatformInt, EndCullDistance: UE.PerPlatformInt, MinLOD: number, Scaling: UE.EGrassScaling, ScaleX: UE.FloatInterval, ScaleY: UE.FloatInterval, ScaleZ: UE.FloatInterval, RandomRotation: boolean, AlignToSurface: boolean, bUseLandscapeLightmap: boolean, LightingChannels: UE.LightingChannels, bReceivesDecals: boolean, bCastDynamicShadow: boolean, bKeepInstanceBufferCPUCopy: boolean);
        GrassMesh: UE.StaticMesh;
        GrassDensity: UE.PerPlatformFloat;
        bUseGrid: boolean;
        PlacementJitter: number;
        StartCullDistance: UE.PerPlatformInt;
        EndCullDistance: UE.PerPlatformInt;
        MinLOD: number;
        Scaling: UE.EGrassScaling;
        ScaleX: UE.FloatInterval;
        ScaleY: UE.FloatInterval;
        ScaleZ: UE.FloatInterval;
        RandomRotation: boolean;
        AlignToSurface: boolean;
        bUseLandscapeLightmap: boolean;
        LightingChannels: UE.LightingChannels;
        bReceivesDecals: boolean;
        bCastDynamicShadow: boolean;
        bKeepInstanceBufferCPUCopy: boolean;
        static StaticClass(): Class;
    }
    
    class LandscapeGrassType extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GrassVarieties: TArray<UE.GrassVariety>;
        bEnableDensityScaling: boolean;
        GrassMesh: UE.StaticMesh;
        GrassDensity: number;
        PlacementJitter: number;
        StartCullDistance: number;
        EndCullDistance: number;
        RandomRotation: boolean;
        AlignToSurface: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeGrassType;
        static Load(InName: string): LandscapeGrassType;
    }
    
    class LandscapeGrassTypeFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeGrassTypeFactory;
        static Load(InName: string): LandscapeGrassTypeFactory;
    }
    
    class LandscapeInfoMap extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeInfoMap;
        static Load(InName: string): LandscapeInfoMap;
    }
    
    class LandscapeMeshCollisionComponent extends UE.LandscapeHeightfieldCollisionComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MeshGuid: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeMeshCollisionComponent;
        static Load(InName: string): LandscapeMeshCollisionComponent;
    }
    
    class LandscapeMeshProxyComponent extends UE.StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LandscapeGuid: UE.Guid;
        ProxyComponentBases: TArray<UE.IntPoint>;
        ProxyLOD: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeMeshProxyComponent;
        static Load(InName: string): LandscapeMeshProxyComponent;
    }
    
    class LandscapeMeshProxyActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LandscapeMeshProxyComponent: UE.LandscapeMeshProxyComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeMeshProxyActor;
        static Load(InName: string): LandscapeMeshProxyActor;
    }
    
    class LandscapePlaceholder extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapePlaceholder;
        static Load(InName: string): LandscapePlaceholder;
    }
    
    class LandscapeSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxNumberOfLayers: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeSettings;
        static Load(InName: string): LandscapeSettings;
    }
    
    class LatentActionState extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LatentActionCallback: $Delegate<() => void>;
        GetLatentActionInfo() : UE.LatentActionInfo;
        OnLatentActionCompleted(LinkID: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LatentActionState;
        static Load(InName: string): LatentActionState;
    }
    
    class ActorLayer {
        constructor();
        constructor(Name: string);
        Name: string;
        static StaticClass(): Class;
    }
    
    class LayersBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AddActorToLayer(InActor: $Nullable<UE.Actor>, Layer: UE.ActorLayer) : void;
        static GetActors(WorldContextObject: $Nullable<UE.Object>, ActorLayer: UE.ActorLayer) : TArray<UE.Actor>;
        static RemoveActorFromLayer(InActor: $Nullable<UE.Actor>, Layer: UE.ActorLayer) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LayersBlueprintLibrary;
        static Load(InName: string): LayersBlueprintLibrary;
    }
    
    class LayersSubsystem extends UE.EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddActorsToLayer(Actors: TArray<UE.Actor>, LayerName: string) : boolean;
        AddActorsToLayers(Actors: TArray<UE.Actor>, LayerNames: TArray<string>) : boolean;
        AddActorToLayer(Actor: $Nullable<UE.Actor>, LayerName: string) : boolean;
        AddActorToLayers(Actor: $Nullable<UE.Actor>, LayerNames: TArray<string>) : boolean;
        AddAllLayerNamesTo(OutLayerNames: $Ref<TArray<string>>) : void;
        AddAllLayersTo(OutLayers: $Ref<TArray<UE.Layer>>) : void;
        AddLevelLayerInformation(Level: $Nullable<UE.Level>) : void;
        AddSelectedActorsToLayer(LayerName: string) : boolean;
        AddSelectedActorsToLayers(LayerNames: TArray<string>) : boolean;
        AppendActorsFromLayer(LayerName: string, InOutActors: $Ref<TArray<UE.Actor>>) : void;
        AppendActorsFromLayers(LayerNames: TArray<string>, InOutActors: $Ref<TArray<UE.Actor>>) : void;
        CreateLayer(LayerName: string) : UE.Layer;
        DeleteLayer(LayerToDelete: string) : void;
        DeleteLayers(LayersToDelete: TArray<string>) : void;
        DisassociateActorFromLayers(Actor: $Nullable<UE.Actor>) : boolean;
        EditorMapChange() : void;
        EditorRefreshLayerBrowser() : void;
        GetActorsFromLayer(LayerName: string) : TArray<UE.Actor>;
        GetActorsFromLayers(LayerNames: TArray<string>) : TArray<UE.Actor>;
        GetLayer(LayerName: string) : UE.Layer;
        GetSelectedActors() : TArray<UE.Actor>;
        GetWorld() : UE.World;
        /**
         * @deprecated Unsupported super overloads.
         */
        GetWorld() : World;
        InitializeNewActorLayers(Actor: $Nullable<UE.Actor>) : boolean;
        IsActorValidForLayer(Actor: $Nullable<UE.Actor>) : boolean;
        IsLayer(LayerName: string) : boolean;
        MakeAllLayersVisible() : void;
        RemoveActorFromLayer(Actor: $Nullable<UE.Actor>, LayerToRemove: string, bUpdateStats?: boolean /* = true */) : boolean;
        RemoveActorFromLayers(Actor: $Nullable<UE.Actor>, LayerNames: TArray<string>, bUpdateStats?: boolean /* = true */) : boolean;
        RemoveActorsFromLayer(Actors: TArray<UE.Actor>, LayerName: string, bUpdateStats?: boolean /* = true */) : boolean;
        RemoveActorsFromLayers(Actors: TArray<UE.Actor>, LayerNames: TArray<string>, bUpdateStats?: boolean /* = true */) : boolean;
        RemoveLevelLayerInformation(Level: $Nullable<UE.Level>) : void;
        RemoveSelectedActorsFromLayer(LayerName: string) : boolean;
        RemoveSelectedActorsFromLayers(LayerNames: TArray<string>) : boolean;
        RenameLayer(OriginalLayerName: string, NewLayerName: string) : boolean;
        SelectActorsInLayer(LayerName: string, bSelect: boolean, bNotify: boolean, bSelectEvenIfHidden?: boolean /* = false */) : boolean;
        SelectActorsInLayers(LayerNames: TArray<string>, bSelect: boolean, bNotify: boolean, bSelectEvenIfHidden?: boolean /* = false */) : boolean;
        SetLayersVisibility(LayerNames: TArray<string>, bIsVisible: boolean) : void;
        SetLayerVisibility(LayerName: string, bIsVisible: boolean) : void;
        ToggleLayersVisibility(LayerNames: TArray<string>) : void;
        ToggleLayerVisibility(LayerName: string) : void;
        TryGetLayer(LayerName: string, OutLayer: $Ref<UE.Layer>) : boolean;
        UpdateActorAllViewsVisibility(Actor: $Nullable<UE.Actor>) : void;
        UpdateActorVisibility(Actor: $Nullable<UE.Actor>, bOutSelectionChanged: $Ref<boolean>, bOutActorModified: $Ref<boolean>, bNotifySelectionChange: boolean, bRedrawViewports: boolean) : boolean;
        UpdateAllActorsVisibility(bNotifySelectionChange: boolean, bRedrawViewports: boolean) : boolean;
        UpdateAllViewVisibility(LayerThatChanged: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LayersSubsystem;
        static Load(InName: string): LayersSubsystem;
    }
    
    class LazyObjectProperty extends UE.ObjectPropertyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LazyObjectProperty;
        static Load(InName: string): LazyObjectProperty;
    }
    
    class LeaderboardBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static WriteLeaderboardInteger(PlayerController: $Nullable<UE.PlayerController>, StatName: string, StatValue: number) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LeaderboardBlueprintLibrary;
        static Load(InName: string): LeaderboardBlueprintLibrary;
    }
    
    class LeaderboardFlushCallbackProxy extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(SessionName: string) => void>;
        OnFailure: $MulticastDelegate<(SessionName: string) => void>;
        static CreateProxyObjectForFlush(PlayerController: $Nullable<UE.PlayerController>, SessionName: string) : UE.LeaderboardFlushCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LeaderboardFlushCallbackProxy;
        static Load(InName: string): LeaderboardFlushCallbackProxy;
    }
    
    class LeaderboardQueryCallbackProxy extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(LeaderboardValue: number) => void>;
        OnFailure: $MulticastDelegate<(LeaderboardValue: number) => void>;
        static CreateProxyObjectForIntQuery(PlayerController: $Nullable<UE.PlayerController>, StatName: string) : UE.LeaderboardQueryCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LeaderboardQueryCallbackProxy;
        static Load(InName: string): LeaderboardQueryCallbackProxy;
    }
    
    class LegacyLevelSequenceDirectorBlueprint extends UE.Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LegacyLevelSequenceDirectorBlueprint;
        static Load(InName: string): LegacyLevelSequenceDirectorBlueprint;
    }
    
    class LevelBounds extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoUpdateBounds: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelBounds;
        static Load(InName: string): LevelBounds;
    }
    
    class LevelCapture extends UE.MovieSceneCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoStartCapture: boolean;
        PrerequisiteActorId: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelCapture;
        static Load(InName: string): LevelCapture;
    }
    
    enum ELevelEditor2DAxis { X, Y, Z, ELevelEditor2DAxis_MAX}
    class Mode2DLayer {
        constructor();
        constructor(Name: string, Depth: number);
        Name: string;
        Depth: number;
        static StaticClass(): Class;
    }
    
    class LevelEditor2DSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnable2DWidget: boolean;
        bEnableSnapLayers: boolean;
        SnapAxis: UE.ELevelEditor2DAxis;
        SnapLayers: TArray<UE.Mode2DLayer>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelEditor2DSettings;
        static Load(InName: string): LevelEditor2DSettings;
    }
    
    namespace Engine.Tutorial.Basics.LevelEditorAttract {
        class LevelEditorAttract_C extends UE.EditorTutorial {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): LevelEditorAttract_C;
            static Load(InName: string): LevelEditorAttract_C;
        }
        
    }

    class LevelEditorContextMenuContext extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelEditorContextMenuContext;
        static Load(InName: string): LevelEditorContextMenuContext;
    }
    
    class LevelEditorMenuContext extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelEditorMenuContext;
        static Load(InName: string): LevelEditorMenuContext;
    }
    
    class LevelEditorMiscSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoApplyLightingEnable: boolean;
        bBSPAutoUpdate: boolean;
        bAutoMoveBSPPivotOffset: boolean;
        bNavigationAutoUpdate: boolean;
        bReplaceRespectsScale: boolean;
        bAllowBackgroundAudio: boolean;
        bCreateNewAudioDeviceForPlayInEditor: boolean;
        bEnableRealTimeAudio: boolean;
        EditorVolumeLevel: number;
        bEnableEditorSounds: boolean;
        DefaultLevelStreamingClass: UE.Class;
        bPromptWhenAddingToLevelBeforeCheckout: boolean;
        bPromptWhenAddingToLevelOutsideBounds: boolean;
        PercentageThresholdForPrompt: number;
        MinimumBoundsForCheckingSize: UE.Vector;
        EditorScreenshotSaveDirectory: UE.DirectoryPath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelEditorMiscSettings;
        static Load(InName: string): LevelEditorMiscSettings;
    }
    
    namespace Engine.Tutorial.Basics.LevelEditorOverview {
        class LevelEditorOverview_C extends UE.EditorTutorial {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): LevelEditorOverview_C;
            static Load(InName: string): LevelEditorOverview_C;
        }
        
    }

    enum ELabelAnchorMode { LabelAnchorMode_TopLeft, LabelAnchorMode_TopCenter, LabelAnchorMode_TopRight, LabelAnchorMode_CenterLeft, LabelAnchorMode_Centered, LabelAnchorMode_CenterRight, LabelAnchorMode_BottomLeft, LabelAnchorMode_BottomCenter, LabelAnchorMode_BottomRight, LabelAnchorMode_MAX}
    enum EPlayOnBuildMode { PlayOnBuild_Always, PlayOnBuild_Never, PlayOnBuild_Default, PlayOnBuild_IfEditorBuiltLocally, PlayOnBuild_MAX}
    enum EPlayOnLaunchConfiguration { LaunchConfig_Default, LaunchConfig_Debug, LaunchConfig_Development, LaunchConfig_Test, LaunchConfig_Shipping, LaunchConfig_MAX}
    enum EPlayNetMode { PIE_Standalone, PIE_ListenServer, PIE_Client, PIE_StandaloneWithServer, PIE_MAX}
    enum NetworkEmulationTarget { Server, Client, Any, NetworkEmulationTarget_MAX}
    class NetworkEmulationPacketSettings {
        constructor();
        constructor(MinLatency: number, MaxLatency: number, PacketLossPercentage: number);
        MinLatency: number;
        MaxLatency: number;
        PacketLossPercentage: number;
        static StaticClass(): Class;
    }
    
    class LevelEditorPlayNetworkEmulationSettings {
        constructor();
        constructor(bIsNetworkEmulationEnabled: boolean, EmulationTarget: UE.NetworkEmulationTarget, CurrentProfile: string, OutPackets: UE.NetworkEmulationPacketSettings, InPackets: UE.NetworkEmulationPacketSettings);
        bIsNetworkEmulationEnabled: boolean;
        EmulationTarget: UE.NetworkEmulationTarget;
        CurrentProfile: string;
        OutPackets: UE.NetworkEmulationPacketSettings;
        InPackets: UE.NetworkEmulationPacketSettings;
        static StaticClass(): Class;
    }
    
    enum ELaunchModeType { LaunchMode_OnDevice, LaunchMode_MAX}
    enum EPlayModeLocations { PlayLocation_CurrentCameraLocation, PlayLocation_DefaultPlayerStart, PlayLocation_MAX}
    enum EPlayModeType { PlayMode_InViewPort, PlayMode_InEditorFloating, PlayMode_InMobilePreview, PlayMode_InTargetedMobilePreview, PlayMode_InVulkanPreview, PlayMode_InNewProcess, PlayMode_InVR, PlayMode_Simulate, PlayMode_Count, PlayMode_MAX}
    class PlayScreenResolution {
        constructor();
        constructor(Description: string, Width: number, Height: number, AspectRatio: string, bCanSwapAspectRatio: boolean, ProfileName: string);
        Description: string;
        Width: number;
        Height: number;
        AspectRatio: string;
        bCanSwapAspectRatio: boolean;
        ProfileName: string;
        static StaticClass(): Class;
    }
    
    class LevelEditorPlaySettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlayFromHerePlayerStartClassName: string;
        GameGetsMouseControl: boolean;
        UseMouseForTouch: boolean;
        ShowMouseControlLabel: boolean;
        MouseControlLabelPosition: UE.ELabelAnchorMode;
        ViewportGetsHMDControl: boolean;
        ShouldMinimizeEditorOnVRPIE: boolean;
        AutoRecompileBlueprints: boolean;
        EnableGameSound: boolean;
        EnablePIEEnterAndExitSounds: boolean;
        PlayInEditorSoundQualityLevel: number;
        bOnlyLoadVisibleLevelsInPIE: boolean;
        bPreferToStreamLevelsInPIE: boolean;
        NewWindowWidth: number;
        NewWindowHeight: number;
        NewWindowPosition: UE.IntPoint;
        CenterNewWindow: boolean;
        PIEAlwaysOnTop: boolean;
        DisableStandaloneSound: boolean;
        AdditionalLaunchParameters: string;
        AdditionalLaunchParametersForMobile: string;
        BuildGameBeforeLaunch: UE.EPlayOnBuildMode;
        LaunchConfiguration: UE.EPlayOnLaunchConfiguration;
        bAutoCompileBlueprintsOnLaunch: boolean;
        PlayNetMode: UE.EPlayNetMode;
        RunUnderOneProcess: boolean;
        PlayNetDedicated: boolean;
        PlayNumberOfClients: number;
        ServerPort: number;
        ClientWindowWidth: number;
        AutoConnectToServer: boolean;
        RouteGamepadToSecondWindow: boolean;
        CreateAudioDeviceForEveryPlayer: boolean;
        ClientWindowHeight: number;
        ServerMapNameOverride: string;
        AdditionalServerGameOptions: string;
        AdditionalLaunchOptions: string;
        NetworkEmulationSettings: UE.LevelEditorPlayNetworkEmulationSettings;
        MultipleInstanceLastHeight: number;
        MultipleInstanceLastWidth: number;
        MultipleInstancePositions: TArray<UE.IntPoint>;
        LastExecutedLaunchDevice: string;
        LastExecutedLaunchName: string;
        LastExecutedLaunchModeType: UE.ELaunchModeType;
        LastExecutedPlayModeLocation: UE.EPlayModeLocations;
        LastExecutedPlayModeType: UE.EPlayModeType;
        LastExecutedPIEPreviewDevice: string;
        LaptopScreenResolutions: TArray<UE.PlayScreenResolution>;
        MonitorScreenResolutions: TArray<UE.PlayScreenResolution>;
        PhoneScreenResolutions: TArray<UE.PlayScreenResolution>;
        TabletScreenResolutions: TArray<UE.PlayScreenResolution>;
        TelevisionScreenResolutions: TArray<UE.PlayScreenResolution>;
        DeviceToEmulate: string;
        PIESafeZoneOverride: UE.Margin;
        CustomUnsafeZoneStarts: TArray<UE.Vector2D>;
        CustomUnsafeZoneDimensions: TArray<UE.Vector2D>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelEditorPlaySettings;
        static Load(InName: string): LevelEditorPlaySettings;
    }
    
    enum EWASDType { WASD_Always, WASD_RMBOnly, WASD_Never, WASD_MAX}
    enum ELandscapeFoliageEditorControlType { IgnoreCtrl, RequireCtrl, RequireNoCtrl, ELandscapeFoliageEditorControlType_MAX}
    enum EScrollGestureDirection { UseSystemSetting, Standard, Natural, EScrollGestureDirection_MAX}
    class SnapToSurfaceSettings {
        constructor();
        constructor(bEnabled: boolean, SnapOffsetExtent: number, bSnapRotation: boolean);
        bEnabled: boolean;
        SnapOffsetExtent: number;
        bSnapRotation: boolean;
        static StaticClass(): Class;
    }
    
    enum ERotationGridMode { GridMode_DivisionsOf360, GridMode_Common, GridMode_MAX}
    enum EMeasuringToolUnits { MeasureUnits_Centimeters, MeasureUnits_Meters, MeasureUnits_Kilometers, MeasureUnits_MAX}
    enum ELevelViewportType { LVT_OrthoXY, LVT_OrthoXZ, LVT_OrthoYZ, LVT_Perspective, LVT_OrthoFreelook, LVT_OrthoNegativeXY, LVT_OrthoNegativeXZ, LVT_OrthoNegativeYZ, LVT_MAX, LVT_None}
    class ExposureSettings {
        constructor();
        constructor(FixedEV100: number, bFixed: boolean);
        FixedEV100: number;
        bFixed: boolean;
        static StaticClass(): Class;
    }
    
    class LevelEditorViewportInstanceSettings {
        constructor();
        constructor(ViewportType: UE.ELevelViewportType, PerspViewModeIndex: UE.EViewModeIndex, OrthoViewModeIndex: UE.EViewModeIndex, EditorShowFlagsString: string, GameShowFlagsString: string, BufferVisualizationMode: string, RayTracingDebugVisualizationMode: string, ExposureSettings: UE.ExposureSettings, FOVAngle: number, FarViewPlane: number, bIsRealtime: boolean, bShowFPS: boolean, bShowOnScreenStats: boolean, EnabledStats: TArray<string>, bShowFullToolbar: boolean);
        ViewportType: UE.ELevelViewportType;
        PerspViewModeIndex: UE.EViewModeIndex;
        OrthoViewModeIndex: UE.EViewModeIndex;
        EditorShowFlagsString: string;
        GameShowFlagsString: string;
        BufferVisualizationMode: string;
        RayTracingDebugVisualizationMode: string;
        ExposureSettings: UE.ExposureSettings;
        FOVAngle: number;
        FarViewPlane: number;
        bIsRealtime: boolean;
        bShowFPS: boolean;
        bShowOnScreenStats: boolean;
        EnabledStats: TArray<string>;
        bShowFullToolbar: boolean;
        static StaticClass(): Class;
    }
    
    class LevelEditorViewportInstanceSettingsKeyValuePair {
        constructor();
        constructor(ConfigName: string, ConfigSettings: UE.LevelEditorViewportInstanceSettings);
        ConfigName: string;
        ConfigSettings: UE.LevelEditorViewportInstanceSettings;
        static StaticClass(): Class;
    }
    
    class LevelEditorViewportSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FlightCameraControlType: UE.EWASDType;
        LandscapeEditorControlType: UE.ELandscapeFoliageEditorControlType;
        FoliageEditorControlType: UE.ELandscapeFoliageEditorControlType;
        bPanMovesCanvas: boolean;
        bCenterZoomAroundCursor: boolean;
        bAllowTranslateRotateZWidget: boolean;
        bAllowArcballRotate: boolean;
        bAllowScreenRotate: boolean;
        bClickBSPSelectsBrush: boolean;
        CameraSpeed: number;
        CameraSpeedScalar: number;
        MouseScrollCameraSpeed: number;
        MouseSensitivty: number;
        bInvertMouseLookYAxis: boolean;
        bInvertOrbitYAxis: boolean;
        bInvertMiddleMousePan: boolean;
        bInvertRightMouseDollyYAxis: boolean;
        bUseAbsoluteTranslation: boolean;
        bLevelStreamingVolumePrevis: boolean;
        bUseUE3OrbitControls: boolean;
        ScrollGestureDirectionFor3DViewports: UE.EScrollGestureDirection;
        ScrollGestureDirectionForOrthoViewports: UE.EScrollGestureDirection;
        bLevelEditorJoystickControls: boolean;
        bUseDistanceScaledCameraSpeed: boolean;
        bOrbitCameraAroundSelection: boolean;
        bUsePowerOf2SnapSize: boolean;
        DecimalGridSizes: TArray<number>;
        DecimalGridIntervals: TArray<number>;
        Pow2GridSizes: TArray<number>;
        Pow2GridIntervals: TArray<number>;
        CommonRotGridSizes: TArray<number>;
        DivisionsOf360RotGridSizes: TArray<number>;
        ScalingGridSizes: TArray<number>;
        GridEnabled: boolean;
        RotGridEnabled: boolean;
        SnapScaleEnabled: boolean;
        SnapToSurface: UE.SnapToSurfaceSettings;
        bUsePercentageBasedScaling: boolean;
        bEnableLayerSnap: boolean;
        ActiveSnapLayerIndex: number;
        bEnableActorSnap: boolean;
        ActorSnapScale: number;
        ActorSnapDistance: number;
        bSnapVertices: boolean;
        SnapDistance: number;
        CurrentPosGridSize: number;
        CurrentRotGridSize: number;
        CurrentScalingGridSize: number;
        PreserveNonUniformScale: boolean;
        CurrentRotGridMode: UE.ERotationGridMode;
        AspectRatioAxisConstraint: UE.EAspectRatioAxisConstraint;
        bEnableViewportHoverFeedback: boolean;
        bHighlightWithBrackets: boolean;
        bUseLinkedOrthographicViewports: boolean;
        bStrictBoxSelection: boolean;
        bTransparentBoxSelection: boolean;
        bUseSelectionOutline: boolean;
        SelectionHighlightIntensity: number;
        BSPSelectionHighlightIntensity: number;
        bEnableViewportCameraToUpdateFromPIV: boolean;
        bPreviewSelectedCameras: boolean;
        CameraPreviewSize: number;
        BackgroundDropDistance: number;
        PreviewMeshes: TArray<UE.SoftObjectPath>;
        BillboardScale: number;
        TransformWidgetSizeAdjustment: number;
        bSaveEngineStats: boolean;
        MeasuringToolUnits: UE.EMeasuringToolUnits;
        PerInstanceSettings: TArray<UE.LevelEditorViewportInstanceSettingsKeyValuePair>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelEditorViewportSettings;
        static Load(InName: string): LevelEditorViewportSettings;
    }
    
    class LevelExporterFBX extends UE.ExporterFBX {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelExporterFBX;
        static Load(InName: string): LevelExporterFBX;
    }
    
    class LevelExporterLOD extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelExporterLOD;
        static Load(InName: string): LevelExporterLOD;
    }
    
    class LevelExporterOBJ extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelExporterOBJ;
        static Load(InName: string): LevelExporterOBJ;
    }
    
    class LevelExporterSTL extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelExporterSTL;
        static Load(InName: string): LevelExporterSTL;
    }
    
    class LevelExporterT3D extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelExporterT3D;
        static Load(InName: string): LevelExporterT3D;
    }
    
    class LevelFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelFactory;
        static Load(InName: string): LevelFactory;
    }
    
    class LevelSequenceDirector extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Player: UE.LevelSequencePlayer;
        OnCreated() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceDirector;
        static Load(InName: string): LevelSequenceDirector;
    }
    
    class LevelSequenceEditorBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CloseLevelSequence() : void;
        static GetCurrentLevelSequence() : UE.LevelSequence;
        static GetCurrentTime() : number;
        static IsLevelSequenceLocked() : boolean;
        static IsPlaying() : boolean;
        static OpenLevelSequence(LevelSequence: $Nullable<UE.LevelSequence>) : boolean;
        static Pause() : void;
        static Play() : void;
        static SetCurrentTime(NewFrame: number) : void;
        static SetLockLevelSequence(bLock: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceEditorBlueprintLibrary;
        static Load(InName: string): LevelSequenceEditorBlueprintLibrary;
    }
    
    class LevelSequencePropertyTrackSettings {
        constructor();
        constructor(ComponentPath: string, PropertyPath: string);
        ComponentPath: string;
        PropertyPath: string;
        static StaticClass(): Class;
    }
    
    class LevelSequenceTrackSettings {
        constructor();
        constructor(MatchingActorClass: UE.SoftClassPath, DefaultTracks: TArray<UE.SoftClassPath>, ExcludeDefaultTracks: TArray<UE.SoftClassPath>, DefaultPropertyTracks: TArray<UE.LevelSequencePropertyTrackSettings>, ExcludeDefaultPropertyTracks: TArray<UE.LevelSequencePropertyTrackSettings>);
        MatchingActorClass: UE.SoftClassPath;
        DefaultTracks: TArray<UE.SoftClassPath>;
        ExcludeDefaultTracks: TArray<UE.SoftClassPath>;
        DefaultPropertyTracks: TArray<UE.LevelSequencePropertyTrackSettings>;
        ExcludeDefaultPropertyTracks: TArray<UE.LevelSequencePropertyTrackSettings>;
        static StaticClass(): Class;
    }
    
    class LevelSequenceEditorSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TrackSettings: TArray<UE.LevelSequenceTrackSettings>;
        bAutoBindToPIE: boolean;
        bAutoBindToSimulate: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceEditorSettings;
        static Load(InName: string): LevelSequenceEditorSettings;
    }
    
    class LevelSequenceFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceFactoryNew;
        static Load(InName: string): LevelSequenceFactoryNew;
    }
    
    class LevelSequenceMasterSequenceSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MasterSequenceName: string;
        MasterSequenceSuffix: string;
        MasterSequenceBasePath: UE.DirectoryPath;
        MasterSequenceNumShots: number;
        MasterSequenceLevelSequenceToDuplicate: TLazyObjectPtr<UE.LevelSequence>;
        SubSequenceNames: TArray<string>;
        bInstanceSubSequences: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceMasterSequenceSettings;
        static Load(InName: string): LevelSequenceMasterSequenceSettings;
    }
    
    class LevelSequenceMetaData extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceMetaData;
        static Load(InName: string): LevelSequenceMetaData;
    }
    
    class LevelStreamingAlwaysLoaded extends UE.LevelStreaming {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelStreamingAlwaysLoaded;
        static Load(InName: string): LevelStreamingAlwaysLoaded;
    }
    
    class LevelStreamingDynamic extends UE.LevelStreaming {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bInitiallyLoaded: boolean;
        bInitiallyVisible: boolean;
        static LoadLevelInstance(WorldContextObject: $Nullable<UE.Object>, LevelName: string, Location: UE.Vector, Rotation: UE.Rotator, bOutSuccess: $Ref<boolean>) : UE.LevelStreamingDynamic;
        static LoadLevelInstanceBySoftObjectPtr(WorldContextObject: $Nullable<UE.Object>, Level: TSoftObjectPtr<UE.World>, Location: UE.Vector, Rotation: UE.Rotator, bOutSuccess: $Ref<boolean>) : UE.LevelStreamingDynamic;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelStreamingDynamic;
        static Load(InName: string): LevelStreamingDynamic;
    }
    
    class LevelStreamingPersistent extends UE.LevelStreaming {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelStreamingPersistent;
        static Load(InName: string): LevelStreamingPersistent;
    }
    
    class LevelThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelThumbnailRenderer;
        static Load(InName: string): LevelThumbnailRenderer;
    }
    
    class LevelVariantSetsActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LevelVariantSets: UE.SoftObjectPath;
        GetLevelVariantSets(bLoad?: boolean /* = false */) : UE.LevelVariantSets;
        SetLevelVariantSets(InVariantSets: $Nullable<UE.LevelVariantSets>) : void;
        SwitchOnVariantByIndex(VariantSetIndex: number, VariantIndex: number) : boolean;
        SwitchOnVariantByName(VariantSetName: string, VariantName: string) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelVariantSetsActor;
        static Load(InName: string): LevelVariantSetsActor;
    }
    
    class LevelVariantSetsActorFactory extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelVariantSetsActorFactory;
        static Load(InName: string): LevelVariantSetsActorFactory;
    }
    
    class LevelVariantSetsFunctionDirector extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelVariantSetsFunctionDirector;
        static Load(InName: string): LevelVariantSetsFunctionDirector;
    }
    
    class LightingBuildInfo extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Object: TWeakObjectPtr<UE.Object>;
        LightingTime: number;
        UnmappedTexelsPercentage: number;
        UnmappedTexelsMemory: number;
        TotalTexelMemory: number;
        LevelName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightingBuildInfo;
        static Load(InName: string): LightingBuildInfo;
    }
    
    class LightmappedSurfaceCollection extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceModel: UE.Model;
        Surfaces: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightmappedSurfaceCollection;
        static Load(InName: string): LightmappedSurfaceCollection;
    }
    
    class LightMapTexture2D extends UE.Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightMapTexture2D;
        static Load(InName: string): LightMapTexture2D;
    }
    
    class VirtualTexture extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VirtualTexture;
        static Load(InName: string): VirtualTexture;
    }
    
    class LightMapVirtualTexture extends UE.VirtualTexture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightMapVirtualTexture;
        static Load(InName: string): LightMapVirtualTexture;
    }
    
    class LightMapVirtualTexture2D extends UE.Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TypeToLayer: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightMapVirtualTexture2D;
        static Load(InName: string): LightMapVirtualTexture2D;
    }
    
    class LightmassCharacterIndirectDetailVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightmassCharacterIndirectDetailVolume;
        static Load(InName: string): LightmassCharacterIndirectDetailVolume;
    }
    
    class LightmassImportanceVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightmassImportanceVolume;
        static Load(InName: string): LightmassImportanceVolume;
    }
    
    class LightmassDebugOptions {
        constructor();
        constructor(bDebugMode: boolean, bStatsEnabled: boolean, bGatherBSPSurfacesAcrossComponents: boolean, CoplanarTolerance: number, bUseImmediateImport: boolean, bImmediateProcessMappings: boolean, bSortMappings: boolean, bDumpBinaryFiles: boolean, bDebugMaterials: boolean, bPadMappings: boolean, bDebugPaddings: boolean, bOnlyCalcDebugTexelMappings: boolean, bUseRandomColors: boolean, bColorBordersGreen: boolean, bColorByExecutionTime: boolean, ExecutionTimeDivisor: number);
        bDebugMode: boolean;
        bStatsEnabled: boolean;
        bGatherBSPSurfacesAcrossComponents: boolean;
        CoplanarTolerance: number;
        bUseImmediateImport: boolean;
        bImmediateProcessMappings: boolean;
        bSortMappings: boolean;
        bDumpBinaryFiles: boolean;
        bDebugMaterials: boolean;
        bPadMappings: boolean;
        bDebugPaddings: boolean;
        bOnlyCalcDebugTexelMappings: boolean;
        bUseRandomColors: boolean;
        bColorBordersGreen: boolean;
        bColorByExecutionTime: boolean;
        ExecutionTimeDivisor: number;
        static StaticClass(): Class;
    }
    
    class SwarmDebugOptions {
        constructor();
        constructor(bDistributionEnabled: boolean, bForceContentExport: boolean, bInitialized: boolean);
        bDistributionEnabled: boolean;
        bForceContentExport: boolean;
        bInitialized: boolean;
        static StaticClass(): Class;
    }
    
    class LightmassOptionsObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DebugSettings: UE.LightmassDebugOptions;
        SwarmSettings: UE.SwarmDebugOptions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightmassOptionsObject;
        static Load(InName: string): LightmassOptionsObject;
    }
    
    class LightmassPortalComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PreviewBox: UE.BoxComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightmassPortalComponent;
        static Load(InName: string): LightmassPortalComponent;
    }
    
    class LightmassPortal extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PortalComponent: UE.LightmassPortalComponent;
        SpriteComponent: UE.BillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightmassPortal;
        static Load(InName: string): LightmassPortal;
    }
    
    class LightmassPrimitiveSettingsObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightmassSettings: UE.LightmassPrimitiveSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightmassPrimitiveSettingsObject;
        static Load(InName: string): LightmassPrimitiveSettingsObject;
    }
    
    class LightPropagationVolumeSettings {
        constructor();
        constructor(bOverride_LPVIntensity: boolean, bOverride_LPVDirectionalOcclusionIntensity: boolean, bOverride_LPVDirectionalOcclusionRadius: boolean, bOverride_LPVDiffuseOcclusionExponent: boolean, bOverride_LPVSpecularOcclusionExponent: boolean, bOverride_LPVDiffuseOcclusionIntensity: boolean, bOverride_LPVSpecularOcclusionIntensity: boolean, bOverride_LPVSize: boolean, bOverride_LPVSecondaryOcclusionIntensity: boolean, bOverride_LPVSecondaryBounceIntensity: boolean, bOverride_LPVGeometryVolumeBias: boolean, bOverride_LPVVplInjectionBias: boolean, bOverride_LPVEmissiveInjectionIntensity: boolean, LPVIntensity: number, LPVVplInjectionBias: number, LPVSize: number, LPVSecondaryOcclusionIntensity: number, LPVSecondaryBounceIntensity: number, LPVGeometryVolumeBias: number, LPVEmissiveInjectionIntensity: number, LPVDirectionalOcclusionIntensity: number, LPVDirectionalOcclusionRadius: number, LPVDiffuseOcclusionExponent: number, LPVSpecularOcclusionExponent: number, LPVDiffuseOcclusionIntensity: number, LPVSpecularOcclusionIntensity: number, LPVFadeRange: number, LPVDirectionalOcclusionFadeRange: number);
        bOverride_LPVIntensity: boolean;
        bOverride_LPVDirectionalOcclusionIntensity: boolean;
        bOverride_LPVDirectionalOcclusionRadius: boolean;
        bOverride_LPVDiffuseOcclusionExponent: boolean;
        bOverride_LPVSpecularOcclusionExponent: boolean;
        bOverride_LPVDiffuseOcclusionIntensity: boolean;
        bOverride_LPVSpecularOcclusionIntensity: boolean;
        bOverride_LPVSize: boolean;
        bOverride_LPVSecondaryOcclusionIntensity: boolean;
        bOverride_LPVSecondaryBounceIntensity: boolean;
        bOverride_LPVGeometryVolumeBias: boolean;
        bOverride_LPVVplInjectionBias: boolean;
        bOverride_LPVEmissiveInjectionIntensity: boolean;
        LPVIntensity: number;
        LPVVplInjectionBias: number;
        LPVSize: number;
        LPVSecondaryOcclusionIntensity: number;
        LPVSecondaryBounceIntensity: number;
        LPVGeometryVolumeBias: number;
        LPVEmissiveInjectionIntensity: number;
        LPVDirectionalOcclusionIntensity: number;
        LPVDirectionalOcclusionRadius: number;
        LPVDiffuseOcclusionExponent: number;
        LPVSpecularOcclusionExponent: number;
        LPVDiffuseOcclusionIntensity: number;
        LPVSpecularOcclusionIntensity: number;
        LPVFadeRange: number;
        LPVDirectionalOcclusionFadeRange: number;
        static StaticClass(): Class;
    }
    
    class LightPropagationVolumeBlendable extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: UE.LightPropagationVolumeSettings;
        BlendWeight: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightPropagationVolumeBlendable;
        static Load(InName: string): LightPropagationVolumeBlendable;
    }
    
    class LightPropagationVolumeBlendableFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightPropagationVolumeBlendableFactory;
        static Load(InName: string): LightPropagationVolumeBlendableFactory;
    }
    
    class LinearStairBuilder extends UE.EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StepLength: number;
        StepHeight: number;
        StepWidth: number;
        NumSteps: number;
        AddToFirstStep: number;
        GroupName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LinearStairBuilder;
        static Load(InName: string): LinearStairBuilder;
    }
    
    class LineSplineGenerator extends UE.SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumberOfPoints: number;
        Length: number;
        bEnableUpToNextPoint: boolean;
        bUpToNextPoint: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LineSplineGenerator;
        static Load(InName: string): LineSplineGenerator;
    }
    
    class LinkerPlaceholderClass extends UE.Class {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LinkerPlaceholderClass;
        static Load(InName: string): LinkerPlaceholderClass;
    }
    
    class LinkerPlaceholderExportObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LinkerPlaceholderExportObject;
        static Load(InName: string): LinkerPlaceholderExportObject;
    }
    
    class LinkerPlaceholderFunction extends UE.Function {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LinkerPlaceholderFunction;
        static Load(InName: string): LinkerPlaceholderFunction;
    }
    
    class ListMaterialsUsedWithMeshEmittersCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ListMaterialsUsedWithMeshEmittersCommandlet;
        static Load(InName: string): ListMaterialsUsedWithMeshEmittersCommandlet;
    }
    
    class ListStaticMeshesImportedFromSpeedTreesCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ListStaticMeshesImportedFromSpeedTreesCommandlet;
        static Load(InName: string): ListStaticMeshesImportedFromSpeedTreesCommandlet;
    }
    
    class ListViewBase extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EntryWidgetClass: UE.Class;
        WheelScrollMultiplier: number;
        bEnableScrollAnimation: boolean;
        bEnableFixedLineOffset: boolean;
        FixedLineScrollOffset: number;
        BP_OnEntryGenerated: $MulticastDelegate<(Widget: $Nullable<UE.UserWidget>) => void>;
        BP_OnEntryReleased: $MulticastDelegate<(Widget: $Nullable<UE.UserWidget>) => void>;
        NumDesignerPreviewEntries: number;
        EntryWidgetPool: UE.UserWidgetPool;
        GetDisplayedEntryWidgets() : TArray<UE.UserWidget>;
        RegenerateAllEntries() : void;
        RequestRefresh() : void;
        ScrollToBottom() : void;
        ScrollToTop() : void;
        SetScrollbarVisibility(InVisibility: UE.ESlateVisibility) : void;
        SetScrollOffset(InScrollOffset: number) : void;
        SetWheelScrollMultiplier(NewWheelScrollMultiplier: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ListViewBase;
        static Load(InName: string): ListViewBase;
    }
    
    enum EOrientation { Orient_Horizontal, Orient_Vertical, Orient_MAX}
    enum ESelectionMode { None, Single, SingleToggle, Multi, ESelectionMode_MAX}
    enum EConsumeMouseWheel { WhenScrollingPossible, Always, Never, EConsumeMouseWheel_MAX}
    class ListView extends UE.ListViewBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Orientation: UE.EOrientation;
        SelectionMode: UE.ESelectionMode;
        ConsumeMouseWheel: UE.EConsumeMouseWheel;
        bClearSelectionOnClick: boolean;
        bIsFocusable: boolean;
        EntrySpacing: number;
        bReturnFocusToSelection: boolean;
        ListItems: TArray<UE.Object>;
        BP_OnEntryInitialized: $MulticastDelegate<(Item: $Nullable<UE.Object>, Widget: $Nullable<UE.UserWidget>) => void>;
        BP_OnItemClicked: $MulticastDelegate<(Item: $Nullable<UE.Object>) => void>;
        BP_OnItemDoubleClicked: $MulticastDelegate<(Item: $Nullable<UE.Object>) => void>;
        BP_OnItemIsHoveredChanged: $MulticastDelegate<(Item: $Nullable<UE.Object>, bIsHovered: boolean) => void>;
        BP_OnItemSelectionChanged: $MulticastDelegate<(Item: $Nullable<UE.Object>, bIsSelected: boolean) => void>;
        BP_OnItemScrolledIntoView: $MulticastDelegate<(Item: $Nullable<UE.Object>, Widget: $Nullable<UE.UserWidget>) => void>;
        AddItem(Item: $Nullable<UE.Object>) : void;
        BP_CancelScrollIntoView() : void;
        BP_ClearSelection() : void;
        BP_GetNumItemsSelected() : number;
        BP_GetSelectedItem() : UE.Object;
        BP_GetSelectedItems(Items: $Ref<TArray<UE.Object>>) : boolean;
        BP_IsItemVisible(Item: $Nullable<UE.Object>) : boolean;
        BP_NavigateToItem(Item: $Nullable<UE.Object>) : void;
        BP_ScrollItemIntoView(Item: $Nullable<UE.Object>) : void;
        BP_SetItemSelection(Item: $Nullable<UE.Object>, bSelected: boolean) : void;
        BP_SetListItems(InListItems: TArray<UE.Object>) : void;
        BP_SetSelectedItem(Item: $Nullable<UE.Object>) : void;
        ClearListItems() : void;
        GetIndexForItem(Item: $Nullable<UE.Object>) : number;
        GetItemAt(Index: number) : UE.Object;
        GetListItems() : TArray<UE.Object>;
        GetNumItems() : number;
        IsRefreshPending() : boolean;
        NavigateToIndex(Index: number) : void;
        RemoveItem(Item: $Nullable<UE.Object>) : void;
        ScrollIndexIntoView(Index: number) : void;
        SetSelectedIndex(Index: number) : void;
        SetSelectionMode(SelectionMode: UE.ESelectionMode) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ListView;
        static Load(InName: string): ListView;
    }
    
    class ListViewDesignerPreviewItem extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ListViewDesignerPreviewItem;
        static Load(InName: string): ListViewDesignerPreviewItem;
    }
    
    enum ELiveCodingStartupMode { Automatic, AutomaticButHidden, Manual, ELiveCodingStartupMode_MAX}
    class LiveCodingSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnabled: boolean;
        Startup: UE.ELiveCodingStartupMode;
        bPreloadEngineModules: boolean;
        bPreloadEnginePluginModules: boolean;
        bPreloadProjectModules: boolean;
        bPreloadProjectPluginModules: boolean;
        PreloadNamedModules: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveCodingSettings;
        static Load(InName: string): LiveCodingSettings;
    }
    
    class LiveLinkRole extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkRole;
        static Load(InName: string): LiveLinkRole;
    }
    
    class LiveLinkBasicRole extends UE.LiveLinkRole {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkBasicRole;
        static Load(InName: string): LiveLinkBasicRole;
    }
    
    class LiveLinkAnimationRole extends UE.LiveLinkBasicRole {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkAnimationRole;
        static Load(InName: string): LiveLinkAnimationRole;
    }
    
    class LiveLinkTransformRole extends UE.LiveLinkBasicRole {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkTransformRole;
        static Load(InName: string): LiveLinkTransformRole;
    }
    
    class LiveLinkCameraRole extends UE.LiveLinkTransformRole {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkCameraRole;
        static Load(InName: string): LiveLinkCameraRole;
    }
    
    class LiveLinkController extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkController;
        static Load(InName: string): LiveLinkController;
    }
    
    enum ELiveLinkSourceMode { Latest, EngineTime, Timecode, ELiveLinkSourceMode_MAX}
    class LiveLinkSourceBufferManagementSettings {
        constructor();
        constructor(ValidEngineTime: number, EngineTimeOffset: number, TimecodeFrameRate: UE.FrameRate, bGenerateSubFrame: boolean, SourceTimecodeFrameRate: UE.FrameRate, ValidTimecodeFrame: number, TimecodeFrameOffset: number, LatestOffset: number, MaxNumberOfFrameToBuffered: number, bKeepAtLeastOneFrame: boolean);
        ValidEngineTime: number;
        EngineTimeOffset: number;
        TimecodeFrameRate: UE.FrameRate;
        bGenerateSubFrame: boolean;
        SourceTimecodeFrameRate: UE.FrameRate;
        ValidTimecodeFrame: number;
        TimecodeFrameOffset: number;
        LatestOffset: number;
        MaxNumberOfFrameToBuffered: number;
        bKeepAtLeastOneFrame: boolean;
        static StaticClass(): Class;
    }
    
    class LiveLinkSubjectName {
        constructor();
        constructor(Name: string);
        Name: string;
        static StaticClass(): Class;
    }
    
    class LiveLinkSourceDebugInfo {
        constructor();
        constructor(SubjectName: UE.LiveLinkSubjectName, SnapshotIndex: number, NumberOfBufferAtSnapshot: number);
        SubjectName: UE.LiveLinkSubjectName;
        SnapshotIndex: number;
        NumberOfBufferAtSnapshot: number;
        static StaticClass(): Class;
    }
    
    class LiveLinkSourceSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Mode: UE.ELiveLinkSourceMode;
        BufferSettings: UE.LiveLinkSourceBufferManagementSettings;
        ConnectionString: string;
        Factory: UE.Class;
        SourceDebugInfos: TArray<UE.LiveLinkSourceDebugInfo>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkSourceSettings;
        static Load(InName: string): LiveLinkSourceSettings;
    }
    
    class LiveLinkCurveConversionSettings {
        constructor();
        constructor(CurveConversionAssetMap: TMap<string, UE.SoftObjectPath>);
        CurveConversionAssetMap: TMap<string, UE.SoftObjectPath>;
        static StaticClass(): Class;
    }
    
    class LiveLinkCurveRemapSettings extends UE.LiveLinkSourceSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurveConversionSettings: UE.LiveLinkCurveConversionSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkCurveRemapSettings;
        static Load(InName: string): LiveLinkCurveRemapSettings;
    }
    
    class LiveLinkFrameInterpolationProcessor extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkFrameInterpolationProcessor;
        static Load(InName: string): LiveLinkFrameInterpolationProcessor;
    }
    
    class LiveLinkFramePreProcessor extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkFramePreProcessor;
        static Load(InName: string): LiveLinkFramePreProcessor;
    }
    
    class LiveLinkFrameTranslator extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkFrameTranslator;
        static Load(InName: string): LiveLinkFrameTranslator;
    }
    
    class LiveLinkLightRole extends UE.LiveLinkTransformRole {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkLightRole;
        static Load(InName: string): LiveLinkLightRole;
    }
    
    class LiveLinkSourceFactory extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkSourceFactory;
        static Load(InName: string): LiveLinkSourceFactory;
    }
    
    class LiveLinkMagicLeapHandTrackingSourceFactory extends UE.LiveLinkSourceFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkMagicLeapHandTrackingSourceFactory;
        static Load(InName: string): LiveLinkMagicLeapHandTrackingSourceFactory;
    }
    
    class LiveLinkSubjectSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PreProcessors: TArray<UE.LiveLinkFramePreProcessor>;
        InterpolationProcessor: UE.LiveLinkFrameInterpolationProcessor;
        Translators: TArray<UE.LiveLinkFrameTranslator>;
        Role: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkSubjectSettings;
        static Load(InName: string): LiveLinkSubjectSettings;
    }
    
    class LiveLinkVirtualSubject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Role: UE.Class;
        Subjects: TArray<UE.LiveLinkSubjectName>;
        FrameTranslators: TArray<UE.LiveLinkFrameTranslator>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkVirtualSubject;
        static Load(InName: string): LiveLinkVirtualSubject;
    }
    
    class LoadPackageCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LoadPackageCommandlet;
        static Load(InName: string): LoadPackageCommandlet;
    }
    
    class LocalizationDashboardSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalizationDashboardSettings;
        static Load(InName: string): LocalizationDashboardSettings;
    }
    
    enum ELocalizationTargetConflictStatus { Unknown, ConflictsPresent, Clear, ELocalizationTargetConflictStatus_MAX}
    enum ELocalizationGatherPathRoot { Auto, Engine, Project, ELocalizationGatherPathRoot_MAX}
    class GatherTextSearchDirectory {
        constructor();
        constructor(PathRoot: UE.ELocalizationGatherPathRoot, Path: string);
        PathRoot: UE.ELocalizationGatherPathRoot;
        Path: string;
        static StaticClass(): Class;
    }
    
    class GatherTextExcludePath {
        constructor();
        constructor(PathRoot: UE.ELocalizationGatherPathRoot, Pattern: string);
        PathRoot: UE.ELocalizationGatherPathRoot;
        Pattern: string;
        static StaticClass(): Class;
    }
    
    class GatherTextFileExtension {
        constructor();
        constructor(Pattern: string);
        Pattern: string;
        static StaticClass(): Class;
    }
    
    class GatherTextFromTextFilesConfiguration {
        constructor();
        constructor(IsEnabled: boolean, SearchDirectories: TArray<UE.GatherTextSearchDirectory>, ExcludePathWildcards: TArray<UE.GatherTextExcludePath>, FileExtensions: TArray<UE.GatherTextFileExtension>, ShouldGatherFromEditorOnlyData: boolean);
        IsEnabled: boolean;
        SearchDirectories: TArray<UE.GatherTextSearchDirectory>;
        ExcludePathWildcards: TArray<UE.GatherTextExcludePath>;
        FileExtensions: TArray<UE.GatherTextFileExtension>;
        ShouldGatherFromEditorOnlyData: boolean;
        static StaticClass(): Class;
    }
    
    class GatherTextIncludePath {
        constructor();
        constructor(PathRoot: UE.ELocalizationGatherPathRoot, Pattern: string);
        PathRoot: UE.ELocalizationGatherPathRoot;
        Pattern: string;
        static StaticClass(): Class;
    }
    
    class GatherTextFromPackagesConfiguration {
        constructor();
        constructor(IsEnabled: boolean, IncludePathWildcards: TArray<UE.GatherTextIncludePath>, ExcludePathWildcards: TArray<UE.GatherTextExcludePath>, FileExtensions: TArray<UE.GatherTextFileExtension>, Collections: TArray<string>, ShouldGatherFromEditorOnlyData: boolean, SkipGatherCache: boolean);
        IsEnabled: boolean;
        IncludePathWildcards: TArray<UE.GatherTextIncludePath>;
        ExcludePathWildcards: TArray<UE.GatherTextExcludePath>;
        FileExtensions: TArray<UE.GatherTextFileExtension>;
        Collections: TArray<string>;
        ShouldGatherFromEditorOnlyData: boolean;
        SkipGatherCache: boolean;
        static StaticClass(): Class;
    }
    
    class MetaDataKeyName {
        constructor();
        constructor(Name: string);
        Name: string;
        static StaticClass(): Class;
    }
    
    class MetaDataTextKeyPattern {
        constructor();
        constructor(Pattern: string);
        Pattern: string;
        static StaticClass(): Class;
    }
    
    class MetaDataKeyGatherSpecification {
        constructor();
        constructor(MetaDataKey: UE.MetaDataKeyName, TextNamespace: string, TextKeyPattern: UE.MetaDataTextKeyPattern);
        MetaDataKey: UE.MetaDataKeyName;
        TextNamespace: string;
        TextKeyPattern: UE.MetaDataTextKeyPattern;
        static StaticClass(): Class;
    }
    
    class GatherTextFromMetaDataConfiguration {
        constructor();
        constructor(IsEnabled: boolean, IncludePathWildcards: TArray<UE.GatherTextIncludePath>, ExcludePathWildcards: TArray<UE.GatherTextExcludePath>, KeySpecifications: TArray<UE.MetaDataKeyGatherSpecification>, ShouldGatherFromEditorOnlyData: boolean);
        IsEnabled: boolean;
        IncludePathWildcards: TArray<UE.GatherTextIncludePath>;
        ExcludePathWildcards: TArray<UE.GatherTextExcludePath>;
        KeySpecifications: TArray<UE.MetaDataKeyGatherSpecification>;
        ShouldGatherFromEditorOnlyData: boolean;
        static StaticClass(): Class;
    }
    
    enum ELocalizedTextCollapseMode { IdenticalTextIdAndSource, IdenticalPackageIdTextIdAndSource, IdenticalNamespaceAndSource, ELocalizedTextCollapseMode_MAX}
    class LocalizationExportingSettings {
        constructor();
        constructor(CollapseMode: UE.ELocalizedTextCollapseMode, ShouldPersistCommentsOnExport: boolean, ShouldAddSourceLocationsAsComments: boolean);
        CollapseMode: UE.ELocalizedTextCollapseMode;
        ShouldPersistCommentsOnExport: boolean;
        ShouldAddSourceLocationsAsComments: boolean;
        static StaticClass(): Class;
    }
    
    class LocalizationCompilationSettings {
        constructor();
        constructor(SkipSourceCheck: boolean, ValidateFormatPatterns: boolean, ValidateSafeWhitespace: boolean);
        SkipSourceCheck: boolean;
        ValidateFormatPatterns: boolean;
        ValidateSafeWhitespace: boolean;
        static StaticClass(): Class;
    }
    
    class LocalizationImportDialogueSettings {
        constructor();
        constructor(RawAudioPath: UE.DirectoryPath, ImportedDialogueFolder: string, bImportNativeAsSource: boolean);
        RawAudioPath: UE.DirectoryPath;
        ImportedDialogueFolder: string;
        bImportNativeAsSource: boolean;
        static StaticClass(): Class;
    }
    
    class CultureStatistics {
        constructor();
        constructor(CultureName: string, WordCount: number);
        CultureName: string;
        WordCount: number;
        static StaticClass(): Class;
    }
    
    class LocalizationTargetSettings {
        constructor();
        constructor(Name: string, Guid: UE.Guid, ConflictStatus: UE.ELocalizationTargetConflictStatus, TargetDependencies: TArray<UE.Guid>, AdditionalManifestDependencies: TArray<UE.FilePath>, RequiredModuleNames: TArray<string>, GatherFromTextFiles: UE.GatherTextFromTextFilesConfiguration, GatherFromPackages: UE.GatherTextFromPackagesConfiguration, GatherFromMetaData: UE.GatherTextFromMetaDataConfiguration, ExportSettings: UE.LocalizationExportingSettings, CompileSettings: UE.LocalizationCompilationSettings, ImportDialogueSettings: UE.LocalizationImportDialogueSettings, NativeCultureIndex: number, SupportedCulturesStatistics: TArray<UE.CultureStatistics>);
        Name: string;
        Guid: UE.Guid;
        ConflictStatus: UE.ELocalizationTargetConflictStatus;
        TargetDependencies: TArray<UE.Guid>;
        AdditionalManifestDependencies: TArray<UE.FilePath>;
        RequiredModuleNames: TArray<string>;
        GatherFromTextFiles: UE.GatherTextFromTextFilesConfiguration;
        GatherFromPackages: UE.GatherTextFromPackagesConfiguration;
        GatherFromMetaData: UE.GatherTextFromMetaDataConfiguration;
        ExportSettings: UE.LocalizationExportingSettings;
        CompileSettings: UE.LocalizationCompilationSettings;
        ImportDialogueSettings: UE.LocalizationImportDialogueSettings;
        NativeCultureIndex: number;
        SupportedCulturesStatistics: TArray<UE.CultureStatistics>;
        static StaticClass(): Class;
    }
    
    class LocalizationTarget extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: UE.LocalizationTargetSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalizationTarget;
        static Load(InName: string): LocalizationTarget;
    }
    
    class LocalizationTargetSet extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetObjects: TArray<UE.LocalizationTarget>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalizationTargetSet;
        static Load(InName: string): LocalizationTargetSet;
    }
    
    class LocalizationSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EngineTargetSet: UE.LocalizationTargetSet;
        EngineTargetsSettings: TArray<UE.LocalizationTargetSettings>;
        GameTargetSet: UE.LocalizationTargetSet;
        GameTargetsSettings: TArray<UE.LocalizationTargetSettings>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalizationSettings;
        static Load(InName: string): LocalizationSettings;
    }
    
    class LocalizedOverlays extends UE.Overlays {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultOverlays: UE.BasicOverlays;
        LocaleToOverlaysMap: TMap<string, UE.BasicOverlays>;
        AssetImportData: UE.AssetImportData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalizedOverlays;
        static Load(InName: string): LocalizedOverlays;
    }
    
    class LocalizedOverlaysFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalizedOverlaysFactoryNew;
        static Load(InName: string): LocalizedOverlaysFactoryNew;
    }
    
    class LocalPlayerSubsystem extends UE.Subsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalPlayerSubsystem;
        static Load(InName: string): LocalPlayerSubsystem;
    }
    
    class LocalProfiles extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Profiles: TArray<UE.PreviewSceneProfile>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalProfiles;
        static Load(InName: string): LocalProfiles;
    }
    
    enum ELocationAccuracy { LA_ThreeKilometers, LA_OneKilometer, LA_HundredMeters, LA_TenMeters, LA_Best, LA_Navigation, LA_MAX}
    class LocationServicesData {
        constructor();
        constructor(Timestamp: number, Longitude: number, Latitude: number, HorizontalAccuracy: number, VerticalAccuracy: number, Altitude: number);
        Timestamp: number;
        Longitude: number;
        Latitude: number;
        HorizontalAccuracy: number;
        VerticalAccuracy: number;
        Altitude: number;
        static StaticClass(): Class;
    }
    
    class LocationServicesImpl extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnLocationChanged: $MulticastDelegate<(LocationData: UE.LocationServicesData) => void>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocationServicesImpl;
        static Load(InName: string): LocationServicesImpl;
    }
    
    class LocationServices extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AreLocationServicesEnabled() : boolean;
        static GetLastKnownLocation() : UE.LocationServicesData;
        static GetLocationServicesImpl() : UE.LocationServicesImpl;
        static InitLocationServices(Accuracy: UE.ELocationAccuracy, UpdateFrequency: number, MinDistanceFilter: number) : boolean;
        static IsLocationAccuracyAvailable(Accuracy: UE.ELocationAccuracy) : boolean;
        static StartLocationServices() : boolean;
        static StopLocationServices() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocationServices;
        static Load(InName: string): LocationServices;
    }
    
    class LODInfoUILayout extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LODInfo: UE.SkeletalMeshLODInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LODInfoUILayout;
        static Load(InName: string): LODInfoUILayout;
    }
    
    class LogoutCallbackProxy extends UE.BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(PlayerController: $Nullable<UE.PlayerController>) => void>;
        OnFailure: $MulticastDelegate<(PlayerController: $Nullable<UE.PlayerController>) => void>;
        static Logout(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>) : UE.LogoutCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LogoutCallbackProxy;
        static Load(InName: string): LogoutCallbackProxy;
    }
    
    class LogVisualizerSessionSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnableGraphsVisualization: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LogVisualizerSessionSettings;
        static Load(InName: string): LogVisualizerSessionSettings;
    }
    
    class CategoryFilter {
        constructor();
        constructor(CategoryName: string, LogVerbosity: number, Enabled: boolean);
        CategoryName: string;
        LogVerbosity: number;
        Enabled: boolean;
        static StaticClass(): Class;
    }
    
    class VisualLoggerFiltersData {
        constructor();
        constructor(SearchBoxFilter: string, ObjectNameFilter: string, Categories: TArray<UE.CategoryFilter>, SelectedClasses: TArray<string>);
        SearchBoxFilter: string;
        ObjectNameFilter: string;
        Categories: TArray<UE.CategoryFilter>;
        SelectedClasses: TArray<string>;
        static StaticClass(): Class;
    }
    
    class LogVisualizerSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIgnoreTrivialLogs: boolean;
        TrivialLogsThreshold: number;
        bStickToRecentData: boolean;
        bResetDataWithNewSession: boolean;
        bShowHistogramLabelsOutside: boolean;
        DefaultCameraDistance: number;
        bSearchInsideLogs: boolean;
        GraphsBackgroundColor: UE.Color;
        bPresistentFilters: boolean;
        bDrawExtremesOnGraphs: boolean;
        bConstrainGraphToLocalMinMax: boolean;
        bUsePlayersOnlyForPause: boolean;
        bLogNavOctreeOnStop: boolean;
        PresistentFilters: UE.VisualLoggerFiltersData;
        DebugMeshMaterialFakeLight: UE.Material;
        DebugMeshMaterialFakeLightName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LogVisualizerSettings;
        static Load(InName: string): LogVisualizerSettings;
    }
    
    class LuminApplicationLifecycleComponent extends UE.ApplicationLifecycleComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DeviceHasReactivatedDelegate: $MulticastDelegate<() => void>;
        DeviceWillEnterRealityModeDelegate: $MulticastDelegate<() => void>;
        DeviceWillGoInStandbyDelegate: $MulticastDelegate<() => void>;
        LuminApplicationLifetimeDelegate__DelegateSignature() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LuminApplicationLifecycleComponent;
        static Load(InName: string): LuminApplicationLifecycleComponent;
    }
    
    enum ELuminARLineTraceChannel { None, FeaturePoint, InfinitePlane, PlaneUsingExtent, PlaneUsingBoundaryPolygon, FeaturePointWithSurfaceNormal, ELuminARLineTraceChannel_MAX}
    enum ELuminARTrackingState { Tracking, NotTracking, StoppedTracking, ELuminARTrackingState_MAX}
    class LuminARLightEstimate {
        constructor();
        constructor(bIsValid: boolean, PixelIntensity: number, RGBScaleFactor: UE.Vector);
        bIsValid: boolean;
        PixelIntensity: number;
        RGBScaleFactor: UE.Vector;
        static StaticClass(): Class;
    }
    
    class LuminARFrameFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetLightEstimation(OutLightEstimate: $Ref<UE.LuminARLightEstimate>) : void;
        static GetTrackingState() : UE.ELuminARTrackingState;
        static LuminARLineTrace(WorldContextObject: $Nullable<UE.Object>, ScreenPosition: UE.Vector2D, TraceChannels: TSet<UE.ELuminARLineTraceChannel>, OutHitResults: $Ref<TArray<UE.ARTraceResult>>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LuminARFrameFunctionLibrary;
        static Load(InName: string): LuminARFrameFunctionLibrary;
    }
    
    enum EMagicLeapPlaneQueryFlags { Vertical, Horizontal, Arbitrary, OrientToGravity, PreferInner, Ceiling, Floor, Wall, Polygons, EMagicLeapPlaneQueryFlags_MAX}
    class LuminARSessionConfig extends UE.ARSessionConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxPlaneQueryResults: number;
        MinPlaneArea: number;
        bArbitraryOrientationPlaneDetection: boolean;
        PlaneSearchExtents: UE.Vector;
        PlaneQueryFlags: TArray<UE.EMagicLeapPlaneQueryFlags>;
        bDiscardZeroExtentPlanes: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LuminARSessionConfig;
        static Load(InName: string): LuminARSessionConfig;
    }
    
    class LuminARSessionFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StartLuminARSession(WorldContextObject: $Nullable<UE.Object>, LatentInfo: UE.LatentActionInfo, Configuration: $Nullable<UE.LuminARSessionConfig>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LuminARSessionFunctionLibrary;
        static Load(InName: string): LuminARSessionFunctionLibrary;
    }
    
    class LuminARUObjectManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AllAnchors: TArray<UE.ARPin>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LuminARUObjectManager;
        static Load(InName: string): LuminARUObjectManager;
    }
    
    enum ELuminFrameTimingHint { Unspecified, Maximum, FPS_60, FPS_120, ELuminFrameTimingHint_MAX}
    enum ELuminPrivilege { Invalid, BatteryInfo, CameraCapture, WorldReconstruction, InAppPurchase, AudioCaptureMic, DrmCertificates, Occlusion, LowLatencyLightwear, Internet, IdentityRead, BackgroundDownload, BackgroundUpload, MediaDrm, Media, MediaMetadata, PowerInfo, LocalAreaNetwork, VoiceInput, Documents, ConnectBackgroundMusicService, RegisterBackgroundMusicService, PwFoundObjRead, NormalNotificationsUsage, MusicService, ControllerPose, ScreensProvider, GesturesSubscribe, GesturesConfig, AddressBookRead, AddressBookWrite, CoarseLocation, HandMesh, WifiStatusRead, ELuminPrivilege_MAX}
    enum ELuminComponentSubElementType { FileExtension, MimeType, Mode, MusicAttribute, Schema, ELuminComponentSubElementType_MAX}
    class LuminComponentSubElement {
        constructor();
        constructor(ElementType: UE.ELuminComponentSubElementType, Value: string);
        ElementType: UE.ELuminComponentSubElementType;
        Value: string;
        static StaticClass(): Class;
    }
    
    enum ELuminComponentType { Universe, Fullscreen, SearchProvider, MusicService, Screens, ScreensImmersive, Console, SystemUI, ELuminComponentType_MAX}
    class LuminComponentElement {
        constructor();
        constructor(Name: string, VisibleName: string, ExecutableName: string, ComponentType: UE.ELuminComponentType, ExtraComponentSubElements: TArray<UE.LuminComponentSubElement>);
        Name: string;
        VisibleName: string;
        ExecutableName: string;
        ComponentType: UE.ELuminComponentType;
        ExtraComponentSubElements: TArray<UE.LuminComponentSubElement>;
        static StaticClass(): Class;
    }
    
    class LuminRuntimeSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PackageName: string;
        ApplicationDisplayName: string;
        bIsScreensApp: boolean;
        FrameTimingHint: UE.ELuminFrameTimingHint;
        bProtectedContent: boolean;
        bUseMobileRendering: boolean;
        bUseVulkan: boolean;
        Certificate: UE.FilePath;
        IconModelPath: UE.DirectoryPath;
        IconPortalPath: UE.DirectoryPath;
        VersionCode: number;
        MinimumAPILevel: number;
        AppPrivileges: TArray<UE.ELuminPrivilege>;
        ExtraComponentSubElements: TArray<UE.LuminComponentSubElement>;
        ExtraComponentElements: TArray<UE.LuminComponentElement>;
        SpatializationPlugin: string;
        ReverbPlugin: string;
        OcclusionPlugin: string;
        SoundCueCookQualityIndex: number;
        bRemoveDebugInfo: boolean;
        VulkanValidationLayerLibs: UE.DirectoryPath;
        bFrameVignette: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LuminRuntimeSettings;
        static Load(InName: string): LuminRuntimeSettings;
    }
    
    enum EMagicLeapAutoPinType { OnlyOnDataRestoration, Always, Never, EMagicLeapAutoPinType_MAX}
    class MagicLeapARPinSaveGame extends UE.SaveGame {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PinnedID: UE.Guid;
        ComponentWorldTransform: UE.Transform;
        PinTransform: UE.Transform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapARPinSaveGame;
        static Load(InName: string): MagicLeapARPinSaveGame;
    }
    
    class MagicLeapARPinComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ObjectUID: string;
        UserIndex: number;
        AutoPinType: UE.EMagicLeapAutoPinType;
        bShouldPinActor: boolean;
        PinDataClass: UE.Class;
        OnPersistentEntityPinned: $MulticastDelegate<(bRestoredOrSynced: boolean) => void>;
        OnPersistentEntityPinLost: $MulticastDelegate<() => void>;
        PinnedCFUID: UE.Guid;
        PinnedSceneComponent: UE.SceneComponent;
        PinData: UE.MagicLeapARPinSaveGame;
        GetPinData(PinDataClass: $Nullable<UE.Class>) : UE.MagicLeapARPinSaveGame;
        GetPinnedPinID(PinID: $Ref<UE.Guid>) : boolean;
        IsPinned() : boolean;
        PersistentEntityPinLost__DelegateSignature() : void;
        PersistentEntityPinned__DelegateSignature(bRestoredOrSynced: boolean) : void;
        PinActor(ActorToPin: $Nullable<UE.Actor>) : boolean;
        PinRestoredOrSynced() : boolean;
        PinSceneComponent(ComponentToPin: $Nullable<UE.SceneComponent>) : boolean;
        UnPin() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapARPinComponent;
        static Load(InName: string): MagicLeapARPinComponent;
    }
    
    enum EMagicLeapPassableWorldError { None, LowMapQuality, UnableToLocalize, Unavailable, PrivilegeDenied, InvalidParam, UnspecifiedFailure, PrivilegeRequestPending, EMagicLeapPassableWorldError_MAX}
    class MagicLeapARPinFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CreateTracker() : UE.EMagicLeapPassableWorldError;
        static DestroyTracker() : UE.EMagicLeapPassableWorldError;
        static GetARPinPositionAndOrientation(PinID: UE.Guid, Position: $Ref<UE.Vector>, Orientation: $Ref<UE.Rotator>, PinFoundInEnvironment: $Ref<boolean>) : boolean;
        static GetAvailableARPins(NumRequested: number, Pins: $Ref<TArray<UE.Guid>>) : UE.EMagicLeapPassableWorldError;
        static GetClosestARPin(SearchPoint: UE.Vector, PinID: $Ref<UE.Guid>) : UE.EMagicLeapPassableWorldError;
        static GetNumAvailableARPins(Count: $Ref<number>) : UE.EMagicLeapPassableWorldError;
        static IsTrackerValid() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapARPinFunctionLibrary;
        static Load(InName: string): MagicLeapARPinFunctionLibrary;
    }
    
    class MagicLeapAudioFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetOnAudioJackPluggedDelegate(ResultDelegate: $Delegate<() => void>) : boolean;
        static SetOnAudioJackUnpluggedDelegate(ResultDelegate: $Delegate<() => void>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapAudioFunctionLibrary;
        static Load(InName: string): MagicLeapAudioFunctionLibrary;
    }
    
    enum EMagicLeapControllerTrackingMode { InputService, CoordinateFrameUID, EMagicLeapControllerTrackingMode_MAX}
    enum EMagicLeapControllerLEDPattern { None, Clock01, Clock02, Clock03, Clock04, Clock05, Clock06, Clock07, Clock08, Clock09, Clock10, Clock11, Clock12, Clock01_07, Clock02_08, Clock03_09, Clock04_10, Clock05_11, Clock06_12, EMagicLeapControllerLEDPattern_MAX}
    enum EMagicLeapControllerLEDColor { BrightMissionRed, PastelMissionRed, BrightFloridaOrange, PastelFloridaOrange, BrightLunaYellow, PastelLunaYellow, BrightNebulaPink, PastelNebulaPink, BrightCosmicPurple, PastelCosmicPurple, BrightMysticBlue, PastelMysticBlue, BrightCelestialBlue, PastelCelestialBlue, BrightShaggleGreen, PastelShaggleGreen, EMagicLeapControllerLEDColor_MAX}
    enum EMagicLeapControllerLEDEffect { RotateCW, RotateCCW, Pulse, PaintCW, PaintCCW, Blink, EMagicLeapControllerLEDEffect_MAX}
    enum EMagicLeapControllerLEDSpeed { Slow, Medium, Fast, EMagicLeapControllerLEDSpeed_MAX}
    enum EMagicLeapControllerHapticPattern { None, Click, Bump, DoubleClick, Buzz, Tick, ForceDown, ForceUp, ForceDwell, SecondForceDown, EMagicLeapControllerHapticPattern_MAX}
    enum EMagicLeapControllerHapticIntensity { Low, Medium, High, EMagicLeapControllerHapticIntensity_MAX}
    enum EMagicLeapControllerType { None, Device, MobileApp, EMagicLeapControllerType_MAX}
    class MagicLeapControllerFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetControllerMapping(ControllerIndex: number, Hand: $Ref<UE.EControllerHand>) : boolean;
        static GetControllerTrackingMode() : UE.EMagicLeapControllerTrackingMode;
        static GetControllerType(MotionSource: string) : UE.EMagicLeapControllerType;
        static GetHandForMotionSource(MotionSource: string) : UE.EControllerHand;
        static GetMLControllerType(Hand: UE.EControllerHand) : UE.EMagicLeapControllerType;
        static GetMotionSourceForHand(Hand: UE.EControllerHand) : string;
        static InvertControllerMapping() : void;
        static IsMLControllerConnected(MotionSource: string) : boolean;
        static MaxSupportedMagicLeapControllers() : number;
        static PlayControllerHapticFeedback(Hand: UE.EControllerHand, HapticPattern: UE.EMagicLeapControllerHapticPattern, Intensity: UE.EMagicLeapControllerHapticIntensity) : boolean;
        static PlayControllerLED(Hand: UE.EControllerHand, LEDPattern: UE.EMagicLeapControllerLEDPattern, LEDColor: UE.EMagicLeapControllerLEDColor, DurationInSec: number) : boolean;
        static PlayControllerLEDEffect(Hand: UE.EControllerHand, LEDEffect: UE.EMagicLeapControllerLEDEffect, LEDSpeed: UE.EMagicLeapControllerLEDSpeed, LEDPattern: UE.EMagicLeapControllerLEDPattern, LEDColor: UE.EMagicLeapControllerLEDColor, DurationInSec: number) : boolean;
        static PlayHapticPattern(MotionSource: string, HapticPattern: UE.EMagicLeapControllerHapticPattern, Intensity: UE.EMagicLeapControllerHapticIntensity) : boolean;
        static PlayLEDEffect(MotionSource: string, LEDEffect: UE.EMagicLeapControllerLEDEffect, LEDSpeed: UE.EMagicLeapControllerLEDSpeed, LEDPattern: UE.EMagicLeapControllerLEDPattern, LEDColor: UE.EMagicLeapControllerLEDColor, DurationInSec: number) : boolean;
        static PlayLEDPattern(MotionSource: string, LEDPattern: UE.EMagicLeapControllerLEDPattern, LEDColor: UE.EMagicLeapControllerLEDColor, DurationInSec: number) : boolean;
        static SetControllerTrackingMode(TrackingMode: UE.EMagicLeapControllerTrackingMode) : boolean;
        static SetMotionSourceForHand(Hand: UE.EControllerHand, MotionSource: string) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapControllerFunctionLibrary;
        static Load(InName: string): MagicLeapControllerFunctionLibrary;
    }
    
    class MagicLeapFixationComfort {
        constructor();
        constructor(FixationDepthIsUncomfortable: boolean, FixationDepthViolationHasOccurred: boolean, RemainingTimeAtUncomfortableDepth: number);
        FixationDepthIsUncomfortable: boolean;
        FixationDepthViolationHasOccurred: boolean;
        RemainingTimeAtUncomfortableDepth: number;
        static StaticClass(): Class;
    }
    
    class MagicLeapEyeBlinkState {
        constructor();
        constructor(LeftEyeBlinked: boolean, RightEyeBlinked: boolean);
        LeftEyeBlinked: boolean;
        RightEyeBlinked: boolean;
        static StaticClass(): Class;
    }
    
    enum EMagicLeapEyeTrackingCalibrationStatus { None, Bad, Good, EMagicLeapEyeTrackingCalibrationStatus_MAX}
    class MagicLeapEyeTrackerFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetCalibrationStatus() : UE.EMagicLeapEyeTrackingCalibrationStatus;
        static GetEyeBlinkState(BlinkState: $Ref<UE.MagicLeapEyeBlinkState>) : boolean;
        static GetFixationComfort(FixationComfort: $Ref<UE.MagicLeapFixationComfort>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapEyeTrackerFunctionLibrary;
        static Load(InName: string): MagicLeapEyeTrackerFunctionLibrary;
    }
    
    class MagicLeapFileMediaSourceFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapFileMediaSourceFactory;
        static Load(InName: string): MagicLeapFileMediaSourceFactory;
    }
    
    class MagicLeapHandMeshingComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConnectMRMesh(InMRMeshPtr: $Nullable<UE.MRMeshComponent>) : boolean;
        DisconnectMRMesh(InMRMeshPtr: $Nullable<UE.MRMeshComponent>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapHandMeshingComponent;
        static Load(InName: string): MagicLeapHandMeshingComponent;
    }
    
    class MagicLeapHandMeshingFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ConnectMRMesh(InMRMeshPtr: $Nullable<UE.MRMeshComponent>) : boolean;
        static CreateClient() : boolean;
        static DestroyClient() : boolean;
        static DisconnectMRMesh(InMRMeshPtr: $Nullable<UE.MRMeshComponent>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapHandMeshingFunctionLibrary;
        static Load(InName: string): MagicLeapHandMeshingFunctionLibrary;
    }
    
    enum EMagicLeapHandTrackingGesture { Finger, Fist, Pinch, Thumb, L, OpenHand, OpenHandBack, Ok, C, NoPose, NoHand, EMagicLeapHandTrackingGesture_MAX}
    enum EMagicLeapHandTrackingKeypointFilterLevel { NoFilter, SimpleSmoothing, PredictiveSmoothing, EMagicLeapHandTrackingKeypointFilterLevel_MAX}
    enum EMagicLeapHandTrackingGestureFilterLevel { NoFilter, SlightRobustnessToFlicker, MoreRobustnessToFlicker, EMagicLeapHandTrackingGestureFilterLevel_MAX}
    class LiveLinkSourceHandle {
        constructor();
        static StaticClass(): Class;
    }
    
    enum EMagicLeapGestureTransformSpace { World, Hand, Tracking, EMagicLeapGestureTransformSpace_MAX}
    enum EMagicLeapHandTrackingKeypoint { Thumb_Tip, Thumb_IP, Thumb_MCP, Thumb_CMC, Index_Tip, Index_DIP, Index_PIP, Index_MCP, Middle_Tip, Middle_DIP, Middle_PIP, Middle_MCP, Ring_Tip, Ring_DIP, Ring_PIP, Ring_MCP, Pinky_Tip, Pinky_DIP, Pinky_PIP, Pinky_MCP, Wrist_Center, Wrist_Ulnar, Wrist_Radial, Hand_Center, EMagicLeapHandTrackingKeypoint_MAX}
    class MagicLeapHandTrackingFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetConfiguration(ActiveStaticGestures: $Ref<TArray<UE.EMagicLeapHandTrackingGesture>>, KeypointsFilterLevel: $Ref<UE.EMagicLeapHandTrackingKeypointFilterLevel>, GestureFilterLevel: $Ref<UE.EMagicLeapHandTrackingGestureFilterLevel>, bTrackingEnabled: $Ref<boolean>) : boolean;
        static GetCurrentGesture(Hand: UE.EControllerHand, Gesture: $Ref<UE.EMagicLeapHandTrackingGesture>) : boolean;
        static GetCurrentGestureConfidence(Hand: UE.EControllerHand, Confidence: $Ref<number>) : boolean;
        static GetGestureKeypoints(Hand: UE.EControllerHand, Keypoints: $Ref<TArray<UE.Transform>>) : boolean;
        static GetGestureKeypointTransform(Hand: UE.EControllerHand, Keypoint: UE.EMagicLeapHandTrackingKeypoint, TransformSpace: UE.EMagicLeapGestureTransformSpace, Transform: $Ref<UE.Transform>) : boolean;
        static GetHandCenter(Hand: UE.EControllerHand, HandCenter: $Ref<UE.Transform>) : boolean;
        static GetHandCenterNormalized(Hand: UE.EControllerHand, HandCenterNormalized: $Ref<UE.Vector>) : boolean;
        static GetHandIndexFingerTip(Hand: UE.EControllerHand, TransformSpace: UE.EMagicLeapGestureTransformSpace, Pointer: $Ref<UE.Transform>) : boolean;
        static GetHandThumbTip(Hand: UE.EControllerHand, TransformSpace: UE.EMagicLeapGestureTransformSpace, Secondary: $Ref<UE.Transform>) : boolean;
        static GetMagicLeapHandTrackingLiveLinkSource(SourceHandle: $Ref<UE.LiveLinkSourceHandle>) : boolean;
        static GetStaticGestureConfidenceThreshold(Gesture: UE.EMagicLeapHandTrackingGesture) : number;
        static SetConfiguration(StaticGesturesToActivate: TArray<UE.EMagicLeapHandTrackingGesture>, KeypointsFilterLevel?: UE.EMagicLeapHandTrackingKeypointFilterLevel /* = NoFilter */, GestureFilterLevel?: UE.EMagicLeapHandTrackingGestureFilterLevel /* = NoFilter */, bTrackingEnabled?: boolean /* = true */) : boolean;
        static SetStaticGestureConfidenceThreshold(Gesture: UE.EMagicLeapHandTrackingGesture, Confidence: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapHandTrackingFunctionLibrary;
        static Load(InName: string): MagicLeapHandTrackingFunctionLibrary;
    }
    
    class VRNotificationsComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HMDTrackingInitializingAndNeedsHMDToBeTrackedDelegate: $MulticastDelegate<() => void>;
        HMDTrackingInitializedDelegate: $MulticastDelegate<() => void>;
        HMDRecenteredDelegate: $MulticastDelegate<() => void>;
        HMDLostDelegate: $MulticastDelegate<() => void>;
        HMDReconnectedDelegate: $MulticastDelegate<() => void>;
        HMDConnectCanceledDelegate: $MulticastDelegate<() => void>;
        HMDPutOnHeadDelegate: $MulticastDelegate<() => void>;
        HMDRemovedFromHeadDelegate: $MulticastDelegate<() => void>;
        VRControllerRecenteredDelegate: $MulticastDelegate<() => void>;
        VRNotificationsDelegate__DelegateSignature() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VRNotificationsComponent;
        static Load(InName: string): VRNotificationsComponent;
    }
    
    class MagicLeapHeadTrackingNotificationsComponent extends UE.VRNotificationsComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnHeadTrackingLost: $MulticastDelegate<() => void>;
        OnHeadTrackingRecovered: $MulticastDelegate<() => void>;
        OnHeadTrackingRecoveryFailed: $MulticastDelegate<() => void>;
        OnHeadTrackingNewSessionStarted: $MulticastDelegate<() => void>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapHeadTrackingNotificationsComponent;
        static Load(InName: string): MagicLeapHeadTrackingNotificationsComponent;
    }
    
    enum EMagicLeapHeadTrackingMode { PositionAndOrientation, Unavailable, Unknown, EMagicLeapHeadTrackingMode_MAX}
    enum EMagicLeapHeadTrackingError { None, NotEnoughFeatures, LowLight, Unknown, EMagicLeapHeadTrackingError_MAX}
    class MagicLeapHeadTrackingState {
        constructor();
        constructor(Mode: UE.EMagicLeapHeadTrackingMode, Error: UE.EMagicLeapHeadTrackingError, Confidence: number);
        Mode: UE.EMagicLeapHeadTrackingMode;
        Error: UE.EMagicLeapHeadTrackingError;
        Confidence: number;
        static StaticClass(): Class;
    }
    
    enum EMagicLeapHeadTrackingMapEvent { Lost, Recovered, RecoveryFailed, NewSession, EMagicLeapHeadTrackingMapEvent_MAX}
    class MagicLeapHMDFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetHeadTrackingMapEvents(MapEvents: $Ref<TSet<UE.EMagicLeapHeadTrackingMapEvent>>) : boolean;
        static GetHeadTrackingState(State: $Ref<UE.MagicLeapHeadTrackingState>) : boolean;
        static GetMLSDKVersion() : string;
        static GetMLSDKVersionMajor() : number;
        static GetMLSDKVersionMinor() : number;
        static GetMLSDKVersionRevision() : number;
        static IsRunningOnMagicLeapHMD() : boolean;
        static SetAppReady() : boolean;
        static SetBaseOrientation(InBaseOrientation: UE.Quat) : void;
        static SetBasePosition(InBasePosition: UE.Vector) : void;
        static SetBaseRotation(InBaseRotation: UE.Rotator) : void;
        static SetFocusActor(InFocusActor: $Nullable<UE.Actor>, bSetStabilizationActor?: boolean /* = true */) : void;
        static SetStabilizationDepthActor(InStabilizationDepthActor: $Nullable<UE.Actor>, bSetFocusActor?: boolean /* = true */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapHMDFunctionLibrary;
        static Load(InName: string): MagicLeapHMDFunctionLibrary;
    }
    
    enum EMagicLeapIdentityError { Ok, InvalidParam, AllocFailed, PrivilegeDenied, FailedToConnectToLocalService, FailedToConnectToCloudService, CloudAuthentication, InvalidInformationFromCloud, NotLoggedIn, ExpiredCredentials, FailedToGetUserProfile, Unauthorized, CertificateError, RejectedByCloud, AlreadyLoggedIn, ModifyIsNotSupported, NetworkError, UnspecifiedFailure, EMagicLeapIdentityError_MAX}
    enum EMagicLeapIdentityKey { GivenName, FamilyName, Email, Bio, PhoneNumber, Avatar2D, Avatar3D, Unknown, EMagicLeapIdentityKey_MAX}
    class MagicLeapIdentityAttribute {
        constructor();
        constructor(Attribute: UE.EMagicLeapIdentityKey, Value: string);
        Attribute: UE.EMagicLeapIdentityKey;
        Value: string;
        static StaticClass(): Class;
    }
    
    class MagicLeapIdentity extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AvailableIdentityAttributesDelegate__DelegateSignature(ResultCode: UE.EMagicLeapIdentityError, AvailableAttributes: TArray<UE.EMagicLeapIdentityKey>) : void;
        GetAllAvailableAttributes(AvailableAttributes: $Ref<TArray<UE.EMagicLeapIdentityKey>>) : UE.EMagicLeapIdentityError;
        GetAllAvailableAttributesAsync(ResultDelegate: $Delegate<(ResultCode: UE.EMagicLeapIdentityError, AvailableAttributes: TArray<UE.EMagicLeapIdentityKey>) => void>) : void;
        ModifyIdentityAttributeValueDelegate__DelegateSignature(ResultCode: UE.EMagicLeapIdentityError, AttributesUpdatedSuccessfully: TArray<UE.EMagicLeapIdentityKey>) : void;
        RequestAttributeValue(RequestedAttributeList: TArray<UE.EMagicLeapIdentityKey>, RequestedAttributeValues: $Ref<TArray<UE.MagicLeapIdentityAttribute>>) : UE.EMagicLeapIdentityError;
        RequestAttributeValueAsync(RequestedAttributeList: TArray<UE.EMagicLeapIdentityKey>, ResultDelegate: $Delegate<(ResultCode: UE.EMagicLeapIdentityError, AttributeValue: TArray<UE.MagicLeapIdentityAttribute>) => void>) : UE.EMagicLeapIdentityError;
        RequestIdentityAttributeValueDelegate__DelegateSignature(ResultCode: UE.EMagicLeapIdentityError, AttributeValue: TArray<UE.MagicLeapIdentityAttribute>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapIdentity;
        static Load(InName: string): MagicLeapIdentity;
    }
    
    class MagicLeapImageTrackerComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetImageTexture: UE.Texture2D;
        Name: string;
        LongerDimension: number;
        bIsStationary: boolean;
        bUseUnreliablePose: boolean;
        OnSetImageTargetSucceeded: $MulticastDelegate<() => void>;
        OnSetImageTargetFailed: $MulticastDelegate<() => void>;
        OnImageTargetFound: $MulticastDelegate<() => void>;
        OnImageTargetLost: $MulticastDelegate<() => void>;
        OnImageTargetUnreliableTracking: $MulticastDelegate<(LastTrackedLocation: UE.Vector, LastTrackedRotation: UE.Rotator, NewUnreliableLocation: UE.Vector, NewUnreliableRotation: UE.Rotator) => void>;
        RemoveTargetAsync() : boolean;
        SetTargetAsync(ImageTarget: $Nullable<UE.Texture2D>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapImageTrackerComponent;
        static Load(InName: string): MagicLeapImageTrackerComponent;
    }
    
    class MagicLeapImageTrackerFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static EnableImageTracking(bEnable: boolean) : void;
        static GetMaxSimultaneousTargets() : number;
        static IsImageTrackingEnabled() : boolean;
        static SetMaxSimultaneousTargets(MaxSimultaneousTargets: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapImageTrackerFunctionLibrary;
        static Load(InName: string): MagicLeapImageTrackerFunctionLibrary;
    }
    
    enum EMagicLeapMeshState { New, Updated, Deleted, Unchanged, EMagicLeapMeshState_MAX}
    class MagicLeapMeshBlockInfo {
        constructor();
        constructor(BlockID: UE.Guid, BlockPosition: UE.Vector, BlockOrientation: UE.Rotator, BlockDimensions: UE.Vector, Timestamp: UE.Timespan, BlockState: UE.EMagicLeapMeshState);
        BlockID: UE.Guid;
        BlockPosition: UE.Vector;
        BlockOrientation: UE.Rotator;
        BlockDimensions: UE.Vector;
        Timestamp: UE.Timespan;
        BlockState: UE.EMagicLeapMeshState;
        static StaticClass(): Class;
    }
    
    class MagicLeapTrackingMeshInfo {
        constructor();
        constructor(Timestamp: UE.Timespan, BlockData: TArray<UE.MagicLeapMeshBlockInfo>);
        Timestamp: UE.Timespan;
        BlockData: TArray<UE.MagicLeapMeshBlockInfo>;
        static StaticClass(): Class;
    }
    
    enum EMagicLeapMeshLOD { Minimum, Medium, Maximum, EMagicLeapMeshLOD_MAX}
    class MagicLeapMeshBlockRequest {
        constructor();
        constructor(BlockID: UE.Guid, LevelOfDetail: UE.EMagicLeapMeshLOD);
        BlockID: UE.Guid;
        LevelOfDetail: UE.EMagicLeapMeshLOD;
        static StaticClass(): Class;
    }
    
    class MagicLeapMeshBlockSelectorInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SelectMeshBlocks(NewMeshInfo: UE.MagicLeapTrackingMeshInfo, RequestedMesh: $Ref<TArray<UE.MagicLeapMeshBlockRequest>>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapMeshBlockSelectorInterface;
        static Load(InName: string): MagicLeapMeshBlockSelectorInterface;
    }
    
    class MagicLeapPlaneResult {
        constructor();
        constructor(PlanePosition: UE.Vector, PlaneOrientation: UE.Rotator, ContentOrientation: UE.Rotator, PlaneDimensions: UE.Vector2D, PlaneFlags: TArray<UE.EMagicLeapPlaneQueryFlags>, ID: UE.Guid);
        PlanePosition: UE.Vector;
        PlaneOrientation: UE.Rotator;
        ContentOrientation: UE.Rotator;
        PlaneDimensions: UE.Vector2D;
        PlaneFlags: TArray<UE.EMagicLeapPlaneQueryFlags>;
        ID: UE.Guid;
        static StaticClass(): Class;
    }
    
    class MagicLeapPolygon {
        constructor();
        constructor(Vertices: TArray<UE.Vector>);
        Vertices: TArray<UE.Vector>;
        static StaticClass(): Class;
    }
    
    class MagicLeapPlaneBoundary {
        constructor();
        constructor(Polygon: UE.MagicLeapPolygon, Holes: TArray<UE.MagicLeapPolygon>);
        Polygon: UE.MagicLeapPolygon;
        Holes: TArray<UE.MagicLeapPolygon>;
        static StaticClass(): Class;
    }
    
    class MagicLeapPlaneBoundaries {
        constructor();
        constructor(ID: UE.Guid, Boundaries: TArray<UE.MagicLeapPlaneBoundary>);
        ID: UE.Guid;
        Boundaries: TArray<UE.MagicLeapPlaneBoundary>;
        static StaticClass(): Class;
    }
    
    class MagicLeapPlanesComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        QueryFlags: TArray<UE.EMagicLeapPlaneQueryFlags>;
        SearchVolume: UE.BoxComponent;
        MaxResults: number;
        MinHolePerimeter: number;
        MinPlaneArea: number;
        OnPlanesQueryResult: $MulticastDelegate<(bSuccess: boolean, Planes: TArray<UE.MagicLeapPlaneResult>, Polygons: TArray<UE.MagicLeapPlaneBoundaries>) => void>;
        RequestPlanesAsync() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapPlanesComponent;
        static Load(InName: string): MagicLeapPlanesComponent;
    }
    
    class MagicLeapPlanesQuery {
        constructor();
        constructor(Flags: TArray<UE.EMagicLeapPlaneQueryFlags>, SearchVolume: UE.BoxComponent, MaxResults: number, MinHoleLength: number, MinPlaneArea: number, SearchVolumePosition: UE.Vector, SearchVolumeOrientation: UE.Quat, SearchVolumeExtents: UE.Vector);
        Flags: TArray<UE.EMagicLeapPlaneQueryFlags>;
        SearchVolume: UE.BoxComponent;
        MaxResults: number;
        MinHoleLength: number;
        MinPlaneArea: number;
        SearchVolumePosition: UE.Vector;
        SearchVolumeOrientation: UE.Quat;
        SearchVolumeExtents: UE.Vector;
        static StaticClass(): Class;
    }
    
    class MagicLeapPlanesFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CreateTracker() : boolean;
        static DestroyTracker() : boolean;
        static GetContentScale(ContentActor: $Nullable<UE.Actor>, PlaneResult: UE.MagicLeapPlaneResult) : UE.Transform;
        static IsTrackerValid() : boolean;
        static PlanesQueryBeginAsync(Query: UE.MagicLeapPlanesQuery, ResultDelegate: $Delegate<(bSuccess: boolean, Planes: TArray<UE.MagicLeapPlaneResult>, Polygons: TArray<UE.MagicLeapPlaneBoundaries>) => void>) : boolean;
        static RemoveFlagsNotInQuery(InQueryFlags: TArray<UE.EMagicLeapPlaneQueryFlags>, InResultFlags: TArray<UE.EMagicLeapPlaneQueryFlags>, OutFlags: $Ref<TArray<UE.EMagicLeapPlaneQueryFlags>>) : void;
        static ReorderPlaneFlags(InPriority: TArray<UE.EMagicLeapPlaneQueryFlags>, InFlagsToReorder: TArray<UE.EMagicLeapPlaneQueryFlags>, OutReorderedFlags: $Ref<TArray<UE.EMagicLeapPlaneQueryFlags>>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapPlanesFunctionLibrary;
        static Load(InName: string): MagicLeapPlanesFunctionLibrary;
    }
    
    enum EMagicLeapPrivilege { Invalid, BatteryInfo, CameraCapture, WorldReconstruction, InAppPurchase, AudioCaptureMic, DrmCertificates, Occlusion, LowLatencyLightwear, Internet, IdentityRead, BackgroundDownload, BackgroundUpload, MediaDrm, Media, MediaMetadata, PowerInfo, LocalAreaNetwork, VoiceInput, Documents, ConnectBackgroundMusicService, RegisterBackgroundMusicService, PwFoundObjRead, NormalNotificationsUsage, MusicService, ControllerPose, ScreensProvider, GesturesSubscribe, GesturesConfig, AddressBookRead, AddressBookWrite, CoarseLocation, HandMesh, WifiStatusRead, EMagicLeapPrivilege_MAX}
    class MagicLeapPrivilegesFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CheckPrivilege(Privilege: UE.EMagicLeapPrivilege) : boolean;
        static RequestPrivilege(Privilege: UE.EMagicLeapPrivilege) : boolean;
        static RequestPrivilegeAsync(Privilege: UE.EMagicLeapPrivilege, ResultDelegate: $Delegate<(RequestedPrivilege: UE.EMagicLeapPrivilege, WasGranted: boolean) => void>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapPrivilegesFunctionLibrary;
        static Load(InName: string): MagicLeapPrivilegesFunctionLibrary;
    }
    
    enum EMagicLeapRaycastResultState { RequestFailed, NoCollision, HitUnobserved, HitObserved, EMagicLeapRaycastResultState_MAX}
    class MagicLeapRaycastHitResult {
        constructor();
        constructor(HitState: UE.EMagicLeapRaycastResultState, HitPoint: UE.Vector, Normal: UE.Vector, Confidence: number, UserData: number);
        HitState: UE.EMagicLeapRaycastResultState;
        HitPoint: UE.Vector;
        Normal: UE.Vector;
        Confidence: number;
        UserData: number;
        static StaticClass(): Class;
    }
    
    class MagicLeapRaycastQueryParams {
        constructor();
        constructor(Position: UE.Vector, Direction: UE.Vector, UpVector: UE.Vector, Width: number, Height: number, HorizontalFovDegrees: number, CollideWithUnobserved: boolean, UserData: number);
        Position: UE.Vector;
        Direction: UE.Vector;
        UpVector: UE.Vector;
        Width: number;
        Height: number;
        HorizontalFovDegrees: number;
        CollideWithUnobserved: boolean;
        UserData: number;
        static StaticClass(): Class;
    }
    
    class MagicLeapRaycastComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RaycastResultDelegate__DelegateSignature(HitResult: UE.MagicLeapRaycastHitResult) : void;
        RequestRaycast(RequestParams: UE.MagicLeapRaycastQueryParams, ResultDelegate: $Delegate<(HitResult: UE.MagicLeapRaycastHitResult) => void>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapRaycastComponent;
        static Load(InName: string): MagicLeapRaycastComponent;
    }
    
    class MagicLeapRaycastFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static MakeRaycastQueryParams(Position: UE.Vector, Direction: UE.Vector, UpVector: UE.Vector, Width: number, Height: number, HorizontalFovDegrees: number, CollideWithUnobserved: boolean, UserData: number) : UE.MagicLeapRaycastQueryParams;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapRaycastFunctionLibrary;
        static Load(InName: string): MagicLeapRaycastFunctionLibrary;
    }
    
    class MagicLeapSDKSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MLSDKPath: UE.DirectoryPath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapSDKSettings;
        static Load(InName: string): MagicLeapSDKSettings;
    }
    
    class MagicLeapSecureStorage extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static DeleteSecureData(Key: string) : boolean;
        static GetSecureArray(Key: string, DataToRetrieve: $Ref<TArray<number>>) : boolean;
        static GetSecureBool(Key: string, DataToRetrieve: $Ref<boolean>) : boolean;
        static GetSecureByte(Key: string, DataToRetrieve: $Ref<number>) : boolean;
        static GetSecureFloat(Key: string, DataToRetrieve: $Ref<number>) : boolean;
        static GetSecureInt(Key: string, DataToRetrieve: $Ref<number>) : boolean;
        static GetSecureInt64(Key: string, DataToRetrieve: $Ref<bigint>) : boolean;
        static GetSecureRotator(Key: string, DataToRetrieve: $Ref<UE.Rotator>) : boolean;
        static GetSecureSaveGame(Key: string, ObjectToRetrieve: $Ref<UE.SaveGame>) : boolean;
        static GetSecureString(Key: string, DataToRetrieve: $Ref<string>) : boolean;
        static GetSecureTransform(Key: string, DataToRetrieve: $Ref<UE.Transform>) : boolean;
        static GetSecureVector(Key: string, DataToRetrieve: $Ref<UE.Vector>) : boolean;
        static PutSecureArray(Key: string, DataToStore: TArray<number>) : boolean;
        static PutSecureBool(Key: string, DataToStore: boolean) : boolean;
        static PutSecureByte(Key: string, DataToStore: number) : boolean;
        static PutSecureFloat(Key: string, DataToStore: number) : boolean;
        static PutSecureInt(Key: string, DataToStore: number) : boolean;
        static PutSecureInt64(Key: string, DataToStore: bigint) : boolean;
        static PutSecureRotator(Key: string, DataToStore: UE.Rotator) : boolean;
        static PutSecureSaveGame(Key: string, ObjectToStore: $Nullable<UE.SaveGame>) : boolean;
        static PutSecureString(Key: string, DataToStore: string) : boolean;
        static PutSecureTransform(Key: string, DataToStore: UE.Transform) : boolean;
        static PutSecureVector(Key: string, DataToStore: UE.Vector) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapSecureStorage;
        static Load(InName: string): MagicLeapSecureStorage;
    }
    
    class MagicLeapSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnableZI: boolean;
        bUseVulkanForZI: boolean;
        bUseMLAudioForZI: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapSettings;
        static Load(InName: string): MagicLeapSettings;
    }
    
    enum EMagicLeapTouchpadGestureType { None, Tap, ForceTapDown, ForceTapUp, ForceDwell, SecondForceDown, LongHold, RadialScroll, Swipe, Scroll, Pinch, EMagicLeapTouchpadGestureType_MAX}
    enum EMagicLeapTouchpadGestureDirection { None, Up, Down, Left, Right, In, Out, Clockwise, CounterClockwise, EMagicLeapTouchpadGestureDirection_MAX}
    class MagicLeapTouchpadGesture {
        constructor();
        constructor(Hand: UE.EControllerHand, MotionSource: string, Type: UE.EMagicLeapTouchpadGestureType, Direction: UE.EMagicLeapTouchpadGestureDirection, PositionAndForce: UE.Vector, Speed: number, Distance: number, FingerGap: number, Radius: number, Angle: number);
        Hand: UE.EControllerHand;
        MotionSource: string;
        Type: UE.EMagicLeapTouchpadGestureType;
        Direction: UE.EMagicLeapTouchpadGestureDirection;
        PositionAndForce: UE.Vector;
        Speed: number;
        Distance: number;
        FingerGap: number;
        Radius: number;
        Angle: number;
        static StaticClass(): Class;
    }
    
    class MagicLeapTouchpadGesturesComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnTouchpadGestureStart: $MulticastDelegate<(GestureData: UE.MagicLeapTouchpadGesture) => void>;
        OnTouchpadGestureContinue: $MulticastDelegate<(GestureData: UE.MagicLeapTouchpadGesture) => void>;
        OnTouchpadGestureEnd: $MulticastDelegate<(GestureData: UE.MagicLeapTouchpadGesture) => void>;
        TouchpadGestureEvent__DelegateSignature(GestureData: UE.MagicLeapTouchpadGesture) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapTouchpadGesturesComponent;
        static Load(InName: string): MagicLeapTouchpadGesturesComponent;
    }
    
    class MainActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NotifyWithInt: $MulticastDelegate<(A: number) => void>;
        NotifyWithString: $Delegate<(A: string) => void>;
        NotifyWithRefString: $Delegate<(A: $Ref<string>) => void>;
        NotifyWithStringRet: $Delegate<(A: string) => string>;
        NotifyWithNothing: $MulticastDelegate<() => void>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MainActor;
        static Load(InName: string): MainActor;
    }
    
    class SomeData {
        constructor();
        constructor(Alignment: UE.Vector2D, WillSerialize: number);
        Alignment: UE.Vector2D;
        WillSerialize: number;
        static StaticClass(): Class;
    }
    
    enum EToTest { V0, V1, V13, EToTest_MAX}
    class MainObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SomeData: UE.SomeData;
        V: UE.Vector;
        MyFixSizeArray: FixSizeArray<number>;
        MyArray: TArray<number>;
        MySet: TSet<string>;
        MyMap: TMap<string, number>;
        MyString: string;
        ArrayBuffer: UE.ArrayBuffer;
        Add(a: number, b: number) : number;
        ArrayBufferTest(Ab: UE.ArrayBuffer) : UE.ArrayBuffer;
        Bar(V: UE.Vector) : string;
        Bar2(V: $Ref<UE.Vector>) : string;
        Bar3(V: $Ref<UE.Vector>) : UE.Vector;
        Callback__DelegateSignature(A: string) : boolean;
        DefaultTest(Str?: string /* = "i am default" */, I?: number /* = 10 */, Vec?: UE.Vector /* = 1.100000,2.200000,3.300000 */) : void;
        EnumTest(E: UE.EToTest) : void;
        Foo() : string;
        GetData() : TArray<number>;
        GetInts() : TArray<number>;
        GetStrings() : TArray<string>;
        NameTest(Name: string) : void;
        PassJsFunctionAsDelegate(Callback: $Delegate<(A: string) => boolean>) : void;
        PrintState() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MainObject;
        static Load(InName: string): MainObject;
    }
    
    class Manipulator extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssociatedComponent: UE.SceneComponent;
        StaticMeshComponent: UE.StaticMeshComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Manipulator;
        static Load(InName: string): Manipulator;
    }
    
    class MapProperty extends UE.Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MapProperty;
        static Load(InName: string): MapProperty;
    }
    
    class MasterAudioSubmixCaptureProtocol extends UE.MovieSceneAudioCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FileName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MasterAudioSubmixCaptureProtocol;
        static Load(InName: string): MasterAudioSubmixCaptureProtocol;
    }
    
    enum EMaterialUsage { MATUSAGE_SkeletalMesh, MATUSAGE_ParticleSprites, MATUSAGE_BeamTrails, MATUSAGE_MeshParticles, MATUSAGE_StaticLighting, MATUSAGE_MorphTargets, MATUSAGE_SplineMesh, MATUSAGE_InstancedStaticMeshes, MATUSAGE_GeometryCollections, MATUSAGE_Clothing, MATUSAGE_NiagaraSprites, MATUSAGE_NiagaraRibbons, MATUSAGE_NiagaraMeshParticles, MATUSAGE_GeometryCache, MATUSAGE_Water, MATUSAGE_HairStrands, MATUSAGE_MAX}
    enum EMaterialProperty { MP_EmissiveColor, MP_Opacity, MP_OpacityMask, MP_DiffuseColor, MP_SpecularColor, MP_BaseColor, MP_Metallic, MP_Specular, MP_Roughness, MP_Normal, MP_WorldPositionOffset, MP_WorldDisplacement, MP_TessellationMultiplier, MP_SubsurfaceColor, MP_CustomData0, MP_CustomData1, MP_AmbientOcclusion, MP_Refraction, MP_CustomizedUVs0, MP_CustomizedUVs1, MP_CustomizedUVs2, MP_CustomizedUVs3, MP_CustomizedUVs4, MP_CustomizedUVs5, MP_CustomizedUVs6, MP_CustomizedUVs7, MP_PixelDepthOffset, MP_ShadingModel, MP_MaterialAttributes, MP_CustomOutput, MP_MAX}
    class MaterialEditingLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetScalarParameterSource(Material: $Nullable<UE.MaterialInterface>, ParameterName: string, ParameterSource: $Ref<UE.SoftObjectPath>) : boolean;
        GetStaticSwitchParameterSource(Material: $Nullable<UE.MaterialInterface>, ParameterName: string, ParameterSource: $Ref<UE.SoftObjectPath>) : boolean;
        GetTextureParameterSource(Material: $Nullable<UE.MaterialInterface>, ParameterName: string, ParameterSource: $Ref<UE.SoftObjectPath>) : boolean;
        GetVectorParameterSource(Material: $Nullable<UE.MaterialInterface>, ParameterName: string, ParameterSource: $Ref<UE.SoftObjectPath>) : boolean;
        static ClearAllMaterialInstanceParameters(Instance: $Nullable<UE.MaterialInstanceConstant>) : void;
        static ConnectMaterialExpressions(FromExpression: $Nullable<UE.MaterialExpression>, FromOutputName: string, ToExpression: $Nullable<UE.MaterialExpression>, ToInputName: string) : boolean;
        static ConnectMaterialProperty(FromExpression: $Nullable<UE.MaterialExpression>, FromOutputName: string, Property: UE.EMaterialProperty) : boolean;
        static CreateMaterialExpression(Material: $Nullable<UE.Material>, ExpressionClass: $Nullable<UE.Class>, NodePosX?: number /* = 0 */, NodePosY?: number /* = 0 */) : UE.MaterialExpression;
        static CreateMaterialExpressionInFunction(MaterialFunction: $Nullable<UE.MaterialFunction>, ExpressionClass: $Nullable<UE.Class>, NodePosX?: number /* = 0 */, NodePosY?: number /* = 0 */) : UE.MaterialExpression;
        static DeleteAllMaterialExpressions(Material: $Nullable<UE.Material>) : void;
        static DeleteAllMaterialExpressionsInFunction(MaterialFunction: $Nullable<UE.MaterialFunction>) : void;
        static DeleteMaterialExpression(Material: $Nullable<UE.Material>, Expression: $Nullable<UE.MaterialExpression>) : void;
        static DeleteMaterialExpressionInFunction(MaterialFunction: $Nullable<UE.MaterialFunction>, Expression: $Nullable<UE.MaterialExpression>) : void;
        static GetChildInstances(Parent: $Nullable<UE.MaterialInterface>, ChildInstances: $Ref<TArray<UE.AssetData>>) : void;
        static GetMaterialDefaultScalarParameterValue(Material: $Nullable<UE.Material>, ParameterName: string) : number;
        static GetMaterialDefaultStaticSwitchParameterValue(Material: $Nullable<UE.Material>, ParameterName: string) : boolean;
        static GetMaterialDefaultTextureParameterValue(Material: $Nullable<UE.Material>, ParameterName: string) : UE.Texture;
        static GetMaterialDefaultVectorParameterValue(Material: $Nullable<UE.Material>, ParameterName: string) : UE.LinearColor;
        static GetMaterialInstanceScalarParameterValue(Instance: $Nullable<UE.MaterialInstanceConstant>, ParameterName: string) : number;
        static GetMaterialInstanceStaticSwitchParameterValue(Instance: $Nullable<UE.MaterialInstanceConstant>, ParameterName: string) : boolean;
        static GetMaterialInstanceTextureParameterValue(Instance: $Nullable<UE.MaterialInstanceConstant>, ParameterName: string) : UE.Texture;
        static GetMaterialInstanceVectorParameterValue(Instance: $Nullable<UE.MaterialInstanceConstant>, ParameterName: string) : UE.LinearColor;
        static GetMaterialSelectedNodes(Material: $Nullable<UE.Material>) : TSet<UE.Object>;
        static GetNumMaterialExpressions(Material: $Nullable<UE.Material>) : number;
        static GetNumMaterialExpressionsInFunction(MaterialFunction: $Nullable<UE.MaterialFunction>) : number;
        static GetScalarParameterNames(Material: $Nullable<UE.MaterialInterface>, ParameterNames: $Ref<TArray<string>>) : void;
        static GetStaticSwitchParameterNames(Material: $Nullable<UE.MaterialInterface>, ParameterNames: $Ref<TArray<string>>) : void;
        static GetTextureParameterNames(Material: $Nullable<UE.MaterialInterface>, ParameterNames: $Ref<TArray<string>>) : void;
        static GetVectorParameterNames(Material: $Nullable<UE.MaterialInterface>, ParameterNames: $Ref<TArray<string>>) : void;
        static HasMaterialUsage(Material: $Nullable<UE.Material>, Usage: UE.EMaterialUsage) : boolean;
        static LayoutMaterialExpressions(Material: $Nullable<UE.Material>) : void;
        static LayoutMaterialFunctionExpressions(MaterialFunction: $Nullable<UE.MaterialFunction>) : void;
        static RecompileMaterial(Material: $Nullable<UE.Material>) : void;
        static SetMaterialInstanceParent(Instance: $Nullable<UE.MaterialInstanceConstant>, NewParent: $Nullable<UE.MaterialInterface>) : void;
        static SetMaterialInstanceScalarParameterValue(Instance: $Nullable<UE.MaterialInstanceConstant>, ParameterName: string, Value: number) : boolean;
        static SetMaterialInstanceTextureParameterValue(Instance: $Nullable<UE.MaterialInstanceConstant>, ParameterName: string, Value: $Nullable<UE.Texture>) : boolean;
        static SetMaterialInstanceVectorParameterValue(Instance: $Nullable<UE.MaterialInstanceConstant>, ParameterName: string, Value: UE.LinearColor) : boolean;
        static SetMaterialUsage(Material: $Nullable<UE.Material>, Usage: UE.EMaterialUsage, bNeedsRecompile: $Ref<boolean>) : boolean;
        static UpdateMaterialFunction(MaterialFunction: $Nullable<UE.MaterialFunctionInterface>, PreviewMaterial?: UE.Material /* = None */) : void;
        static UpdateMaterialInstance(Instance: $Nullable<UE.MaterialInstanceConstant>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialEditingLibrary;
        static Load(InName: string): MaterialEditingLibrary;
    }
    
    class EditorParameterGroup {
        constructor();
        constructor(GroupName: string, GroupAssociation: UE.EMaterialParameterAssociation, Parameters: TArray<UE.DEditorParameterValue>, GroupSortPriority: number);
        GroupName: string;
        GroupAssociation: UE.EMaterialParameterAssociation;
        Parameters: TArray<UE.DEditorParameterValue>;
        GroupSortPriority: number;
        static StaticClass(): Class;
    }
    
    class MaterialFunctionInstance extends UE.MaterialFunctionInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Parent: UE.MaterialFunctionInterface;
        Base: UE.MaterialFunctionInterface;
        ScalarParameterValues: TArray<UE.ScalarParameterValue>;
        VectorParameterValues: TArray<UE.VectorParameterValue>;
        TextureParameterValues: TArray<UE.TextureParameterValue>;
        FontParameterValues: TArray<UE.FontParameterValue>;
        StaticSwitchParameterValues: TArray<UE.StaticSwitchParameter>;
        StaticComponentMaskParameterValues: TArray<UE.StaticComponentMaskParameter>;
        RuntimeVirtualTextureParameterValues: TArray<UE.RuntimeVirtualTextureParameterValue>;
        PreviewMaterial: UE.MaterialInstanceConstant;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionInstance;
        static Load(InName: string): MaterialFunctionInstance;
    }
    
    class LightmassParameterValue {
        constructor();
        constructor(bOverride: boolean);
        bOverride: boolean;
        static StaticClass(): Class;
    }
    
    class LightmassBooleanParameterValue extends UE.LightmassParameterValue {
        constructor();
        constructor(ParameterValue: boolean);
        ParameterValue: boolean;
        static StaticClass(): Class;
    }
    
    class LightmassScalarParameterValue extends UE.LightmassParameterValue {
        constructor();
        constructor(ParameterValue: number);
        ParameterValue: number;
        static StaticClass(): Class;
    }
    
    class LightmassParameterizedMaterialSettings {
        constructor();
        constructor(CastShadowAsMasked: UE.LightmassBooleanParameterValue, EmissiveBoost: UE.LightmassScalarParameterValue, DiffuseBoost: UE.LightmassScalarParameterValue, ExportResolutionScale: UE.LightmassScalarParameterValue);
        CastShadowAsMasked: UE.LightmassBooleanParameterValue;
        EmissiveBoost: UE.LightmassScalarParameterValue;
        DiffuseBoost: UE.LightmassScalarParameterValue;
        ExportResolutionScale: UE.LightmassScalarParameterValue;
        static StaticClass(): Class;
    }
    
    class MaterialEditorInstanceConstant extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysMaterial: UE.PhysicalMaterial;
        Parent: UE.MaterialInterface;
        ParameterGroups: TArray<UE.EditorParameterGroup>;
        RefractionDepthBias: number;
        SubsurfaceProfile: UE.SubsurfaceProfile;
        bOverrideSubsurfaceProfile: boolean;
        bOverrideBaseProperties: boolean;
        bIsFunctionPreviewMaterial: boolean;
        bIsFunctionInstanceDirty: boolean;
        BasePropertyOverrides: UE.MaterialInstanceBasePropertyOverrides;
        SourceInstance: UE.MaterialInstanceConstant;
        SourceFunction: UE.MaterialFunctionInstance;
        VisibleExpressions: TArray<UE.MaterialParameterInfo>;
        LightmassSettings: UE.LightmassParameterizedMaterialSettings;
        bUseOldStyleMICEditorGroups: boolean;
        StoredLayerPreviews: TArray<UE.MaterialInstanceConstant>;
        StoredBlendPreviews: TArray<UE.MaterialInstanceConstant>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialEditorInstanceConstant;
        static Load(InName: string): MaterialEditorInstanceConstant;
    }
    
    class MaterialEditorMeshComponent extends UE.StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialEditorMeshComponent;
        static Load(InName: string): MaterialEditorMeshComponent;
    }
    
    class MaterialEditorOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bShowGrid: boolean;
        bHideUnusedConnectors: boolean;
        bRealtimeMaterialViewport: boolean;
        bRealtimeExpressionViewport: boolean;
        bLivePreviewUpdate: boolean;
        bHideUnrelatedNodes: boolean;
        bAlwaysRefreshAllPreviews: boolean;
        bUseUnsortedMenus: boolean;
        FavoriteExpressions: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialEditorOptions;
        static Load(InName: string): MaterialEditorOptions;
    }
    
    class MaterialEditorPreviewParameters extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterGroups: TArray<UE.EditorParameterGroup>;
        PreviewMaterial: UE.Material;
        OriginalFunction: UE.MaterialFunction;
        OriginalMaterial: UE.Material;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialEditorPreviewParameters;
        static Load(InName: string): MaterialEditorPreviewParameters;
    }
    
    class MaterialEditorSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaliOfflineCompilerPath: UE.FilePath;
        DefaultPreviewWidth: number;
        DefaultPreviewHeight: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialEditorSettings;
        static Load(InName: string): MaterialEditorSettings;
    }
    
    class MaterialExpressionAbs extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAbs;
        static Load(InName: string): MaterialExpressionAbs;
    }
    
    class MaterialExpressionActorPositionWS extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionActorPositionWS;
        static Load(InName: string): MaterialExpressionActorPositionWS;
    }
    
    class MaterialExpressionAdd extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: UE.ExpressionInput;
        B: UE.ExpressionInput;
        ConstA: number;
        ConstB: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAdd;
        static Load(InName: string): MaterialExpressionAdd;
    }
    
    enum EMaterialSamplerType { SAMPLERTYPE_Color, SAMPLERTYPE_Grayscale, SAMPLERTYPE_Alpha, SAMPLERTYPE_Normal, SAMPLERTYPE_Masks, SAMPLERTYPE_DistanceFieldFont, SAMPLERTYPE_LinearColor, SAMPLERTYPE_LinearGrayscale, SAMPLERTYPE_Data, SAMPLERTYPE_External, SAMPLERTYPE_VirtualColor, SAMPLERTYPE_VirtualGrayscale, SAMPLERTYPE_VirtualAlpha, SAMPLERTYPE_VirtualNormal, SAMPLERTYPE_VirtualMasks, SAMPLERTYPE_VirtualLinearColor, SAMPLERTYPE_VirtualLinearGrayscale, SAMPLERTYPE_MAX}
    class MaterialExpressionTextureBase extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Texture: UE.Texture;
        SamplerType: UE.EMaterialSamplerType;
        IsDefaultMeshpaintTexture: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureBase;
        static Load(InName: string): MaterialExpressionTextureBase;
    }
    
    enum ETextureMipValueMode { TMVM_None, TMVM_MipLevel, TMVM_MipBias, TMVM_Derivative, TMVM_MAX}
    enum ESamplerSourceMode { SSM_FromTextureAsset, SSM_Wrap_WorldGroupSettings, SSM_Clamp_WorldGroupSettings, SSM_MAX}
    class MaterialExpressionTextureSample extends UE.MaterialExpressionTextureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Coordinates: UE.ExpressionInput;
        TextureObject: UE.ExpressionInput;
        MipValue: UE.ExpressionInput;
        CoordinatesDX: UE.ExpressionInput;
        CoordinatesDY: UE.ExpressionInput;
        AutomaticViewMipBiasValue: UE.ExpressionInput;
        MipValueMode: UE.ETextureMipValueMode;
        SamplerSource: UE.ESamplerSourceMode;
        AutomaticViewMipBias: boolean;
        ConstCoordinate: number;
        ConstMipValue: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSample;
        static Load(InName: string): MaterialExpressionTextureSample;
    }
    
    class MaterialExpressionTextureSampleParameter extends UE.MaterialExpressionTextureSample {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterName: string;
        ExpressionGUID: UE.Guid;
        Group: string;
        SortPriority: number;
        ChannelNames: UE.ParameterChannelNames;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameter;
        static Load(InName: string): MaterialExpressionTextureSampleParameter;
    }
    
    class MaterialExpressionTextureSampleParameter2D extends UE.MaterialExpressionTextureSampleParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameter2D;
        static Load(InName: string): MaterialExpressionTextureSampleParameter2D;
    }
    
    enum ETextureColorChannel { TCC_Red, TCC_Green, TCC_Blue, TCC_Alpha, TCC_MAX}
    class MaterialExpressionAntialiasedTextureMask extends UE.MaterialExpressionTextureSampleParameter2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Threshold: number;
        Channel: UE.ETextureColorChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAntialiasedTextureMask;
        static Load(InName: string): MaterialExpressionAntialiasedTextureMask;
    }
    
    class MaterialExpressionAppendVector extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: UE.ExpressionInput;
        B: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAppendVector;
        static Load(InName: string): MaterialExpressionAppendVector;
    }
    
    class MaterialExpressionArccosine extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArccosine;
        static Load(InName: string): MaterialExpressionArccosine;
    }
    
    class MaterialExpressionArccosineFast extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArccosineFast;
        static Load(InName: string): MaterialExpressionArccosineFast;
    }
    
    class MaterialExpressionArcsine extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArcsine;
        static Load(InName: string): MaterialExpressionArcsine;
    }
    
    class MaterialExpressionArcsineFast extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArcsineFast;
        static Load(InName: string): MaterialExpressionArcsineFast;
    }
    
    class MaterialExpressionArctangent extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArctangent;
        static Load(InName: string): MaterialExpressionArctangent;
    }
    
    class MaterialExpressionArctangent2 extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Y: UE.ExpressionInput;
        X: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArctangent2;
        static Load(InName: string): MaterialExpressionArctangent2;
    }
    
    class MaterialExpressionArctangent2Fast extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Y: UE.ExpressionInput;
        X: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArctangent2Fast;
        static Load(InName: string): MaterialExpressionArctangent2Fast;
    }
    
    class MaterialExpressionArctangentFast extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArctangentFast;
        static Load(InName: string): MaterialExpressionArctangentFast;
    }
    
    class MaterialExpressionAtmosphericFogColor extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WorldPosition: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAtmosphericFogColor;
        static Load(InName: string): MaterialExpressionAtmosphericFogColor;
    }
    
    class MaterialExpressionAtmosphericLightColor extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAtmosphericLightColor;
        static Load(InName: string): MaterialExpressionAtmosphericLightColor;
    }
    
    class MaterialExpressionAtmosphericLightVector extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAtmosphericLightVector;
        static Load(InName: string): MaterialExpressionAtmosphericLightVector;
    }
    
    class MaterialExpressionCustomOutput extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCustomOutput;
        static Load(InName: string): MaterialExpressionCustomOutput;
    }
    
    class MaterialExpressionBentNormalCustomOutput extends UE.MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionBentNormalCustomOutput;
        static Load(InName: string): MaterialExpressionBentNormalCustomOutput;
    }
    
    class MaterialExpressionBlackBody extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Temp: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionBlackBody;
        static Load(InName: string): MaterialExpressionBlackBody;
    }
    
    enum EMaterialAttributeBlend { Blend, UseA, UseB, EMaterialAttributeBlend_MAX}
    class MaterialExpressionBlendMaterialAttributes extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: UE.MaterialAttributesInput;
        B: UE.MaterialAttributesInput;
        Alpha: UE.ExpressionInput;
        PixelAttributeBlendType: UE.EMaterialAttributeBlend;
        VertexAttributeBlendType: UE.EMaterialAttributeBlend;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionBlendMaterialAttributes;
        static Load(InName: string): MaterialExpressionBlendMaterialAttributes;
    }
    
    class MaterialExpressionBreakMaterialAttributes extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialAttributes: UE.MaterialAttributesInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionBreakMaterialAttributes;
        static Load(InName: string): MaterialExpressionBreakMaterialAttributes;
    }
    
    class MaterialExpressionBumpOffset extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Coordinate: UE.ExpressionInput;
        Height: UE.ExpressionInput;
        HeightRatioInput: UE.ExpressionInput;
        HeightRatio: number;
        ReferencePlane: number;
        ConstCoordinate: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionBumpOffset;
        static Load(InName: string): MaterialExpressionBumpOffset;
    }
    
    class MaterialExpressionCameraPositionWS extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCameraPositionWS;
        static Load(InName: string): MaterialExpressionCameraPositionWS;
    }
    
    class MaterialExpressionCameraVectorWS extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCameraVectorWS;
        static Load(InName: string): MaterialExpressionCameraVectorWS;
    }
    
    class MaterialExpressionCeil extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCeil;
        static Load(InName: string): MaterialExpressionCeil;
    }
    
    class MaterialExpressionParameter extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterName: string;
        ExpressionGUID: UE.Guid;
        Group: string;
        SortPriority: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParameter;
        static Load(InName: string): MaterialExpressionParameter;
    }
    
    class MaterialExpressionVectorParameter extends UE.MaterialExpressionParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultValue: UE.LinearColor;
        bUseCustomPrimitiveData: boolean;
        PrimitiveDataIndex: number;
        ChannelNames: UE.ParameterChannelNames;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVectorParameter;
        static Load(InName: string): MaterialExpressionVectorParameter;
    }
    
    enum EChannelMaskParameterColor { Red, Green, Blue, Alpha, EChannelMaskParameterColor_MAX}
    class MaterialExpressionChannelMaskParameter extends UE.MaterialExpressionVectorParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaskChannel: UE.EChannelMaskParameterColor;
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionChannelMaskParameter;
        static Load(InName: string): MaterialExpressionChannelMaskParameter;
    }
    
    enum EClampMode { CMODE_Clamp, CMODE_ClampMin, CMODE_ClampMax, CMODE_MAX}
    class MaterialExpressionClamp extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        Min: UE.ExpressionInput;
        Max: UE.ExpressionInput;
        ClampMode: UE.EClampMode;
        MinDefault: number;
        MaxDefault: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionClamp;
        static Load(InName: string): MaterialExpressionClamp;
    }
    
    class MaterialExpressionClearCoatNormalCustomOutput extends UE.MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionClearCoatNormalCustomOutput;
        static Load(InName: string): MaterialExpressionClearCoatNormalCustomOutput;
    }
    
    class MaterialExpressionCollectionParameter extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Collection: UE.MaterialParameterCollection;
        ParameterName: string;
        ParameterId: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCollectionParameter;
        static Load(InName: string): MaterialExpressionCollectionParameter;
    }
    
    class MaterialExpressionComponentMask extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        R: boolean;
        G: boolean;
        B: boolean;
        A: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionComponentMask;
        static Load(InName: string): MaterialExpressionComponentMask;
    }
    
    class MaterialExpressionConstant extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        R: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionConstant;
        static Load(InName: string): MaterialExpressionConstant;
    }
    
    class MaterialExpressionConstant2Vector extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        R: number;
        G: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionConstant2Vector;
        static Load(InName: string): MaterialExpressionConstant2Vector;
    }
    
    class MaterialExpressionConstant3Vector extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Constant: UE.LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionConstant3Vector;
        static Load(InName: string): MaterialExpressionConstant3Vector;
    }
    
    class MaterialExpressionConstant4Vector extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Constant: UE.LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionConstant4Vector;
        static Load(InName: string): MaterialExpressionConstant4Vector;
    }
    
    class MaterialExpressionConstantBiasScale extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        Bias: number;
        Scale: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionConstantBiasScale;
        static Load(InName: string): MaterialExpressionConstantBiasScale;
    }
    
    class MaterialExpressionCosine extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        Period: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCosine;
        static Load(InName: string): MaterialExpressionCosine;
    }
    
    class MaterialExpressionCrossProduct extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: UE.ExpressionInput;
        B: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCrossProduct;
        static Load(InName: string): MaterialExpressionCrossProduct;
    }
    
    class MaterialExpressionScalarParameter extends UE.MaterialExpressionParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultValue: number;
        bUseCustomPrimitiveData: boolean;
        PrimitiveDataIndex: number;
        SliderMin: number;
        SliderMax: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionScalarParameter;
        static Load(InName: string): MaterialExpressionScalarParameter;
    }
    
    class MaterialExpressionCurveAtlasRowParameter extends UE.MaterialExpressionScalarParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Curve: UE.CurveLinearColor;
        Atlas: UE.CurveLinearColorAtlas;
        InputTime: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCurveAtlasRowParameter;
        static Load(InName: string): MaterialExpressionCurveAtlasRowParameter;
    }
    
    enum ECustomMaterialOutputType { CMOT_Float1, CMOT_Float2, CMOT_Float3, CMOT_Float4, CMOT_MAX}
    class CustomInput {
        constructor();
        constructor(InputName: string, Input: UE.ExpressionInput);
        InputName: string;
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
    }
    
    class MaterialExpressionCustom extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Code: string;
        OutputType: UE.ECustomMaterialOutputType;
        Description: string;
        Inputs: TArray<UE.CustomInput>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCustom;
        static Load(InName: string): MaterialExpressionCustom;
    }
    
    class MaterialExpressionDDX extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Value: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDDX;
        static Load(InName: string): MaterialExpressionDDX;
    }
    
    class MaterialExpressionDDY extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Value: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDDY;
        static Load(InName: string): MaterialExpressionDDY;
    }
    
    class MaterialExpressionDecalDerivative extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDecalDerivative;
        static Load(InName: string): MaterialExpressionDecalDerivative;
    }
    
    class MaterialExpressionDecalLifetimeOpacity extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDecalLifetimeOpacity;
        static Load(InName: string): MaterialExpressionDecalLifetimeOpacity;
    }
    
    class MaterialExpressionDecalMipmapLevel extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TextureSize: UE.ExpressionInput;
        ConstWidth: number;
        ConstHeight: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDecalMipmapLevel;
        static Load(InName: string): MaterialExpressionDecalMipmapLevel;
    }
    
    class MaterialExpressionDeltaTime extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDeltaTime;
        static Load(InName: string): MaterialExpressionDeltaTime;
    }
    
    class MaterialExpressionDepthFade extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InOpacity: UE.ExpressionInput;
        FadeDistance: UE.ExpressionInput;
        OpacityDefault: number;
        FadeDistanceDefault: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDepthFade;
        static Load(InName: string): MaterialExpressionDepthFade;
    }
    
    enum EDepthOfFieldFunctionValue { TDOF_NearAndFarMask, TDOF_NearMask, TDOF_FarMask, TDOF_CircleOfConfusionRadius, TDOF_MAX}
    class MaterialExpressionDepthOfFieldFunction extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FunctionValue: UE.EDepthOfFieldFunctionValue;
        Depth: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDepthOfFieldFunction;
        static Load(InName: string): MaterialExpressionDepthOfFieldFunction;
    }
    
    class MaterialExpressionDeriveNormalZ extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InXY: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDeriveNormalZ;
        static Load(InName: string): MaterialExpressionDeriveNormalZ;
    }
    
    class MaterialExpressionDesaturation extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        Fraction: UE.ExpressionInput;
        LuminanceFactors: UE.LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDesaturation;
        static Load(InName: string): MaterialExpressionDesaturation;
    }
    
    class MaterialExpressionDistance extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: UE.ExpressionInput;
        B: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDistance;
        static Load(InName: string): MaterialExpressionDistance;
    }
    
    class MaterialExpressionDistanceCullFade extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDistanceCullFade;
        static Load(InName: string): MaterialExpressionDistanceCullFade;
    }
    
    class MaterialExpressionDistanceFieldGradient extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Position: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDistanceFieldGradient;
        static Load(InName: string): MaterialExpressionDistanceFieldGradient;
    }
    
    class MaterialExpressionDistanceToNearestSurface extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Position: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDistanceToNearestSurface;
        static Load(InName: string): MaterialExpressionDistanceToNearestSurface;
    }
    
    class MaterialExpressionDivide extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: UE.ExpressionInput;
        B: UE.ExpressionInput;
        ConstA: number;
        ConstB: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDivide;
        static Load(InName: string): MaterialExpressionDivide;
    }
    
    class MaterialExpressionDotProduct extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: UE.ExpressionInput;
        B: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDotProduct;
        static Load(InName: string): MaterialExpressionDotProduct;
    }
    
    class MaterialExpressionDynamicParameter extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParamNames: TArray<string>;
        DefaultValue: UE.LinearColor;
        ParameterIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDynamicParameter;
        static Load(InName: string): MaterialExpressionDynamicParameter;
    }
    
    class MaterialExpressionEyeAdaptation extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionEyeAdaptation;
        static Load(InName: string): MaterialExpressionEyeAdaptation;
    }
    
    class MaterialExpressionFeatureLevelSwitch extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Default: UE.ExpressionInput;
        Inputs: FixSizeArray<UE.ExpressionInput>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFeatureLevelSwitch;
        static Load(InName: string): MaterialExpressionFeatureLevelSwitch;
    }
    
    class MaterialExpressionFloor extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFloor;
        static Load(InName: string): MaterialExpressionFloor;
    }
    
    class MaterialExpressionFmod extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: UE.ExpressionInput;
        B: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFmod;
        static Load(InName: string): MaterialExpressionFmod;
    }
    
    class MaterialExpressionFontSample extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Font: UE.Font;
        FontTexturePage: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFontSample;
        static Load(InName: string): MaterialExpressionFontSample;
    }
    
    class MaterialExpressionFontSampleParameter extends UE.MaterialExpressionFontSample {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterName: string;
        ExpressionGUID: UE.Guid;
        Group: string;
        SortPriority: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFontSampleParameter;
        static Load(InName: string): MaterialExpressionFontSampleParameter;
    }
    
    class MaterialExpressionFrac extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFrac;
        static Load(InName: string): MaterialExpressionFrac;
    }
    
    class MaterialExpressionFresnel extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ExponentIn: UE.ExpressionInput;
        Exponent: number;
        BaseReflectFractionIn: UE.ExpressionInput;
        BaseReflectFraction: number;
        Normal: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFresnel;
        static Load(InName: string): MaterialExpressionFresnel;
    }
    
    enum EFunctionInputType { FunctionInput_Scalar, FunctionInput_Vector2, FunctionInput_Vector3, FunctionInput_Vector4, FunctionInput_Texture2D, FunctionInput_TextureCube, FunctionInput_Texture2DArray, FunctionInput_VolumeTexture, FunctionInput_StaticBool, FunctionInput_MaterialAttributes, FunctionInput_TextureExternal, FunctionInput_MAX}
    class MaterialExpressionFunctionInput extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Preview: UE.ExpressionInput;
        InputName: string;
        Description: string;
        Id: UE.Guid;
        InputType: UE.EFunctionInputType;
        PreviewValue: UE.Vector4;
        bUsePreviewValueAsDefault: boolean;
        SortPriority: number;
        bCompilingFunctionPreview: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFunctionInput;
        static Load(InName: string): MaterialExpressionFunctionInput;
    }
    
    class MaterialExpressionFunctionOutput extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OutputName: string;
        Description: string;
        SortPriority: number;
        A: UE.ExpressionInput;
        bLastPreviewed: boolean;
        Id: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFunctionOutput;
        static Load(InName: string): MaterialExpressionFunctionOutput;
    }
    
    class MaterialExpressionGetMaterialAttributes extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialAttributes: UE.MaterialAttributesInput;
        AttributeGetTypes: TArray<UE.Guid>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionGetMaterialAttributes;
        static Load(InName: string): MaterialExpressionGetMaterialAttributes;
    }
    
    class MaterialExpressionGIReplace extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Default: UE.ExpressionInput;
        StaticIndirect: UE.ExpressionInput;
        DynamicIndirect: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionGIReplace;
        static Load(InName: string): MaterialExpressionGIReplace;
    }
    
    class MaterialExpressionHairAttributes extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionHairAttributes;
        static Load(InName: string): MaterialExpressionHairAttributes;
    }
    
    class MaterialExpressionIf extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: UE.ExpressionInput;
        B: UE.ExpressionInput;
        AGreaterThanB: UE.ExpressionInput;
        AEqualsB: UE.ExpressionInput;
        ALessThanB: UE.ExpressionInput;
        EqualsThreshold: number;
        ConstB: number;
        ConstAEqualsB: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionIf;
        static Load(InName: string): MaterialExpressionIf;
    }
    
    class GrassInput {
        constructor();
        constructor(Name: string, GrassType: UE.LandscapeGrassType, Input: UE.ExpressionInput);
        Name: string;
        GrassType: UE.LandscapeGrassType;
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
    }
    
    class MaterialExpressionLandscapeGrassOutput extends UE.MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GrassTypes: TArray<UE.GrassInput>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeGrassOutput;
        static Load(InName: string): MaterialExpressionLandscapeGrassOutput;
    }
    
    enum ELandscapeLayerBlendType { LB_WeightBlend, LB_AlphaBlend, LB_HeightBlend, LB_MAX}
    class LayerBlendInput {
        constructor();
        constructor(LayerName: string, BlendType: UE.ELandscapeLayerBlendType, LayerInput: UE.ExpressionInput, HeightInput: UE.ExpressionInput, PreviewWeight: number, ConstLayerInput: UE.Vector, ConstHeightInput: number);
        LayerName: string;
        BlendType: UE.ELandscapeLayerBlendType;
        LayerInput: UE.ExpressionInput;
        HeightInput: UE.ExpressionInput;
        PreviewWeight: number;
        ConstLayerInput: UE.Vector;
        ConstHeightInput: number;
        static StaticClass(): Class;
    }
    
    class MaterialExpressionLandscapeLayerBlend extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Layers: TArray<UE.LayerBlendInput>;
        ExpressionGUID: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeLayerBlend;
        static Load(InName: string): MaterialExpressionLandscapeLayerBlend;
    }
    
    enum ETerrainCoordMappingType { TCMT_Auto, TCMT_XY, TCMT_XZ, TCMT_YZ, TCMT_MAX}
    enum ELandscapeCustomizedCoordType { LCCT_None, LCCT_CustomUV0, LCCT_CustomUV1, LCCT_CustomUV2, LCCT_WeightMapUV, LCCT_MAX}
    class MaterialExpressionLandscapeLayerCoords extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MappingType: UE.ETerrainCoordMappingType;
        CustomUVType: UE.ELandscapeCustomizedCoordType;
        MappingScale: number;
        MappingRotation: number;
        MappingPanU: number;
        MappingPanV: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeLayerCoords;
        static Load(InName: string): MaterialExpressionLandscapeLayerCoords;
    }
    
    class MaterialExpressionLandscapeLayerSample extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterName: string;
        PreviewWeight: number;
        ExpressionGUID: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeLayerSample;
        static Load(InName: string): MaterialExpressionLandscapeLayerSample;
    }
    
    class MaterialExpressionLandscapeLayerSwitch extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LayerUsed: UE.ExpressionInput;
        LayerNotUsed: UE.ExpressionInput;
        ParameterName: string;
        PreviewUsed: boolean;
        ExpressionGUID: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeLayerSwitch;
        static Load(InName: string): MaterialExpressionLandscapeLayerSwitch;
    }
    
    class MaterialExpressionLandscapeLayerWeight extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Base: UE.ExpressionInput;
        Layer: UE.ExpressionInput;
        ParameterName: string;
        PreviewWeight: number;
        ConstBase: UE.Vector;
        ExpressionGUID: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeLayerWeight;
        static Load(InName: string): MaterialExpressionLandscapeLayerWeight;
    }
    
    class MaterialExpressionLandscapeVisibilityMask extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ExpressionGUID: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeVisibilityMask;
        static Load(InName: string): MaterialExpressionLandscapeVisibilityMask;
    }
    
    class MaterialExpressionLightmapUVs extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLightmapUVs;
        static Load(InName: string): MaterialExpressionLightmapUVs;
    }
    
    class MaterialExpressionLightmassReplace extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Realtime: UE.ExpressionInput;
        Lightmass: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLightmassReplace;
        static Load(InName: string): MaterialExpressionLightmassReplace;
    }
    
    class MaterialExpressionLightVector extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLightVector;
        static Load(InName: string): MaterialExpressionLightVector;
    }
    
    class MaterialExpressionLinearInterpolate extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: UE.ExpressionInput;
        B: UE.ExpressionInput;
        Alpha: UE.ExpressionInput;
        ConstA: number;
        ConstB: number;
        ConstAlpha: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLinearInterpolate;
        static Load(InName: string): MaterialExpressionLinearInterpolate;
    }
    
    class MaterialExpressionLogarithm10 extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        X: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLogarithm10;
        static Load(InName: string): MaterialExpressionLogarithm10;
    }
    
    class MaterialExpressionLogarithm2 extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        X: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLogarithm2;
        static Load(InName: string): MaterialExpressionLogarithm2;
    }
    
    class MaterialExpressionMakeMaterialAttributes extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseColor: UE.ExpressionInput;
        Metallic: UE.ExpressionInput;
        Specular: UE.ExpressionInput;
        Roughness: UE.ExpressionInput;
        EmissiveColor: UE.ExpressionInput;
        Opacity: UE.ExpressionInput;
        OpacityMask: UE.ExpressionInput;
        Normal: UE.ExpressionInput;
        WorldPositionOffset: UE.ExpressionInput;
        WorldDisplacement: UE.ExpressionInput;
        TessellationMultiplier: UE.ExpressionInput;
        SubsurfaceColor: UE.ExpressionInput;
        ClearCoat: UE.ExpressionInput;
        ClearCoatRoughness: UE.ExpressionInput;
        AmbientOcclusion: UE.ExpressionInput;
        Refraction: UE.ExpressionInput;
        CustomizedUVs: FixSizeArray<UE.ExpressionInput>;
        PixelDepthOffset: UE.ExpressionInput;
        ShadingModel: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMakeMaterialAttributes;
        static Load(InName: string): MaterialExpressionMakeMaterialAttributes;
    }
    
    class MaterialExpressionMapARPassthroughCameraUV extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Coordinates: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMapARPassthroughCameraUV;
        static Load(InName: string): MaterialExpressionMapARPassthroughCameraUV;
    }
    
    class FunctionExpressionInput {
        constructor();
        constructor(ExpressionInput: UE.MaterialExpressionFunctionInput, ExpressionInputId: UE.Guid, Input: UE.ExpressionInput);
        ExpressionInput: UE.MaterialExpressionFunctionInput;
        ExpressionInputId: UE.Guid;
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
    }
    
    class FunctionExpressionOutput {
        constructor();
        constructor(ExpressionOutput: UE.MaterialExpressionFunctionOutput, ExpressionOutputId: UE.Guid, Output: UE.ExpressionOutput);
        ExpressionOutput: UE.MaterialExpressionFunctionOutput;
        ExpressionOutputId: UE.Guid;
        Output: UE.ExpressionOutput;
        static StaticClass(): Class;
    }
    
    class MaterialExpressionMaterialFunctionCall extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialFunction: UE.MaterialFunctionInterface;
        FunctionInputs: TArray<UE.FunctionExpressionInput>;
        FunctionOutputs: TArray<UE.FunctionExpressionOutput>;
        FunctionParameterInfo: UE.MaterialParameterInfo;
        SetMaterialFunction(NewMaterialFunction: $Nullable<UE.MaterialFunctionInterface>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMaterialFunctionCall;
        static Load(InName: string): MaterialExpressionMaterialFunctionCall;
    }
    
    class MaterialExpressionMaterialAttributeLayers extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterName: string;
        ExpressionGUID: UE.Guid;
        Input: UE.MaterialAttributesInput;
        DefaultLayers: UE.MaterialLayersFunctions;
        LayerCallers: TArray<UE.MaterialExpressionMaterialFunctionCall>;
        NumActiveLayerCallers: number;
        BlendCallers: TArray<UE.MaterialExpressionMaterialFunctionCall>;
        NumActiveBlendCallers: number;
        bIsLayerGraphBuilt: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMaterialAttributeLayers;
        static Load(InName: string): MaterialExpressionMaterialAttributeLayers;
    }
    
    class MaterialExpressionMaterialLayerOutput extends UE.MaterialExpressionFunctionOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMaterialLayerOutput;
        static Load(InName: string): MaterialExpressionMaterialLayerOutput;
    }
    
    class MaterialExpressionMaterialProxyReplace extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Realtime: UE.ExpressionInput;
        MaterialProxy: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMaterialProxyReplace;
        static Load(InName: string): MaterialExpressionMaterialProxyReplace;
    }
    
    class MaterialExpressionMax extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: UE.ExpressionInput;
        B: UE.ExpressionInput;
        ConstA: number;
        ConstB: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMax;
        static Load(InName: string): MaterialExpressionMax;
    }
    
    class MaterialExpressionMin extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: UE.ExpressionInput;
        B: UE.ExpressionInput;
        ConstA: number;
        ConstB: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMin;
        static Load(InName: string): MaterialExpressionMin;
    }
    
    class MaterialExpressionMultiply extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: UE.ExpressionInput;
        B: UE.ExpressionInput;
        ConstA: number;
        ConstB: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMultiply;
        static Load(InName: string): MaterialExpressionMultiply;
    }
    
    enum ENoiseFunction { NOISEFUNCTION_SimplexTex, NOISEFUNCTION_GradientTex, NOISEFUNCTION_GradientTex3D, NOISEFUNCTION_GradientALU, NOISEFUNCTION_ValueALU, NOISEFUNCTION_VoronoiALU, NOISEFUNCTION_MAX}
    class MaterialExpressionNoise extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Position: UE.ExpressionInput;
        FilterWidth: UE.ExpressionInput;
        Scale: number;
        Quality: number;
        NoiseFunction: UE.ENoiseFunction;
        bTurbulence: boolean;
        Levels: number;
        OutputMin: number;
        OutputMax: number;
        LevelScale: number;
        bTiling: boolean;
        RepeatSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionNoise;
        static Load(InName: string): MaterialExpressionNoise;
    }
    
    class MaterialExpressionNormalize extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VectorInput: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionNormalize;
        static Load(InName: string): MaterialExpressionNormalize;
    }
    
    class MaterialExpressionObjectBounds extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionObjectBounds;
        static Load(InName: string): MaterialExpressionObjectBounds;
    }
    
    class MaterialExpressionObjectOrientation extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionObjectOrientation;
        static Load(InName: string): MaterialExpressionObjectOrientation;
    }
    
    class MaterialExpressionObjectPositionWS extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionObjectPositionWS;
        static Load(InName: string): MaterialExpressionObjectPositionWS;
    }
    
    class MaterialExpressionObjectRadius extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionObjectRadius;
        static Load(InName: string): MaterialExpressionObjectRadius;
    }
    
    class MaterialExpressionOneMinus extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionOneMinus;
        static Load(InName: string): MaterialExpressionOneMinus;
    }
    
    class MaterialExpressionPanner extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Coordinate: UE.ExpressionInput;
        Time: UE.ExpressionInput;
        Speed: UE.ExpressionInput;
        SpeedX: number;
        SpeedY: number;
        ConstCoordinate: number;
        bFractionalPart: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPanner;
        static Load(InName: string): MaterialExpressionPanner;
    }
    
    class MaterialExpressionParticleColor extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleColor;
        static Load(InName: string): MaterialExpressionParticleColor;
    }
    
    class MaterialExpressionParticleDirection extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleDirection;
        static Load(InName: string): MaterialExpressionParticleDirection;
    }
    
    class MaterialExpressionParticleMacroUV extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleMacroUV;
        static Load(InName: string): MaterialExpressionParticleMacroUV;
    }
    
    class MaterialExpressionParticleMotionBlurFade extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleMotionBlurFade;
        static Load(InName: string): MaterialExpressionParticleMotionBlurFade;
    }
    
    class MaterialExpressionParticlePositionWS extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticlePositionWS;
        static Load(InName: string): MaterialExpressionParticlePositionWS;
    }
    
    class MaterialExpressionParticleRadius extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleRadius;
        static Load(InName: string): MaterialExpressionParticleRadius;
    }
    
    class MaterialExpressionParticleRandom extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleRandom;
        static Load(InName: string): MaterialExpressionParticleRandom;
    }
    
    class MaterialExpressionParticleRelativeTime extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleRelativeTime;
        static Load(InName: string): MaterialExpressionParticleRelativeTime;
    }
    
    class MaterialExpressionParticleSize extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleSize;
        static Load(InName: string): MaterialExpressionParticleSize;
    }
    
    class MaterialExpressionParticleSpeed extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleSpeed;
        static Load(InName: string): MaterialExpressionParticleSpeed;
    }
    
    class MaterialExpressionParticleSubUV extends UE.MaterialExpressionTextureSample {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bBlend: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleSubUV;
        static Load(InName: string): MaterialExpressionParticleSubUV;
    }
    
    class MaterialExpressionParticleSubUVProperties extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleSubUVProperties;
        static Load(InName: string): MaterialExpressionParticleSubUVProperties;
    }
    
    class MaterialExpressionPerInstanceFadeAmount extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPerInstanceFadeAmount;
        static Load(InName: string): MaterialExpressionPerInstanceFadeAmount;
    }
    
    class MaterialExpressionPerInstanceRandom extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPerInstanceRandom;
        static Load(InName: string): MaterialExpressionPerInstanceRandom;
    }
    
    class MaterialExpressionPixelDepth extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPixelDepth;
        static Load(InName: string): MaterialExpressionPixelDepth;
    }
    
    class MaterialExpressionPixelNormalWS extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPixelNormalWS;
        static Load(InName: string): MaterialExpressionPixelNormalWS;
    }
    
    class MaterialExpressionPower extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Base: UE.ExpressionInput;
        Exponent: UE.ExpressionInput;
        ConstExponent: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPower;
        static Load(InName: string): MaterialExpressionPower;
    }
    
    class MaterialExpressionPrecomputedAOMask extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPrecomputedAOMask;
        static Load(InName: string): MaterialExpressionPrecomputedAOMask;
    }
    
    class MaterialExpressionPreSkinnedLocalBounds extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPreSkinnedLocalBounds;
        static Load(InName: string): MaterialExpressionPreSkinnedLocalBounds;
    }
    
    class MaterialExpressionPreSkinnedNormal extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPreSkinnedNormal;
        static Load(InName: string): MaterialExpressionPreSkinnedNormal;
    }
    
    class MaterialExpressionPreSkinnedPosition extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPreSkinnedPosition;
        static Load(InName: string): MaterialExpressionPreSkinnedPosition;
    }
    
    class MaterialExpressionPreviousFrameSwitch extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurrentFrame: UE.ExpressionInput;
        PreviousFrame: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPreviousFrameSwitch;
        static Load(InName: string): MaterialExpressionPreviousFrameSwitch;
    }
    
    class MaterialExpressionQualitySwitch extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Default: UE.ExpressionInput;
        Inputs: FixSizeArray<UE.ExpressionInput>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionQualitySwitch;
        static Load(InName: string): MaterialExpressionQualitySwitch;
    }
    
    class MaterialExpressionRayTracingQualitySwitch extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Normal: UE.ExpressionInput;
        RayTraced: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRayTracingQualitySwitch;
        static Load(InName: string): MaterialExpressionRayTracingQualitySwitch;
    }
    
    class MaterialExpressionReflectionVectorWS extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CustomWorldNormal: UE.ExpressionInput;
        bNormalizeCustomWorldNormal: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionReflectionVectorWS;
        static Load(InName: string): MaterialExpressionReflectionVectorWS;
    }
    
    class MaterialExpressionReroute extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionReroute;
        static Load(InName: string): MaterialExpressionReroute;
    }
    
    class MaterialExpressionRotateAboutAxis extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NormalizedRotationAxis: UE.ExpressionInput;
        RotationAngle: UE.ExpressionInput;
        PivotPoint: UE.ExpressionInput;
        Position: UE.ExpressionInput;
        Period: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRotateAboutAxis;
        static Load(InName: string): MaterialExpressionRotateAboutAxis;
    }
    
    class MaterialExpressionRotator extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Coordinate: UE.ExpressionInput;
        Time: UE.ExpressionInput;
        CenterX: number;
        CenterY: number;
        Speed: number;
        ConstCoordinate: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRotator;
        static Load(InName: string): MaterialExpressionRotator;
    }
    
    class MaterialExpressionRound extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRound;
        static Load(InName: string): MaterialExpressionRound;
    }
    
    class MaterialExpressionRuntimeVirtualTextureOutput extends UE.MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseColor: UE.ExpressionInput;
        Specular: UE.ExpressionInput;
        Roughness: UE.ExpressionInput;
        Normal: UE.ExpressionInput;
        WorldHeight: UE.ExpressionInput;
        Opacity: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRuntimeVirtualTextureOutput;
        static Load(InName: string): MaterialExpressionRuntimeVirtualTextureOutput;
    }
    
    class MaterialExpressionRuntimeVirtualTextureReplace extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Default: UE.ExpressionInput;
        VirtualTextureOutput: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRuntimeVirtualTextureReplace;
        static Load(InName: string): MaterialExpressionRuntimeVirtualTextureReplace;
    }
    
    enum ERuntimeVirtualTextureMipValueMode { RVTMVM_None, RVTMVM_MipLevel, RVTMVM_MipBias, RVTMVM_MAX}
    class MaterialExpressionRuntimeVirtualTextureSample extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Coordinates: UE.ExpressionInput;
        MipValue: UE.ExpressionInput;
        VirtualTexture: UE.RuntimeVirtualTexture;
        MaterialType: UE.ERuntimeVirtualTextureMaterialType;
        bSinglePhysicalSpace: boolean;
        MipValueMode: UE.ERuntimeVirtualTextureMipValueMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRuntimeVirtualTextureSample;
        static Load(InName: string): MaterialExpressionRuntimeVirtualTextureSample;
    }
    
    class MaterialExpressionRuntimeVirtualTextureSampleParameter extends UE.MaterialExpressionRuntimeVirtualTextureSample {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterName: string;
        ExpressionGUID: UE.Guid;
        Group: string;
        SortPriority: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRuntimeVirtualTextureSampleParameter;
        static Load(InName: string): MaterialExpressionRuntimeVirtualTextureSampleParameter;
    }
    
    class MaterialExpressionSaturate extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSaturate;
        static Load(InName: string): MaterialExpressionSaturate;
    }
    
    enum EMaterialSceneAttributeInputMode { Coordinates, OffsetFraction, EMaterialSceneAttributeInputMode_MAX}
    class MaterialExpressionSceneColor extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputMode: UE.EMaterialSceneAttributeInputMode;
        Input: UE.ExpressionInput;
        OffsetFraction: UE.ExpressionInput;
        ConstInput: UE.Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSceneColor;
        static Load(InName: string): MaterialExpressionSceneColor;
    }
    
    class MaterialExpressionSceneDepth extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputMode: UE.EMaterialSceneAttributeInputMode;
        Input: UE.ExpressionInput;
        Coordinates: UE.ExpressionInput;
        ConstInput: UE.Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSceneDepth;
        static Load(InName: string): MaterialExpressionSceneDepth;
    }
    
    class MaterialExpressionSceneTexelSize extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSceneTexelSize;
        static Load(InName: string): MaterialExpressionSceneTexelSize;
    }
    
    enum ESceneTextureId { PPI_SceneColor, PPI_SceneDepth, PPI_DiffuseColor, PPI_SpecularColor, PPI_SubsurfaceColor, PPI_BaseColor, PPI_Specular, PPI_Metallic, PPI_WorldNormal, PPI_SeparateTranslucency, PPI_Opacity, PPI_Roughness, PPI_MaterialAO, PPI_CustomDepth, PPI_PostProcessInput0, PPI_PostProcessInput1, PPI_PostProcessInput2, PPI_PostProcessInput3, PPI_PostProcessInput4, PPI_PostProcessInput5, PPI_PostProcessInput6, PPI_DecalMask, PPI_ShadingModelColor, PPI_ShadingModelID, PPI_AmbientOcclusion, PPI_CustomStencil, PPI_StoredBaseColor, PPI_StoredSpecular, PPI_Velocity, PPI_MAX}
    class MaterialExpressionSceneTexture extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Coordinates: UE.ExpressionInput;
        SceneTextureId: UE.ESceneTextureId;
        bFiltered: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSceneTexture;
        static Load(InName: string): MaterialExpressionSceneTexture;
    }
    
    class MaterialExpressionScreenPosition extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionScreenPosition;
        static Load(InName: string): MaterialExpressionScreenPosition;
    }
    
    class MaterialExpressionSetMaterialAttributes extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Inputs: TArray<UE.ExpressionInput>;
        AttributeSetTypes: TArray<UE.Guid>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSetMaterialAttributes;
        static Load(InName: string): MaterialExpressionSetMaterialAttributes;
    }
    
    class MaterialExpressionShaderStageSwitch extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PixelShader: UE.ExpressionInput;
        VertexShader: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionShaderStageSwitch;
        static Load(InName: string): MaterialExpressionShaderStageSwitch;
    }
    
    class MaterialExpressionShadingModel extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShadingModel: UE.EMaterialShadingModel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionShadingModel;
        static Load(InName: string): MaterialExpressionShadingModel;
    }
    
    class MaterialExpressionShadingPathSwitch extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Default: UE.ExpressionInput;
        Inputs: FixSizeArray<UE.ExpressionInput>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionShadingPathSwitch;
        static Load(InName: string): MaterialExpressionShadingPathSwitch;
    }
    
    class MaterialExpressionShadowReplace extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Default: UE.ExpressionInput;
        Shadow: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionShadowReplace;
        static Load(InName: string): MaterialExpressionShadowReplace;
    }
    
    class MaterialExpressionSign extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSign;
        static Load(InName: string): MaterialExpressionSign;
    }
    
    class MaterialExpressionSine extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        Period: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSine;
        static Load(InName: string): MaterialExpressionSine;
    }
    
    class MaterialExpressionSingleLayerWaterMaterialOutput extends UE.MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ScatteringCoefficients: UE.ExpressionInput;
        AbsorptionCoefficients: UE.ExpressionInput;
        PhaseG: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSingleLayerWaterMaterialOutput;
        static Load(InName: string): MaterialExpressionSingleLayerWaterMaterialOutput;
    }
    
    class MaterialExpressionSkyAtmosphereAerialPerspective extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WorldPosition: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereAerialPerspective;
        static Load(InName: string): MaterialExpressionSkyAtmosphereAerialPerspective;
    }
    
    class MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance;
        static Load(InName: string): MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance;
    }
    
    class MaterialExpressionSkyAtmosphereLightDirection extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereLightDirection;
        static Load(InName: string): MaterialExpressionSkyAtmosphereLightDirection;
    }
    
    class MaterialExpressionSkyAtmosphereLightDiskLuminance extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereLightDiskLuminance;
        static Load(InName: string): MaterialExpressionSkyAtmosphereLightDiskLuminance;
    }
    
    class MaterialExpressionSkyAtmosphereLightIlluminance extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightIndex: number;
        WorldPosition: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereLightIlluminance;
        static Load(InName: string): MaterialExpressionSkyAtmosphereLightIlluminance;
    }
    
    class MaterialExpressionSkyAtmosphereViewLuminance extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereViewLuminance;
        static Load(InName: string): MaterialExpressionSkyAtmosphereViewLuminance;
    }
    
    class MaterialExpressionSobol extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Cell: UE.ExpressionInput;
        Index: UE.ExpressionInput;
        Seed: UE.ExpressionInput;
        ConstIndex: number;
        ConstSeed: UE.Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSobol;
        static Load(InName: string): MaterialExpressionSobol;
    }
    
    enum ESpeedTreeGeometryType { STG_Branch, STG_Frond, STG_Leaf, STG_FacingLeaf, STG_Billboard, STG_MAX}
    enum ESpeedTreeWindType { STW_None, STW_Fastest, STW_Fast, STW_Better, STW_Best, STW_Palm, STW_BestPlus, STW_MAX}
    enum ESpeedTreeLODType { STLOD_Pop, STLOD_Smooth, STLOD_MAX}
    class MaterialExpressionSpeedTree extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GeometryInput: UE.ExpressionInput;
        WindInput: UE.ExpressionInput;
        LODInput: UE.ExpressionInput;
        ExtraBendWS: UE.ExpressionInput;
        GeometryType: UE.ESpeedTreeGeometryType;
        WindType: UE.ESpeedTreeWindType;
        LODType: UE.ESpeedTreeLODType;
        BillboardThreshold: number;
        bAccurateWindVelocities: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSpeedTree;
        static Load(InName: string): MaterialExpressionSpeedTree;
    }
    
    class MaterialExpressionSphereMask extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: UE.ExpressionInput;
        B: UE.ExpressionInput;
        Radius: UE.ExpressionInput;
        Hardness: UE.ExpressionInput;
        AttenuationRadius: number;
        HardnessPercent: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSphereMask;
        static Load(InName: string): MaterialExpressionSphereMask;
    }
    
    class MaterialExpressionSphericalParticleOpacity extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Density: UE.ExpressionInput;
        ConstantDensity: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSphericalParticleOpacity;
        static Load(InName: string): MaterialExpressionSphericalParticleOpacity;
    }
    
    class MaterialExpressionSpriteTextureSampler extends UE.MaterialExpressionTextureSampleParameter2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bSampleAdditionalTextures: boolean;
        AdditionalSlotIndex: number;
        SlotDisplayName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSpriteTextureSampler;
        static Load(InName: string): MaterialExpressionSpriteTextureSampler;
    }
    
    class MaterialExpressionSquareRoot extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSquareRoot;
        static Load(InName: string): MaterialExpressionSquareRoot;
    }
    
    class MaterialExpressionStaticBool extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Value: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionStaticBool;
        static Load(InName: string): MaterialExpressionStaticBool;
    }
    
    class MaterialExpressionStaticBoolParameter extends UE.MaterialExpressionParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultValue: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionStaticBoolParameter;
        static Load(InName: string): MaterialExpressionStaticBoolParameter;
    }
    
    class MaterialExpressionStaticComponentMaskParameter extends UE.MaterialExpressionParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        DefaultR: boolean;
        DefaultG: boolean;
        DefaultB: boolean;
        DefaultA: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionStaticComponentMaskParameter;
        static Load(InName: string): MaterialExpressionStaticComponentMaskParameter;
    }
    
    class MaterialExpressionStaticSwitch extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultValue: boolean;
        A: UE.ExpressionInput;
        B: UE.ExpressionInput;
        Value: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionStaticSwitch;
        static Load(InName: string): MaterialExpressionStaticSwitch;
    }
    
    class MaterialExpressionStaticSwitchParameter extends UE.MaterialExpressionStaticBoolParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: UE.ExpressionInput;
        B: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionStaticSwitchParameter;
        static Load(InName: string): MaterialExpressionStaticSwitchParameter;
    }
    
    class MaterialExpressionSubtract extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: UE.ExpressionInput;
        B: UE.ExpressionInput;
        ConstA: number;
        ConstB: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSubtract;
        static Load(InName: string): MaterialExpressionSubtract;
    }
    
    class MaterialExpressionTangent extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        Period: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTangent;
        static Load(InName: string): MaterialExpressionTangent;
    }
    
    class MaterialExpressionTangentOutput extends UE.MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTangentOutput;
        static Load(InName: string): MaterialExpressionTangentOutput;
    }
    
    class MaterialExpressionTemporalSobol extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Index: UE.ExpressionInput;
        Seed: UE.ExpressionInput;
        ConstIndex: number;
        ConstSeed: UE.Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTemporalSobol;
        static Load(InName: string): MaterialExpressionTemporalSobol;
    }
    
    class MaterialExpressionTextureCoordinate extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CoordinateIndex: number;
        UTiling: number;
        VTiling: number;
        UnMirrorU: boolean;
        UnMirrorV: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureCoordinate;
        static Load(InName: string): MaterialExpressionTextureCoordinate;
    }
    
    class MaterialExpressionTextureObject extends UE.MaterialExpressionTextureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureObject;
        static Load(InName: string): MaterialExpressionTextureObject;
    }
    
    class MaterialExpressionTextureObjectParameter extends UE.MaterialExpressionTextureSampleParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureObjectParameter;
        static Load(InName: string): MaterialExpressionTextureObjectParameter;
    }
    
    enum EMaterialExposedTextureProperty { TMTM_TextureSize, TMTM_TexelSize, TMTM_MAX}
    class MaterialExpressionTextureProperty extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TextureObject: UE.ExpressionInput;
        Property: UE.EMaterialExposedTextureProperty;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureProperty;
        static Load(InName: string): MaterialExpressionTextureProperty;
    }
    
    class MaterialExpressionTextureSampleParameter2DArray extends UE.MaterialExpressionTextureSampleParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameter2DArray;
        static Load(InName: string): MaterialExpressionTextureSampleParameter2DArray;
    }
    
    class MaterialExpressionTextureSampleParameterCube extends UE.MaterialExpressionTextureSampleParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameterCube;
        static Load(InName: string): MaterialExpressionTextureSampleParameterCube;
    }
    
    class MaterialExpressionTextureSampleParameterSubUV extends UE.MaterialExpressionTextureSampleParameter2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bBlend: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameterSubUV;
        static Load(InName: string): MaterialExpressionTextureSampleParameterSubUV;
    }
    
    class MaterialExpressionTextureSampleParameterVolume extends UE.MaterialExpressionTextureSampleParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameterVolume;
        static Load(InName: string): MaterialExpressionTextureSampleParameterVolume;
    }
    
    class MaterialExpressionTime extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIgnorePause: boolean;
        bOverride_Period: boolean;
        Period: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTime;
        static Load(InName: string): MaterialExpressionTime;
    }
    
    enum EMaterialVectorCoordTransformSource { TRANSFORMSOURCE_Tangent, TRANSFORMSOURCE_Local, TRANSFORMSOURCE_World, TRANSFORMSOURCE_View, TRANSFORMSOURCE_Camera, TRANSFORMSOURCE_ParticleWorld, TRANSFORMSOURCE_MAX}
    enum EMaterialVectorCoordTransform { TRANSFORM_Tangent, TRANSFORM_Local, TRANSFORM_World, TRANSFORM_View, TRANSFORM_Camera, TRANSFORM_ParticleWorld, TRANSFORM_MAX}
    class MaterialExpressionTransform extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        TransformSourceType: UE.EMaterialVectorCoordTransformSource;
        TransformType: UE.EMaterialVectorCoordTransform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTransform;
        static Load(InName: string): MaterialExpressionTransform;
    }
    
    enum EMaterialPositionTransformSource { TRANSFORMPOSSOURCE_Local, TRANSFORMPOSSOURCE_World, TRANSFORMPOSSOURCE_TranslatedWorld, TRANSFORMPOSSOURCE_View, TRANSFORMPOSSOURCE_Camera, TRANSFORMPOSSOURCE_Particle, TRANSFORMPOSSOURCE_MAX}
    class MaterialExpressionTransformPosition extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        TransformSourceType: UE.EMaterialPositionTransformSource;
        TransformType: UE.EMaterialPositionTransformSource;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTransformPosition;
        static Load(InName: string): MaterialExpressionTransformPosition;
    }
    
    class MaterialExpressionTruncate extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTruncate;
        static Load(InName: string): MaterialExpressionTruncate;
    }
    
    class MaterialExpressionTwoSidedSign extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTwoSidedSign;
        static Load(InName: string): MaterialExpressionTwoSidedSign;
    }
    
    enum EVectorNoiseFunction { VNF_CellnoiseALU, VNF_VectorALU, VNF_GradientALU, VNF_CurlALU, VNF_VoronoiALU, VNF_MAX}
    class MaterialExpressionVectorNoise extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Position: UE.ExpressionInput;
        NoiseFunction: UE.EVectorNoiseFunction;
        Quality: number;
        bTiling: boolean;
        TileSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVectorNoise;
        static Load(InName: string): MaterialExpressionVectorNoise;
    }
    
    class MaterialExpressionVertexColor extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVertexColor;
        static Load(InName: string): MaterialExpressionVertexColor;
    }
    
    class MaterialExpressionVertexInterpolator extends UE.MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVertexInterpolator;
        static Load(InName: string): MaterialExpressionVertexInterpolator;
    }
    
    class MaterialExpressionVertexNormalWS extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVertexNormalWS;
        static Load(InName: string): MaterialExpressionVertexNormalWS;
    }
    
    enum EMaterialExposedViewProperty { MEVP_BufferSize, MEVP_FieldOfView, MEVP_TanHalfFieldOfView, MEVP_ViewSize, MEVP_WorldSpaceViewPosition, MEVP_WorldSpaceCameraPosition, MEVP_ViewportOffset, MEVP_TemporalSampleCount, MEVP_TemporalSampleIndex, MEVP_TemporalSampleOffset, MEVP_RuntimeVirtualTextureOutputLevel, MEVP_RuntimeVirtualTextureOutputDerivative, MEVP_PreExposure, MEVP_MAX}
    class MaterialExpressionViewProperty extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Property: UE.EMaterialExposedViewProperty;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionViewProperty;
        static Load(InName: string): MaterialExpressionViewProperty;
    }
    
    class MaterialExpressionViewSize extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionViewSize;
        static Load(InName: string): MaterialExpressionViewSize;
    }
    
    class MaterialExpressionVirtualTextureFeatureSwitch extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        No: UE.ExpressionInput;
        Yes: UE.ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVirtualTextureFeatureSwitch;
        static Load(InName: string): MaterialExpressionVirtualTextureFeatureSwitch;
    }
    
    enum EWorldPositionIncludedOffsets { WPT_Default, WPT_ExcludeAllShaderOffsets, WPT_CameraRelative, WPT_CameraRelativeNoOffsets, WPT_MAX}
    class MaterialExpressionWorldPosition extends UE.MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WorldPositionShaderOffset: UE.EWorldPositionIncludedOffsets;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionWorldPosition;
        static Load(InName: string): MaterialExpressionWorldPosition;
    }
    
    class MaterialFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialTexture: UE.Texture;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFactoryNew;
        static Load(InName: string): MaterialFactoryNew;
    }
    
    class MaterialFunctionFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionFactoryNew;
        static Load(InName: string): MaterialFunctionFactoryNew;
    }
    
    class MaterialFunctionInstanceFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialParent: UE.MaterialFunctionInterface;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionInstanceFactory;
        static Load(InName: string): MaterialFunctionInstanceFactory;
    }
    
    class MaterialFunctionMaterialLayer extends UE.MaterialFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayer;
        static Load(InName: string): MaterialFunctionMaterialLayer;
    }
    
    class MaterialFunctionMaterialLayerBlend extends UE.MaterialFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerBlend;
        static Load(InName: string): MaterialFunctionMaterialLayerBlend;
    }
    
    class MaterialFunctionMaterialLayerBlendFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerBlendFactory;
        static Load(InName: string): MaterialFunctionMaterialLayerBlendFactory;
    }
    
    class MaterialFunctionMaterialLayerBlendInstance extends UE.MaterialFunctionInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerBlendInstance;
        static Load(InName: string): MaterialFunctionMaterialLayerBlendInstance;
    }
    
    class MaterialFunctionMaterialLayerBlendInstanceFactory extends UE.MaterialFunctionInstanceFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerBlendInstanceFactory;
        static Load(InName: string): MaterialFunctionMaterialLayerBlendInstanceFactory;
    }
    
    class MaterialFunctionMaterialLayerFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerFactory;
        static Load(InName: string): MaterialFunctionMaterialLayerFactory;
    }
    
    class MaterialFunctionMaterialLayerInstance extends UE.MaterialFunctionInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerInstance;
        static Load(InName: string): MaterialFunctionMaterialLayerInstance;
    }
    
    class MaterialFunctionMaterialLayerInstanceFactory extends UE.MaterialFunctionInstanceFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerInstanceFactory;
        static Load(InName: string): MaterialFunctionMaterialLayerInstanceFactory;
    }
    
    class MaterialFunctionThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionThumbnailRenderer;
        static Load(InName: string): MaterialFunctionThumbnailRenderer;
    }
    
    class MaterialGraphNode_Base extends UE.EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialGraphNode_Base;
        static Load(InName: string): MaterialGraphNode_Base;
    }
    
    class MaterialGraphNode_Root extends UE.MaterialGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Material: UE.Material;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialGraphNode_Root;
        static Load(InName: string): MaterialGraphNode_Root;
    }
    
    class MaterialGraph extends UE.EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Material: UE.Material;
        MaterialFunction: UE.MaterialFunction;
        RootNode: UE.MaterialGraphNode_Root;
        OriginalMaterialFullName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialGraph;
        static Load(InName: string): MaterialGraph;
    }
    
    class MaterialGraphNode extends UE.MaterialGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialExpression: UE.MaterialExpression;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialGraphNode;
        static Load(InName: string): MaterialGraphNode;
    }
    
    class MaterialGraphNode_Comment extends UE.EdGraphNode_Comment {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialExpressionComment: UE.MaterialExpressionComment;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialGraphNode_Comment;
        static Load(InName: string): MaterialGraphNode_Comment;
    }
    
    class MaterialGraphNode_Knot extends UE.MaterialGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialGraphNode_Knot;
        static Load(InName: string): MaterialGraphNode_Knot;
    }
    
    class MaterialGraphSchema extends UE.EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialGraphSchema;
        static Load(InName: string): MaterialGraphSchema;
    }
    
    class MaterialImportHelpers extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static FindExistingMaterial(BasePath: string, MaterialFullName: string, bRecursivePaths: boolean, OutError: $Ref<string>) : UE.MaterialInterface;
        static FindExistingMaterialFromSearchLocation(MaterialFullName: string, BasePackagePath: string, SearchLocation: UE.EMaterialSearchLocation, OutError: $Ref<string>) : UE.MaterialInterface;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialImportHelpers;
        static Load(InName: string): MaterialImportHelpers;
    }
    
    class MaterialInstanceActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetActors: TArray<UE.Actor>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialInstanceActor;
        static Load(InName: string): MaterialInstanceActor;
    }
    
    class MaterialInstanceConstantFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialParent: UE.MaterialInterface;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialInstanceConstantFactoryNew;
        static Load(InName: string): MaterialInstanceConstantFactoryNew;
    }
    
    class MaterialInstanceThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialInstanceThumbnailRenderer;
        static Load(InName: string): MaterialInstanceThumbnailRenderer;
    }
    
    enum EMaterialBakeMethod { IndividualMaterial, AtlasMaterial, BinnedMaterial, EMaterialBakeMethod_MAX}
    class MaterialMergeOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Method: UE.EMaterialBakeMethod;
        BlendMode: UE.EBlendMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialMergeOptions;
        static Load(InName: string): MaterialMergeOptions;
    }
    
    class PropertyEntry {
        constructor();
        constructor(Property: UE.EMaterialProperty, bUseCustomSize: boolean, CustomSize: UE.IntPoint, bUseConstantValue: boolean, ConstantValue: number);
        Property: UE.EMaterialProperty;
        bUseCustomSize: boolean;
        CustomSize: UE.IntPoint;
        bUseConstantValue: boolean;
        ConstantValue: number;
        static StaticClass(): Class;
    }
    
    class MaterialOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Properties: TArray<UE.PropertyEntry>;
        TextureSize: UE.IntPoint;
        LODIndices: TArray<number>;
        bUseMeshData: boolean;
        bUseSpecificUVIndex: boolean;
        TextureCoordinateIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialOptions;
        static Load(InName: string): MaterialOptions;
    }
    
    class MaterialParameterCollectionFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialParameterCollectionFactoryNew;
        static Load(InName: string): MaterialParameterCollectionFactoryNew;
    }
    
    enum EMobileCSMQuality { NoFiltering, PCF_1x1, PCF_2x2, EMobileCSMQuality_MAX}
    class MaterialQualityOverrides {
        constructor();
        constructor(bDiscardQualityDuringCook: boolean, bEnableOverride: boolean, bForceFullyRough: boolean, bForceNonMetal: boolean, bForceDisableLMDirectionality: boolean, bForceLQReflections: boolean, bDisableMaterialNormalCalculation: boolean, MobileCSMQuality: UE.EMobileCSMQuality);
        bDiscardQualityDuringCook: boolean;
        bEnableOverride: boolean;
        bForceFullyRough: boolean;
        bForceNonMetal: boolean;
        bForceDisableLMDirectionality: boolean;
        bForceLQReflections: boolean;
        bDisableMaterialNormalCalculation: boolean;
        MobileCSMQuality: UE.EMobileCSMQuality;
        static StaticClass(): Class;
    }
    
    class ShaderPlatformQualitySettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        QualityOverrides: FixSizeArray<UE.MaterialQualityOverrides>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ShaderPlatformQualitySettings;
        static Load(InName: string): ShaderPlatformQualitySettings;
    }
    
    class MaterialShaderQualitySettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ForwardSettingMap: TMap<string, UE.ShaderPlatformQualitySettings>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialShaderQualitySettings;
        static Load(InName: string): MaterialShaderQualitySettings;
    }
    
    class MaterialStatsOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bPlatformUsed: FixSizeArray<number>;
        bMaterialQualityUsed: FixSizeArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialStatsOptions;
        static Load(InName: string): MaterialStatsOptions;
    }
    
    class MatineeActorCameraAnim extends UE.MatineeActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CameraAnim: UE.CameraAnim;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MatineeActorCameraAnim;
        static Load(InName: string): MatineeActorCameraAnim;
    }
    
    class MatineeAnimInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MatineeAnimInterface;
        static Load(InName: string): MatineeAnimInterface;
    }
    
    class MatineeInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MatineeInterface;
        static Load(InName: string): MatineeInterface;
    }
    
    class MediaCaptureDevice {
        constructor();
        constructor(DisplayName: string, Url: string);
        DisplayName: string;
        Url: string;
        static StaticClass(): Class;
    }
    
    class MediaBlueprintFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static EnumerateAudioCaptureDevices(OutDevices: $Ref<TArray<UE.MediaCaptureDevice>>, Filter?: number /* = -1 */) : void;
        static EnumerateVideoCaptureDevices(OutDevices: $Ref<TArray<UE.MediaCaptureDevice>>, Filter?: number /* = -1 */) : void;
        static EnumerateWebcamCaptureDevices(OutDevices: $Ref<TArray<UE.MediaCaptureDevice>>, Filter?: number /* = -1 */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaBlueprintFunctionLibrary;
        static Load(InName: string): MediaBlueprintFunctionLibrary;
    }
    
    class MediaPlaylist extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Items: TArray<UE.MediaSource>;
        Add(MediaSource: $Nullable<UE.MediaSource>) : boolean;
        AddFile(FilePath: string) : boolean;
        AddUrl(Url: string) : boolean;
        Get(Index: number) : UE.MediaSource;
        GetNext(InOutIndex: $Ref<number>) : UE.MediaSource;
        GetPrevious(InOutIndex: $Ref<number>) : UE.MediaSource;
        GetRandom(OutIndex: $Ref<number>) : UE.MediaSource;
        Insert(MediaSource: $Nullable<UE.MediaSource>, Index: number) : void;
        Num() : number;
        Remove(MediaSource: $Nullable<UE.MediaSource>) : boolean;
        RemoveAt(Index: number) : boolean;
        Replace(Index: number, Replacement: $Nullable<UE.MediaSource>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaPlaylist;
        static Load(InName: string): MediaPlaylist;
    }
    
    enum EMediaPlayerTrack { Audio, Caption, Metadata, Script, Subtitle, Text, Video, EMediaPlayerTrack_MAX}
    class MediaPlayerTrackOptions {
        constructor();
        constructor(Audio: number, Caption: number, Metadata: number, Script: number, Subtitle: number, Text: number, Video: number);
        Audio: number;
        Caption: number;
        Metadata: number;
        Script: number;
        Subtitle: number;
        Text: number;
        Video: number;
        static StaticClass(): Class;
    }
    
    enum EMediaPlayerOptionBooleanOverride { UseMediaPlayerSetting, Enabled, Disabled, EMediaPlayerOptionBooleanOverride_MAX}
    class MediaPlayerOptions {
        constructor();
        constructor(Tracks: UE.MediaPlayerTrackOptions, SeekTime: UE.Timespan, PlayOnOpen: UE.EMediaPlayerOptionBooleanOverride, Loop: UE.EMediaPlayerOptionBooleanOverride);
        Tracks: UE.MediaPlayerTrackOptions;
        SeekTime: UE.Timespan;
        PlayOnOpen: UE.EMediaPlayerOptionBooleanOverride;
        Loop: UE.EMediaPlayerOptionBooleanOverride;
        static StaticClass(): Class;
    }
    
    class MediaPlayer extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnEndReached: $MulticastDelegate<() => void>;
        OnMediaClosed: $MulticastDelegate<() => void>;
        OnMediaOpened: $MulticastDelegate<(OpenedUrl: string) => void>;
        OnMediaOpenFailed: $MulticastDelegate<(FailedUrl: string) => void>;
        OnPlaybackResumed: $MulticastDelegate<() => void>;
        OnPlaybackSuspended: $MulticastDelegate<() => void>;
        OnSeekCompleted: $MulticastDelegate<() => void>;
        OnTracksChanged: $MulticastDelegate<() => void>;
        CacheAhead: UE.Timespan;
        CacheBehind: UE.Timespan;
        CacheBehindGame: UE.Timespan;
        NativeAudioOut: boolean;
        PlayOnOpen: boolean;
        Shuffle: boolean;
        Loop: boolean;
        Playlist: UE.MediaPlaylist;
        PlaylistIndex: number;
        TimeDelay: UE.Timespan;
        HorizontalFieldOfView: number;
        VerticalFieldOfView: number;
        ViewRotation: UE.Rotator;
        PlayerGuid: UE.Guid;
        AffectedByPIEHandling: boolean;
        CanPause() : boolean;
        CanPlaySource(MediaSource: $Nullable<UE.MediaSource>) : boolean;
        CanPlayUrl(Url: string) : boolean;
        Close() : void;
        GetAudioTrackChannels(TrackIndex: number, FormatIndex: number) : number;
        GetAudioTrackSampleRate(TrackIndex: number, FormatIndex: number) : number;
        GetAudioTrackType(TrackIndex: number, FormatIndex: number) : string;
        GetDesiredPlayerName() : string;
        GetDuration() : UE.Timespan;
        GetHorizontalFieldOfView() : number;
        GetLastAudioSampleProcessedTime() : UE.Timespan;
        GetLastVideoSampleProcessedTime() : UE.Timespan;
        GetMediaName() : string;
        GetNumTrackFormats(TrackType: UE.EMediaPlayerTrack, TrackIndex: number) : number;
        GetNumTracks(TrackType: UE.EMediaPlayerTrack) : number;
        GetPlayerName() : string;
        GetPlaylist() : UE.MediaPlaylist;
        GetPlaylistIndex() : number;
        GetRate() : number;
        GetSelectedTrack(TrackType: UE.EMediaPlayerTrack) : number;
        GetSupportedRates(OutRates: $Ref<TArray<UE.FloatRange>>, Unthinned: boolean) : void;
        GetTime() : UE.Timespan;
        GetTimeDelay() : UE.Timespan;
        GetTrackDisplayName(TrackType: UE.EMediaPlayerTrack, TrackIndex: number) : string;
        GetTrackFormat(TrackType: UE.EMediaPlayerTrack, TrackIndex: number) : number;
        GetTrackLanguage(TrackType: UE.EMediaPlayerTrack, TrackIndex: number) : string;
        GetUrl() : string;
        GetVerticalFieldOfView() : number;
        GetVideoTrackAspectRatio(TrackIndex: number, FormatIndex: number) : number;
        GetVideoTrackDimensions(TrackIndex: number, FormatIndex: number) : UE.IntPoint;
        GetVideoTrackFrameRate(TrackIndex: number, FormatIndex: number) : number;
        GetVideoTrackFrameRates(TrackIndex: number, FormatIndex: number) : UE.FloatRange;
        GetVideoTrackType(TrackIndex: number, FormatIndex: number) : string;
        GetViewRotation() : UE.Rotator;
        HasError() : boolean;
        IsBuffering() : boolean;
        IsClosed() : boolean;
        IsConnecting() : boolean;
        IsLooping() : boolean;
        IsPaused() : boolean;
        IsPlaying() : boolean;
        IsPreparing() : boolean;
        IsReady() : boolean;
        Next() : boolean;
        OpenFile(FilePath: string) : boolean;
        OpenPlaylist(InPlaylist: $Nullable<UE.MediaPlaylist>) : boolean;
        OpenPlaylistIndex(InPlaylist: $Nullable<UE.MediaPlaylist>, Index: number) : boolean;
        OpenSource(MediaSource: $Nullable<UE.MediaSource>) : boolean;
        OpenSourceLatent(WorldContextObject: $Nullable<UE.Object>, LatentInfo: UE.LatentActionInfo, MediaSource: $Nullable<UE.MediaSource>, Options: UE.MediaPlayerOptions, bSuccess: $Ref<boolean>) : void;
        OpenSourceWithOptions(MediaSource: $Nullable<UE.MediaSource>, Options: UE.MediaPlayerOptions) : boolean;
        OpenUrl(Url: string) : boolean;
        Pause() : boolean;
        Play() : boolean;
        Previous() : boolean;
        Reopen() : boolean;
        Rewind() : boolean;
        Seek(Time: UE.Timespan) : boolean;
        SelectTrack(TrackType: UE.EMediaPlayerTrack, TrackIndex: number) : boolean;
        SetBlockOnTime(Time: UE.Timespan) : void;
        SetDesiredPlayerName(PlayerName: string) : void;
        SetLooping(Looping: boolean) : boolean;
        SetMediaOptions(Options: $Nullable<UE.MediaSource>) : void;
        SetNativeVolume(Volume: number) : boolean;
        SetRate(Rate: number) : boolean;
        SetTimeDelay(TimeDelay: UE.Timespan) : void;
        SetTrackFormat(TrackType: UE.EMediaPlayerTrack, TrackIndex: number, FormatIndex: number) : boolean;
        SetVideoTrackFrameRate(TrackIndex: number, FormatIndex: number, FrameRate: number) : boolean;
        SetViewField(Horizontal: number, Vertical: number, Absolute: boolean) : boolean;
        SetViewRotation(Rotation: UE.Rotator, Absolute: boolean) : boolean;
        SupportsRate(Rate: number, Unthinned: boolean) : boolean;
        SupportsScrubbing() : boolean;
        SupportsSeeking() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaPlayer;
        static Load(InName: string): MediaPlayer;
    }
    
    class ToolMenuContextBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenuContextBase;
        static Load(InName: string): ToolMenuContextBase;
    }
    
    class MediaPlayerEditorMediaContext extends UE.ToolMenuContextBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SelectedAsset: UE.Object;
        StyleSetName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaPlayerEditorMediaContext;
        static Load(InName: string): MediaPlayerEditorMediaContext;
    }
    
    enum EMediaPlayerEditorScale { Fill, Fit, Original, EMediaPlayerEditorScale_MAX}
    class MediaPlayerEditorSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DesiredPlayerName: string;
        ShowTextOverlays: boolean;
        ViewportScale: UE.EMediaPlayerEditorScale;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaPlayerEditorSettings;
        static Load(InName: string): MediaPlayerEditorSettings;
    }
    
    class MediaPlayerFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaPlayerFactoryNew;
        static Load(InName: string): MediaPlayerFactoryNew;
    }
    
    enum EMediaPlayerRecordingNumerationStyle { AppendFrameNumber, AppendSampleTime, EMediaPlayerRecordingNumerationStyle_MAX}
    enum EMediaPlayerRecordingImageFormat { PNG, JPEG, BMP, EXR, EMediaPlayerRecordingImageFormat_MAX}
    class MediaPlayerRecordingSettings {
        constructor();
        constructor(bActive: boolean, bRecordMediaFrame: boolean, BaseFilename: string, NumerationStyle: UE.EMediaPlayerRecordingNumerationStyle, ImageFormat: UE.EMediaPlayerRecordingImageFormat, CompressionQuality: number, bResetAlpha: boolean);
        bActive: boolean;
        bRecordMediaFrame: boolean;
        BaseFilename: string;
        NumerationStyle: UE.EMediaPlayerRecordingNumerationStyle;
        ImageFormat: UE.EMediaPlayerRecordingImageFormat;
        CompressionQuality: number;
        bResetAlpha: boolean;
        static StaticClass(): Class;
    }
    
    class MediaPlayerRecording extends UE.SequenceRecordingBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RecordingSettings: UE.MediaPlayerRecordingSettings;
        MediaPlayerToRecord: TWeakObjectPtr<UE.MediaPlayer>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaPlayerRecording;
        static Load(InName: string): MediaPlayerRecording;
    }
    
    class MediaPlaylistFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaPlaylistFactoryNew;
        static Load(InName: string): MediaPlaylistFactoryNew;
    }
    
    class MediaSequenceRecorderSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bRecordMediaPlayerEnabled: boolean;
        MediaPlayerSubDirectory: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaSequenceRecorderSettings;
        static Load(InName: string): MediaSequenceRecorderSettings;
    }
    
    enum EMediaSoundChannels { Mono, Stereo, Surround, EMediaSoundChannels_MAX}
    enum EMediaSoundComponentFFTSize { Min_64, Small_256, Medium_512, Large_1024, EMediaSoundComponentFFTSize_MAX}
    class MediaSoundComponentSpectralData {
        constructor();
        constructor(FrequencyHz: number, Magnitude: number);
        FrequencyHz: number;
        Magnitude: number;
        static StaticClass(): Class;
    }
    
    class MediaSoundComponent extends UE.SynthComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Channels: UE.EMediaSoundChannels;
        DynamicRateAdjustment: boolean;
        RateAdjustmentFactor: number;
        RateAdjustmentRange: UE.FloatRange;
        MediaPlayer: UE.MediaPlayer;
        BP_GetAttenuationSettingsToApply(OutAttenuationSettings: $Ref<UE.SoundAttenuationSettings>) : boolean;
        GetEnvelopeValue() : number;
        GetMediaPlayer() : UE.MediaPlayer;
        GetSpectralData() : TArray<UE.MediaSoundComponentSpectralData>;
        SetEnableEnvelopeFollowing(bInEnvelopeFollowing: boolean) : void;
        SetEnableSpectralAnalysis(bInSpectralAnalysisEnabled: boolean) : void;
        SetEnvelopeFollowingsettings(AttackTimeMsec: number, ReleaseTimeMsec: number) : void;
        SetMediaPlayer(NewMediaPlayer: $Nullable<UE.MediaPlayer>) : void;
        SetSpectralAnalysisSettings(InFrequenciesToAnalyze: TArray<number>, InFFTSize?: UE.EMediaSoundComponentFFTSize /* = Medium_512 */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaSoundComponent;
        static Load(InName: string): MediaSoundComponent;
    }
    
    class MediaTexture extends UE.Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddressX: UE.TextureAddress;
        AddressY: UE.TextureAddress;
        AutoClear: boolean;
        ClearColor: UE.LinearColor;
        MediaPlayer: UE.MediaPlayer;
        GetAspectRatio() : number;
        GetHeight() : number;
        GetMediaPlayer() : UE.MediaPlayer;
        GetWidth() : number;
        SetMediaPlayer(NewMediaPlayer: $Nullable<UE.MediaPlayer>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaTexture;
        static Load(InName: string): MediaTexture;
    }
    
    class MediaTextureFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaTextureFactoryNew;
        static Load(InName: string): MediaTextureFactoryNew;
    }
    
    enum EMenuPlacement { MenuPlacement_BelowAnchor, MenuPlacement_CenteredBelowAnchor, MenuPlacement_BelowRightAnchor, MenuPlacement_ComboBox, MenuPlacement_ComboBoxRight, MenuPlacement_MenuRight, MenuPlacement_AboveAnchor, MenuPlacement_CenteredAboveAnchor, MenuPlacement_AboveRightAnchor, MenuPlacement_MenuLeft, MenuPlacement_Center, MenuPlacement_RightLeftCenter, MenuPlacement_MatchBottomLeft, MenuPlacement_MAX}
    class MenuAnchor extends UE.ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MenuClass: UE.Class;
        OnGetMenuContentEvent: $Delegate<() => UE.Widget>;
        Placement: UE.EMenuPlacement;
        bFitInWindow: boolean;
        ShouldDeferPaintingAfterWindowContent: boolean;
        UseApplicationMenuStack: boolean;
        OnMenuOpenChanged: $MulticastDelegate<(bIsOpen: boolean) => void>;
        Close() : void;
        FitInWindow(bFit: boolean) : void;
        GetMenuPosition() : UE.Vector2D;
        HasOpenSubMenus() : boolean;
        IsOpen() : boolean;
        Open(bFocusMenu: boolean) : void;
        SetPlacement(InPlacement: UE.EMenuPlacement) : void;
        ShouldOpenDueToClick() : boolean;
        ToggleOpen(bFocusOnOpen: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MenuAnchor;
        static Load(InName: string): MenuAnchor;
    }
    
    class MergeShaderPipelineCachesCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MergeShaderPipelineCachesCommandlet;
        static Load(InName: string): MergeShaderPipelineCachesCommandlet;
    }
    
    class MeshDescription extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshDescription;
        static Load(InName: string): MeshDescription;
    }
    
    enum EMeshInstancingReplacementMethod { RemoveOriginalActors, KeepOriginalActorsAsEditorOnly, EMeshInstancingReplacementMethod_MAX}
    class MeshInstancingSettings {
        constructor();
        constructor(ActorClassToUse: UE.Class, InstanceReplacementThreshold: number, MeshReplacementMethod: UE.EMeshInstancingReplacementMethod, bSkipMeshesWithVertexColors: boolean, bUseHLODVolumes: boolean, ISMComponentToUse: UE.Class);
        ActorClassToUse: UE.Class;
        InstanceReplacementThreshold: number;
        MeshReplacementMethod: UE.EMeshInstancingReplacementMethod;
        bSkipMeshesWithVertexColors: boolean;
        bUseHLODVolumes: boolean;
        ISMComponentToUse: UE.Class;
        static StaticClass(): Class;
    }
    
    class MeshInstancingSettingsObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: UE.MeshInstancingSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshInstancingSettingsObject;
        static Load(InName: string): MeshInstancingSettingsObject;
    }
    
    class MeshMergeCullingVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshMergeCullingVolume;
        static Load(InName: string): MeshMergeCullingVolume;
    }
    
    class MeshMergingSettingsObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: UE.MeshMergingSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshMergingSettingsObject;
        static Load(InName: string): MeshMergingSettingsObject;
    }
    
    class MeshProxySettingsObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: UE.MeshProxySettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshProxySettingsObject;
        static Load(InName: string): MeshProxySettingsObject;
    }
    
    class MeshReconstructorBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConnectMRMesh(Mesh: $Nullable<UE.MRMeshComponent>) : void;
        DisconnectMRMesh() : void;
        IsReconstructionPaused() : boolean;
        IsReconstructionStarted() : boolean;
        PauseReconstruction() : void;
        StartReconstruction() : void;
        StopReconstruction() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshReconstructorBase;
        static Load(InName: string): MeshReconstructorBase;
    }
    
    class SelectionSet extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SelectionSet;
        static Load(InName: string): SelectionSet;
    }
    
    class MeshSelectionSet extends UE.SelectionSet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Vertices: TArray<number>;
        Edges: TArray<number>;
        Faces: TArray<number>;
        Groups: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshSelectionSet;
        static Load(InName: string): MeshSelectionSet;
    }
    
    class MeshSimplificationSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MeshReductionModuleName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshSimplificationSettings;
        static Load(InName: string): MeshSimplificationSettings;
    }
    
    class SingleSelectionTool extends UE.InteractiveTool {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SingleSelectionTool;
        static Load(InName: string): SingleSelectionTool;
    }
    
    class MeshSurfacePointTool extends UE.SingleSelectionTool {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshSurfacePointTool;
        static Load(InName: string): MeshSurfacePointTool;
    }
    
    class MeshSurfacePointToolBuilder extends UE.InteractiveToolBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshSurfacePointToolBuilder;
        static Load(InName: string): MeshSurfacePointToolBuilder;
    }
    
    class MeshSurfacePointToolMouseBehavior extends UE.AnyButtonInputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshSurfacePointToolMouseBehavior;
        static Load(InName: string): MeshSurfacePointToolMouseBehavior;
    }
    
    enum EMagicLeapMeshType { Triangles, PointCloud, EMagicLeapMeshType_MAX}
    enum EMagicLeapMeshVertexColorMode { None, Confidence, Block, LOD, EMagicLeapMeshVertexColorMode_MAX}
    class MeshTrackerComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnMeshTrackerUpdated: $MulticastDelegate<(ID: UE.Guid, Vertices: TArray<UE.Vector>, Triangles: TArray<number>, Normals: TArray<UE.Vector>, Confidence: TArray<number>) => void>;
        ScanWorld: boolean;
        MeshType: UE.EMagicLeapMeshType;
        BoundingVolume: UE.BoxComponent;
        LevelOfDetail: UE.EMagicLeapMeshLOD;
        PerimeterOfGapsToFill: number;
        Planarize: boolean;
        DisconnectedSectionArea: number;
        RequestNormals: boolean;
        RequestVertexConfidence: boolean;
        VertexColorMode: UE.EMagicLeapMeshVertexColorMode;
        BlockVertexColors: TArray<UE.Color>;
        VertexColorFromConfidenceZero: UE.LinearColor;
        VertexColorFromConfidenceOne: UE.LinearColor;
        RemoveOverlappingTriangles: boolean;
        MRMesh: UE.MRMeshComponent;
        BricksPerFrame: number;
        ConnectBlockSelector(Selector: MagicLeapMeshBlockSelectorInterface) : void;
        ConnectMRMesh(InMRMeshPtr: $Nullable<UE.MRMeshComponent>) : void;
        DisconnectBlockSelector() : void;
        DisconnectMRMesh(InMRMeshPtr: $Nullable<UE.MRMeshComponent>) : void;
        GetNumQueuedBlockUpdates() : number;
        OnMeshTrackerUpdated__DelegateSignature(ID: UE.Guid, Vertices: TArray<UE.Vector>, Triangles: TArray<number>, Normals: TArray<UE.Vector>, Confidence: TArray<number>) : void;
        SelectMeshBlocks(NewMeshInfo: UE.MagicLeapTrackingMeshInfo, RequestedMesh: $Ref<TArray<UE.MagicLeapMeshBlockRequest>>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshTrackerComponent;
        static Load(InName: string): MeshTrackerComponent;
    }
    
    enum EVertexPaintAxis { X, Y, Z, EVertexPaintAxis_MAX}
    class MeshVertexPainterKismetLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static PaintVerticesLerpAlongAxis(StaticMeshComponent: $Nullable<UE.StaticMeshComponent>, StartColor: UE.LinearColor, EndColor: UE.LinearColor, Axis: UE.EVertexPaintAxis, bConvertToSRGB?: boolean /* = true */) : void;
        static PaintVerticesSingleColor(StaticMeshComponent: $Nullable<UE.StaticMeshComponent>, FillColor: UE.LinearColor, bConvertToSRGB?: boolean /* = true */) : void;
        static RemovePaintedVertices(StaticMeshComponent: $Nullable<UE.StaticMeshComponent>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshVertexPainterKismetLibrary;
        static Load(InName: string): MeshVertexPainterKismetLibrary;
    }
    
    class MetaData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MetaData;
        static Load(InName: string): MetaData;
    }
    
    class PurchaseInfo {
        constructor();
        constructor(Identifier: string, DisplayName: string, DisplayDescription: string, DisplayPrice: string);
        Identifier: string;
        DisplayName: string;
        DisplayDescription: string;
        DisplayPrice: string;
        static StaticClass(): Class;
    }
    
    class MicroTransactionBase extends UE.PlatformInterfaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AvailableProducts: TArray<UE.PurchaseInfo>;
        LastError: string;
        LastErrorSolution: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MicroTransactionBase;
        static Load(InName: string): MicroTransactionBase;
    }
    
    class MobileInstalledContent extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetDiskFreeSpace() : number;
        GetInstalledContentSize() : number;
        Mount(PakOrder: number, MountPoint: string) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MobileInstalledContent;
        static Load(InName: string): MobileInstalledContent;
    }
    
    class MobilePendingContent extends UE.MobileInstalledContent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetDownloadSize() : number;
        GetDownloadSpeed() : number;
        GetDownloadStatusText() : string;
        GetInstallProgress() : number;
        GetRequiredDiskSpace() : number;
        GetTotalDownloadedSize() : number;
        StartInstall(OnSucceeded: $Delegate<() => void>, OnFailed: $Delegate<(ErrorText: string, ErrorCode: number) => void>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MobilePendingContent;
        static Load(InName: string): MobilePendingContent;
    }
    
    class MobilePatchingLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetActiveDeviceProfileName() : string;
        static GetInstalledContent(InstallDirectory: string) : UE.MobileInstalledContent;
        static GetSupportedPlatformNames() : TArray<string>;
        static HasActiveWiFiConnection() : boolean;
        static RequestContent(RemoteManifestURL: string, CloudURL: string, InstallDirectory: string, OnSucceeded: $Delegate<(MobilePendingContent: $Nullable<UE.MobilePendingContent>) => void>, OnFailed: $Delegate<(ErrorText: string, ErrorCode: number) => void>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MobilePatchingLibrary;
        static Load(InName: string): MobilePatchingLibrary;
    }
    
    class MockAI extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BBComp: UE.BlackboardComponent;
        BrainComp: UE.BrainComponent;
        PerceptionComp: UE.AIPerceptionComponent;
        PawnActionComp: UE.PawnActionsComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MockAI;
        static Load(InName: string): MockAI;
    }
    
    class MockAI_BT extends UE.MockAI {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BTComp: UE.BehaviorTreeComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MockAI_BT;
        static Load(InName: string): MockAI_BT;
    }
    
    enum EMeshTrackerVertexColorMode { None, Confidence, Block, EMeshTrackerVertexColorMode_MAX}
    class MockDataMeshTrackerComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnMeshTrackerUpdated: $MulticastDelegate<(Index: number, Vertices: TArray<UE.Vector>, Triangles: TArray<number>, Normals: TArray<UE.Vector>, Confidence: TArray<number>) => void>;
        ScanWorld: boolean;
        RequestNormals: boolean;
        RequestVertexConfidence: boolean;
        VertexColorMode: UE.EMeshTrackerVertexColorMode;
        BlockVertexColors: TArray<UE.Color>;
        VertexColorFromConfidenceZero: UE.LinearColor;
        VertexColorFromConfidenceOne: UE.LinearColor;
        UpdateInterval: number;
        MRMesh: UE.MRMeshComponent;
        ConnectMRMesh(InMRMeshPtr: $Nullable<UE.MRMeshComponent>) : void;
        DisconnectMRMesh(InMRMeshPtr: $Nullable<UE.MRMeshComponent>) : void;
        OnMockDataMeshTrackerUpdated__DelegateSignature(Index: number, Vertices: TArray<UE.Vector>, Triangles: TArray<number>, Normals: TArray<UE.Vector>, Confidence: TArray<number>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MockDataMeshTrackerComponent;
        static Load(InName: string): MockDataMeshTrackerComponent;
    }
    
    class MockGameplayTaskOwner extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GTComponent: UE.GameplayTasksComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MockGameplayTaskOwner;
        static Load(InName: string): MockGameplayTaskOwner;
    }
    
    class MockGameplayTasksComponent extends UE.GameplayTasksComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MockGameplayTasksComponent;
        static Load(InName: string): MockGameplayTasksComponent;
    }
    
    class MockTask_Log extends UE.GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MockTask_Log;
        static Load(InName: string): MockTask_Log;
    }
    
    class ModelExporterT3D extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ModelExporterT3D;
        static Load(InName: string): ModelExporterT3D;
    }
    
    class ModelFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ModelFactory;
        static Load(InName: string): ModelFactory;
    }
    
    enum ETrackingStatus { NotTracked, InertialOnly, Tracked, ETrackingStatus_MAX}
    class MotionControllerComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlayerIndex: number;
        Hand: UE.EControllerHand;
        MotionSource: string;
        bDisableLowLatencyUpdate: boolean;
        CurrentTrackingStatus: UE.ETrackingStatus;
        bDisplayDeviceModel: boolean;
        DisplayModelSource: string;
        CustomDisplayMesh: UE.StaticMesh;
        DisplayMeshMaterialOverrides: TArray<UE.MaterialInterface>;
        DisplayComponent: UE.PrimitiveComponent;
        GetHandJointPosition(jointIndex: number, bValueFound: $Ref<boolean>) : UE.Vector;
        GetParameterValue(InName: string, bValueFound: $Ref<boolean>) : number;
        GetTrackingSource() : UE.EControllerHand;
        IsTracked() : boolean;
        OnMotionControllerUpdated() : void;
        SetAssociatedPlayerIndex(NewPlayer: number) : void;
        SetCustomDisplayMesh(NewDisplayMesh: $Nullable<UE.StaticMesh>) : void;
        SetDisplayModelSource(NewDisplayModelSource: string) : void;
        SetShowDeviceModel(bShowControllerModel: boolean) : void;
        SetTrackingMotionSource(NewSource: string) : void;
        SetTrackingSource(NewSource: UE.EControllerHand) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MotionControllerComponent;
        static Load(InName: string): MotionControllerComponent;
    }
    
    class MotionTrackedDeviceFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static DisableMotionTrackingForComponent(MotionControllerComponent: $Nullable<UE.MotionControllerComponent>) : void;
        static DisableMotionTrackingOfAllControllers() : void;
        static DisableMotionTrackingOfControllersForPlayer(PlayerIndex: number) : void;
        static DisableMotionTrackingOfDevice(PlayerIndex: number, Hand: UE.EControllerHand) : void;
        static DisableMotionTrackingOfSource(PlayerIndex: number, SourceName: string) : void;
        static EnableMotionTrackingForComponent(MotionControllerComponent: $Nullable<UE.MotionControllerComponent>) : boolean;
        static EnableMotionTrackingOfDevice(PlayerIndex: number, Hand: UE.EControllerHand) : boolean;
        static EnableMotionTrackingOfSource(PlayerIndex: number, SourceName: string) : boolean;
        static EnumerateMotionSources() : TArray<string>;
        static GetActiveTrackingSystemName() : string;
        static GetMaximumMotionTrackedControllerCount() : number;
        static GetMotionTrackingEnabledControllerCount() : number;
        static IsMotionSourceTracking(PlayerIndex: number, SourceName: string) : boolean;
        static IsMotionTrackedDeviceCountManagementNecessary() : boolean;
        static IsMotionTrackingEnabledForComponent(MotionControllerComponent: $Nullable<UE.MotionControllerComponent>) : boolean;
        static IsMotionTrackingEnabledForDevice(PlayerIndex: number, Hand: UE.EControllerHand) : boolean;
        static IsMotionTrackingEnabledForSource(PlayerIndex: number, SourceName: string) : boolean;
        static SetIsControllerMotionTrackingEnabledByDefault(Enable: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MotionTrackedDeviceFunctionLibrary;
        static Load(InName: string): MotionTrackedDeviceFunctionLibrary;
    }
    
    class MouseCursorBinding extends UE.PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetValue() : UE.EMouseCursor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MouseCursorBinding;
        static Load(InName: string): MouseCursorBinding;
    }
    
    class MouseHoverBehavior extends UE.InputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MouseHoverBehavior;
        static Load(InName: string): MouseHoverBehavior;
    }
    
    class MoviePlayerSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bWaitForMoviesToComplete: boolean;
        bMoviesAreSkippable: boolean;
        StartupMovies: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MoviePlayerSettings;
        static Load(InName: string): MoviePlayerSettings;
    }
    
    class MovieScene2DTransformMask {
        constructor();
        constructor(Mask: number);
        Mask: number;
        static StaticClass(): Class;
    }
    
    class MovieSceneChannel {
        constructor();
        static StaticClass(): Class;
    }
    
    class KeyHandleLookupTable {
        constructor();
        static StaticClass(): Class;
    }
    
    class MovieSceneKeyHandleMap extends UE.KeyHandleLookupTable {
        constructor();
        static StaticClass(): Class;
    }
    
    class MovieSceneFloatChannel extends UE.MovieSceneChannel {
        constructor();
        constructor(PreInfinityExtrap: UE.ERichCurveExtrapolation, PostInfinityExtrap: UE.ERichCurveExtrapolation, Times: TArray<UE.FrameNumber>, Values: TArray<UE.MovieSceneFloatValue>, DefaultValue: number, bHasDefaultValue: boolean, KeyHandles: UE.MovieSceneKeyHandleMap, TickResolution: UE.FrameRate);
        PreInfinityExtrap: UE.ERichCurveExtrapolation;
        PostInfinityExtrap: UE.ERichCurveExtrapolation;
        Times: TArray<UE.FrameNumber>;
        Values: TArray<UE.MovieSceneFloatValue>;
        DefaultValue: number;
        bHasDefaultValue: boolean;
        KeyHandles: UE.MovieSceneKeyHandleMap;
        TickResolution: UE.FrameRate;
        static StaticClass(): Class;
    }
    
    class MovieScene2DTransformSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TransformMask: UE.MovieScene2DTransformMask;
        Translation: FixSizeArray<UE.MovieSceneFloatChannel>;
        Rotation: UE.MovieSceneFloatChannel;
        Scale: FixSizeArray<UE.MovieSceneFloatChannel>;
        Shear: FixSizeArray<UE.MovieSceneFloatChannel>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene2DTransformSection;
        static Load(InName: string): MovieScene2DTransformSection;
    }
    
    class MovieSceneNameableTrack extends UE.MovieSceneTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DisplayName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneNameableTrack;
        static Load(InName: string): MovieSceneNameableTrack;
    }
    
    class MovieScenePropertyTrack extends UE.MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UniqueTrackName: string;
        SectionToKey: UE.MovieSceneSection;
        PropertyName: string;
        PropertyPath: string;
        Sections: TArray<UE.MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScenePropertyTrack;
        static Load(InName: string): MovieScenePropertyTrack;
    }
    
    class MovieScene2DTransformTrack extends UE.MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene2DTransformTrack;
        static Load(InName: string): MovieScene2DTransformTrack;
    }
    
    class MovieScene3DConstraintSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstraintId: UE.Guid;
        ConstraintBindingID: UE.MovieSceneObjectBindingID;
        GetConstraintBindingID() : UE.MovieSceneObjectBindingID;
        SetConstraintBindingID(InConstraintBindingID: UE.MovieSceneObjectBindingID) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DConstraintSection;
        static Load(InName: string): MovieScene3DConstraintSection;
    }
    
    class MovieScene3DAttachSection extends UE.MovieScene3DConstraintSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AttachSocketName: string;
        AttachComponentName: string;
        bFullRevertOnDetach: boolean;
        ReAttachOnDetach: TSoftObjectPtr<UE.Actor>;
        AttachmentLocationRule: UE.EAttachmentRule;
        AttachmentRotationRule: UE.EAttachmentRule;
        AttachmentScaleRule: UE.EAttachmentRule;
        DetachmentLocationRule: UE.EDetachmentRule;
        DetachmentRotationRule: UE.EDetachmentRule;
        DetachmentScaleRule: UE.EDetachmentRule;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DAttachSection;
        static Load(InName: string): MovieScene3DAttachSection;
    }
    
    class MovieScene3DConstraintTrack extends UE.MovieSceneTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstraintSections: TArray<UE.MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DConstraintTrack;
        static Load(InName: string): MovieScene3DConstraintTrack;
    }
    
    class MovieScene3DAttachTrack extends UE.MovieScene3DConstraintTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DAttachTrack;
        static Load(InName: string): MovieScene3DAttachTrack;
    }
    
    enum MovieScene3DPathSection_Axis { X, Y, Z, NEG_X, NEG_Y, NEG_Z, MovieScene3DPathSection_MAX}
    class MovieScene3DPathSection extends UE.MovieScene3DConstraintSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TimingCurve: UE.MovieSceneFloatChannel;
        FrontAxisEnum: UE.MovieScene3DPathSection_Axis;
        UpAxisEnum: UE.MovieScene3DPathSection_Axis;
        bFollow: boolean;
        bReverse: boolean;
        bForceUpright: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DPathSection;
        static Load(InName: string): MovieScene3DPathSection;
    }
    
    class MovieScene3DPathTrack extends UE.MovieScene3DConstraintTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DPathTrack;
        static Load(InName: string): MovieScene3DPathTrack;
    }
    
    class MovieSceneTransformMask {
        constructor();
        constructor(Mask: number);
        Mask: number;
        static StaticClass(): Class;
    }
    
    enum EShow3DTrajectory { EST_OnlyWhenSelected, EST_Always, EST_Never, EST_MAX}
    class MovieScene3DTransformSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TransformMask: UE.MovieSceneTransformMask;
        Translation: FixSizeArray<UE.MovieSceneFloatChannel>;
        Rotation: FixSizeArray<UE.MovieSceneFloatChannel>;
        Scale: FixSizeArray<UE.MovieSceneFloatChannel>;
        ManualWeight: UE.MovieSceneFloatChannel;
        bUseQuaternionInterpolation: boolean;
        Show3DTrajectory: UE.EShow3DTrajectory;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DTransformSection;
        static Load(InName: string): MovieScene3DTransformSection;
    }
    
    class MovieScene3DTransformSectionRecorderSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bRecordTransforms: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DTransformSectionRecorderSettings;
        static Load(InName: string): MovieScene3DTransformSectionRecorderSettings;
    }
    
    class MovieScene3DTransformTrack extends UE.MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DTransformTrack;
        static Load(InName: string): MovieScene3DTransformTrack;
    }
    
    class MovieSceneActorReferenceKey {
        constructor();
        constructor(Object: UE.MovieSceneObjectBindingID);
        Object: UE.MovieSceneObjectBindingID;
        static StaticClass(): Class;
    }
    
    class MovieSceneActorReferenceData extends UE.MovieSceneChannel {
        constructor();
        constructor(KeyTimes: TArray<UE.FrameNumber>, KeyValues: TArray<UE.MovieSceneActorReferenceKey>);
        KeyTimes: TArray<UE.FrameNumber>;
        KeyValues: TArray<UE.MovieSceneActorReferenceKey>;
        static StaticClass(): Class;
    }
    
    class IntegralKey {
        constructor();
        constructor(Time: number, Value: number);
        Time: number;
        Value: number;
        static StaticClass(): Class;
    }
    
    class IntegralCurve extends UE.IndexedCurve {
        constructor();
        constructor(Keys: TArray<UE.IntegralKey>, DefaultValue: number, bUseDefaultValueBeforeFirstKey: boolean);
        Keys: TArray<UE.IntegralKey>;
        DefaultValue: number;
        bUseDefaultValueBeforeFirstKey: boolean;
        static StaticClass(): Class;
    }
    
    class MovieSceneActorReferenceSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActorReferenceData: UE.MovieSceneActorReferenceData;
        ActorGuidIndexCurve: UE.IntegralCurve;
        ActorGuidStrings: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneActorReferenceSection;
        static Load(InName: string): MovieSceneActorReferenceSection;
    }
    
    class MovieSceneActorReferenceTrack extends UE.MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneActorReferenceTrack;
        static Load(InName: string): MovieSceneActorReferenceTrack;
    }
    
    class MovieSceneAudioSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sound: UE.SoundBase;
        StartFrameOffset: UE.FrameNumber;
        StartOffset: number;
        AudioStartTime: number;
        AudioDilationFactor: number;
        AudioVolume: number;
        SoundVolume: UE.MovieSceneFloatChannel;
        PitchMultiplier: UE.MovieSceneFloatChannel;
        bSuppressSubtitles: boolean;
        bOverrideAttenuation: boolean;
        AttenuationSettings: UE.SoundAttenuation;
        OnQueueSubtitles: $Delegate<(Subtitles: TArray<UE.SubtitleCue>, CueDuration: number) => void>;
        OnAudioFinished: $MulticastDelegate<() => void>;
        OnAudioPlaybackPercent: $MulticastDelegate<(PlayingSoundWave: $Nullable<UE.SoundWave>, PlaybackPercent: number) => void>;
        GetSound() : UE.SoundBase;
        GetStartOffset() : UE.FrameNumber;
        SetSound(InSound: $Nullable<UE.SoundBase>) : void;
        SetStartOffset(InStartOffset: UE.FrameNumber) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneAudioSection;
        static Load(InName: string): MovieSceneAudioSection;
    }
    
    class MovieSceneAudioTrack extends UE.MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AudioSections: TArray<UE.MovieSceneSection>;
        RowHeight: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneAudioTrack;
        static Load(InName: string): MovieSceneAudioTrack;
    }
    
    class MovieSceneBindingOwnerInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneBindingOwnerInterface;
        static Load(InName: string): MovieSceneBindingOwnerInterface;
    }
    
    class MovieSceneBoolChannel extends UE.MovieSceneChannel {
        constructor();
        constructor(Times: TArray<UE.FrameNumber>, DefaultValue: boolean, bHasDefaultValue: boolean, Values: TArray<boolean>);
        Times: TArray<UE.FrameNumber>;
        DefaultValue: boolean;
        bHasDefaultValue: boolean;
        Values: TArray<boolean>;
        static StaticClass(): Class;
    }
    
    class MovieSceneBoolSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultValue: boolean;
        BoolCurve: UE.MovieSceneBoolChannel;
        bIsExternallyInverted: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneBoolSection;
        static Load(InName: string): MovieSceneBoolSection;
    }
    
    class MovieSceneBoolTrack extends UE.MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneBoolTrack;
        static Load(InName: string): MovieSceneBoolTrack;
    }
    
    enum EMovieSceneBuiltInEasing { Linear, SinIn, SinOut, SinInOut, QuadIn, QuadOut, QuadInOut, CubicIn, CubicOut, CubicInOut, QuartIn, QuartOut, QuartInOut, QuintIn, QuintOut, QuintInOut, ExpoIn, ExpoOut, ExpoInOut, CircIn, CircOut, CircInOut, EMovieSceneBuiltInEasing_MAX}
    class MovieSceneBuiltInEasingFunction extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Type: UE.EMovieSceneBuiltInEasing;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneBuiltInEasingFunction;
        static Load(InName: string): MovieSceneBuiltInEasingFunction;
    }
    
    class MovieSceneByteChannel extends UE.MovieSceneChannel {
        constructor();
        constructor(Times: TArray<UE.FrameNumber>, DefaultValue: number, bHasDefaultValue: boolean, Values: TArray<number>, Enum: UE.Enum);
        Times: TArray<UE.FrameNumber>;
        DefaultValue: number;
        bHasDefaultValue: boolean;
        Values: TArray<number>;
        Enum: UE.Enum;
        static StaticClass(): Class;
    }
    
    class MovieSceneByteSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ByteCurve: UE.MovieSceneByteChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneByteSection;
        static Load(InName: string): MovieSceneByteSection;
    }
    
    class MovieSceneByteTrack extends UE.MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Enum: UE.Enum;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneByteTrack;
        static Load(InName: string): MovieSceneByteTrack;
    }
    
    class MovieSceneCameraAnimSectionData {
        constructor();
        constructor(CameraAnim: UE.CameraAnim, PlayRate: number, PlayScale: number, BlendInTime: number, BlendOutTime: number, bLooping: boolean);
        CameraAnim: UE.CameraAnim;
        PlayRate: number;
        PlayScale: number;
        BlendInTime: number;
        BlendOutTime: number;
        bLooping: boolean;
        static StaticClass(): Class;
    }
    
    class MovieSceneCameraAnimSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimData: UE.MovieSceneCameraAnimSectionData;
        CameraAnim: UE.CameraAnim;
        PlayRate: number;
        PlayScale: number;
        BlendInTime: number;
        BlendOutTime: number;
        bLooping: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraAnimSection;
        static Load(InName: string): MovieSceneCameraAnimSection;
    }
    
    class MovieSceneCameraAnimTrack extends UE.MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CameraAnimSections: TArray<UE.MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraAnimTrack;
        static Load(InName: string): MovieSceneCameraAnimTrack;
    }
    
    class MovieSceneCameraCutSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CameraGuid: UE.Guid;
        CameraBindingID: UE.MovieSceneObjectBindingID;
        ThumbnailReferenceOffset: number;
        GetCameraBindingID() : UE.MovieSceneObjectBindingID;
        SetCameraBindingID(InCameraBindingID: UE.MovieSceneObjectBindingID) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraCutSection;
        static Load(InName: string): MovieSceneCameraCutSection;
    }
    
    class MovieSceneCameraCutTrack extends UE.MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sections: TArray<UE.MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraCutTrack;
        static Load(InName: string): MovieSceneCameraCutTrack;
    }
    
    class MovieSceneCameraShakeSectionData {
        constructor();
        constructor(ShakeClass: UE.Class, PlayScale: number, PlaySpace: UE.ECameraAnimPlaySpace, UserDefinedPlaySpace: UE.Rotator);
        ShakeClass: UE.Class;
        PlayScale: number;
        PlaySpace: UE.ECameraAnimPlaySpace;
        UserDefinedPlaySpace: UE.Rotator;
        static StaticClass(): Class;
    }
    
    class MovieSceneCameraShakeSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShakeData: UE.MovieSceneCameraShakeSectionData;
        ShakeClass: UE.Class;
        PlayScale: number;
        PlaySpace: UE.ECameraAnimPlaySpace;
        UserDefinedPlaySpace: UE.Rotator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraShakeSection;
        static Load(InName: string): MovieSceneCameraShakeSection;
    }
    
    class MovieSceneCameraShakeTrack extends UE.MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CameraShakeSections: TArray<UE.MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraShakeTrack;
        static Load(InName: string): MovieSceneCameraShakeTrack;
    }
    
    class MovieSceneCaptureEnvironment extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static FindAudioCaptureProtocol() : UE.MovieSceneAudioCaptureProtocolBase;
        static FindImageCaptureProtocol() : UE.MovieSceneImageCaptureProtocolBase;
        static GetCaptureElapsedTime() : number;
        static GetCaptureFrameNumber() : number;
        static IsCaptureInProgress() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCaptureEnvironment;
        static Load(InName: string): MovieSceneCaptureEnvironment;
    }
    
    class MovieSceneCaptureInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCaptureInterface;
        static Load(InName: string): MovieSceneCaptureInterface;
    }
    
    class MovieSceneSectionParameters {
        constructor();
        constructor(StartFrameOffset: UE.FrameNumber, TimeScale: number, HierarchicalBias: number, StartOffset: number, PrerollTime: number, PostrollTime: number);
        StartFrameOffset: UE.FrameNumber;
        TimeScale: number;
        HierarchicalBias: number;
        StartOffset: number;
        PrerollTime: number;
        PostrollTime: number;
        static StaticClass(): Class;
    }
    
    class MovieSceneSubSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Parameters: UE.MovieSceneSectionParameters;
        StartOffset: number;
        TimeScale: number;
        PrerollTime: number;
        SubSequence: UE.MovieSceneSequence;
        ActorToRecord: TLazyObjectPtr<UE.Actor>;
        TargetSequenceName: string;
        TargetPathToRecordTo: UE.DirectoryPath;
        GetSequence() : UE.MovieSceneSequence;
        SetSequence(Sequence: $Nullable<UE.MovieSceneSequence>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSubSection;
        static Load(InName: string): MovieSceneSubSection;
    }
    
    class MovieSceneCinematicShotSection extends UE.MovieSceneSubSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShotDisplayName: string;
        DisplayName: string;
        ThumbnailReferenceOffset: number;
        GetShotDisplayName() : string;
        SetShotDisplayName(InShotDisplayName: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCinematicShotSection;
        static Load(InName: string): MovieSceneCinematicShotSection;
    }
    
    class MovieSceneSubTrack extends UE.MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sections: TArray<UE.MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSubTrack;
        static Load(InName: string): MovieSceneSubTrack;
    }
    
    class MovieSceneCinematicShotTrack extends UE.MovieSceneSubTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCinematicShotTrack;
        static Load(InName: string): MovieSceneCinematicShotTrack;
    }
    
    class MovieSceneColorSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RedCurve: UE.MovieSceneFloatChannel;
        GreenCurve: UE.MovieSceneFloatChannel;
        BlueCurve: UE.MovieSceneFloatChannel;
        AlphaCurve: UE.MovieSceneFloatChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneColorSection;
        static Load(InName: string): MovieSceneColorSection;
    }
    
    class MovieSceneColorTrack extends UE.MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsSlateColor: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneColorTrack;
        static Load(InName: string): MovieSceneColorTrack;
    }
    
    class MovieSceneMaterialTrack extends UE.MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sections: TArray<UE.MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneMaterialTrack;
        static Load(InName: string): MovieSceneMaterialTrack;
    }
    
    class MovieSceneComponentMaterialTrack extends UE.MovieSceneMaterialTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneComponentMaterialTrack;
        static Load(InName: string): MovieSceneComponentMaterialTrack;
    }
    
    class MovieSceneCopyableBinding extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpawnableObjectTemplate: UE.Object;
        Tracks: TArray<UE.MovieSceneTrack>;
        Binding: UE.MovieSceneBinding;
        Spawnable: UE.MovieSceneSpawnable;
        Possessable: UE.MovieScenePossessable;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCopyableBinding;
        static Load(InName: string): MovieSceneCopyableBinding;
    }
    
    class MovieSceneCopyableTrack extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Track: UE.MovieSceneTrack;
        bIsAMasterTrack: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCopyableTrack;
        static Load(InName: string): MovieSceneCopyableTrack;
    }
    
    class MovieSceneEasingExternalCurve extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Curve: UE.CurveFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEasingExternalCurve;
        static Load(InName: string): MovieSceneEasingExternalCurve;
    }
    
    class MovieSceneEnumSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EnumCurve: UE.MovieSceneByteChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEnumSection;
        static Load(InName: string): MovieSceneEnumSection;
    }
    
    class MovieSceneEnumTrack extends UE.MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Enum: UE.Enum;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEnumTrack;
        static Load(InName: string): MovieSceneEnumTrack;
    }
    
    class MovieSceneEulerTransformTrack extends UE.MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEulerTransformTrack;
        static Load(InName: string): MovieSceneEulerTransformTrack;
    }
    
    class MovieSceneEventSectionBase extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DirectorBlueprint: TWeakObjectPtr<UE.Blueprint>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEventSectionBase;
        static Load(InName: string): MovieSceneEventSectionBase;
    }
    
    class MovieSceneEventBlueprintExtension extends UE.BlueprintExtension {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EventSections: TArray<UE.MovieSceneEventSectionBase>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEventBlueprintExtension;
        static Load(InName: string): MovieSceneEventBlueprintExtension;
    }
    
    class MovieSceneEventPtrs {
        constructor();
        constructor(Function: UE.Function, BoundObjectProperty: UE.Property);
        Function: UE.Function;
        BoundObjectProperty: UE.Property;
        static StaticClass(): Class;
    }
    
    class MovieSceneEventPayloadVariable {
        constructor();
        constructor(Value: string);
        Value: string;
        static StaticClass(): Class;
    }
    
    class MovieSceneEvent {
        constructor();
        constructor(Ptrs: UE.MovieSceneEventPtrs, PayloadVariables: TMap<string, UE.MovieSceneEventPayloadVariable>, CompiledFunctionName: string, BoundObjectPinName: string, GraphGuid: UE.Guid, NodeGuid: UE.Guid, WeakCachedEndpoint: TWeakObjectPtr<UE.Object>, FunctionEntry: TWeakObjectPtr<UE.Object>);
        Ptrs: UE.MovieSceneEventPtrs;
        PayloadVariables: TMap<string, UE.MovieSceneEventPayloadVariable>;
        CompiledFunctionName: string;
        BoundObjectPinName: string;
        GraphGuid: UE.Guid;
        NodeGuid: UE.Guid;
        WeakCachedEndpoint: TWeakObjectPtr<UE.Object>;
        FunctionEntry: TWeakObjectPtr<UE.Object>;
        static StaticClass(): Class;
    }
    
    class MovieSceneEventRepeaterSection extends UE.MovieSceneEventSectionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Event: UE.MovieSceneEvent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEventRepeaterSection;
        static Load(InName: string): MovieSceneEventRepeaterSection;
    }
    
    class NameCurveKey {
        constructor();
        constructor(Time: number, Value: string);
        Time: number;
        Value: string;
        static StaticClass(): Class;
    }
    
    class NameCurve extends UE.IndexedCurve {
        constructor();
        constructor(Keys: TArray<UE.NameCurveKey>);
        Keys: TArray<UE.NameCurveKey>;
        static StaticClass(): Class;
    }
    
    class MovieSceneEventParameters {
        constructor();
        static StaticClass(): Class;
    }
    
    class EventPayload {
        constructor();
        constructor(EventName: string, Parameters: UE.MovieSceneEventParameters);
        EventName: string;
        Parameters: UE.MovieSceneEventParameters;
        static StaticClass(): Class;
    }
    
    class MovieSceneEventSectionData extends UE.MovieSceneChannel {
        constructor();
        constructor(Times: TArray<UE.FrameNumber>, KeyValues: TArray<UE.EventPayload>, KeyTimes: TArray<number>);
        Times: TArray<UE.FrameNumber>;
        KeyValues: TArray<UE.EventPayload>;
        KeyTimes: TArray<number>;
        static StaticClass(): Class;
    }
    
    class MovieSceneEventSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Events: UE.NameCurve;
        EventData: UE.MovieSceneEventSectionData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEventSection;
        static Load(InName: string): MovieSceneEventSection;
    }
    
    enum EFireEventsAtPosition { AtStartOfEvaluation, AtEndOfEvaluation, AfterSpawn, EFireEventsAtPosition_MAX}
    class MovieSceneEventTrack extends UE.MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bFireEventsWhenForwards: boolean;
        bFireEventsWhenBackwards: boolean;
        EventPosition: UE.EFireEventsAtPosition;
        EventReceivers: TArray<UE.MovieSceneObjectBindingID>;
        Sections: TArray<UE.MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEventTrack;
        static Load(InName: string): MovieSceneEventTrack;
    }
    
    class MovieSceneEventChannel extends UE.MovieSceneChannel {
        constructor();
        constructor(KeyTimes: TArray<UE.FrameNumber>, KeyValues: TArray<UE.MovieSceneEvent>);
        KeyTimes: TArray<UE.FrameNumber>;
        KeyValues: TArray<UE.MovieSceneEvent>;
        static StaticClass(): Class;
    }
    
    class MovieSceneEventTriggerSection extends UE.MovieSceneEventSectionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EventChannel: UE.MovieSceneEventChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEventTriggerSection;
        static Load(InName: string): MovieSceneEventTriggerSection;
    }
    
    class MovieSceneFloatSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FloatCurve: UE.MovieSceneFloatChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneFloatSection;
        static Load(InName: string): MovieSceneFloatSection;
    }
    
    class MovieSceneFadeSection extends UE.MovieSceneFloatSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FadeColor: UE.LinearColor;
        bFadeAudio: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneFadeSection;
        static Load(InName: string): MovieSceneFadeSection;
    }
    
    class MovieSceneFloatTrack extends UE.MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneFloatTrack;
        static Load(InName: string): MovieSceneFloatTrack;
    }
    
    class MovieSceneFadeTrack extends UE.MovieSceneFloatTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneFadeTrack;
        static Load(InName: string): MovieSceneFadeTrack;
    }
    
    class MovieSceneGeometryCacheParams {
        constructor();
        constructor(GeometryCacheAsset: UE.GeometryCache, FirstLoopStartFrameOffset: UE.FrameNumber, StartFrameOffset: UE.FrameNumber, EndFrameOffset: UE.FrameNumber, PlayRate: number, bReverse: boolean, StartOffset: number, EndOffset: number, GeometryCache: UE.SoftObjectPath);
        GeometryCacheAsset: UE.GeometryCache;
        FirstLoopStartFrameOffset: UE.FrameNumber;
        StartFrameOffset: UE.FrameNumber;
        EndFrameOffset: UE.FrameNumber;
        PlayRate: number;
        bReverse: boolean;
        StartOffset: number;
        EndOffset: number;
        GeometryCache: UE.SoftObjectPath;
        static StaticClass(): Class;
    }
    
    class MovieSceneGeometryCacheSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Params: UE.MovieSceneGeometryCacheParams;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneGeometryCacheSection;
        static Load(InName: string): MovieSceneGeometryCacheSection;
    }
    
    class MovieSceneGeometryCacheTrack extends UE.MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimationSections: TArray<UE.MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneGeometryCacheTrack;
        static Load(InName: string): MovieSceneGeometryCacheTrack;
    }
    
    class MovieSceneIntegerChannel extends UE.MovieSceneChannel {
        constructor();
        constructor(Times: TArray<UE.FrameNumber>, DefaultValue: number, bHasDefaultValue: boolean, Values: TArray<number>);
        Times: TArray<UE.FrameNumber>;
        DefaultValue: number;
        bHasDefaultValue: boolean;
        Values: TArray<number>;
        static StaticClass(): Class;
    }
    
    class MovieSceneIntegerSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IntegerCurve: UE.MovieSceneIntegerChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneIntegerSection;
        static Load(InName: string): MovieSceneIntegerSection;
    }
    
    class MovieSceneIntegerTrack extends UE.MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneIntegerTrack;
        static Load(InName: string): MovieSceneIntegerTrack;
    }
    
    class MovieSceneKeyProxy extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneKeyProxy;
        static Load(InName: string): MovieSceneKeyProxy;
    }
    
    class MovieSceneKeyStructType extends UE.ScriptStruct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceTimesProperty: UE.ArrayProperty;
        SourceValuesProperty: UE.ArrayProperty;
        DestTimeProperty: UE.StructProperty;
        DestValueProperty: UE.Property;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneKeyStructType;
        static Load(InName: string): MovieSceneKeyStructType;
    }
    
    enum ELevelVisibility { Visible, Hidden, ELevelVisibility_MAX}
    class MovieSceneLevelVisibilitySection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Visibility: UE.ELevelVisibility;
        LevelNames: TArray<string>;
        GetLevelNames() : TArray<string>;
        GetVisibility() : UE.ELevelVisibility;
        SetLevelNames(InLevelNames: TArray<string>) : void;
        SetVisibility(InVisibility: UE.ELevelVisibility) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneLevelVisibilitySection;
        static Load(InName: string): MovieSceneLevelVisibilitySection;
    }
    
    class MovieSceneLevelVisibilityTrack extends UE.MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sections: TArray<UE.MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneLevelVisibilityTrack;
        static Load(InName: string): MovieSceneLevelVisibilityTrack;
    }
    
    class MovieSceneMarginSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TopCurve: UE.MovieSceneFloatChannel;
        LeftCurve: UE.MovieSceneFloatChannel;
        RightCurve: UE.MovieSceneFloatChannel;
        BottomCurve: UE.MovieSceneFloatChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneMarginSection;
        static Load(InName: string): MovieSceneMarginSection;
    }
    
    class MovieSceneMarginTrack extends UE.MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneMarginTrack;
        static Load(InName: string): MovieSceneMarginTrack;
    }
    
    class MovieSceneMaterialParameterCollectionTrack extends UE.MovieSceneMaterialTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MPC: UE.MaterialParameterCollection;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneMaterialParameterCollectionTrack;
        static Load(InName: string): MovieSceneMaterialParameterCollectionTrack;
    }
    
    class MovieSceneMediaSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MediaSource: UE.MediaSource;
        bLooping: boolean;
        StartFrameOffset: UE.FrameNumber;
        MediaTexture: UE.MediaTexture;
        MediaSoundComponent: UE.MediaSoundComponent;
        bUseExternalMediaPlayer: boolean;
        ExternalMediaPlayer: UE.MediaPlayer;
        ThumbnailReferenceOffset: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneMediaSection;
        static Load(InName: string): MovieSceneMediaSection;
    }
    
    class MovieSceneMediaTrack extends UE.MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MediaSections: TArray<UE.MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneMediaTrack;
        static Load(InName: string): MovieSceneMediaTrack;
    }
    
    class MovieSceneObjectPathChannelKeyValue {
        constructor();
        constructor(SoftPtr: TSoftObjectPtr<UE.Object>, HardPtr: UE.Object);
        SoftPtr: TSoftObjectPtr<UE.Object>;
        HardPtr: UE.Object;
        static StaticClass(): Class;
    }
    
    class MovieSceneObjectPathChannel extends UE.MovieSceneChannel {
        constructor();
        constructor(PropertyClass: UE.Class, Times: TArray<UE.FrameNumber>, Values: TArray<UE.MovieSceneObjectPathChannelKeyValue>, DefaultValue: UE.MovieSceneObjectPathChannelKeyValue);
        PropertyClass: UE.Class;
        Times: TArray<UE.FrameNumber>;
        Values: TArray<UE.MovieSceneObjectPathChannelKeyValue>;
        DefaultValue: UE.MovieSceneObjectPathChannelKeyValue;
        static StaticClass(): Class;
    }
    
    class MovieSceneObjectPropertySection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ObjectChannel: UE.MovieSceneObjectPathChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneObjectPropertySection;
        static Load(InName: string): MovieSceneObjectPropertySection;
    }
    
    class MovieSceneObjectPropertyTrack extends UE.MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PropertyClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneObjectPropertyTrack;
        static Load(InName: string): MovieSceneObjectPropertyTrack;
    }
    
    class ScalarParameterNameAndCurve {
        constructor();
        constructor(ParameterName: string, ParameterCurve: UE.MovieSceneFloatChannel);
        ParameterName: string;
        ParameterCurve: UE.MovieSceneFloatChannel;
        static StaticClass(): Class;
    }
    
    class VectorParameterNameAndCurves {
        constructor();
        constructor(ParameterName: string, XCurve: UE.MovieSceneFloatChannel, YCurve: UE.MovieSceneFloatChannel, ZCurve: UE.MovieSceneFloatChannel);
        ParameterName: string;
        XCurve: UE.MovieSceneFloatChannel;
        YCurve: UE.MovieSceneFloatChannel;
        ZCurve: UE.MovieSceneFloatChannel;
        static StaticClass(): Class;
    }
    
    class ColorParameterNameAndCurves {
        constructor();
        constructor(ParameterName: string, RedCurve: UE.MovieSceneFloatChannel, GreenCurve: UE.MovieSceneFloatChannel, BlueCurve: UE.MovieSceneFloatChannel, AlphaCurve: UE.MovieSceneFloatChannel);
        ParameterName: string;
        RedCurve: UE.MovieSceneFloatChannel;
        GreenCurve: UE.MovieSceneFloatChannel;
        BlueCurve: UE.MovieSceneFloatChannel;
        AlphaCurve: UE.MovieSceneFloatChannel;
        static StaticClass(): Class;
    }
    
    class TransformParameterNameAndCurves {
        constructor();
        constructor(ParameterName: string, Translation: FixSizeArray<UE.MovieSceneFloatChannel>, Rotation: FixSizeArray<UE.MovieSceneFloatChannel>, Scale: FixSizeArray<UE.MovieSceneFloatChannel>);
        ParameterName: string;
        Translation: FixSizeArray<UE.MovieSceneFloatChannel>;
        Rotation: FixSizeArray<UE.MovieSceneFloatChannel>;
        Scale: FixSizeArray<UE.MovieSceneFloatChannel>;
        static StaticClass(): Class;
    }
    
    class MovieSceneParameterSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ScalarParameterNamesAndCurves: TArray<UE.ScalarParameterNameAndCurve>;
        VectorParameterNamesAndCurves: TArray<UE.VectorParameterNameAndCurves>;
        ColorParameterNamesAndCurves: TArray<UE.ColorParameterNameAndCurves>;
        TransformParameterNamesAndCurves: TArray<UE.TransformParameterNameAndCurves>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneParameterSection;
        static Load(InName: string): MovieSceneParameterSection;
    }
    
    class MovieSceneParticleParameterTrack extends UE.MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sections: TArray<UE.MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneParticleParameterTrack;
        static Load(InName: string): MovieSceneParticleParameterTrack;
    }
    
    class MovieSceneParticleChannel extends UE.MovieSceneByteChannel {
        constructor();
        static StaticClass(): Class;
    }
    
    class MovieSceneParticleSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParticleKeys: UE.MovieSceneParticleChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneParticleSection;
        static Load(InName: string): MovieSceneParticleSection;
    }
    
    class MovieSceneParticleTrack extends UE.MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParticleSections: TArray<UE.MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneParticleTrack;
        static Load(InName: string): MovieSceneParticleTrack;
    }
    
    class MovieSceneParticleTrackSectionRecorder extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnTriggered(Component: $Nullable<UE.ParticleSystemComponent>, bActivating: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneParticleTrackSectionRecorder;
        static Load(InName: string): MovieSceneParticleTrackSectionRecorder;
    }
    
    class MovieScenePrimitiveMaterialSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialChannel: UE.MovieSceneObjectPathChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScenePrimitiveMaterialSection;
        static Load(InName: string): MovieScenePrimitiveMaterialSection;
    }
    
    class MovieScenePrimitiveMaterialTrack extends UE.MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScenePrimitiveMaterialTrack;
        static Load(InName: string): MovieScenePrimitiveMaterialTrack;
    }
    
    class MovieSceneSkeletalAnimationParams {
        constructor();
        constructor(Animation: UE.AnimSequenceBase, FirstLoopStartFrameOffset: UE.FrameNumber, StartFrameOffset: UE.FrameNumber, EndFrameOffset: UE.FrameNumber, PlayRate: number, bReverse: boolean, SlotName: string, Weight: UE.MovieSceneFloatChannel, bSkipAnimNotifiers: boolean, bForceCustomMode: boolean, StartOffset: number, EndOffset: number);
        Animation: UE.AnimSequenceBase;
        FirstLoopStartFrameOffset: UE.FrameNumber;
        StartFrameOffset: UE.FrameNumber;
        EndFrameOffset: UE.FrameNumber;
        PlayRate: number;
        bReverse: boolean;
        SlotName: string;
        Weight: UE.MovieSceneFloatChannel;
        bSkipAnimNotifiers: boolean;
        bForceCustomMode: boolean;
        StartOffset: number;
        EndOffset: number;
        static StaticClass(): Class;
    }
    
    class MovieSceneSkeletalAnimationSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Params: UE.MovieSceneSkeletalAnimationParams;
        AnimSequence: UE.AnimSequence;
        Animation: UE.AnimSequenceBase;
        StartOffset: number;
        EndOffset: number;
        PlayRate: number;
        bReverse: boolean;
        SlotName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSkeletalAnimationSection;
        static Load(InName: string): MovieSceneSkeletalAnimationSection;
    }
    
    class MovieSceneSkeletalAnimationTrack extends UE.MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimationSections: TArray<UE.MovieSceneSection>;
        bUseLegacySectionIndexBlend: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSkeletalAnimationTrack;
        static Load(InName: string): MovieSceneSkeletalAnimationTrack;
    }
    
    class MovieSceneSlomoSection extends UE.MovieSceneFloatSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSlomoSection;
        static Load(InName: string): MovieSceneSlomoSection;
    }
    
    class MovieSceneSlomoTrack extends UE.MovieSceneFloatTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSlomoTrack;
        static Load(InName: string): MovieSceneSlomoTrack;
    }
    
    class MovieSceneSpawnSection extends UE.MovieSceneBoolSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSpawnSection;
        static Load(InName: string): MovieSceneSpawnSection;
    }
    
    class MovieSceneSpawnTrack extends UE.MovieSceneTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sections: TArray<UE.MovieSceneSection>;
        ObjectGuid: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSpawnTrack;
        static Load(InName: string): MovieSceneSpawnTrack;
    }
    
    class MovieSceneStringChannel extends UE.MovieSceneChannel {
        constructor();
        constructor(Times: TArray<UE.FrameNumber>, Values: TArray<string>, DefaultValue: string, bHasDefaultValue: boolean);
        Times: TArray<UE.FrameNumber>;
        Values: TArray<string>;
        DefaultValue: string;
        bHasDefaultValue: boolean;
        static StaticClass(): Class;
    }
    
    class MovieSceneStringSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StringCurve: UE.MovieSceneStringChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneStringSection;
        static Load(InName: string): MovieSceneStringSection;
    }
    
    class MovieSceneStringTrack extends UE.MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneStringTrack;
        static Load(InName: string): MovieSceneStringTrack;
    }
    
    class MovieSceneToolsPropertyTrackSettings {
        constructor();
        constructor(ComponentName: string, PropertyName: string);
        ComponentName: string;
        PropertyName: string;
        static StaticClass(): Class;
    }
    
    class MovieSceneToolsFbxSettings {
        constructor();
        constructor(FbxPropertyName: string, PropertyPath: UE.MovieSceneToolsPropertyTrackSettings);
        FbxPropertyName: string;
        PropertyPath: UE.MovieSceneToolsPropertyTrackSettings;
        static StaticClass(): Class;
    }
    
    class MovieSceneToolsProjectSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultStartTime: number;
        DefaultDuration: number;
        ShotDirectory: string;
        ShotPrefix: string;
        FirstShotNumber: number;
        ShotIncrement: number;
        ShotNumDigits: number;
        TakeNumDigits: number;
        FirstTakeNumber: number;
        TakeSeparator: string;
        SubSequenceSeparator: string;
        FbxSettings: TArray<UE.MovieSceneToolsFbxSettings>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneToolsProjectSettings;
        static Load(InName: string): MovieSceneToolsProjectSettings;
    }
    
    class MovieSceneTransformOrigin extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BP_GetTransformOrigin() : UE.Transform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneTransformOrigin;
        static Load(InName: string): MovieSceneTransformOrigin;
    }
    
    class MovieSceneTransformTrack extends UE.MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneTransformTrack;
        static Load(InName: string): MovieSceneTransformTrack;
    }
    
    class MovieSceneUserImportFBXSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bMatchByNameOnly: boolean;
        bForceFrontXAxis: boolean;
        bCreateCameras: boolean;
        bReduceKeys: boolean;
        ReduceKeysTolerance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneUserImportFBXSettings;
        static Load(InName: string): MovieSceneUserImportFBXSettings;
    }
    
    enum EThumbnailQuality { Draft, Normal, Best, EThumbnailQuality_MAX}
    class MovieSceneUserThumbnailSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDrawThumbnails: boolean;
        bDrawSingleThumbnails: boolean;
        ThumbnailSize: UE.IntPoint;
        Quality: UE.EThumbnailQuality;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneUserThumbnailSettings;
        static Load(InName: string): MovieSceneUserThumbnailSettings;
    }
    
    class MovieSceneVectorSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Curves: FixSizeArray<UE.MovieSceneFloatChannel>;
        ChannelsUsed: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneVectorSection;
        static Load(InName: string): MovieSceneVectorSection;
    }
    
    class MovieSceneVectorTrack extends UE.MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumChannelsUsed: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneVectorTrack;
        static Load(InName: string): MovieSceneVectorTrack;
    }
    
    class MovieSceneVisibilitySectionRecorderSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bRecordVisibility: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneVisibilitySectionRecorderSettings;
        static Load(InName: string): MovieSceneVisibilitySectionRecorderSettings;
    }
    
    class MovieSceneVisibilityTrack extends UE.MovieSceneBoolTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneVisibilityTrack;
        static Load(InName: string): MovieSceneVisibilityTrack;
    }
    
    class MovieSceneWidgetMaterialTrack extends UE.MovieSceneMaterialTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BrushPropertyNamePath: TArray<string>;
        TrackName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneWidgetMaterialTrack;
        static Load(InName: string): MovieSceneWidgetMaterialTrack;
    }
    
    class MulticastInlineDelegateProperty extends UE.MulticastDelegateProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MulticastInlineDelegateProperty;
        static Load(InName: string): MulticastInlineDelegateProperty;
    }
    
    class MulticastSparseDelegateProperty extends UE.MulticastDelegateProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MulticastSparseDelegateProperty;
        static Load(InName: string): MulticastSparseDelegateProperty;
    }
    
    class MultiClickSequenceInputBehavior extends UE.AnyButtonInputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MultiClickSequenceInputBehavior;
        static Load(InName: string): MultiClickSequenceInputBehavior;
    }
    
    enum ETextWrappingPolicy { DefaultWrapping, AllowPerCharacterWrapping, ETextWrappingPolicy_MAX}
    class TextLayoutWidget extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShapedTextOptions: UE.ShapedTextOptions;
        Justification: UE.ETextJustify;
        WrappingPolicy: UE.ETextWrappingPolicy;
        AutoWrapText: boolean;
        WrapTextAt: number;
        Margin: UE.Margin;
        LineHeightPercentage: number;
        SetJustification(InJustification: UE.ETextJustify) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextLayoutWidget;
        static Load(InName: string): TextLayoutWidget;
    }
    
    class MultiLineEditableText extends UE.TextLayoutWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Text: string;
        HintText: string;
        HintTextDelegate: $Delegate<() => string>;
        WidgetStyle: UE.TextBlockStyle;
        bIsReadOnly: boolean;
        Font: UE.SlateFontInfo;
        SelectAllTextWhenFocused: boolean;
        ClearTextSelectionOnFocusLoss: boolean;
        RevertTextOnEscape: boolean;
        ClearKeyboardFocusOnCommit: boolean;
        AllowContextMenu: boolean;
        VirtualKeyboardOptions: UE.VirtualKeyboardOptions;
        VirtualKeyboardDismissAction: UE.EVirtualKeyboardDismissAction;
        OnTextChanged: $MulticastDelegate<(Text: string) => void>;
        OnTextCommitted: $MulticastDelegate<(Text: string, CommitMethod: UE.ETextCommit) => void>;
        GetHintText() : string;
        GetText() : string;
        OnMultiLineEditableTextChangedEvent__DelegateSignature(Text: string) : void;
        OnMultiLineEditableTextCommittedEvent__DelegateSignature(Text: string, CommitMethod: UE.ETextCommit) : void;
        SetHintText(InHintText: string) : void;
        SetIsReadOnly(bReadOnly: boolean) : void;
        SetText(InText: string) : void;
        SetWidgetStyle(InWidgetStyle: UE.TextBlockStyle) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MultiLineEditableText;
        static Load(InName: string): MultiLineEditableText;
    }
    
    class MultiLineEditableTextBox extends UE.TextLayoutWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Text: string;
        HintText: string;
        HintTextDelegate: $Delegate<() => string>;
        WidgetStyle: UE.EditableTextBoxStyle;
        TextStyle: UE.TextBlockStyle;
        bIsReadOnly: boolean;
        AllowContextMenu: boolean;
        VirtualKeyboardOptions: UE.VirtualKeyboardOptions;
        VirtualKeyboardDismissAction: UE.EVirtualKeyboardDismissAction;
        Style: UE.SlateWidgetStyleAsset;
        Font: UE.SlateFontInfo;
        ForegroundColor: UE.LinearColor;
        BackgroundColor: UE.LinearColor;
        ReadOnlyForegroundColor: UE.LinearColor;
        OnTextChanged: $MulticastDelegate<(Text: string) => void>;
        OnTextCommitted: $MulticastDelegate<(Text: string, CommitMethod: UE.ETextCommit) => void>;
        GetHintText() : string;
        GetText() : string;
        OnMultiLineEditableTextBoxChangedEvent__DelegateSignature(Text: string) : void;
        OnMultiLineEditableTextBoxCommittedEvent__DelegateSignature(Text: string, CommitMethod: UE.ETextCommit) : void;
        SetError(InError: string) : void;
        SetHintText(InHintText: string) : void;
        SetIsReadOnly(bReadOnly: boolean) : void;
        SetText(InText: string) : void;
        SetTextStyle(InTextStyle: UE.TextBlockStyle) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MultiLineEditableTextBox;
        static Load(InName: string): MultiLineEditableTextBox;
    }
    
    class MultiSelectionTool extends UE.InteractiveTool {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MultiSelectionTool;
        static Load(InName: string): MultiSelectionTool;
    }
    
    class MyPluginStruct {
        constructor();
        constructor(TestString: string);
        TestString: string;
        static StaticClass(): Class;
    }
    
    class MyPluginObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MyStruct: UE.MyPluginStruct;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MyPluginObject;
        static Load(InName: string): MyPluginObject;
    }
    
    namespace Game.Blueprints.TypeScript.MyTestActor {
        class MyTestActor_C extends UE.Actor {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            DefaultSceneRoot: UE.SceneComponent;
            Test() : void;
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): MyTestActor_C;
            static Load(InName: string): MyTestActor_C;
        }
        
    }

    namespace Game.Blueprints.TypeScript.MyTestActor_Child {
        class MyTestActor_Child_C extends UE.Game.Blueprints.TypeScript.MyTestActor.MyTestActor_C {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            UberGraphFrame: UE.PointerToUberGraphFrame;
            ExecuteUbergraph_MyTestActor_Child(EntryPoint: number) : void;
            ReceiveBeginPlay() : void;
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): MyTestActor_Child_C;
            static Load(InName: string): MyTestActor_Child_C;
        }
        
    }

    namespace Game.Blueprints.TypeScript.MyTestActorComp {
        class MyTestActorComp_C extends UE.ActorComponent {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            UberGraphFrame: UE.PointerToUberGraphFrame;
            ExecuteUbergraph_MyTestActorComp(EntryPoint: number) : void;
            ReceiveBeginPlay() : void;
            ReceiveTick(DeltaSeconds: number) : void;
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): MyTestActorComp_C;
            static Load(InName: string): MyTestActorComp_C;
        }
        
    }

    class NamedInterface {
        constructor();
        constructor(InterfaceName: string, InterfaceObject: UE.Object);
        InterfaceName: string;
        InterfaceObject: UE.Object;
        static StaticClass(): Class;
    }
    
    class NamedInterfaceDef {
        constructor();
        constructor(InterfaceName: string, InterfaceClassName: string);
        InterfaceName: string;
        InterfaceClassName: string;
        static StaticClass(): Class;
    }
    
    class NamedInterfaces extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NamedInterfaces: TArray<UE.NamedInterface>;
        NamedInterfaceDefs: TArray<UE.NamedInterfaceDef>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NamedInterfaces;
        static Load(InName: string): NamedInterfaces;
    }
    
    class NamedSlot extends UE.ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NamedSlot;
        static Load(InName: string): NamedSlot;
    }
    
    class NamedSlotInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NamedSlotInterface;
        static Load(InName: string): NamedSlotInterface;
    }
    
    class NameProperty extends UE.Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NameProperty;
        static Load(InName: string): NameProperty;
    }
    
    class NativeCodeGenCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NativeCodeGenCommandlet;
        static Load(InName: string): NativeCodeGenCommandlet;
    }
    
    class NativeWidgetHost extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NativeWidgetHost;
        static Load(InName: string): NativeWidgetHost;
    }
    
    class NavAgentInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavAgentInterface;
        static Load(InName: string): NavAgentInterface;
    }
    
    class NavAreaBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavAreaBase;
        static Load(InName: string): NavAreaBase;
    }
    
    class NavArea extends UE.NavAreaBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultCost: number;
        FixedAreaEnteringCost: number;
        DrawColor: UE.Color;
        SupportedAgents: UE.NavAgentSelector;
        bSupportsAgent0: boolean;
        bSupportsAgent1: boolean;
        bSupportsAgent2: boolean;
        bSupportsAgent3: boolean;
        bSupportsAgent4: boolean;
        bSupportsAgent5: boolean;
        bSupportsAgent6: boolean;
        bSupportsAgent7: boolean;
        bSupportsAgent8: boolean;
        bSupportsAgent9: boolean;
        bSupportsAgent10: boolean;
        bSupportsAgent11: boolean;
        bSupportsAgent12: boolean;
        bSupportsAgent13: boolean;
        bSupportsAgent14: boolean;
        bSupportsAgent15: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavArea;
        static Load(InName: string): NavArea;
    }
    
    class NavArea_Default extends UE.NavArea {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavArea_Default;
        static Load(InName: string): NavArea_Default;
    }
    
    class NavArea_LowHeight extends UE.NavArea {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavArea_LowHeight;
        static Load(InName: string): NavArea_LowHeight;
    }
    
    class NavArea_Null extends UE.NavArea {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavArea_Null;
        static Load(InName: string): NavArea_Null;
    }
    
    class NavArea_Obstacle extends UE.NavArea {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavArea_Obstacle;
        static Load(InName: string): NavArea_Obstacle;
    }
    
    class NavAreaMeta extends UE.NavArea {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavAreaMeta;
        static Load(InName: string): NavAreaMeta;
    }
    
    class NavAreaMeta_SwitchByAgent extends UE.NavAreaMeta {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Agent0Area: UE.Class;
        Agent1Area: UE.Class;
        Agent2Area: UE.Class;
        Agent3Area: UE.Class;
        Agent4Area: UE.Class;
        Agent5Area: UE.Class;
        Agent6Area: UE.Class;
        Agent7Area: UE.Class;
        Agent8Area: UE.Class;
        Agent9Area: UE.Class;
        Agent10Area: UE.Class;
        Agent11Area: UE.Class;
        Agent12Area: UE.Class;
        Agent13Area: UE.Class;
        Agent14Area: UE.Class;
        Agent15Area: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavAreaMeta_SwitchByAgent;
        static Load(InName: string): NavAreaMeta_SwitchByAgent;
    }
    
    class NavCollisionCylinder {
        constructor();
        constructor(Offset: UE.Vector, Radius: number, Height: number);
        Offset: UE.Vector;
        Radius: number;
        Height: number;
        static StaticClass(): Class;
    }
    
    class NavCollisionBox {
        constructor();
        constructor(Offset: UE.Vector, Extent: UE.Vector);
        Offset: UE.Vector;
        Extent: UE.Vector;
        static StaticClass(): Class;
    }
    
    class NavCollision extends UE.NavCollisionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CylinderCollision: TArray<UE.NavCollisionCylinder>;
        BoxCollision: TArray<UE.NavCollisionBox>;
        AreaClass: UE.Class;
        bGatherConvexGeometry: boolean;
        bCreateOnClient: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavCollision;
        static Load(InName: string): NavCollision;
    }
    
    class NavEdgeProviderInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavEdgeProviderInterface;
        static Load(InName: string): NavEdgeProviderInterface;
    }
    
    class NavigationFilterArea {
        constructor();
        constructor(AreaClass: UE.Class, TravelCostOverride: number, EnteringCostOverride: number, bIsExcluded: boolean, bOverrideTravelCost: boolean, bOverrideEnteringCost: boolean);
        AreaClass: UE.Class;
        TravelCostOverride: number;
        EnteringCostOverride: number;
        bIsExcluded: boolean;
        bOverrideTravelCost: boolean;
        bOverrideEnteringCost: boolean;
        static StaticClass(): Class;
    }
    
    class NavigationFilterFlags {
        constructor();
        constructor(bNavFlag0: boolean, bNavFlag1: boolean, bNavFlag2: boolean, bNavFlag3: boolean, bNavFlag4: boolean, bNavFlag5: boolean, bNavFlag6: boolean, bNavFlag7: boolean, bNavFlag8: boolean, bNavFlag9: boolean, bNavFlag10: boolean, bNavFlag11: boolean, bNavFlag12: boolean, bNavFlag13: boolean, bNavFlag14: boolean, bNavFlag15: boolean);
        bNavFlag0: boolean;
        bNavFlag1: boolean;
        bNavFlag2: boolean;
        bNavFlag3: boolean;
        bNavFlag4: boolean;
        bNavFlag5: boolean;
        bNavFlag6: boolean;
        bNavFlag7: boolean;
        bNavFlag8: boolean;
        bNavFlag9: boolean;
        bNavFlag10: boolean;
        bNavFlag11: boolean;
        bNavFlag12: boolean;
        bNavFlag13: boolean;
        bNavFlag14: boolean;
        bNavFlag15: boolean;
        static StaticClass(): Class;
    }
    
    class NavigationQueryFilter extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Areas: TArray<UE.NavigationFilterArea>;
        IncludeFlags: UE.NavigationFilterFlags;
        ExcludeFlags: UE.NavigationFilterFlags;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationQueryFilter;
        static Load(InName: string): NavigationQueryFilter;
    }
    
    class NavFilter_AIControllerDefault extends UE.NavigationQueryFilter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavFilter_AIControllerDefault;
        static Load(InName: string): NavFilter_AIControllerDefault;
    }
    
    class NavigationDataInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationDataInterface;
        static Load(InName: string): NavigationDataInterface;
    }
    
    class NavigationGraph extends UE.NavigationData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationGraph;
        static Load(InName: string): NavigationGraph;
    }
    
    class NavigationGraphNode extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationGraphNode;
        static Load(InName: string): NavigationGraphNode;
    }
    
    class NavGraphNode {
        constructor();
        constructor(Owner: UE.Object);
        Owner: UE.Object;
        static StaticClass(): Class;
    }
    
    class NavigationGraphNodeComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: UE.NavGraphNode;
        NextNodeComponent: UE.NavigationGraphNodeComponent;
        PrevNodeComponent: UE.NavigationGraphNodeComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationGraphNodeComponent;
        static Load(InName: string): NavigationGraphNodeComponent;
    }
    
    class NavigationInvokerComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TileGenerationRadius: number;
        TileRemovalRadius: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationInvokerComponent;
        static Load(InName: string): NavigationInvokerComponent;
    }
    
    class NavigationPathGenerator extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationPathGenerator;
        static Load(InName: string): NavigationPathGenerator;
    }
    
    class NavigationSystemModuleConfig extends UE.NavigationSystemConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bStrictlyStatic: boolean;
        bCreateOnClient: boolean;
        bAutoSpawnMissingNavData: boolean;
        bSpawnNavDataInNavBoundsLevel: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationSystemModuleConfig;
        static Load(InName: string): NavigationSystemModuleConfig;
    }
    
    enum ENavDataGatheringModeConfig { Invalid, Instant, Lazy, ENavDataGatheringModeConfig_MAX}
    enum FNavigationSystemRunMode { InvalidMode, GameMode, EditorMode, SimulationMode, PIEMode, FNavigationSystemRunMode_MAX}
    class NavMeshBoundsVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SupportedAgents: UE.NavAgentSelector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavMeshBoundsVolume;
        static Load(InName: string): NavMeshBoundsVolume;
    }
    
    enum ENavigationQueryResult { Invalid, Error, Fail, Success, ENavigationQueryResult_MAX}
    class NavigationSystemV1 extends UE.NavigationSystemBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MainNavData: UE.NavigationData;
        AbstractNavData: UE.NavigationData;
        DefaultAgentName: string;
        CrowdManagerClass: TSoftClassPtr<UE.CrowdManagerBase>;
        bAutoCreateNavigationData: boolean;
        bSpawnNavDataInNavBoundsLevel: boolean;
        bAllowClientSideNavigation: boolean;
        bShouldDiscardSubLevelNavData: boolean;
        bTickWhilePaused: boolean;
        bSupportRebuilding: boolean;
        bInitialBuildingLocked: boolean;
        bSkipAgentHeightCheckWhenPickingNavData: boolean;
        DataGatheringMode: UE.ENavDataGatheringModeConfig;
        bGenerateNavigationOnlyAroundNavigationInvokers: boolean;
        ActiveTilesUpdateInterval: number;
        SupportedAgents: TArray<UE.NavDataConfig>;
        SupportedAgentsMask: UE.NavAgentSelector;
        NavDataSet: TArray<UE.NavigationData>;
        NavDataRegistrationQueue: TArray<UE.NavigationData>;
        OnNavDataRegisteredEvent: $MulticastDelegate<(NavData: $Nullable<UE.NavigationData>) => void>;
        OnNavigationGenerationFinishedDelegate: $MulticastDelegate<(NavData: $Nullable<UE.NavigationData>) => void>;
        OperationMode: UE.FNavigationSystemRunMode;
        DirtyAreasUpdateFreq: number;
        K2_ReplaceAreaInOctreeData(Object: $Nullable<UE.Object>, OldArea: $Nullable<UE.Class>, NewArea: $Nullable<UE.Class>) : boolean;
        OnNavigationBoundsUpdated(NavVolume: $Nullable<UE.NavMeshBoundsVolume>) : void;
        RegisterNavigationInvoker(Invoker: $Nullable<UE.Actor>, TileGenerationRadius?: number /* = 3000.000000 */, TileRemovalRadius?: number /* = 5000.000000 */) : void;
        ResetMaxSimultaneousTileGenerationJobsCount() : void;
        SetGeometryGatheringMode(NewMode: UE.ENavDataGatheringModeConfig) : void;
        SetMaxSimultaneousTileGenerationJobsCount(MaxNumberOfJobs: number) : void;
        UnregisterNavigationInvoker(Invoker: $Nullable<UE.Actor>) : void;
        static FindPathToActorSynchronously(WorldContextObject: $Nullable<UE.Object>, PathStart: UE.Vector, GoalActor: $Nullable<UE.Actor>, TetherDistance?: number /* = 50.000000 */, PathfindingContext?: UE.Actor /* = None */, FilterClass?: UE.Class /* = None */) : UE.NavigationPath;
        static FindPathToLocationSynchronously(WorldContextObject: $Nullable<UE.Object>, PathStart: UE.Vector, PathEnd: UE.Vector, PathfindingContext?: UE.Actor /* = None */, FilterClass?: UE.Class /* = None */) : UE.NavigationPath;
        static GetNavigationSystem(WorldContextObject: $Nullable<UE.Object>) : UE.NavigationSystemV1;
        static GetPathCost(WorldContextObject: $Nullable<UE.Object>, PathStart: UE.Vector, PathEnd: UE.Vector, PathCost: $Ref<number>, NavData?: UE.NavigationData /* = None */, FilterClass?: UE.Class /* = None */) : UE.ENavigationQueryResult;
        static GetPathLength(WorldContextObject: $Nullable<UE.Object>, PathStart: UE.Vector, PathEnd: UE.Vector, PathLength: $Ref<number>, NavData?: UE.NavigationData /* = None */, FilterClass?: UE.Class /* = None */) : UE.ENavigationQueryResult;
        static GetRandomPointInNavigableRadius(WorldContextObject: $Nullable<UE.Object>, Origin: UE.Vector, Radius: number, NavData?: UE.NavigationData /* = None */, FilterClass?: UE.Class /* = None */) : UE.Vector;
        static GetRandomReachablePointInRadius(WorldContextObject: $Nullable<UE.Object>, Origin: UE.Vector, Radius: number, NavData?: UE.NavigationData /* = None */, FilterClass?: UE.Class /* = None */) : UE.Vector;
        static IsNavigationBeingBuilt(WorldContextObject: $Nullable<UE.Object>) : boolean;
        static IsNavigationBeingBuiltOrLocked(WorldContextObject: $Nullable<UE.Object>) : boolean;
        static K2_GetRandomLocationInNavigableRadius(WorldContextObject: $Nullable<UE.Object>, Origin: UE.Vector, RandomLocation: $Ref<UE.Vector>, Radius: number, NavData?: UE.NavigationData /* = None */, FilterClass?: UE.Class /* = None */) : boolean;
        static K2_GetRandomPointInNavigableRadius(WorldContextObject: $Nullable<UE.Object>, Origin: UE.Vector, RandomLocation: $Ref<UE.Vector>, Radius: number, NavData?: UE.NavigationData /* = None */, FilterClass?: UE.Class /* = None */) : boolean;
        static K2_GetRandomReachablePointInRadius(WorldContextObject: $Nullable<UE.Object>, Origin: UE.Vector, RandomLocation: $Ref<UE.Vector>, Radius: number, NavData?: UE.NavigationData /* = None */, FilterClass?: UE.Class /* = None */) : boolean;
        static K2_ProjectPointToNavigation(WorldContextObject: $Nullable<UE.Object>, Point: UE.Vector, ProjectedLocation: $Ref<UE.Vector>, NavData: $Nullable<UE.NavigationData>, FilterClass: $Nullable<UE.Class>, QueryExtent?: UE.Vector /* =  */) : boolean;
        static NavigationRaycast(WorldContextObject: $Nullable<UE.Object>, RayStart: UE.Vector, RayEnd: UE.Vector, HitLocation: $Ref<UE.Vector>, FilterClass?: UE.Class /* = None */, Querier?: UE.Controller /* = None */) : boolean;
        static ProjectPointToNavigation(WorldContextObject: $Nullable<UE.Object>, Point: UE.Vector, NavData?: UE.NavigationData /* = None */, FilterClass?: UE.Class /* = None */, QueryExtent?: UE.Vector /* =  */) : UE.Vector;
        static SimpleMoveToActor(Controller: $Nullable<UE.Controller>, Goal: $Nullable<UE.Actor>) : void;
        static SimpleMoveToLocation(Controller: $Nullable<UE.Controller>, Goal: UE.Vector) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationSystemV1;
        static Load(InName: string): NavigationSystemV1;
    }
    
    class NavTestRenderingComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavTestRenderingComponent;
        static Load(InName: string): NavTestRenderingComponent;
    }
    
    enum ENavCostDisplay { TotalCost, HeuristicOnly, RealCostOnly, ENavCostDisplay_MAX}
    class NavigationTestingActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CapsuleComponent: UE.CapsuleComponent;
        EdRenderComp: UE.NavTestRenderingComponent;
        InvokerComponent: UE.NavigationInvokerComponent;
        bActAsNavigationInvoker: boolean;
        NavAgentProps: UE.NavAgentProperties;
        QueryingExtent: UE.Vector;
        MyNavData: UE.NavigationData;
        ProjectedLocation: UE.Vector;
        bProjectedLocationValid: boolean;
        bSearchStart: boolean;
        bBacktracking: boolean;
        bUseHierarchicalPathfinding: boolean;
        bGatherDetailedInfo: boolean;
        bDrawDistanceToWall: boolean;
        bShowNodePool: boolean;
        bShowBestPath: boolean;
        bShowDiffWithPreviousStep: boolean;
        bShouldBeVisibleInGame: boolean;
        CostDisplayMode: UE.ENavCostDisplay;
        TextCanvasOffset: UE.Vector2D;
        bPathExist: boolean;
        bPathIsPartial: boolean;
        bPathSearchOutOfNodes: boolean;
        PathfindingTime: number;
        PathCost: number;
        PathfindingSteps: number;
        OtherActor: UE.NavigationTestingActor;
        FilterClass: UE.Class;
        ShowStepIndex: number;
        OffsetFromCornersDistance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationTestingActor;
        static Load(InName: string): NavigationTestingActor;
    }
    
    enum ENavLinkDirection { BothWays, LeftToRight, RightToLeft, ENavLinkDirection_MAX}
    class NavigationLinkBase {
        constructor();
        constructor(LeftProjectHeight: number, MaxFallDownLength: number, SnapRadius: number, SnapHeight: number, SupportedAgents: UE.NavAgentSelector, bSupportsAgent0: boolean, bSupportsAgent1: boolean, bSupportsAgent2: boolean, bSupportsAgent3: boolean, bSupportsAgent4: boolean, bSupportsAgent5: boolean, bSupportsAgent6: boolean, bSupportsAgent7: boolean, bSupportsAgent8: boolean, bSupportsAgent9: boolean, bSupportsAgent10: boolean, bSupportsAgent11: boolean, bSupportsAgent12: boolean, bSupportsAgent13: boolean, bSupportsAgent14: boolean, bSupportsAgent15: boolean, Description: string, Direction: UE.ENavLinkDirection, bUseSnapHeight: boolean, bSnapToCheapestArea: boolean, bCustomFlag0: boolean, bCustomFlag1: boolean, bCustomFlag2: boolean, bCustomFlag3: boolean, bCustomFlag4: boolean, bCustomFlag5: boolean, bCustomFlag6: boolean, bCustomFlag7: boolean, AreaClass: UE.Class);
        LeftProjectHeight: number;
        MaxFallDownLength: number;
        SnapRadius: number;
        SnapHeight: number;
        SupportedAgents: UE.NavAgentSelector;
        bSupportsAgent0: boolean;
        bSupportsAgent1: boolean;
        bSupportsAgent2: boolean;
        bSupportsAgent3: boolean;
        bSupportsAgent4: boolean;
        bSupportsAgent5: boolean;
        bSupportsAgent6: boolean;
        bSupportsAgent7: boolean;
        bSupportsAgent8: boolean;
        bSupportsAgent9: boolean;
        bSupportsAgent10: boolean;
        bSupportsAgent11: boolean;
        bSupportsAgent12: boolean;
        bSupportsAgent13: boolean;
        bSupportsAgent14: boolean;
        bSupportsAgent15: boolean;
        Description: string;
        Direction: UE.ENavLinkDirection;
        bUseSnapHeight: boolean;
        bSnapToCheapestArea: boolean;
        bCustomFlag0: boolean;
        bCustomFlag1: boolean;
        bCustomFlag2: boolean;
        bCustomFlag3: boolean;
        bCustomFlag4: boolean;
        bCustomFlag5: boolean;
        bCustomFlag6: boolean;
        bCustomFlag7: boolean;
        AreaClass: UE.Class;
        static StaticClass(): Class;
    }
    
    class NavigationLink extends UE.NavigationLinkBase {
        constructor();
        constructor(Left: UE.Vector, Right: UE.Vector);
        Left: UE.Vector;
        Right: UE.Vector;
        static StaticClass(): Class;
    }
    
    class NavLinkComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Links: TArray<UE.NavigationLink>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLinkComponent;
        static Load(InName: string): NavLinkComponent;
    }
    
    class NavRelevantComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAttachToOwnersRoot: boolean;
        CachedNavParent: UE.Object;
        SetNavigationRelevancy(bRelevant: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavRelevantComponent;
        static Load(InName: string): NavRelevantComponent;
    }
    
    class NavLinkCustomComponent extends UE.NavRelevantComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NavLinkUserId: number;
        EnabledAreaClass: UE.Class;
        DisabledAreaClass: UE.Class;
        SupportedAgents: UE.NavAgentSelector;
        LinkRelativeStart: UE.Vector;
        LinkRelativeEnd: UE.Vector;
        LinkDirection: UE.ENavLinkDirection;
        bLinkEnabled: boolean;
        bNotifyWhenEnabled: boolean;
        bNotifyWhenDisabled: boolean;
        bCreateBoxObstacle: boolean;
        ObstacleOffset: UE.Vector;
        ObstacleExtent: UE.Vector;
        ObstacleAreaClass: UE.Class;
        BroadcastRadius: number;
        BroadcastInterval: number;
        BroadcastChannel: UE.ECollisionChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLinkCustomComponent;
        static Load(InName: string): NavLinkCustomComponent;
    }
    
    class NavLinkCustomInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLinkCustomInterface;
        static Load(InName: string): NavLinkCustomInterface;
    }
    
    class NavigationSegmentLink extends UE.NavigationLinkBase {
        constructor();
        constructor(LeftStart: UE.Vector, LeftEnd: UE.Vector, RightStart: UE.Vector, RightEnd: UE.Vector);
        LeftStart: UE.Vector;
        LeftEnd: UE.Vector;
        RightStart: UE.Vector;
        RightEnd: UE.Vector;
        static StaticClass(): Class;
    }
    
    class NavLinkDefinition extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Links: TArray<UE.NavigationLink>;
        SegmentLinks: TArray<UE.NavigationSegmentLink>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLinkDefinition;
        static Load(InName: string): NavLinkDefinition;
    }
    
    class NavLinkHostInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLinkHostInterface;
        static Load(InName: string): NavLinkHostInterface;
    }
    
    class NavLinkRenderingComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLinkRenderingComponent;
        static Load(InName: string): NavLinkRenderingComponent;
    }
    
    class NavLinkProxy extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PointLinks: TArray<UE.NavigationLink>;
        SegmentLinks: TArray<UE.NavigationSegmentLink>;
        SmartLinkComp: UE.NavLinkCustomComponent;
        bSmartLinkIsRelevant: boolean;
        EdRenderComp: UE.NavLinkRenderingComponent;
        SpriteComponent: UE.BillboardComponent;
        OnSmartLinkReached: $MulticastDelegate<(MovingActor: $Nullable<UE.Actor>, DestinationPoint: UE.Vector) => void>;
        HasMovingAgents() : boolean;
        IsSmartLinkEnabled() : boolean;
        ReceiveSmartLinkReached(Agent: $Nullable<UE.Actor>, Destination: UE.Vector) : void;
        ResumePathFollowing(Agent: $Nullable<UE.Actor>) : void;
        SetSmartLinkEnabled(bEnabled: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLinkProxy;
        static Load(InName: string): NavLinkProxy;
    }
    
    class NavLinkTrivial extends UE.NavLinkDefinition {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLinkTrivial;
        static Load(InName: string): NavLinkTrivial;
    }
    
    class NavMeshRenderingComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavMeshRenderingComponent;
        static Load(InName: string): NavMeshRenderingComponent;
    }
    
    class NavModifierComponent extends UE.NavRelevantComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AreaClass: UE.Class;
        FailsafeExtent: UE.Vector;
        bIncludeAgentHeight: boolean;
        SetAreaClass(NewAreaClass: $Nullable<UE.Class>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavModifierComponent;
        static Load(InName: string): NavModifierComponent;
    }
    
    class NavModifierVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AreaClass: UE.Class;
        SetAreaClass(NewAreaClass?: UE.Class /* = None */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavModifierVolume;
        static Load(InName: string): NavModifierVolume;
    }
    
    class NavNodeInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavNodeInterface;
        static Load(InName: string): NavNodeInterface;
    }
    
    class NavPathObserverInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavPathObserverInterface;
        static Load(InName: string): NavPathObserverInterface;
    }
    
    class NavRelevantInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavRelevantInterface;
        static Load(InName: string): NavRelevantInterface;
    }
    
    enum ENavSystemOverridePolicy { Override, Append, Skip, ENavSystemOverridePolicy_MAX}
    class NavSystemConfigOverride extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpriteComponent: UE.BillboardComponent;
        NavigationSystemConfig: UE.NavigationSystemConfig;
        OverridePolicy: UE.ENavSystemOverridePolicy;
        bLoadOnClient: boolean;
        ApplyChanges() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavSystemConfigOverride;
        static Load(InName: string): NavSystemConfigOverride;
    }
    
    class NetAnalyticsDataConfig {
        constructor();
        constructor(DataName: string, bEnabled: boolean);
        DataName: string;
        bEnabled: boolean;
        static StaticClass(): Class;
    }
    
    class NetAnalyticsAggregatorConfig extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NetAnalyticsData: TArray<UE.NetAnalyticsDataConfig>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NetAnalyticsAggregatorConfig;
        static Load(InName: string): NetAnalyticsAggregatorConfig;
    }
    
    class NetBitsTest extends UE.UnitTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NetBitsTest;
        static Load(InName: string): NetBitsTest;
    }
    
    class NetPropertyHook extends UE.Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NetPropertyHook;
        static Load(InName: string): NetPropertyHook;
    }
    
    class NetworkPredictionInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NetworkPredictionInterface;
        static Load(InName: string): NetworkPredictionInterface;
    }
    
    class NetworkEmulationProfileDescription {
        constructor();
        constructor(ProfileName: string, ToolTip: string);
        ProfileName: string;
        ToolTip: string;
        static StaticClass(): Class;
    }
    
    class NetworkSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bVerifyPeer: boolean;
        bEnableMultiplayerWorldOriginRebasing: boolean;
        MaxRepArraySize: number;
        MaxRepArrayMemory: number;
        NetworkEmulationProfiles: TArray<UE.NetworkEmulationProfileDescription>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NetworkSettings;
        static Load(InName: string): NetworkSettings;
    }
    
    namespace Game.NewBlueprint1 {
        class NewBlueprint1_C extends UE.Actor {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            UberGraphFrame: UE.PointerToUberGraphFrame;
            MyTestActorComp: UE.Game.Blueprints.TypeScript.MyTestActorComp.MyTestActorComp_C;
            DefaultSceneRoot: UE.SceneComponent;
            NewVar_0: UE.Transform;
            ExecuteUbergraph_NewBlueprint1(EntryPoint: number) : void;
            ReceiveBeginPlay() : void;
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): NewBlueprint1_C;
            static Load(InName: string): NewBlueprint1_C;
        }
        
    }

    namespace Game.NewBlueprint {
        class NewBlueprint_C extends UE.Actor {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            DefaultSceneRoot: UE.SceneComponent;
            ["()[]"]: boolean;
            ["["]: boolean;
            ["\""]: boolean;
            ["?/ --"]() : void;
            Add(NewParam: number, NewParam1: number) : number;
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): NewBlueprint_C;
            static Load(InName: string): NewBlueprint_C;
        }
        
    }

    class NewPluginDescriptorData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CreatedBy: string;
        CreatedByURL: string;
        Description: string;
        bIsBetaVersion: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NewPluginDescriptorData;
        static Load(InName: string): NewPluginDescriptorData;
    }
    
    class NodeDependingOnEnumInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NodeDependingOnEnumInterface;
        static Load(InName: string): NodeDependingOnEnumInterface;
    }
    
    class NodeMappingProviderInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NodeMappingProviderInterface;
        static Load(InName: string): NodeMappingProviderInterface;
    }
    
    class NoiseField extends UE.FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MinRange: number;
        MaxRange: number;
        Transform: UE.Transform;
        SetNoiseField(MinRange: number, MaxRange: number, Transform: UE.Transform) : UE.NoiseField;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NoiseField;
        static Load(InName: string): NoiseField;
    }
    
    class Note extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Text: string;
        SpriteComponent: UE.BillboardComponent;
        ArrowComponent: UE.ArrowComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Note;
        static Load(InName: string): Note;
    }
    
    class NullAudioCaptureProtocol extends UE.MovieSceneAudioCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NullAudioCaptureProtocol;
        static Load(InName: string): NullAudioCaptureProtocol;
    }
    
    class NullNavSysConfig extends UE.NavigationSystemConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NullNavSysConfig;
        static Load(InName: string): NullNavSysConfig;
    }
    
    class NUTActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TempDelegate: $Delegate<(InNUTActor: $Nullable<UE.NUTActor>) => void>;
        Admin(Command: string) : void;
        NetFlush() : void;
        NetMulticastPing() : void;
        ServerAdmin(Command: string) : void;
        ServerClientPing() : void;
        ServerClientStillAlive() : void;
        ServerExecute(InDelegate: string) : void;
        ServerReceiveText(InText: string) : void;
        UnitSeamlessTravel(Dest?: string /* = " " */) : void;
        UnitTravel(Dest?: string /* = " " */) : void;
        Wait(Seconds: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NUTActor;
        static Load(InName: string): NUTActor;
    }
    
    class NUTGlobals extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EventWatcher: UE.NetConnection;
        ServerPortOffset: number;
        UnitTestNetDriverCount: number;
        DumpRPCMatches: TArray<string>;
        UnitTestModules: TArray<string>;
        UnloadedModules: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NUTGlobals;
        static Load(InName: string): NUTGlobals;
    }
    
    class ObjectExporterT3D extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ObjectExporterT3D;
        static Load(InName: string): ObjectExporterT3D;
    }
    
    class ObjectLibrary extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ObjectBaseClass: UE.Class;
        bHasBlueprintClasses: boolean;
        Objects: TArray<UE.Object>;
        WeakObjects: TArray<TWeakObjectPtr<UE.Object>>;
        bUseWeakReferences: boolean;
        bIsFullyLoaded: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ObjectLibrary;
        static Load(InName: string): ObjectLibrary;
    }
    
    class ObjectLibraryFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ObjectLibraryFactory;
        static Load(InName: string): ObjectLibraryFactory;
    }
    
    class ObjectRedirector extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ObjectRedirector;
        static Load(InName: string): ObjectRedirector;
    }
    
    class ObjectReferencer extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ReferencedObjects: TArray<UE.Object>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ObjectReferencer;
        static Load(InName: string): ObjectReferencer;
    }
    
    enum EOculusPlatform { PC, Mobile, Length, EOculusPlatform_MAX}
    class OculusEditorSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PerfToolIgnoreList: TMap<string, boolean>;
        PerfToolTargetPlatform: UE.EOculusPlatform;
        bAddMenuOption: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusEditorSettings;
        static Load(InName: string): OculusEditorSettings;
    }
    
    enum EFixedFoveatedRenderingLevel { FFR_Off, FFR_Low, FFR_Medium, FFR_High, FFR_HighTop, FFR_MAX}
    enum ETrackedDeviceType { None, HMD, LTouch, RTouch, Touch, DeviceObjectZero, All, ETrackedDeviceType_MAX}
    class HmdUserProfileField {
        constructor();
        constructor(FieldName: string, FieldValue: string);
        FieldName: string;
        FieldValue: string;
        static StaticClass(): Class;
    }
    
    class HmdUserProfile {
        constructor();
        constructor(Name: string, Gender: string, PlayerHeight: number, EyeHeight: number, IPD: number, NeckToEyeDistance: UE.Vector2D, ExtraFields: TArray<UE.HmdUserProfileField>);
        Name: string;
        Gender: string;
        PlayerHeight: number;
        EyeHeight: number;
        IPD: number;
        NeckToEyeDistance: UE.Vector2D;
        ExtraFields: TArray<UE.HmdUserProfileField>;
        static StaticClass(): Class;
    }
    
    enum EBoundaryType { Boundary_Outer, Boundary_PlayArea, Boundary_MAX}
    class GuardianTestResult {
        constructor();
        constructor(IsTriggering: boolean, DeviceType: UE.ETrackedDeviceType, ClosestDistance: number, ClosestPoint: UE.Vector, ClosestPointNormal: UE.Vector);
        IsTriggering: boolean;
        DeviceType: UE.ETrackedDeviceType;
        ClosestDistance: number;
        ClosestPoint: UE.Vector;
        ClosestPointNormal: UE.Vector;
        static StaticClass(): Class;
    }
    
    class OculusFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AddLoadingSplashScreen(Texture: $Nullable<UE.Texture2D>, TranslationInMeters: UE.Vector, Rotation: UE.Rotator, SizeInMeters?: UE.Vector2D /* = (X=1.000,Y=1.000) */, DeltaRotation?: UE.Rotator /* =  */, bClearBeforeAdd?: boolean /* = false */) : void;
        static ClearLoadingSplashScreens() : void;
        static EnableAutoLoadingSplashScreen(bAutoShowEnabled: boolean) : void;
        static EnableOrientationTracking(bOrientationTracking: boolean) : void;
        static EnablePositionTracking(bPositionTracking: boolean) : void;
        static GetAvailableDisplayFrequencies() : TArray<number>;
        static GetBaseRotationAndBaseOffsetInMeters(OutRotation: $Ref<UE.Rotator>, OutBaseOffsetInMeters: $Ref<UE.Vector>) : void;
        static GetBaseRotationAndPositionOffset(OutRot: $Ref<UE.Rotator>, OutPosOffset: $Ref<UE.Vector>) : void;
        static GetCurrentDisplayFrequency() : number;
        static GetDeviceName() : string;
        static GetFixedFoveatedRenderingLevel() : UE.EFixedFoveatedRenderingLevel;
        static GetGPUFrameTime() : number;
        static GetGPUUtilization(IsGPUAvailable: $Ref<boolean>, GPUUtilization: $Ref<number>) : void;
        static GetGuardianDimensions(BoundaryType: UE.EBoundaryType) : UE.Vector;
        static GetGuardianPoints(BoundaryType: UE.EBoundaryType, UsePawnSpace?: boolean /* = false */) : TArray<UE.Vector>;
        static GetLoadingSplashParams(TexturePath: $Ref<string>, DistanceInMeters: $Ref<UE.Vector>, SizeInMeters: $Ref<UE.Vector2D>, RotationAxis: $Ref<UE.Vector>, RotationDeltaInDeg: $Ref<number>) : void;
        static GetNodeGuardianIntersection(DeviceType: UE.ETrackedDeviceType, BoundaryType: UE.EBoundaryType) : UE.GuardianTestResult;
        static GetPlayAreaTransform() : UE.Transform;
        static GetPointGuardianIntersection(Point: UE.Vector, BoundaryType: UE.EBoundaryType) : UE.GuardianTestResult;
        static GetPose(DeviceRotation: $Ref<UE.Rotator>, DevicePosition: $Ref<UE.Vector>, NeckPosition: $Ref<UE.Vector>, bUseOrienationForPlayerCamera?: boolean /* = false */, bUsePositionForPlayerCamera?: boolean /* = false */, PositionScale?: UE.Vector /* =  */) : void;
        static GetRawSensorData(AngularAcceleration: $Ref<UE.Vector>, LinearAcceleration: $Ref<UE.Vector>, AngularVelocity: $Ref<UE.Vector>, LinearVelocity: $Ref<UE.Vector>, TimeInSeconds: $Ref<number>, DeviceType?: UE.ETrackedDeviceType /* = HMD */) : void;
        static GetUserProfile(Profile: $Ref<UE.HmdUserProfile>) : boolean;
        static HasInputFocus() : boolean;
        static HasSystemOverlayPresent() : boolean;
        static HideLoadingIcon() : void;
        static HideLoadingSplashScreen(bClear?: boolean /* = false */) : void;
        static IsAutoLoadingSplashScreenEnabled() : boolean;
        static IsDeviceTracked(DeviceType: UE.ETrackedDeviceType) : boolean;
        static IsGuardianConfigured() : boolean;
        static IsGuardianDisplayed() : boolean;
        static IsLoadingIconEnabled() : boolean;
        static SetBaseRotationAndBaseOffsetInMeters(Rotation: UE.Rotator, BaseOffsetInMeters: UE.Vector, Options: UE.EOrientPositionSelector) : void;
        static SetBaseRotationAndPositionOffset(BaseRot: UE.Rotator, PosOffset: UE.Vector, Options: UE.EOrientPositionSelector) : void;
        static SetColorScaleAndOffset(ColorScale: UE.LinearColor, ColorOffset: UE.LinearColor, bApplyToAllLayers?: boolean /* = false */) : void;
        static SetCPUAndGPULevels(CPULevel: number, GPULevel: number) : void;
        static SetDisplayFrequency(RequestedFrequency: number) : void;
        static SetFixedFoveatedRenderingLevel(level: UE.EFixedFoveatedRenderingLevel) : void;
        static SetGuardianVisibility(GuardianVisible: boolean) : void;
        static SetLoadingSplashParams(TexturePath: string, DistanceInMeters: UE.Vector, SizeInMeters: UE.Vector2D, RotationAxis: UE.Vector, RotationDeltaInDeg: number) : void;
        static SetPositionScale3D(PosScale3D: UE.Vector) : void;
        static SetReorientHMDOnControllerRecenter(recenterMode: boolean) : void;
        static ShowLoadingIcon(Texture: $Nullable<UE.Texture2D>) : void;
        static ShowLoadingSplashScreen() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusFunctionLibrary;
        static Load(InName: string): OculusFunctionLibrary;
    }
    
    class OculusSplashDesc {
        constructor();
        constructor(TexturePath: UE.SoftObjectPath, TransformInMeters: UE.Transform, QuadSizeInMeters: UE.Vector2D, DeltaRotation: UE.Quat, TextureOffset: UE.Vector2D, TextureScale: UE.Vector2D, bNoAlphaChannel: boolean);
        TexturePath: UE.SoftObjectPath;
        TransformInMeters: UE.Transform;
        QuadSizeInMeters: UE.Vector2D;
        DeltaRotation: UE.Quat;
        TextureOffset: UE.Vector2D;
        TextureScale: UE.Vector2D;
        bNoAlphaChannel: boolean;
        static StaticClass(): Class;
    }
    
    class OculusHMDRuntimeSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoEnabled: boolean;
        SplashDescs: TArray<UE.OculusSplashDesc>;
        bSupportsDash: boolean;
        bCompositesDepth: boolean;
        bHQDistortion: boolean;
        PixelDensityMin: number;
        PixelDensityMax: number;
        CPULevel: number;
        GPULevel: number;
        FFRLevel: UE.EFixedFoveatedRenderingLevel;
        bChromaCorrection: boolean;
        bRecenterHMDWithController: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusHMDRuntimeSettings;
        static Load(InName: string): OculusHMDRuntimeSettings;
    }
    
    enum EOculusMR_BoundaryType { BT_OuterBoundary, BT_PlayArea, BT_MAX}
    class SceneCapture extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MeshComp: UE.StaticMeshComponent;
        SceneComponent: UE.SceneComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneCapture;
        static Load(InName: string): SceneCapture;
    }
    
    enum ESceneCapturePrimitiveRenderMode { PRM_LegacySceneCapture, PRM_RenderScenePrimitives, PRM_UseShowOnlyList, PRM_MAX}
    enum ESceneCaptureSource { SCS_SceneColorHDR, SCS_SceneColorHDRNoAlpha, SCS_FinalColorLDR, SCS_SceneColorSceneDepth, SCS_SceneDepth, SCS_DeviceDepth, SCS_Normal, SCS_BaseColor, SCS_FinalColorHDR, SCS_MAX}
    class EngineShowFlagsSetting {
        constructor();
        constructor(ShowFlagName: string, Enabled: boolean);
        ShowFlagName: string;
        Enabled: boolean;
        static StaticClass(): Class;
    }
    
    class SceneCaptureComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PrimitiveRenderMode: UE.ESceneCapturePrimitiveRenderMode;
        CaptureSource: UE.ESceneCaptureSource;
        HiddenComponents: TArray<TWeakObjectPtr<UE.PrimitiveComponent>>;
        HiddenActors: TArray<UE.Actor>;
        ShowOnlyComponents: TArray<TWeakObjectPtr<UE.PrimitiveComponent>>;
        ShowOnlyActors: TArray<UE.Actor>;
        bCaptureEveryFrame: boolean;
        bCaptureOnMovement: boolean;
        bAlwaysPersistRenderingState: boolean;
        LODDistanceFactor: number;
        MaxViewDistanceOverride: number;
        CaptureSortPriority: number;
        ShowFlagSettings: TArray<UE.EngineShowFlagsSetting>;
        ProfilingEventName: string;
        CaptureMesh: UE.StaticMesh;
        ClearHiddenComponents() : void;
        ClearShowOnlyComponents() : void;
        HideActorComponents(InActor: $Nullable<UE.Actor>) : void;
        HideComponent(InComponent: $Nullable<UE.PrimitiveComponent>) : void;
        RemoveShowOnlyActorComponents(InActor: $Nullable<UE.Actor>) : void;
        RemoveShowOnlyComponent(InComponent: $Nullable<UE.PrimitiveComponent>) : void;
        SetCaptureSortPriority(NewCaptureSortPriority: number) : void;
        ShowOnlyActorComponents(InActor: $Nullable<UE.Actor>) : void;
        ShowOnlyComponent(InComponent: $Nullable<UE.PrimitiveComponent>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneCaptureComponent;
        static Load(InName: string): SceneCaptureComponent;
    }
    
    enum ESceneCaptureCompositeMode { SCCM_Overwrite, SCCM_Additive, SCCM_Composite, SCCM_MAX}
    class SceneCaptureComponent2D extends UE.SceneCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProjectionType: UE.ECameraProjectionMode;
        FOVAngle: number;
        OrthoWidth: number;
        TextureTarget: UE.TextureRenderTarget2D;
        CompositeMode: UE.ESceneCaptureCompositeMode;
        PostProcessSettings: UE.PostProcessSettings;
        PostProcessBlendWeight: number;
        bOverride_CustomNearClippingPlane: boolean;
        CustomNearClippingPlane: number;
        bUseCustomProjectionMatrix: boolean;
        CustomProjectionMatrix: UE.Matrix;
        bEnableClipPlane: boolean;
        ClipPlaneBase: UE.Vector;
        ClipPlaneNormal: UE.Vector;
        bCameraCutThisFrame: boolean;
        bConsiderUnrenderedOpaquePixelAsFullyTranslucent: boolean;
        AddOrUpdateBlendable(InBlendableObject: BlendableInterface, InWeight?: number /* = 1.000000 */) : void;
        CaptureScene() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneCaptureComponent2D;
        static Load(InName: string): SceneCaptureComponent2D;
    }
    
    class SceneCapture2D extends UE.SceneCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CaptureComponent2D: UE.SceneCaptureComponent2D;
        OnInterpToggle(bEnable: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneCapture2D;
        static Load(InName: string): SceneCapture2D;
    }
    
    class OculusMR_PlaneMeshTriangle {
        constructor();
        constructor(Vertex0: UE.Vector, UV0: UE.Vector2D, Vertex1: UE.Vector, UV1: UE.Vector2D, Vertex2: UE.Vector, UV2: UE.Vector2D);
        Vertex0: UE.Vector;
        UV0: UE.Vector2D;
        Vertex1: UE.Vector;
        UV1: UE.Vector2D;
        Vertex2: UE.Vector;
        UV2: UE.Vector2D;
        static StaticClass(): Class;
    }
    
    class OculusMR_PlaneMeshComponent extends UE.MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddCustomMeshTriangles(Triangles: TArray<UE.OculusMR_PlaneMeshTriangle>) : void;
        ClearCustomMeshTriangles() : void;
        SetCustomMeshTriangles(Triangles: TArray<UE.OculusMR_PlaneMeshTriangle>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusMR_PlaneMeshComponent;
        static Load(InName: string): OculusMR_PlaneMeshComponent;
    }
    
    enum EOculusMR_ClippingReference { CR_TrackingReference, CR_Head, CR_MAX}
    enum EOculusMR_VirtualGreenScreenType { VGS_Off, VGS_OuterBoundary, VGS_PlayArea, VGS_MAX}
    enum EOculusMR_PostProcessEffects { PPE_Off, PPE_On, PPE_MAX}
    enum EOculusMR_CompositionMethod { ExternalComposition, DirectComposition, EOculusMR_MAX}
    enum EOculusMR_CameraDeviceEnum { CD_None, CD_WebCamera0, CD_WebCamera1, CD_ZEDCamera, CD_MAX}
    enum EOculusMR_DepthQuality { DQ_Low, DQ_Medium, DQ_High, DQ_MAX}
    class OculusMR_Settings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ClippingReference: UE.EOculusMR_ClippingReference;
        bUseTrackedCameraResolution: boolean;
        WidthPerView: number;
        HeightPerView: number;
        CastingLatency: number;
        BackdropColor: UE.Color;
        HandPoseStateLatency: number;
        ChromaKeyColor: UE.Color;
        ChromaKeySimilarity: number;
        ChromaKeySmoothRange: number;
        ChromaKeySpillRange: number;
        VirtualGreenScreenType: UE.EOculusMR_VirtualGreenScreenType;
        DynamicLightingDepthSmoothFactor: number;
        DynamicLightingDepthVariationClampingValue: number;
        ExternalCompositionPostProcessEffects: UE.EOculusMR_PostProcessEffects;
        bIsCasting: boolean;
        CompositionMethod: UE.EOculusMR_CompositionMethod;
        CapturingCamera: UE.EOculusMR_CameraDeviceEnum;
        bUseDynamicLighting: boolean;
        DepthQuality: UE.EOculusMR_DepthQuality;
        BindToTrackedCameraIndexIfAvailable(InTrackedCameraIndex: number) : void;
        GetBindToTrackedCameraIndex() : number;
        GetCapturingCamera() : UE.EOculusMR_CameraDeviceEnum;
        GetCompositionMethod() : UE.EOculusMR_CompositionMethod;
        GetDepthQuality() : UE.EOculusMR_DepthQuality;
        GetIsCasting() : boolean;
        GetUseDynamicLighting() : boolean;
        LoadFromIni() : void;
        SaveToIni() : void;
        SetCapturingCamera(val: UE.EOculusMR_CameraDeviceEnum) : void;
        SetCompositionMethod(val: UE.EOculusMR_CompositionMethod) : void;
        SetDepthQuality(val: UE.EOculusMR_DepthQuality) : void;
        SetIsCasting(val: boolean) : void;
        SetUseDynamicLighting(val: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusMR_Settings;
        static Load(InName: string): OculusMR_Settings;
    }
    
    class TrackedCamera {
        constructor();
        constructor(Index: number, Name: string, FieldOfView: number, SizeX: number, SizeY: number, AttachedTrackedDevice: UE.ETrackedDeviceType, CalibratedRotation: UE.Rotator, CalibratedOffset: UE.Vector, UserRotation: UE.Rotator, UserOffset: UE.Vector, RawRotation: UE.Rotator, RawOffset: UE.Vector);
        Index: number;
        Name: string;
        FieldOfView: number;
        SizeX: number;
        SizeY: number;
        AttachedTrackedDevice: UE.ETrackedDeviceType;
        CalibratedRotation: UE.Rotator;
        CalibratedOffset: UE.Vector;
        UserRotation: UE.Rotator;
        UserOffset: UE.Vector;
        RawRotation: UE.Rotator;
        RawOffset: UE.Vector;
        static StaticClass(): Class;
    }
    
    class OculusMR_State extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TrackedCamera: UE.TrackedCamera;
        TrackingReferenceComponent: UE.SceneComponent;
        ChangeCameraStateRequested: boolean;
        BindToTrackedCameraIndexRequested: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusMR_State;
        static Load(InName: string): OculusMR_State;
    }
    
    class OculusMR_CastingCameraActor extends UE.SceneCapture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VRNotificationComponent: UE.VRNotificationsComponent;
        CameraColorTexture: UE.Texture2D;
        CameraDepthTexture: UE.Texture2D;
        PlaneMeshComponent: UE.OculusMR_PlaneMeshComponent;
        ChromaKeyMaterial: UE.Material;
        ChromaKeyLitMaterial: UE.Material;
        OpaqueColoredMaterial: UE.Material;
        ChromaKeyMaterialInstance: UE.MaterialInstanceDynamic;
        ChromaKeyLitMaterialInstance: UE.MaterialInstanceDynamic;
        CameraFrameMaterialInstance: UE.MaterialInstanceDynamic;
        BackdropMaterialInstance: UE.MaterialInstanceDynamic;
        BoundaryActor: UE.OculusMR_BoundaryActor;
        BoundarySceneCaptureActor: UE.SceneCapture2D;
        DefaultTexture_White: UE.Texture2D;
        BackgroundRenderTargets: TArray<UE.TextureRenderTarget2D>;
        ForegroundCaptureActor: UE.SceneCapture2D;
        ForegroundRenderTargets: TArray<UE.TextureRenderTarget2D>;
        MRSettings: UE.OculusMR_Settings;
        MRState: UE.OculusMR_State;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusMR_CastingCameraActor;
        static Load(InName: string): OculusMR_CastingCameraActor;
    }
    
    class OculusMR_BoundaryMeshComponent extends UE.MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoundaryType: UE.EOculusMR_BoundaryType;
        BottomZ: number;
        TopZ: number;
        WhiteMaterial: UE.Material;
        CastingCameraActor: UE.OculusMR_CastingCameraActor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusMR_BoundaryMeshComponent;
        static Load(InName: string): OculusMR_BoundaryMeshComponent;
    }
    
    class OculusMR_BoundaryActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoundaryMeshComponent: UE.OculusMR_BoundaryMeshComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusMR_BoundaryActor;
        static Load(InName: string): OculusMR_BoundaryActor;
    }
    
    class OculusMRFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetOculusMRSettings() : UE.OculusMR_Settings;
        static GetTrackingReferenceComponent() : UE.SceneComponent;
        static IsMrcActive() : boolean;
        static IsMrcEnabled() : boolean;
        static SetTrackingReferenceComponent(Component: $Nullable<UE.SceneComponent>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusMRFunctionLibrary;
        static Load(InName: string): OculusMRFunctionLibrary;
    }
    
    class RedistPackage {
        constructor();
        constructor(Included: boolean, Name: string, Id: string);
        Included: boolean;
        Name: string;
        Id: string;
        static StaticClass(): Class;
    }
    
    enum EOculusPlatformTarget { Rift, Quest, Mobile, Length, EOculusPlatformTarget_MAX}
    enum EOculusGamepadEmulation { Off, Twinstick, RightDPad, LeftDPad, Length, EOculusGamepadEmulation_MAX}
    enum EOculusAssetType { Default, Store, Language_Pack, Length, EOculusAssetType_MAX}
    class AssetConfig {
        constructor();
        constructor(AssetType: UE.EOculusAssetType, Required: boolean, Name: string, Sku: string);
        AssetType: UE.EOculusAssetType;
        Required: boolean;
        Name: string;
        Sku: string;
        static StaticClass(): Class;
    }
    
    class AssetConfigArray {
        constructor();
        constructor(ConfigArray: TArray<UE.AssetConfig>);
        ConfigArray: TArray<UE.AssetConfig>;
        static StaticClass(): Class;
    }
    
    class OculusPlatformToolSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OculusRiftBuildDirectory: string;
        OculusRiftBuildVersion: string;
        OculusRiftLaunchParams: string;
        OculusRiftFireWallException: boolean;
        OculusRift2DLaunchPath: string;
        OculusRift2DLaunchParams: string;
        OculusRedistPackages: TArray<UE.RedistPackage>;
        OculusTargetPlatform: UE.EOculusPlatformTarget;
        OculusApplicationID: TArray<string>;
        OculusApplicationToken: TArray<string>;
        OculusReleaseChannel: TArray<string>;
        OculusReleaseNote: TArray<string>;
        OculusLaunchFilePath: TArray<string>;
        OculusRiftGamepadEmulation: UE.EOculusGamepadEmulation;
        OculusLanguagePacksPath: TArray<string>;
        OculusExpansionFilesPath: TArray<string>;
        OculusAssetConfigs: TArray<UE.AssetConfigArray>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusPlatformToolSettings;
        static Load(InName: string): OculusPlatformToolSettings;
    }
    
    class OculusSceneCaptureCubemap extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CaptureComponents: TArray<UE.SceneCaptureComponent2D>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusSceneCaptureCubemap;
        static Load(InName: string): OculusSceneCaptureCubemap;
    }
    
    class OnlineBeacon extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BeaconConnectionInitialTimeout: number;
        BeaconConnectionTimeout: number;
        NetDriver: UE.NetDriver;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineBeacon;
        static Load(InName: string): OnlineBeacon;
    }
    
    class OnlineBeaconHostObject extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BeaconTypeName: string;
        ClientBeaconActorClass: UE.Class;
        ClientActors: TArray<UE.OnlineBeaconClient>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineBeaconHostObject;
        static Load(InName: string): OnlineBeaconHostObject;
    }
    
    enum EBeaconConnectionState { Invalid, Closed, Pending, Open, EBeaconConnectionState_MAX}
    class OnlineBeaconClient extends UE.OnlineBeacon {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BeaconOwner: UE.OnlineBeaconHostObject;
        BeaconConnection: UE.NetConnection;
        ConnectionState: UE.EBeaconConnectionState;
        ClientOnConnected() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineBeaconClient;
        static Load(InName: string): OnlineBeaconClient;
    }
    
    class OnlineBeaconHost extends UE.OnlineBeacon {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ListenPort: number;
        ClientActors: TArray<UE.OnlineBeaconClient>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineBeaconHost;
        static Load(InName: string): OnlineBeaconHost;
    }
    
    class OnlineEngineInterface extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineEngineInterface;
        static Load(InName: string): OnlineEngineInterface;
    }
    
    class OnlineEngineInterfaceImpl extends UE.OnlineEngineInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VoiceSubsystemNameOverride: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineEngineInterfaceImpl;
        static Load(InName: string): OnlineEngineInterfaceImpl;
    }
    
    class PIELoginSettingsInternal {
        constructor();
        constructor(Id: string, Token: string, Type: string, TokenBytes: TArray<number>);
        Id: string;
        Token: string;
        Type: string;
        TokenBytes: TArray<number>;
        static StaticClass(): Class;
    }
    
    class OnlinePIESettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bOnlinePIEEnabled: boolean;
        Logins: TArray<UE.PIELoginSettingsInternal>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlinePIESettings;
        static Load(InName: string): OnlinePIESettings;
    }
    
    class OnlineSessionClient extends UE.OnlineSession {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsFromInvite: boolean;
        bHandlingDisconnect: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineSessionClient;
        static Load(InName: string): OnlineSessionClient;
    }
    
    enum EFieldOperationType { Field_Multiply, Field_Divide, Field_Add, Field_Substract, Field_Operation_Max}
    class OperatorField extends UE.FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        RightField: UE.FieldNodeBase;
        LeftField: UE.FieldNodeBase;
        Operation: UE.EFieldOperationType;
        SetOperatorField(Magnitude: number, RightField: $Nullable<UE.FieldNodeBase>, LeftField: $Nullable<UE.FieldNodeBase>, Operation: UE.EFieldOperationType) : UE.OperatorField;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OperatorField;
        static Load(InName: string): OperatorField;
    }
    
    class OverlaySlot extends UE.PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: UE.Margin;
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OverlaySlot;
        static Load(InName: string): OverlaySlot;
    }
    
    class Overlay extends UE.PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddChildToOverlay(Content: $Nullable<UE.Widget>) : UE.OverlaySlot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Overlay;
        static Load(InName: string): Overlay;
    }
    
    class PackageFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PackageFactory;
        static Load(InName: string): PackageFactory;
    }
    
    class PackageMapClient extends UE.PackageMap {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PackageMapClient;
        static Load(InName: string): PackageMapClient;
    }
    
    class PackageTools extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SanitizePackageName(InPackageName: string) : string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PackageTools;
        static Load(InName: string): PackageTools;
    }
    
    class PackedVectorTest extends UE.UnitTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PackedVectorTest;
        static Load(InName: string): PackedVectorTest;
    }
    
    class PacketHandlerProfileConfig extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Components: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PacketHandlerProfileConfig;
        static Load(InName: string): PacketHandlerProfileConfig;
    }
    
    class PackFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PackFactory;
        static Load(InName: string): PackFactory;
    }
    
    class PainCausingVolume extends UE.PhysicsVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bPainCausing: boolean;
        DamagePerSec: number;
        DamageType: UE.Class;
        PainInterval: number;
        bEntryPain: boolean;
        BACKUP_bPainCausing: boolean;
        DamageInstigator: UE.Controller;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PainCausingVolume;
        static Load(InName: string): PainCausingVolume;
    }
    
    enum EMeshPaintColorViewMode { Normal, RGB, Alpha, Red, Green, Blue, EMeshPaintColorViewMode_MAX}
    class PaintBrushSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BrushRadius: number;
        BrushStrength: number;
        BrushFalloffAmount: number;
        bEnableFlow: boolean;
        bOnlyFrontFacingTriangles: boolean;
        ColorViewMode: UE.EMeshPaintColorViewMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaintBrushSettings;
        static Load(InName: string): PaintBrushSettings;
    }
    
    enum EPaintMode { Vertices, Textures, EPaintMode_MAX}
    enum EMeshPaintMode { PaintColors, PaintWeights, EMeshPaintMode_MAX}
    enum ETextureWeightTypes { AlphaLerp, RGB, ARGB, OneMinusARGB, ETextureWeightTypes_MAX}
    enum ETexturePaintIndex { TextureOne, TextureTwo, TextureThree, TextureFour, TextureFive, ETexturePaintIndex_MAX}
    class VertexPaintSettings {
        constructor();
        constructor(MeshPaintMode: UE.EMeshPaintMode, PaintColor: UE.LinearColor, EraseColor: UE.LinearColor, bWriteRed: boolean, bWriteGreen: boolean, bWriteBlue: boolean, bWriteAlpha: boolean, TextureWeightType: UE.ETextureWeightTypes, PaintTextureWeightIndex: UE.ETexturePaintIndex, EraseTextureWeightIndex: UE.ETexturePaintIndex, bPaintOnSpecificLOD: boolean, LODIndex: number);
        MeshPaintMode: UE.EMeshPaintMode;
        PaintColor: UE.LinearColor;
        EraseColor: UE.LinearColor;
        bWriteRed: boolean;
        bWriteGreen: boolean;
        bWriteBlue: boolean;
        bWriteAlpha: boolean;
        TextureWeightType: UE.ETextureWeightTypes;
        PaintTextureWeightIndex: UE.ETexturePaintIndex;
        EraseTextureWeightIndex: UE.ETexturePaintIndex;
        bPaintOnSpecificLOD: boolean;
        LODIndex: number;
        static StaticClass(): Class;
    }
    
    class TexturePaintSettings {
        constructor();
        constructor(PaintColor: UE.LinearColor, EraseColor: UE.LinearColor, bWriteRed: boolean, bWriteGreen: boolean, bWriteBlue: boolean, bWriteAlpha: boolean, UVChannel: number, bEnableSeamPainting: boolean, PaintTexture: UE.Texture2D);
        PaintColor: UE.LinearColor;
        EraseColor: UE.LinearColor;
        bWriteRed: boolean;
        bWriteGreen: boolean;
        bWriteBlue: boolean;
        bWriteAlpha: boolean;
        UVChannel: number;
        bEnableSeamPainting: boolean;
        PaintTexture: UE.Texture2D;
        static StaticClass(): Class;
    }
    
    class PaintModeSettings extends UE.MeshPaintSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PaintMode: UE.EPaintMode;
        VertexPaintSettings: UE.VertexPaintSettings;
        TexturePaintSettings: UE.TexturePaintSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaintModeSettings;
        static Load(InName: string): PaintModeSettings;
    }
    
    class PaperSpriteSocket {
        constructor();
        constructor(LocalTransform: UE.Transform, SocketName: string);
        LocalTransform: UE.Transform;
        SocketName: string;
        static StaticClass(): Class;
    }
    
    enum ESpriteCollisionMode { None, Use2DPhysics, Use3DPhysics, ESpriteCollisionMode_MAX}
    enum ESpritePivotMode { Top_Left, Top_Center, Top_Right, Center_Left, Center_Center, Center_Right, Bottom_Left, Bottom_Center, Bottom_Right, Custom, ESpritePivotMode_MAX}
    enum ESpriteShapeType { Box, Circle, Polygon, ESpriteShapeType_MAX}
    class SpriteGeometryShape {
        constructor();
        constructor(ShapeType: UE.ESpriteShapeType, Vertices: TArray<UE.Vector2D>, BoxSize: UE.Vector2D, BoxPosition: UE.Vector2D, Rotation: number, bNegativeWinding: boolean);
        ShapeType: UE.ESpriteShapeType;
        Vertices: TArray<UE.Vector2D>;
        BoxSize: UE.Vector2D;
        BoxPosition: UE.Vector2D;
        Rotation: number;
        bNegativeWinding: boolean;
        static StaticClass(): Class;
    }
    
    enum ESpritePolygonMode { SourceBoundingBox, TightBoundingBox, ShrinkWrapped, FullyCustom, Diced, ESpritePolygonMode_MAX}
    class SpriteGeometryCollection {
        constructor();
        constructor(Shapes: TArray<UE.SpriteGeometryShape>, GeometryType: UE.ESpritePolygonMode, PixelsPerSubdivisionX: number, PixelsPerSubdivisionY: number, bAvoidVertexMerging: boolean, AlphaThreshold: number, DetailAmount: number, SimplifyEpsilon: number);
        Shapes: TArray<UE.SpriteGeometryShape>;
        GeometryType: UE.ESpritePolygonMode;
        PixelsPerSubdivisionX: number;
        PixelsPerSubdivisionY: number;
        bAvoidVertexMerging: boolean;
        AlphaThreshold: number;
        DetailAmount: number;
        SimplifyEpsilon: number;
        static StaticClass(): Class;
    }
    
    enum EPaperSpriteAtlasPadding { DilateBorder, PadWithZero, EPaperSpriteAtlasPadding_MAX}
    class PaperSpriteAtlasSlot {
        constructor();
        constructor(SpriteRef: TSoftObjectPtr<UE.PaperSprite>, AtlasIndex: number, X: number, Y: number, Width: number, Height: number);
        SpriteRef: TSoftObjectPtr<UE.PaperSprite>;
        AtlasIndex: number;
        X: number;
        Y: number;
        Width: number;
        Height: number;
        static StaticClass(): Class;
    }
    
    class PaperSpriteAtlas extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AtlasDescription: string;
        MaxWidth: number;
        MaxHeight: number;
        MipCount: number;
        PaddingType: UE.EPaperSpriteAtlasPadding;
        Padding: number;
        CompressionSettings: UE.TextureCompressionSettings;
        Filter: UE.TextureFilter;
        GeneratedTextures: TArray<UE.Texture>;
        AtlasGUID: UE.Guid;
        bRebuildAtlas: boolean;
        AtlasSlots: TArray<UE.PaperSpriteAtlasSlot>;
        NumIncrementalBuilds: number;
        BuiltWidth: number;
        BuiltHeight: number;
        BuiltPadding: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteAtlas;
        static Load(InName: string): PaperSpriteAtlas;
    }
    
    class PaperSprite extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OriginInSourceImageBeforeTrimming: UE.Vector2D;
        SourceImageDimensionBeforeTrimming: UE.Vector2D;
        bTrimmedInSourceImage: boolean;
        bRotatedInSourceImage: boolean;
        SourceTextureDimension: UE.Vector2D;
        SourceUV: UE.Vector2D;
        SourceDimension: UE.Vector2D;
        SourceTexture: TSoftObjectPtr<UE.Texture2D>;
        SourceTextureCacheNeverSerialized: UE.Texture2D;
        AdditionalSourceTextures: TArray<UE.Texture>;
        BakedSourceUV: UE.Vector2D;
        BakedSourceDimension: UE.Vector2D;
        BakedSourceTexture: UE.Texture2D;
        DefaultMaterial: UE.MaterialInterface;
        AlternateMaterial: UE.MaterialInterface;
        Sockets: TArray<UE.PaperSpriteSocket>;
        SpriteCollisionDomain: UE.ESpriteCollisionMode;
        PixelsPerUnrealUnit: number;
        BodySetup: UE.BodySetup;
        PivotMode: UE.ESpritePivotMode;
        CustomPivotPoint: UE.Vector2D;
        bSnapPivotToPixelGrid: boolean;
        CollisionGeometry: UE.SpriteGeometryCollection;
        CollisionThickness: number;
        RenderGeometry: UE.SpriteGeometryCollection;
        AtlasGroup: UE.PaperSpriteAtlas;
        AlternateMaterialSplitIndex: number;
        BakedRenderData: TArray<UE.Vector4>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSprite;
        static Load(InName: string): PaperSprite;
    }
    
    class PaperFlipbookKeyFrame {
        constructor();
        constructor(Sprite: UE.PaperSprite, FrameRun: number);
        Sprite: UE.PaperSprite;
        FrameRun: number;
        static StaticClass(): Class;
    }
    
    enum EFlipbookCollisionMode { NoCollision, FirstFrameCollision, EachFrameCollision, EFlipbookCollisionMode_MAX}
    class PaperFlipbook extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FramesPerSecond: number;
        KeyFrames: TArray<UE.PaperFlipbookKeyFrame>;
        DefaultMaterial: UE.MaterialInterface;
        CollisionSource: UE.EFlipbookCollisionMode;
        GetKeyFrameIndexAtTime(Time: number, bClampToEnds?: boolean /* = false */) : number;
        GetNumFrames() : number;
        GetNumKeyFrames() : number;
        GetSpriteAtFrame(FrameIndex: number) : UE.PaperSprite;
        GetSpriteAtTime(Time: number, bClampToEnds?: boolean /* = false */) : UE.PaperSprite;
        GetTotalDuration() : number;
        IsValidKeyFrameIndex(Index: number) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperFlipbook;
        static Load(InName: string): PaperFlipbook;
    }
    
    class PaperFlipbookComponent extends UE.MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceFlipbook: UE.PaperFlipbook;
        Material: UE.MaterialInterface;
        PlayRate: number;
        bLooping: boolean;
        bReversePlayback: boolean;
        bPlaying: boolean;
        AccumulatedTime: number;
        CachedFrameIndex: number;
        SpriteColor: UE.LinearColor;
        CachedBodySetup: UE.BodySetup;
        OnFinishedPlaying: $MulticastDelegate<() => void>;
        GetFlipbook() : UE.PaperFlipbook;
        GetFlipbookFramerate() : number;
        GetFlipbookLength() : number;
        GetFlipbookLengthInFrames() : number;
        GetPlaybackPosition() : number;
        GetPlaybackPositionInFrames() : number;
        GetPlayRate() : number;
        IsLooping() : boolean;
        IsPlaying() : boolean;
        IsReversing() : boolean;
        OnRep_SourceFlipbook(OldFlipbook: $Nullable<UE.PaperFlipbook>) : void;
        Play() : void;
        PlayFromStart() : void;
        Reverse() : void;
        ReverseFromEnd() : void;
        SetFlipbook(NewFlipbook: $Nullable<UE.PaperFlipbook>) : boolean;
        SetLooping(bNewLooping: boolean) : void;
        SetNewTime(NewTime: number) : void;
        SetPlaybackPosition(NewPosition: number, bFireEvents: boolean) : void;
        SetPlaybackPositionInFrames(NewFramePosition: number, bFireEvents: boolean) : void;
        SetPlayRate(NewRate: number) : void;
        SetSpriteColor(NewColor: UE.LinearColor) : void;
        Stop() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperFlipbookComponent;
        static Load(InName: string): PaperFlipbookComponent;
    }
    
    class PaperCharacter extends UE.Character {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sprite: UE.PaperFlipbookComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperCharacter;
        static Load(InName: string): PaperCharacter;
    }
    
    class PaperExtractSpriteGridSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CellWidth: number;
        CellHeight: number;
        NumCellsX: number;
        NumCellsY: number;
        MarginX: number;
        MarginY: number;
        SpacingX: number;
        SpacingY: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperExtractSpriteGridSettings;
        static Load(InName: string): PaperExtractSpriteGridSettings;
    }
    
    enum ESpriteExtractMode { Auto, Grid, ESpriteExtractMode_MAX}
    class PaperExtractSpritesSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpriteExtractMode: UE.ESpriteExtractMode;
        OutlineColor: UE.LinearColor;
        ViewportTextureTint: UE.LinearColor;
        BackgroundColor: UE.LinearColor;
        NamingTemplate: string;
        NamingStartIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperExtractSpritesSettings;
        static Load(InName: string): PaperExtractSpritesSettings;
    }
    
    class PaperFlipbookActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenderComponent: UE.PaperFlipbookComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperFlipbookActor;
        static Load(InName: string): PaperFlipbookActor;
    }
    
    class PaperFlipbookActorFactory extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperFlipbookActorFactory;
        static Load(InName: string): PaperFlipbookActorFactory;
    }
    
    class PaperFlipbookFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperFlipbookFactory;
        static Load(InName: string): PaperFlipbookFactory;
    }
    
    class PaperSpriteThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteThumbnailRenderer;
        static Load(InName: string): PaperSpriteThumbnailRenderer;
    }
    
    class PaperFlipbookThumbnailRenderer extends UE.PaperSpriteThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperFlipbookThumbnailRenderer;
        static Load(InName: string): PaperFlipbookThumbnailRenderer;
    }
    
    class SpriteInstanceData {
        constructor();
        constructor(Transform: UE.Matrix, SourceSprite: UE.PaperSprite, VertexColor: UE.Color, MaterialIndex: number);
        Transform: UE.Matrix;
        SourceSprite: UE.PaperSprite;
        VertexColor: UE.Color;
        MaterialIndex: number;
        static StaticClass(): Class;
    }
    
    class PaperGroupedSpriteComponent extends UE.MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InstanceMaterials: TArray<UE.MaterialInterface>;
        PerInstanceSpriteData: TArray<UE.SpriteInstanceData>;
        AddInstance(Transform: UE.Transform, Sprite: $Nullable<UE.PaperSprite>, bWorldSpace?: boolean /* = false */, Color?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */) : number;
        ClearInstances() : void;
        GetInstanceCount() : number;
        GetInstanceTransform(InstanceIndex: number, OutInstanceTransform: $Ref<UE.Transform>, bWorldSpace?: boolean /* = false */) : boolean;
        RemoveInstance(InstanceIndex: number) : boolean;
        SortInstancesAlongAxis(WorldSpaceSortAxis: UE.Vector) : void;
        UpdateInstanceColor(InstanceIndex: number, NewInstanceColor: UE.LinearColor, bMarkRenderStateDirty?: boolean /* = true */) : boolean;
        UpdateInstanceTransform(InstanceIndex: number, NewInstanceTransform: UE.Transform, bWorldSpace?: boolean /* = false */, bMarkRenderStateDirty?: boolean /* = true */, bTeleport?: boolean /* = false */) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperGroupedSpriteComponent;
        static Load(InName: string): PaperGroupedSpriteComponent;
    }
    
    class PaperGroupedSpriteActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenderComponent: UE.PaperGroupedSpriteComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperGroupedSpriteActor;
        static Load(InName: string): PaperGroupedSpriteActor;
    }
    
    class PaperImporterSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bPickBestMaterialWhenCreatingSprites: boolean;
        bPickBestMaterialWhenCreatingTileMaps: boolean;
        bAnalysisCanUseOpaque: boolean;
        DefaultPixelsPerUnrealUnit: number;
        NormalMapTextureSuffixes: TArray<string>;
        BaseMapTextureSuffixes: TArray<string>;
        DefaultSpriteTextureGroup: UE.TextureGroup;
        bOverrideTextureCompression: boolean;
        DefaultSpriteTextureCompression: UE.TextureCompressionSettings;
        UnlitDefaultMaskedMaterialName: UE.SoftObjectPath;
        UnlitDefaultTranslucentMaterialName: UE.SoftObjectPath;
        UnlitDefaultOpaqueMaterialName: UE.SoftObjectPath;
        LitDefaultMaskedMaterialName: UE.SoftObjectPath;
        LitDefaultTranslucentMaterialName: UE.SoftObjectPath;
        LitDefaultOpaqueMaterialName: UE.SoftObjectPath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperImporterSettings;
        static Load(InName: string): PaperImporterSettings;
    }
    
    class PaperRuntimeSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnableSpriteAtlasGroups: boolean;
        bEnableTerrainSplineEditing: boolean;
        bResizeSpriteDataToMatchTextures: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperRuntimeSettings;
        static Load(InName: string): PaperRuntimeSettings;
    }
    
    class PaperSpriteComponent extends UE.MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceSprite: UE.PaperSprite;
        MaterialOverride: UE.MaterialInterface;
        SpriteColor: UE.LinearColor;
        GetSprite() : UE.PaperSprite;
        SetSprite(NewSprite: $Nullable<UE.PaperSprite>) : boolean;
        SetSpriteColor(NewColor: UE.LinearColor) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteComponent;
        static Load(InName: string): PaperSpriteComponent;
    }
    
    class PaperSpriteActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenderComponent: UE.PaperSpriteComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteActor;
        static Load(InName: string): PaperSpriteActor;
    }
    
    class PaperSpriteActorFactory extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteActorFactory;
        static Load(InName: string): PaperSpriteActorFactory;
    }
    
    class PaperSpriteAtlasFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteAtlasFactory;
        static Load(InName: string): PaperSpriteAtlasFactory;
    }
    
    class PaperSpriteBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static MakeBrushFromSprite(Sprite: $Nullable<UE.PaperSprite>, Width: number, Height: number) : UE.SlateBrush;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteBlueprintLibrary;
        static Load(InName: string): PaperSpriteBlueprintLibrary;
    }
    
    class PaperSpriteFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteFactory;
        static Load(InName: string): PaperSpriteFactory;
    }
    
    class PaperSpriteSheet extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpriteNames: TArray<string>;
        Sprites: TArray<TSoftObjectPtr<UE.PaperSprite>>;
        TextureName: string;
        Texture: UE.Texture2D;
        NormalMapTextureName: string;
        NormalMapTexture: UE.Texture2D;
        AssetImportData: UE.AssetImportData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteSheet;
        static Load(InName: string): PaperSpriteSheet;
    }
    
    class PaperSpriteSheetImportFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteSheetImportFactory;
        static Load(InName: string): PaperSpriteSheetImportFactory;
    }
    
    class PaperSpriteSheetReimportFactory extends UE.PaperSpriteSheetImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteSheetReimportFactory;
        static Load(InName: string): PaperSpriteSheetReimportFactory;
    }
    
    class PaperTerrainSplineComponent extends UE.SplineComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTerrainSplineComponent;
        static Load(InName: string): PaperTerrainSplineComponent;
    }
    
    class PaperTerrainMaterialRule {
        constructor();
        constructor(StartCap: UE.PaperSprite, Body: TArray<UE.PaperSprite>, EndCap: UE.PaperSprite, MinimumAngle: number, MaximumAngle: number, bEnableCollision: boolean, CollisionOffset: number, DrawOrder: number, Description: string);
        StartCap: UE.PaperSprite;
        Body: TArray<UE.PaperSprite>;
        EndCap: UE.PaperSprite;
        MinimumAngle: number;
        MaximumAngle: number;
        bEnableCollision: boolean;
        CollisionOffset: number;
        DrawOrder: number;
        Description: string;
        static StaticClass(): Class;
    }
    
    class PaperTerrainMaterial extends UE.DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Rules: TArray<UE.PaperTerrainMaterialRule>;
        InteriorFill: UE.PaperSprite;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTerrainMaterial;
        static Load(InName: string): PaperTerrainMaterial;
    }
    
    class PaperTerrainComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TerrainMaterial: UE.PaperTerrainMaterial;
        bClosedSpline: boolean;
        bFilledSpline: boolean;
        AssociatedSpline: UE.PaperTerrainSplineComponent;
        RandomSeed: number;
        SegmentOverlapAmount: number;
        TerrainColor: UE.LinearColor;
        ReparamStepsPerSegment: number;
        SpriteCollisionDomain: UE.ESpriteCollisionMode;
        CollisionThickness: number;
        CachedBodySetup: UE.BodySetup;
        SetTerrainColor(NewColor: UE.LinearColor) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTerrainComponent;
        static Load(InName: string): PaperTerrainComponent;
    }
    
    class PaperTerrainActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DummyRoot: UE.SceneComponent;
        SplineComponent: UE.PaperTerrainSplineComponent;
        RenderComponent: UE.PaperTerrainComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTerrainActor;
        static Load(InName: string): PaperTerrainActor;
    }
    
    class PaperTiledImporterFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTiledImporterFactory;
        static Load(InName: string): PaperTiledImporterFactory;
    }
    
    class IntMargin {
        constructor();
        constructor(Left: number, Top: number, Right: number, Bottom: number);
        Left: number;
        Top: number;
        Right: number;
        Bottom: number;
        static StaticClass(): Class;
    }
    
    class PaperTileMetadata {
        constructor();
        constructor(UserDataName: string, CollisionData: UE.SpriteGeometryCollection, TerrainMembership: FixSizeArray<number>);
        UserDataName: string;
        CollisionData: UE.SpriteGeometryCollection;
        TerrainMembership: FixSizeArray<number>;
        static StaticClass(): Class;
    }
    
    class PaperTileSetTerrain {
        constructor();
        constructor(TerrainName: string, CenterTileIndex: number);
        TerrainName: string;
        CenterTileIndex: number;
        static StaticClass(): Class;
    }
    
    class PaperTileSet extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TileSize: UE.IntPoint;
        TileSheet: UE.Texture2D;
        AdditionalSourceTextures: TArray<UE.Texture>;
        BorderMargin: UE.IntMargin;
        PerTileSpacing: UE.IntPoint;
        DrawingOffset: UE.IntPoint;
        BackgroundColor: UE.LinearColor;
        WidthInTiles: number;
        HeightInTiles: number;
        AllocatedWidth: number;
        AllocatedHeight: number;
        PerTileData: TArray<UE.PaperTileMetadata>;
        Terrains: TArray<UE.PaperTileSetTerrain>;
        TileWidth: number;
        TileHeight: number;
        Margin: number;
        Spacing: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileSet;
        static Load(InName: string): PaperTileSet;
    }
    
    class PaperTileInfo {
        constructor();
        constructor(TileSet: UE.PaperTileSet, PackedTileIndex: number);
        TileSet: UE.PaperTileSet;
        PackedTileIndex: number;
        static StaticClass(): Class;
    }
    
    class PaperTileLayer extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LayerName: string;
        LayerWidth: number;
        LayerHeight: number;
        bHiddenInEditor: boolean;
        bHiddenInGame: boolean;
        bLayerCollides: boolean;
        bOverrideCollisionThickness: boolean;
        bOverrideCollisionOffset: boolean;
        CollisionThicknessOverride: number;
        CollisionOffsetOverride: number;
        LayerColor: UE.LinearColor;
        AllocatedWidth: number;
        AllocatedHeight: number;
        AllocatedCells: TArray<UE.PaperTileInfo>;
        TileSet: UE.PaperTileSet;
        AllocatedGrid: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileLayer;
        static Load(InName: string): PaperTileLayer;
    }
    
    enum ETileMapProjectionMode { Orthogonal, IsometricDiamond, IsometricStaggered, HexagonalStaggered, ETileMapProjectionMode_MAX}
    class PaperTileMap extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MapWidth: number;
        MapHeight: number;
        TileWidth: number;
        TileHeight: number;
        PixelsPerUnrealUnit: number;
        SeparationPerTileX: number;
        SeparationPerTileY: number;
        SeparationPerLayer: number;
        SelectedTileSet: TSoftObjectPtr<UE.PaperTileSet>;
        Material: UE.MaterialInterface;
        TileLayers: TArray<UE.PaperTileLayer>;
        CollisionThickness: number;
        SpriteCollisionDomain: UE.ESpriteCollisionMode;
        ProjectionMode: UE.ETileMapProjectionMode;
        HexSideLength: number;
        BodySetup: UE.BodySetup;
        AssetImportData: UE.AssetImportData;
        SelectedLayerIndex: number;
        BackgroundColor: UE.LinearColor;
        TileGridColor: UE.LinearColor;
        MultiTileGridColor: UE.LinearColor;
        MultiTileGridWidth: number;
        MultiTileGridHeight: number;
        MultiTileGridOffsetX: number;
        MultiTileGridOffsetY: number;
        LayerGridColor: UE.LinearColor;
        LayerNameIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileMap;
        static Load(InName: string): PaperTileMap;
    }
    
    class PaperTileMapComponent extends UE.MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MapWidth: number;
        MapHeight: number;
        TileWidth: number;
        TileHeight: number;
        DefaultLayerTileSet: UE.PaperTileSet;
        Material: UE.MaterialInterface;
        TileLayers: TArray<UE.PaperTileLayer>;
        TileMapColor: UE.LinearColor;
        UseSingleLayerIndex: number;
        bUseSingleLayer: boolean;
        TileMap: UE.PaperTileMap;
        bShowPerTileGridWhenSelected: boolean;
        bShowPerLayerGridWhenSelected: boolean;
        bShowOutlineWhenUnselected: boolean;
        bShowPerTileGridWhenUnselected: boolean;
        bShowPerLayerGridWhenUnselected: boolean;
        AddNewLayer() : UE.PaperTileLayer;
        CreateNewTileMap(MapWidth?: number /* = 4 */, MapHeight?: number /* = 4 */, TileWidth?: number /* = 32 */, TileHeight?: number /* = 32 */, PixelsPerUnrealUnit?: number /* = 1.000000 */, bCreateLayer?: boolean /* = true */) : void;
        GetLayerColor(Layer?: number /* = 0 */) : UE.LinearColor;
        GetMapSize(MapWidth: $Ref<number>, MapHeight: $Ref<number>, NumLayers: $Ref<number>) : void;
        GetTile(X: number, Y: number, Layer: number) : UE.PaperTileInfo;
        GetTileCenterPosition(TileX: number, TileY: number, LayerIndex?: number /* = 0 */, bWorldSpace?: boolean /* = false */) : UE.Vector;
        GetTileCornerPosition(TileX: number, TileY: number, LayerIndex?: number /* = 0 */, bWorldSpace?: boolean /* = false */) : UE.Vector;
        GetTileMapColor() : UE.LinearColor;
        GetTilePolygon(TileX: number, TileY: number, Points: $Ref<TArray<UE.Vector>>, LayerIndex?: number /* = 0 */, bWorldSpace?: boolean /* = false */) : void;
        MakeTileMapEditable() : void;
        OwnsTileMap() : boolean;
        RebuildCollision() : void;
        ResizeMap(NewWidthInTiles: number, NewHeightInTiles: number) : void;
        SetDefaultCollisionThickness(Thickness: number, bRebuildCollision?: boolean /* = true */) : void;
        SetLayerCollision(Layer?: number /* = 0 */, bHasCollision?: boolean /* = true */, bOverrideThickness?: boolean /* = true */, CustomThickness?: number /* = 50.000000 */, bOverrideOffset?: boolean /* = false */, CustomOffset?: number /* = 0.000000 */, bRebuildCollision?: boolean /* = true */) : void;
        SetLayerColor(NewColor: UE.LinearColor, Layer?: number /* = 0 */) : void;
        SetTile(X: number, Y: number, Layer: number, NewValue: UE.PaperTileInfo) : void;
        SetTileMap(NewTileMap: $Nullable<UE.PaperTileMap>) : boolean;
        SetTileMapColor(NewColor: UE.LinearColor) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileMapComponent;
        static Load(InName: string): PaperTileMapComponent;
    }
    
    class PaperTileMapActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenderComponent: UE.PaperTileMapComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileMapActor;
        static Load(InName: string): PaperTileMapActor;
    }
    
    class PaperTileMapFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileMapFactory;
        static Load(InName: string): PaperTileMapFactory;
    }
    
    class PaperTileMapPromotionFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssetToRename: UE.PaperTileMap;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileMapPromotionFactory;
        static Load(InName: string): PaperTileMapPromotionFactory;
    }
    
    class PaperTileSetFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileSetFactory;
        static Load(InName: string): PaperTileSetFactory;
    }
    
    class PaperTileSetThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileSetThumbnailRenderer;
        static Load(InName: string): PaperTileSetThumbnailRenderer;
    }
    
    class ParticleModuleAccelerationBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAlwaysInWorldSpace: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAccelerationBase;
        static Load(InName: string): ParticleModuleAccelerationBase;
    }
    
    class ParticleModuleAcceleration extends UE.ParticleModuleAccelerationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Acceleration: UE.RawDistributionVector;
        bApplyOwnerScale: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAcceleration;
        static Load(InName: string): ParticleModuleAcceleration;
    }
    
    class ParticleModuleAccelerationConstant extends UE.ParticleModuleAccelerationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Acceleration: UE.Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAccelerationConstant;
        static Load(InName: string): ParticleModuleAccelerationConstant;
    }
    
    class ParticleModuleAccelerationDrag extends UE.ParticleModuleAccelerationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DragCoefficient: UE.DistributionFloat;
        DragCoefficientRaw: UE.RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAccelerationDrag;
        static Load(InName: string): ParticleModuleAccelerationDrag;
    }
    
    class ParticleModuleAccelerationDragScaleOverLife extends UE.ParticleModuleAccelerationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DragScale: UE.DistributionFloat;
        DragScaleRaw: UE.RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAccelerationDragScaleOverLife;
        static Load(InName: string): ParticleModuleAccelerationDragScaleOverLife;
    }
    
    class ParticleModuleAccelerationOverLifetime extends UE.ParticleModuleAccelerationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AccelOverLife: UE.RawDistributionVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAccelerationOverLifetime;
        static Load(InName: string): ParticleModuleAccelerationOverLifetime;
    }
    
    class ParticleModuleAttractorBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAttractorBase;
        static Load(InName: string): ParticleModuleAttractorBase;
    }
    
    class ParticleModuleAttractorLine extends UE.ParticleModuleAttractorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EndPoint0: UE.Vector;
        EndPoint1: UE.Vector;
        Range: UE.RawDistributionFloat;
        Strength: UE.RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAttractorLine;
        static Load(InName: string): ParticleModuleAttractorLine;
    }
    
    enum EAttractorParticleSelectionMethod { EAPSM_Random, EAPSM_Sequential, EAPSM_MAX}
    class ParticleModuleAttractorParticle extends UE.ParticleModuleAttractorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EmitterName: string;
        Range: UE.RawDistributionFloat;
        bStrengthByDistance: boolean;
        Strength: UE.RawDistributionFloat;
        bAffectBaseVelocity: boolean;
        SelectionMethod: UE.EAttractorParticleSelectionMethod;
        bRenewSource: boolean;
        bInheritSourceVel: boolean;
        LastSelIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAttractorParticle;
        static Load(InName: string): ParticleModuleAttractorParticle;
    }
    
    class ParticleModuleAttractorPoint extends UE.ParticleModuleAttractorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Position: UE.RawDistributionVector;
        Range: UE.RawDistributionFloat;
        Strength: UE.RawDistributionFloat;
        StrengthByDistance: boolean;
        bAffectBaseVelocity: boolean;
        bOverrideVelocity: boolean;
        bUseWorldSpacePosition: boolean;
        Positive_X: boolean;
        Positive_Y: boolean;
        Positive_Z: boolean;
        Negative_X: boolean;
        Negative_Y: boolean;
        Negative_Z: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAttractorPoint;
        static Load(InName: string): ParticleModuleAttractorPoint;
    }
    
    class ParticleModuleAttractorPointGravity extends UE.ParticleModuleAttractorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Position: UE.Vector;
        Radius: number;
        Strength: UE.DistributionFloat;
        StrengthRaw: UE.RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAttractorPointGravity;
        static Load(InName: string): ParticleModuleAttractorPointGravity;
    }
    
    class ParticleModuleBeamBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleBeamBase;
        static Load(InName: string): ParticleModuleBeamBase;
    }
    
    enum BeamModifierType { PEB2MT_Source, PEB2MT_Target, PEB2MT_MAX}
    class BeamModifierOptions {
        constructor();
        constructor(bModify: boolean, bScale: boolean, bLock: boolean);
        bModify: boolean;
        bScale: boolean;
        bLock: boolean;
        static StaticClass(): Class;
    }
    
    class ParticleModuleBeamModifier extends UE.ParticleModuleBeamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ModifierType: UE.BeamModifierType;
        PositionOptions: UE.BeamModifierOptions;
        Position: UE.RawDistributionVector;
        TangentOptions: UE.BeamModifierOptions;
        Tangent: UE.RawDistributionVector;
        bAbsoluteTangent: boolean;
        StrengthOptions: UE.BeamModifierOptions;
        Strength: UE.RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleBeamModifier;
        static Load(InName: string): ParticleModuleBeamModifier;
    }
    
    class ParticleModuleBeamNoise extends UE.ParticleModuleBeamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bLowFreq_Enabled: boolean;
        Frequency: number;
        Frequency_LowRange: number;
        NoiseRange: UE.RawDistributionVector;
        NoiseRangeScale: UE.RawDistributionFloat;
        bNRScaleEmitterTime: boolean;
        NoiseSpeed: UE.RawDistributionVector;
        bSmooth: boolean;
        NoiseLockRadius: number;
        bNoiseLock: boolean;
        bOscillate: boolean;
        NoiseLockTime: number;
        NoiseTension: number;
        bUseNoiseTangents: boolean;
        NoiseTangentStrength: UE.RawDistributionFloat;
        NoiseTessellation: number;
        bTargetNoise: boolean;
        FrequencyDistance: number;
        bApplyNoiseScale: boolean;
        NoiseScale: UE.RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleBeamNoise;
        static Load(InName: string): ParticleModuleBeamNoise;
    }
    
    enum Beam2SourceTargetMethod { PEB2STM_Default, PEB2STM_UserSet, PEB2STM_Emitter, PEB2STM_Particle, PEB2STM_Actor, PEB2STM_MAX}
    enum Beam2SourceTargetTangentMethod { PEB2STTM_Direct, PEB2STTM_UserSet, PEB2STTM_Distribution, PEB2STTM_Emitter, PEB2STTM_MAX}
    class ParticleModuleBeamSource extends UE.ParticleModuleBeamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceMethod: UE.Beam2SourceTargetMethod;
        SourceName: string;
        bSourceAbsolute: boolean;
        Source: UE.RawDistributionVector;
        bLockSource: boolean;
        SourceTangentMethod: UE.Beam2SourceTargetTangentMethod;
        SourceTangent: UE.RawDistributionVector;
        bLockSourceTangent: boolean;
        SourceStrength: UE.RawDistributionFloat;
        bLockSourceStength: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleBeamSource;
        static Load(InName: string): ParticleModuleBeamSource;
    }
    
    class ParticleModuleBeamTarget extends UE.ParticleModuleBeamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetMethod: UE.Beam2SourceTargetMethod;
        TargetName: string;
        Target: UE.RawDistributionVector;
        bTargetAbsolute: boolean;
        bLockTarget: boolean;
        TargetTangentMethod: UE.Beam2SourceTargetTangentMethod;
        TargetTangent: UE.RawDistributionVector;
        bLockTargetTangent: boolean;
        TargetStrength: UE.RawDistributionFloat;
        bLockTargetStength: boolean;
        LockRadius: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleBeamTarget;
        static Load(InName: string): ParticleModuleBeamTarget;
    }
    
    class ParticleModuleCameraBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleCameraBase;
        static Load(InName: string): ParticleModuleCameraBase;
    }
    
    enum EParticleCameraOffsetUpdateMethod { EPCOUM_DirectSet, EPCOUM_Additive, EPCOUM_Scalar, EPCOUM_MAX}
    class ParticleModuleCameraOffset extends UE.ParticleModuleCameraBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CameraOffset: UE.RawDistributionFloat;
        bSpawnTimeOnly: boolean;
        UpdateMethod: UE.EParticleCameraOffsetUpdateMethod;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleCameraOffset;
        static Load(InName: string): ParticleModuleCameraOffset;
    }
    
    class ParticleModuleCollisionBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleCollisionBase;
        static Load(InName: string): ParticleModuleCollisionBase;
    }
    
    enum EParticleCollisionComplete { EPCC_Kill, EPCC_Freeze, EPCC_HaltCollisions, EPCC_FreezeTranslation, EPCC_FreezeRotation, EPCC_FreezeMovement, EPCC_MAX}
    class ParticleModuleCollision extends UE.ParticleModuleCollisionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DampingFactor: UE.RawDistributionVector;
        DampingFactorRotation: UE.RawDistributionVector;
        MaxCollisions: UE.RawDistributionFloat;
        CollisionCompletionOption: UE.EParticleCollisionComplete;
        CollisionTypes: TArray<UE.EObjectTypeQuery>;
        bApplyPhysics: boolean;
        bIgnoreTriggerVolumes: boolean;
        ParticleMass: UE.RawDistributionFloat;
        DirScalar: number;
        bPawnsDoNotDecrementCount: boolean;
        bOnlyVerticalNormalsDecrementCount: boolean;
        VerticalFudgeFactor: number;
        DelayAmount: UE.RawDistributionFloat;
        bDropDetail: boolean;
        bCollideOnlyIfVisible: boolean;
        bIgnoreSourceActor: boolean;
        MaxCollisionDistance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleCollision;
        static Load(InName: string): ParticleModuleCollision;
    }
    
    enum EParticleCollisionResponse { Bounce, Stop, Kill, EParticleCollisionResponse_MAX}
    enum EParticleCollisionMode { SceneDepth, DistanceField, EParticleCollisionMode_MAX}
    class ParticleModuleCollisionGPU extends UE.ParticleModuleCollisionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Resilience: UE.RawDistributionFloat;
        ResilienceScaleOverLife: UE.RawDistributionFloat;
        Friction: number;
        RandomSpread: number;
        RandomDistribution: number;
        RadiusScale: number;
        RadiusBias: number;
        Response: UE.EParticleCollisionResponse;
        CollisionMode: UE.EParticleCollisionMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleCollisionGPU;
        static Load(InName: string): ParticleModuleCollisionGPU;
    }
    
    class ParticleModuleColorBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleColorBase;
        static Load(InName: string): ParticleModuleColorBase;
    }
    
    class ParticleModuleColor extends UE.ParticleModuleColorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartColor: UE.RawDistributionVector;
        StartAlpha: UE.RawDistributionFloat;
        bClampAlpha: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleColor;
        static Load(InName: string): ParticleModuleColor;
    }
    
    class ParticleRandomSeedInfo {
        constructor();
        constructor(ParameterName: string, bGetSeedFromInstance: boolean, bInstanceSeedIsIndex: boolean, bResetSeedOnEmitterLooping: boolean, bRandomlySelectSeedArray: boolean, RandomSeeds: TArray<number>);
        ParameterName: string;
        bGetSeedFromInstance: boolean;
        bInstanceSeedIsIndex: boolean;
        bResetSeedOnEmitterLooping: boolean;
        bRandomlySelectSeedArray: boolean;
        RandomSeeds: TArray<number>;
        static StaticClass(): Class;
    }
    
    class ParticleModuleColor_Seeded extends UE.ParticleModuleColor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: UE.ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleColor_Seeded;
        static Load(InName: string): ParticleModuleColor_Seeded;
    }
    
    class ParticleModuleColorOverLife extends UE.ParticleModuleColorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ColorOverLife: UE.RawDistributionVector;
        AlphaOverLife: UE.RawDistributionFloat;
        bClampAlpha: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleColorOverLife;
        static Load(InName: string): ParticleModuleColorOverLife;
    }
    
    class ParticleModuleColorScaleOverLife extends UE.ParticleModuleColorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ColorScaleOverLife: UE.RawDistributionVector;
        AlphaScaleOverLife: UE.RawDistributionFloat;
        bEmitterTime: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleColorScaleOverLife;
        static Load(InName: string): ParticleModuleColorScaleOverLife;
    }
    
    class ParticleModuleEventReceiverKillParticles extends UE.ParticleModuleEventReceiverBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bStopSpawning: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventReceiverKillParticles;
        static Load(InName: string): ParticleModuleEventReceiverKillParticles;
    }
    
    class ParticleModuleEventReceiverSpawn extends UE.ParticleModuleEventReceiverBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpawnCount: UE.RawDistributionFloat;
        bUseParticleTime: boolean;
        bUsePSysLocation: boolean;
        bInheritVelocity: boolean;
        InheritVelocityScale: UE.RawDistributionVector;
        PhysicalMaterials: TArray<UE.PhysicalMaterial>;
        bBanPhysicalMaterials: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventReceiverSpawn;
        static Load(InName: string): ParticleModuleEventReceiverSpawn;
    }
    
    class ParticleModuleKillBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleKillBase;
        static Load(InName: string): ParticleModuleKillBase;
    }
    
    class ParticleModuleKillBox extends UE.ParticleModuleKillBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LowerLeftCorner: UE.RawDistributionVector;
        UpperRightCorner: UE.RawDistributionVector;
        bAbsolute: boolean;
        bKillInside: boolean;
        bAxisAlignedAndFixedSize: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleKillBox;
        static Load(InName: string): ParticleModuleKillBox;
    }
    
    class ParticleModuleKillHeight extends UE.ParticleModuleKillBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Height: UE.RawDistributionFloat;
        bAbsolute: boolean;
        bFloor: boolean;
        bApplyPSysScale: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleKillHeight;
        static Load(InName: string): ParticleModuleKillHeight;
    }
    
    class ParticleModuleLifetimeBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLifetimeBase;
        static Load(InName: string): ParticleModuleLifetimeBase;
    }
    
    class ParticleModuleLifetime extends UE.ParticleModuleLifetimeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Lifetime: UE.RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLifetime;
        static Load(InName: string): ParticleModuleLifetime;
    }
    
    class ParticleModuleLifetime_Seeded extends UE.ParticleModuleLifetime {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: UE.ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLifetime_Seeded;
        static Load(InName: string): ParticleModuleLifetime_Seeded;
    }
    
    class ParticleModuleLightBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLightBase;
        static Load(InName: string): ParticleModuleLightBase;
    }
    
    class ParticleModuleLight extends UE.ParticleModuleLightBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseInverseSquaredFalloff: boolean;
        bAffectsTranslucency: boolean;
        bPreviewLightRadius: boolean;
        SpawnFraction: number;
        ColorScaleOverLife: UE.RawDistributionVector;
        BrightnessOverLife: UE.RawDistributionFloat;
        RadiusScale: UE.RawDistributionFloat;
        LightExponent: UE.RawDistributionFloat;
        LightingChannels: UE.LightingChannels;
        VolumetricScatteringIntensity: number;
        bHighQualityLights: boolean;
        bShadowCastingLights: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLight;
        static Load(InName: string): ParticleModuleLight;
    }
    
    class ParticleModuleLight_Seeded extends UE.ParticleModuleLight {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: UE.ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLight_Seeded;
        static Load(InName: string): ParticleModuleLight_Seeded;
    }
    
    class ParticleModuleLocationBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationBase;
        static Load(InName: string): ParticleModuleLocationBase;
    }
    
    class ParticleModuleLocation extends UE.ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartLocation: UE.RawDistributionVector;
        DistributeOverNPoints: number;
        DistributeThreshold: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocation;
        static Load(InName: string): ParticleModuleLocation;
    }
    
    class ParticleModuleLocation_Seeded extends UE.ParticleModuleLocation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: UE.ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocation_Seeded;
        static Load(InName: string): ParticleModuleLocation_Seeded;
    }
    
    enum ELocationBoneSocketSource { BONESOCKETSOURCE_Bones, BONESOCKETSOURCE_Sockets, BONESOCKETSOURCE_MAX}
    class LocationBoneSocketInfo {
        constructor();
        constructor(BoneSocketName: string, Offset: UE.Vector);
        BoneSocketName: string;
        Offset: UE.Vector;
        static StaticClass(): Class;
    }
    
    enum ELocationBoneSocketSelectionMethod { BONESOCKETSEL_Sequential, BONESOCKETSEL_Random, BONESOCKETSEL_MAX}
    class ParticleModuleLocationBoneSocket extends UE.ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceType: UE.ELocationBoneSocketSource;
        UniversalOffset: UE.Vector;
        SourceLocations: TArray<UE.LocationBoneSocketInfo>;
        SelectionMethod: UE.ELocationBoneSocketSelectionMethod;
        bUpdatePositionEachFrame: boolean;
        bOrientMeshEmitters: boolean;
        bInheritBoneVelocity: boolean;
        InheritVelocityScale: number;
        SkelMeshActorParamName: string;
        NumPreSelectedIndices: number;
        EditorSkelMesh: UE.SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationBoneSocket;
        static Load(InName: string): ParticleModuleLocationBoneSocket;
    }
    
    class ParticleModuleLocationDirect extends UE.ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Location: UE.RawDistributionVector;
        LocationOffset: UE.RawDistributionVector;
        ScaleFactor: UE.RawDistributionVector;
        Direction: UE.RawDistributionVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationDirect;
        static Load(InName: string): ParticleModuleLocationDirect;
    }
    
    enum ELocationEmitterSelectionMethod { ELESM_Random, ELESM_Sequential, ELESM_MAX}
    class ParticleModuleLocationEmitter extends UE.ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EmitterName: string;
        SelectionMethod: UE.ELocationEmitterSelectionMethod;
        InheritSourceVelocity: boolean;
        InheritSourceVelocityScale: number;
        bInheritSourceRotation: boolean;
        InheritSourceRotationScale: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationEmitter;
        static Load(InName: string): ParticleModuleLocationEmitter;
    }
    
    class ParticleModuleLocationEmitterDirect extends UE.ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EmitterName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationEmitterDirect;
        static Load(InName: string): ParticleModuleLocationEmitterDirect;
    }
    
    class ParticleModuleLocationPrimitiveBase extends UE.ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Positive_X: boolean;
        Positive_Y: boolean;
        Positive_Z: boolean;
        Negative_X: boolean;
        Negative_Y: boolean;
        Negative_Z: boolean;
        SurfaceOnly: boolean;
        Velocity: boolean;
        VelocityScale: UE.RawDistributionFloat;
        StartLocation: UE.RawDistributionVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveBase;
        static Load(InName: string): ParticleModuleLocationPrimitiveBase;
    }
    
    enum CylinderHeightAxis { PMLPC_HEIGHTAXIS_X, PMLPC_HEIGHTAXIS_Y, PMLPC_HEIGHTAXIS_Z, PMLPC_HEIGHTAXIS_MAX}
    class ParticleModuleLocationPrimitiveCylinder extends UE.ParticleModuleLocationPrimitiveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RadialVelocity: boolean;
        StartRadius: UE.RawDistributionFloat;
        StartHeight: UE.RawDistributionFloat;
        HeightAxis: UE.CylinderHeightAxis;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveCylinder;
        static Load(InName: string): ParticleModuleLocationPrimitiveCylinder;
    }
    
    class ParticleModuleLocationPrimitiveCylinder_Seeded extends UE.ParticleModuleLocationPrimitiveCylinder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: UE.ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveCylinder_Seeded;
        static Load(InName: string): ParticleModuleLocationPrimitiveCylinder_Seeded;
    }
    
    class ParticleModuleLocationPrimitiveSphere extends UE.ParticleModuleLocationPrimitiveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartRadius: UE.RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveSphere;
        static Load(InName: string): ParticleModuleLocationPrimitiveSphere;
    }
    
    class ParticleModuleLocationPrimitiveSphere_Seeded extends UE.ParticleModuleLocationPrimitiveSphere {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: UE.ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveSphere_Seeded;
        static Load(InName: string): ParticleModuleLocationPrimitiveSphere_Seeded;
    }
    
    class ParticleModuleLocationPrimitiveTriangle extends UE.ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartOffset: UE.RawDistributionVector;
        Height: UE.RawDistributionFloat;
        Angle: UE.RawDistributionFloat;
        Thickness: UE.RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveTriangle;
        static Load(InName: string): ParticleModuleLocationPrimitiveTriangle;
    }
    
    enum ELocationSkelVertSurfaceSource { VERTSURFACESOURCE_Vert, VERTSURFACESOURCE_Surface, VERTSURFACESOURCE_MAX}
    class ParticleModuleLocationSkelVertSurface extends UE.ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceType: UE.ELocationSkelVertSurfaceSource;
        UniversalOffset: UE.Vector;
        bUpdatePositionEachFrame: boolean;
        bOrientMeshEmitters: boolean;
        bInheritBoneVelocity: boolean;
        InheritVelocityScale: number;
        SkelMeshActorParamName: string;
        EditorSkelMesh: UE.SkeletalMesh;
        ValidAssociatedBones: TArray<string>;
        bEnforceNormalCheck: boolean;
        NormalToCompare: UE.Vector;
        NormalCheckToleranceDegrees: number;
        NormalCheckTolerance: number;
        ValidMaterialIndices: TArray<number>;
        bInheritVertexColor: boolean;
        bInheritUV: boolean;
        InheritUVChannel: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationSkelVertSurface;
        static Load(InName: string): ParticleModuleLocationSkelVertSurface;
    }
    
    class ParticleModuleLocationWorldOffset extends UE.ParticleModuleLocation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationWorldOffset;
        static Load(InName: string): ParticleModuleLocationWorldOffset;
    }
    
    class ParticleModuleLocationWorldOffset_Seeded extends UE.ParticleModuleLocationWorldOffset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: UE.ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationWorldOffset_Seeded;
        static Load(InName: string): ParticleModuleLocationWorldOffset_Seeded;
    }
    
    class ParticleModuleMaterialBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleMaterialBase;
        static Load(InName: string): ParticleModuleMaterialBase;
    }
    
    class ParticleModuleMeshMaterial extends UE.ParticleModuleMaterialBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MeshMaterials: TArray<UE.MaterialInterface>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshMaterial;
        static Load(InName: string): ParticleModuleMeshMaterial;
    }
    
    class ParticleModuleRotationBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationBase;
        static Load(InName: string): ParticleModuleRotationBase;
    }
    
    class ParticleModuleMeshRotation extends UE.ParticleModuleRotationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartRotation: UE.RawDistributionVector;
        bInheritParent: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotation;
        static Load(InName: string): ParticleModuleMeshRotation;
    }
    
    class ParticleModuleMeshRotation_Seeded extends UE.ParticleModuleMeshRotation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: UE.ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotation_Seeded;
        static Load(InName: string): ParticleModuleMeshRotation_Seeded;
    }
    
    class ParticleModuleRotationRateBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationRateBase;
        static Load(InName: string): ParticleModuleRotationRateBase;
    }
    
    class ParticleModuleMeshRotationRate extends UE.ParticleModuleRotationRateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartRotationRate: UE.RawDistributionVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotationRate;
        static Load(InName: string): ParticleModuleMeshRotationRate;
    }
    
    class ParticleModuleMeshRotationRate_Seeded extends UE.ParticleModuleMeshRotationRate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: UE.ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotationRate_Seeded;
        static Load(InName: string): ParticleModuleMeshRotationRate_Seeded;
    }
    
    class ParticleModuleMeshRotationRateMultiplyLife extends UE.ParticleModuleRotationRateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LifeMultiplier: UE.RawDistributionVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotationRateMultiplyLife;
        static Load(InName: string): ParticleModuleMeshRotationRateMultiplyLife;
    }
    
    class ParticleModuleMeshRotationRateOverLife extends UE.ParticleModuleRotationRateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RotRate: UE.RawDistributionVector;
        bScaleRotRate: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotationRateOverLife;
        static Load(InName: string): ParticleModuleMeshRotationRateOverLife;
    }
    
    class ParticleModuleOrientationBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleOrientationBase;
        static Load(InName: string): ParticleModuleOrientationBase;
    }
    
    enum EParticleAxisLock { EPAL_NONE, EPAL_X, EPAL_Y, EPAL_Z, EPAL_NEGATIVE_X, EPAL_NEGATIVE_Y, EPAL_NEGATIVE_Z, EPAL_ROTATE_X, EPAL_ROTATE_Y, EPAL_ROTATE_Z, EPAL_MAX}
    class ParticleModuleOrientationAxisLock extends UE.ParticleModuleOrientationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LockAxisFlags: UE.EParticleAxisLock;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleOrientationAxisLock;
        static Load(InName: string): ParticleModuleOrientationAxisLock;
    }
    
    class ParticleModuleParameterBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleParameterBase;
        static Load(InName: string): ParticleModuleParameterBase;
    }
    
    enum EEmitterDynamicParameterValue { EDPV_UserSet, EDPV_AutoSet, EDPV_VelocityX, EDPV_VelocityY, EDPV_VelocityZ, EDPV_VelocityMag, EDPV_MAX}
    class EmitterDynamicParameter {
        constructor();
        constructor(ParamName: string, bUseEmitterTime: boolean, bSpawnTimeOnly: boolean, ValueMethod: UE.EEmitterDynamicParameterValue, bScaleVelocityByParamValue: boolean, ParamValue: UE.RawDistributionFloat);
        ParamName: string;
        bUseEmitterTime: boolean;
        bSpawnTimeOnly: boolean;
        ValueMethod: UE.EEmitterDynamicParameterValue;
        bScaleVelocityByParamValue: boolean;
        ParamValue: UE.RawDistributionFloat;
        static StaticClass(): Class;
    }
    
    class ParticleModuleParameterDynamic extends UE.ParticleModuleParameterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DynamicParams: TArray<UE.EmitterDynamicParameter>;
        UpdateFlags: number;
        bUsesVelocity: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleParameterDynamic;
        static Load(InName: string): ParticleModuleParameterDynamic;
    }
    
    class ParticleModuleParameterDynamic_Seeded extends UE.ParticleModuleParameterDynamic {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: UE.ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleParameterDynamic_Seeded;
        static Load(InName: string): ParticleModuleParameterDynamic_Seeded;
    }
    
    class ParticleModulePivotOffset extends UE.ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PivotOffset: UE.Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModulePivotOffset;
        static Load(InName: string): ParticleModulePivotOffset;
    }
    
    class ParticleModuleRotation extends UE.ParticleModuleRotationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartRotation: UE.RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotation;
        static Load(InName: string): ParticleModuleRotation;
    }
    
    class ParticleModuleRotation_Seeded extends UE.ParticleModuleRotation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: UE.ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotation_Seeded;
        static Load(InName: string): ParticleModuleRotation_Seeded;
    }
    
    class ParticleModuleRotationOverLifetime extends UE.ParticleModuleRotationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RotationOverLife: UE.RawDistributionFloat;
        Scale: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationOverLifetime;
        static Load(InName: string): ParticleModuleRotationOverLifetime;
    }
    
    class ParticleModuleRotationRate extends UE.ParticleModuleRotationRateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartRotationRate: UE.RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationRate;
        static Load(InName: string): ParticleModuleRotationRate;
    }
    
    class ParticleModuleRotationRate_Seeded extends UE.ParticleModuleRotationRate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: UE.ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationRate_Seeded;
        static Load(InName: string): ParticleModuleRotationRate_Seeded;
    }
    
    class ParticleModuleRotationRateMultiplyLife extends UE.ParticleModuleRotationRateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LifeMultiplier: UE.RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationRateMultiplyLife;
        static Load(InName: string): ParticleModuleRotationRateMultiplyLife;
    }
    
    class ParticleModuleSizeBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSizeBase;
        static Load(InName: string): ParticleModuleSizeBase;
    }
    
    class ParticleModuleSize extends UE.ParticleModuleSizeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartSize: UE.RawDistributionVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSize;
        static Load(InName: string): ParticleModuleSize;
    }
    
    class ParticleModuleSize_Seeded extends UE.ParticleModuleSize {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: UE.ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSize_Seeded;
        static Load(InName: string): ParticleModuleSize_Seeded;
    }
    
    class ParticleModuleSizeMultiplyLife extends UE.ParticleModuleSizeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LifeMultiplier: UE.RawDistributionVector;
        MultiplyX: boolean;
        MultiplyY: boolean;
        MultiplyZ: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSizeMultiplyLife;
        static Load(InName: string): ParticleModuleSizeMultiplyLife;
    }
    
    class ParticleModuleSizeScale extends UE.ParticleModuleSizeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SizeScale: UE.RawDistributionVector;
        EnableX: boolean;
        EnableY: boolean;
        EnableZ: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSizeScale;
        static Load(InName: string): ParticleModuleSizeScale;
    }
    
    class ParticleModuleSizeScaleBySpeed extends UE.ParticleModuleSizeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpeedScale: UE.Vector2D;
        MaxScale: UE.Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSizeScaleBySpeed;
        static Load(InName: string): ParticleModuleSizeScaleBySpeed;
    }
    
    class ParticleModuleSourceMovement extends UE.ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceMovementScale: UE.RawDistributionVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSourceMovement;
        static Load(InName: string): ParticleModuleSourceMovement;
    }
    
    class ParticleModuleSpawnPerUnit extends UE.ParticleModuleSpawnBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UnitScalar: number;
        MovementTolerance: number;
        SpawnPerUnit: UE.RawDistributionFloat;
        MaxFrameDistance: number;
        bIgnoreSpawnRateWhenMoving: boolean;
        bIgnoreMovementAlongX: boolean;
        bIgnoreMovementAlongY: boolean;
        bIgnoreMovementAlongZ: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSpawnPerUnit;
        static Load(InName: string): ParticleModuleSpawnPerUnit;
    }
    
    class ParticleModuleSubUVBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSubUVBase;
        static Load(InName: string): ParticleModuleSubUVBase;
    }
    
    class SubUVAnimation extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SubUVTexture: UE.Texture2D;
        SubImages_Horizontal: number;
        SubImages_Vertical: number;
        BoundingMode: UE.ESubUVBoundingVertexCount;
        OpacitySourceMode: UE.EOpacitySourceMode;
        AlphaThreshold: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubUVAnimation;
        static Load(InName: string): SubUVAnimation;
    }
    
    class ParticleModuleSubUV extends UE.ParticleModuleSubUVBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Animation: UE.SubUVAnimation;
        SubImageIndex: UE.RawDistributionFloat;
        bUseRealTime: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSubUV;
        static Load(InName: string): ParticleModuleSubUV;
    }
    
    class ParticleModuleSubUVMovie extends UE.ParticleModuleSubUV {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseEmitterTime: boolean;
        FrameRate: UE.RawDistributionFloat;
        StartingFrame: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSubUVMovie;
        static Load(InName: string): ParticleModuleSubUVMovie;
    }
    
    class ParticleModuleTrailBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleTrailBase;
        static Load(InName: string): ParticleModuleTrailBase;
    }
    
    enum ETrail2SourceMethod { PET2SRCM_Default, PET2SRCM_Particle, PET2SRCM_Actor, PET2SRCM_MAX}
    enum EParticleSourceSelectionMethod { EPSSM_Random, EPSSM_Sequential, EPSSM_MAX}
    class ParticleModuleTrailSource extends UE.ParticleModuleTrailBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceMethod: UE.ETrail2SourceMethod;
        SourceName: string;
        SourceStrength: UE.RawDistributionFloat;
        bLockSourceStength: boolean;
        SourceOffsetCount: number;
        SourceOffsetDefaults: TArray<UE.Vector>;
        SelectionMethod: UE.EParticleSourceSelectionMethod;
        bInheritRotation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleTrailSource;
        static Load(InName: string): ParticleModuleTrailSource;
    }
    
    class ParticleModuleTypeDataAnimTrail extends UE.ParticleModuleTypeDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDeadTrailsOnDeactivate: boolean;
        bEnablePreviousTangentRecalculation: boolean;
        bTangentRecalculationEveryFrame: boolean;
        TilingDistance: number;
        DistanceTessellationStepSize: number;
        TangentTessellationStepSize: number;
        WidthTessellationStepSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataAnimTrail;
        static Load(InName: string): ParticleModuleTypeDataAnimTrail;
    }
    
    enum EBeam2Method { PEB2M_Distance, PEB2M_Target, PEB2M_Branch, PEB2M_MAX}
    enum EBeamTaperMethod { PEBTM_None, PEBTM_Full, PEBTM_Partial, PEBTM_MAX}
    class ParticleModuleTypeDataBeam2 extends UE.ParticleModuleTypeDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BeamMethod: UE.EBeam2Method;
        TextureTile: number;
        TextureTileDistance: number;
        Sheets: number;
        MaxBeamCount: number;
        Speed: number;
        InterpolationPoints: number;
        bAlwaysOn: boolean;
        UpVectorStepSize: number;
        BranchParentName: string;
        Distance: UE.RawDistributionFloat;
        TaperMethod: UE.EBeamTaperMethod;
        TaperFactor: UE.RawDistributionFloat;
        TaperScale: UE.RawDistributionFloat;
        RenderGeometry: boolean;
        RenderDirectLine: boolean;
        RenderLines: boolean;
        RenderTessellation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataBeam2;
        static Load(InName: string): ParticleModuleTypeDataBeam2;
    }
    
    class VectorField extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Bounds: UE.Box;
        Intensity: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VectorField;
        static Load(InName: string): VectorField;
    }
    
    class GPUSpriteLocalVectorFieldInfo {
        constructor();
        constructor(Field: UE.VectorField, Transform: UE.Transform, MinInitialRotation: UE.Rotator, MaxInitialRotation: UE.Rotator, RotationRate: UE.Rotator, Intensity: number, Tightness: number, bIgnoreComponentTransform: boolean, bTileX: boolean, bTileY: boolean, bTileZ: boolean, bUseFixDT: boolean);
        Field: UE.VectorField;
        Transform: UE.Transform;
        MinInitialRotation: UE.Rotator;
        MaxInitialRotation: UE.Rotator;
        RotationRate: UE.Rotator;
        Intensity: number;
        Tightness: number;
        bIgnoreComponentTransform: boolean;
        bTileX: boolean;
        bTileY: boolean;
        bTileZ: boolean;
        bUseFixDT: boolean;
        static StaticClass(): Class;
    }
    
    class FloatDistribution {
        constructor();
        constructor(Table: UE.DistributionLookupTable);
        Table: UE.DistributionLookupTable;
        static StaticClass(): Class;
    }
    
    class GPUSpriteEmitterInfo {
        constructor();
        constructor(RequiredModule: UE.ParticleModuleRequired, SpawnModule: UE.ParticleModuleSpawn, SpawnPerUnitModule: UE.ParticleModuleSpawnPerUnit, SpawnModules: TArray<UE.ParticleModule>, LocalVectorField: UE.GPUSpriteLocalVectorFieldInfo, VectorFieldScale: UE.FloatDistribution, DragCoefficient: UE.FloatDistribution, PointAttractorStrength: UE.FloatDistribution, Resilience: UE.FloatDistribution, ConstantAcceleration: UE.Vector, PointAttractorPosition: UE.Vector, PointAttractorRadiusSq: number, OrbitOffsetBase: UE.Vector, OrbitOffsetRange: UE.Vector, InvMaxSize: UE.Vector2D, InvRotationRateScale: number, MaxLifetime: number, MaxParticleCount: number, ScreenAlignment: UE.EParticleScreenAlignment, LockAxisFlag: UE.EParticleAxisLock, bEnableCollision: boolean, CollisionMode: UE.EParticleCollisionMode, bRemoveHMDRoll: boolean, MinFacingCameraBlendDistance: number, MaxFacingCameraBlendDistance: number, DynamicColor: UE.RawDistributionVector, DynamicAlpha: UE.RawDistributionFloat, DynamicColorScale: UE.RawDistributionVector, DynamicAlphaScale: UE.RawDistributionFloat);
        RequiredModule: UE.ParticleModuleRequired;
        SpawnModule: UE.ParticleModuleSpawn;
        SpawnPerUnitModule: UE.ParticleModuleSpawnPerUnit;
        SpawnModules: TArray<UE.ParticleModule>;
        LocalVectorField: UE.GPUSpriteLocalVectorFieldInfo;
        VectorFieldScale: UE.FloatDistribution;
        DragCoefficient: UE.FloatDistribution;
        PointAttractorStrength: UE.FloatDistribution;
        Resilience: UE.FloatDistribution;
        ConstantAcceleration: UE.Vector;
        PointAttractorPosition: UE.Vector;
        PointAttractorRadiusSq: number;
        OrbitOffsetBase: UE.Vector;
        OrbitOffsetRange: UE.Vector;
        InvMaxSize: UE.Vector2D;
        InvRotationRateScale: number;
        MaxLifetime: number;
        MaxParticleCount: number;
        ScreenAlignment: UE.EParticleScreenAlignment;
        LockAxisFlag: UE.EParticleAxisLock;
        bEnableCollision: boolean;
        CollisionMode: UE.EParticleCollisionMode;
        bRemoveHMDRoll: boolean;
        MinFacingCameraBlendDistance: number;
        MaxFacingCameraBlendDistance: number;
        DynamicColor: UE.RawDistributionVector;
        DynamicAlpha: UE.RawDistributionFloat;
        DynamicColorScale: UE.RawDistributionVector;
        DynamicAlphaScale: UE.RawDistributionFloat;
        static StaticClass(): Class;
    }
    
    class GPUSpriteResourceData {
        constructor();
        constructor(QuantizedColorSamples: TArray<UE.Color>, QuantizedMiscSamples: TArray<UE.Color>, QuantizedSimulationAttrSamples: TArray<UE.Color>, ColorScale: UE.Vector4, ColorBias: UE.Vector4, MiscScale: UE.Vector4, MiscBias: UE.Vector4, SimulationAttrCurveScale: UE.Vector4, SimulationAttrCurveBias: UE.Vector4, SubImageSize: UE.Vector4, SizeBySpeed: UE.Vector4, ConstantAcceleration: UE.Vector, OrbitOffsetBase: UE.Vector, OrbitOffsetRange: UE.Vector, OrbitFrequencyBase: UE.Vector, OrbitFrequencyRange: UE.Vector, OrbitPhaseBase: UE.Vector, OrbitPhaseRange: UE.Vector, GlobalVectorFieldScale: number, GlobalVectorFieldTightness: number, PerParticleVectorFieldScale: number, PerParticleVectorFieldBias: number, DragCoefficientScale: number, DragCoefficientBias: number, ResilienceScale: number, ResilienceBias: number, CollisionRadiusScale: number, CollisionRadiusBias: number, CollisionTimeBias: number, CollisionRandomSpread: number, CollisionRandomDistribution: number, OneMinusFriction: number, RotationRateScale: number, CameraMotionBlurAmount: number, ScreenAlignment: UE.EParticleScreenAlignment, LockAxisFlag: UE.EParticleAxisLock, PivotOffset: UE.Vector2D, bRemoveHMDRoll: boolean, MinFacingCameraBlendDistance: number, MaxFacingCameraBlendDistance: number);
        QuantizedColorSamples: TArray<UE.Color>;
        QuantizedMiscSamples: TArray<UE.Color>;
        QuantizedSimulationAttrSamples: TArray<UE.Color>;
        ColorScale: UE.Vector4;
        ColorBias: UE.Vector4;
        MiscScale: UE.Vector4;
        MiscBias: UE.Vector4;
        SimulationAttrCurveScale: UE.Vector4;
        SimulationAttrCurveBias: UE.Vector4;
        SubImageSize: UE.Vector4;
        SizeBySpeed: UE.Vector4;
        ConstantAcceleration: UE.Vector;
        OrbitOffsetBase: UE.Vector;
        OrbitOffsetRange: UE.Vector;
        OrbitFrequencyBase: UE.Vector;
        OrbitFrequencyRange: UE.Vector;
        OrbitPhaseBase: UE.Vector;
        OrbitPhaseRange: UE.Vector;
        GlobalVectorFieldScale: number;
        GlobalVectorFieldTightness: number;
        PerParticleVectorFieldScale: number;
        PerParticleVectorFieldBias: number;
        DragCoefficientScale: number;
        DragCoefficientBias: number;
        ResilienceScale: number;
        ResilienceBias: number;
        CollisionRadiusScale: number;
        CollisionRadiusBias: number;
        CollisionTimeBias: number;
        CollisionRandomSpread: number;
        CollisionRandomDistribution: number;
        OneMinusFriction: number;
        RotationRateScale: number;
        CameraMotionBlurAmount: number;
        ScreenAlignment: UE.EParticleScreenAlignment;
        LockAxisFlag: UE.EParticleAxisLock;
        PivotOffset: UE.Vector2D;
        bRemoveHMDRoll: boolean;
        MinFacingCameraBlendDistance: number;
        MaxFacingCameraBlendDistance: number;
        static StaticClass(): Class;
    }
    
    class ParticleModuleTypeDataGpu extends UE.ParticleModuleTypeDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EmitterInfo: UE.GPUSpriteEmitterInfo;
        ResourceData: UE.GPUSpriteResourceData;
        CameraMotionBlurAmount: number;
        bClearExistingParticlesOnInit: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataGpu;
        static Load(InName: string): ParticleModuleTypeDataGpu;
    }
    
    enum EMeshScreenAlignment { PSMA_MeshFaceCameraWithRoll, PSMA_MeshFaceCameraWithSpin, PSMA_MeshFaceCameraWithLockedAxis, PSMA_MAX}
    enum EMeshCameraFacingUpAxis { CameraFacing_NoneUP, CameraFacing_ZUp, CameraFacing_NegativeZUp, CameraFacing_YUp, CameraFacing_NegativeYUp, CameraFacing_MAX}
    enum EMeshCameraFacingOptions { XAxisFacing_NoUp, XAxisFacing_ZUp, XAxisFacing_NegativeZUp, XAxisFacing_YUp, XAxisFacing_NegativeYUp, LockedAxis_ZAxisFacing, LockedAxis_NegativeZAxisFacing, LockedAxis_YAxisFacing, LockedAxis_NegativeYAxisFacing, VelocityAligned_ZAxisFacing, VelocityAligned_NegativeZAxisFacing, VelocityAligned_YAxisFacing, VelocityAligned_NegativeYAxisFacing, EMeshCameraFacingOptions_MAX}
    class ParticleModuleTypeDataMesh extends UE.ParticleModuleTypeDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Mesh: UE.StaticMesh;
        LODSizeScale: number;
        bUseStaticMeshLODs: boolean;
        CastShadows: boolean;
        DoCollisions: boolean;
        MeshAlignment: UE.EMeshScreenAlignment;
        bOverrideMaterial: boolean;
        bOverrideDefaultMotionBlurSettings: boolean;
        bEnableMotionBlur: boolean;
        RollPitchYawRange: UE.RawDistributionVector;
        AxisLockOption: UE.EParticleAxisLock;
        bCameraFacing: boolean;
        CameraFacingUpAxisOption: UE.EMeshCameraFacingUpAxis;
        CameraFacingOption: UE.EMeshCameraFacingOptions;
        bApplyParticleRotationAsSpin: boolean;
        bFaceCameraDirectionRatherThanPosition: boolean;
        bCollisionsConsiderPartilceSize: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataMesh;
        static Load(InName: string): ParticleModuleTypeDataMesh;
    }
    
    enum ETrailsRenderAxisOption { Trails_CameraUp, Trails_SourceUp, Trails_WorldUp, Trails_MAX}
    class ParticleModuleTypeDataRibbon extends UE.ParticleModuleTypeDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxTessellationBetweenParticles: number;
        SheetsPerTrail: number;
        MaxTrailCount: number;
        MaxParticleInTrailCount: number;
        bDeadTrailsOnDeactivate: boolean;
        bDeadTrailsOnSourceLoss: boolean;
        bClipSourceSegement: boolean;
        bEnablePreviousTangentRecalculation: boolean;
        bTangentRecalculationEveryFrame: boolean;
        bSpawnInitialParticle: boolean;
        RenderAxis: UE.ETrailsRenderAxisOption;
        TangentSpawningScalar: number;
        bRenderGeometry: boolean;
        bRenderSpawnPoints: boolean;
        bRenderTangents: boolean;
        bRenderTessellation: boolean;
        TilingDistance: number;
        DistanceTessellationStepSize: number;
        bEnableTangentDiffInterpScale: boolean;
        TangentTessellationScalar: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataRibbon;
        static Load(InName: string): ParticleModuleTypeDataRibbon;
    }
    
    class ParticleModuleVectorFieldBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldBase;
        static Load(InName: string): ParticleModuleVectorFieldBase;
    }
    
    class ParticleModuleVectorFieldGlobal extends UE.ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bOverrideGlobalVectorFieldTightness: boolean;
        GlobalVectorFieldScale: number;
        GlobalVectorFieldTightness: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldGlobal;
        static Load(InName: string): ParticleModuleVectorFieldGlobal;
    }
    
    class ParticleModuleVectorFieldLocal extends UE.ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VectorField: UE.VectorField;
        RelativeTranslation: UE.Vector;
        RelativeRotation: UE.Rotator;
        RelativeScale3D: UE.Vector;
        Intensity: number;
        Tightness: number;
        bIgnoreComponentTransform: boolean;
        bTileX: boolean;
        bTileY: boolean;
        bTileZ: boolean;
        bUseFixDT: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldLocal;
        static Load(InName: string): ParticleModuleVectorFieldLocal;
    }
    
    class ParticleModuleVectorFieldRotation extends UE.ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MinInitialRotation: UE.Vector;
        MaxInitialRotation: UE.Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldRotation;
        static Load(InName: string): ParticleModuleVectorFieldRotation;
    }
    
    class ParticleModuleVectorFieldRotationRate extends UE.ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RotationRate: UE.Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldRotationRate;
        static Load(InName: string): ParticleModuleVectorFieldRotationRate;
    }
    
    class ParticleModuleVectorFieldScale extends UE.ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VectorFieldScale: UE.DistributionFloat;
        VectorFieldScaleRaw: UE.RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldScale;
        static Load(InName: string): ParticleModuleVectorFieldScale;
    }
    
    class ParticleModuleVectorFieldScaleOverLife extends UE.ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VectorFieldScaleOverLife: UE.DistributionFloat;
        VectorFieldScaleOverLifeRaw: UE.RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldScaleOverLife;
        static Load(InName: string): ParticleModuleVectorFieldScaleOverLife;
    }
    
    class ParticleModuleVelocityBase extends UE.ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bInWorldSpace: boolean;
        bApplyOwnerScale: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocityBase;
        static Load(InName: string): ParticleModuleVelocityBase;
    }
    
    class ParticleModuleVelocity extends UE.ParticleModuleVelocityBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartVelocity: UE.RawDistributionVector;
        StartVelocityRadial: UE.RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocity;
        static Load(InName: string): ParticleModuleVelocity;
    }
    
    class ParticleModuleVelocity_Seeded extends UE.ParticleModuleVelocity {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: UE.ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocity_Seeded;
        static Load(InName: string): ParticleModuleVelocity_Seeded;
    }
    
    class ParticleModuleVelocityCone extends UE.ParticleModuleVelocityBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Angle: UE.RawDistributionFloat;
        Velocity: UE.RawDistributionFloat;
        Direction: UE.Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocityCone;
        static Load(InName: string): ParticleModuleVelocityCone;
    }
    
    class ParticleModuleVelocityInheritParent extends UE.ParticleModuleVelocityBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Scale: UE.RawDistributionVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocityInheritParent;
        static Load(InName: string): ParticleModuleVelocityInheritParent;
    }
    
    class ParticleModuleVelocityOverLifetime extends UE.ParticleModuleVelocityBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VelOverLife: UE.RawDistributionVector;
        Absolute: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocityOverLifetime;
        static Load(InName: string): ParticleModuleVelocityOverLifetime;
    }
    
    class ParticleSpriteEmitter extends UE.ParticleEmitter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleSpriteEmitter;
        static Load(InName: string): ParticleSpriteEmitter;
    }
    
    class ParticleSystemAuditCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HighSpawnRateOrBurstThreshold: number;
        FarLODDistanceTheshold: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleSystemAuditCommandlet;
        static Load(InName: string): ParticleSystemAuditCommandlet;
    }
    
    class ParticleSystemFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleSystemFactoryNew;
        static Load(InName: string): ParticleSystemFactoryNew;
    }
    
    class ParticleSystemThumbnailRenderer extends UE.TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NoImage: UE.Texture2D;
        OutOfDate: UE.Texture2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleSystemThumbnailRenderer;
        static Load(InName: string): ParticleSystemThumbnailRenderer;
    }
    
    class PlayerReservation {
        constructor();
        constructor(UniqueId: UE.UniqueNetIdRepl, ValidationStr: string, Platform: string, bAllowCrossplay: boolean, ElapsedTime: number);
        UniqueId: UE.UniqueNetIdRepl;
        ValidationStr: string;
        Platform: string;
        bAllowCrossplay: boolean;
        ElapsedTime: number;
        static StaticClass(): Class;
    }
    
    class PartyReservation {
        constructor();
        constructor(TeamNum: number, PartyLeader: UE.UniqueNetIdRepl, PartyMembers: TArray<UE.PlayerReservation>, RemovedPartyMembers: TArray<UE.PlayerReservation>);
        TeamNum: number;
        PartyLeader: UE.UniqueNetIdRepl;
        PartyMembers: TArray<UE.PlayerReservation>;
        RemovedPartyMembers: TArray<UE.PlayerReservation>;
        static StaticClass(): Class;
    }
    
    enum EClientRequestType { NonePending, ExistingSessionReservation, ReservationUpdate, EmptyServerReservation, Reconnect, Abandon, ReservationRemoveMembers, EClientRequestType_MAX}
    enum EPartyReservationResult { NoResult, RequestPending, GeneralError, PartyLimitReached, IncorrectPlayerCount, RequestTimedOut, ReservationDuplicate, ReservationNotFound, ReservationAccepted, ReservationDenied, ReservationDenied_CrossPlayRestriction, ReservationDenied_Banned, ReservationRequestCanceled, ReservationInvalid, BadSessionId, ReservationDenied_ContainsExistingPlayers, EPartyReservationResult_MAX}
    class PartyBeaconClient extends UE.OnlineBeaconClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DestSessionId: string;
        PendingReservation: UE.PartyReservation;
        RequestType: UE.EClientRequestType;
        bPendingReservationSent: boolean;
        bCancelReservation: boolean;
        ClientCancelReservationResponse(ReservationResponse: UE.EPartyReservationResult) : void;
        ClientReservationResponse(ReservationResponse: UE.EPartyReservationResult) : void;
        ClientSendReservationFull() : void;
        ClientSendReservationUpdates(NumRemainingReservations: number) : void;
        ServerCancelReservationRequest(PartyLeader: UE.UniqueNetIdRepl) : void;
        ServerRemoveMemberFromReservationRequest(SessionId: string, ReservationUpdate: UE.PartyReservation) : void;
        ServerReservationRequest(SessionId: string, Reservation: UE.PartyReservation) : void;
        ServerUpdateReservationRequest(SessionId: string, ReservationUpdate: UE.PartyReservation) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PartyBeaconClient;
        static Load(InName: string): PartyBeaconClient;
    }
    
    class PartyBeaconState extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SessionName: string;
        NumConsumedReservations: number;
        MaxReservations: number;
        NumTeams: number;
        NumPlayersPerTeam: number;
        TeamAssignmentMethod: string;
        ReservedHostTeamNum: number;
        ForceTeamNum: number;
        bRestrictCrossConsole: boolean;
        bEnableRemovalRequests: boolean;
        Reservations: TArray<UE.PartyReservation>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PartyBeaconState;
        static Load(InName: string): PartyBeaconState;
    }
    
    class PartyBeaconHost extends UE.OnlineBeaconHostObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        State: UE.PartyBeaconState;
        bLogoutOnSessionTimeout: boolean;
        SessionTimeoutSecs: number;
        TravelSessionTimeoutSecs: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PartyBeaconHost;
        static Load(InName: string): PartyBeaconHost;
    }
    
    class PathFollowingAgentInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PathFollowingAgentInterface;
        static Load(InName: string): PathFollowingAgentInterface;
    }
    
    class PathFollowingManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PathFollowingManager;
        static Load(InName: string): PathFollowingManager;
    }
    
    class PawnAction_BlueprintBase extends UE.PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActionFinished(ControlledPawn: $Nullable<UE.Pawn>, WithResult: UE.EPawnActionResult) : void;
        ActionPause(ControlledPawn: $Nullable<UE.Pawn>) : void;
        ActionResume(ControlledPawn: $Nullable<UE.Pawn>) : void;
        ActionStart(ControlledPawn: $Nullable<UE.Pawn>) : void;
        ActionTick(ControlledPawn: $Nullable<UE.Pawn>, DeltaSeconds: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnAction_BlueprintBase;
        static Load(InName: string): PawnAction_BlueprintBase;
    }
    
    class PawnAction_Move extends UE.PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GoalActor: UE.Actor;
        GoalLocation: UE.Vector;
        AcceptableRadius: number;
        FilterClass: UE.Class;
        bAllowStrafe: boolean;
        bFinishOnOverlap: boolean;
        bUsePathfinding: boolean;
        bAllowPartialPath: boolean;
        bProjectGoalToNavigation: boolean;
        bUpdatePathToGoal: boolean;
        bAbortChildActionOnPathChange: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnAction_Move;
        static Load(InName: string): PawnAction_Move;
    }
    
    enum EPawnActionFailHandling { RequireSuccess, IgnoreFailure, EPawnActionFailHandling_MAX}
    class PawnAction_Repeat extends UE.PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActionToRepeat: UE.PawnAction;
        RecentActionCopy: UE.PawnAction;
        ChildFailureHandlingMode: UE.EPawnActionFailHandling;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnAction_Repeat;
        static Load(InName: string): PawnAction_Repeat;
    }
    
    class PawnAction_Sequence extends UE.PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActionSequence: TArray<UE.PawnAction>;
        ChildFailureHandlingMode: UE.EPawnActionFailHandling;
        RecentActionCopy: UE.PawnAction;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnAction_Sequence;
        static Load(InName: string): PawnAction_Sequence;
    }
    
    class PawnAction_Wait extends UE.PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TimeToWait: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnAction_Wait;
        static Load(InName: string): PawnAction_Wait;
    }
    
    class PawnNoiseEmitterComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAIPerceptionSystemCompatibilityMode: boolean;
        LastRemoteNoisePosition: UE.Vector;
        NoiseLifetime: number;
        LastRemoteNoiseVolume: number;
        LastRemoteNoiseTime: number;
        LastLocalNoiseVolume: number;
        LastLocalNoiseTime: number;
        MakeNoise(NoiseMaker: $Nullable<UE.Actor>, Loudness: number, NoiseLocation: UE.Vector) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnNoiseEmitterComponent;
        static Load(InName: string): PawnNoiseEmitterComponent;
    }
    
    class PawnSensingComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HearingThreshold: number;
        LOSHearingThreshold: number;
        SightRadius: number;
        SensingInterval: number;
        HearingMaxSoundAge: number;
        bEnableSensingUpdates: boolean;
        bOnlySensePlayers: boolean;
        bSeePawns: boolean;
        bHearNoises: boolean;
        OnSeePawn: $MulticastDelegate<(Pawn: $Nullable<UE.Pawn>) => void>;
        OnHearNoise: $MulticastDelegate<(Instigator: $Nullable<UE.Pawn>, Location: UE.Vector, Volume: number) => void>;
        PeripheralVisionAngle: number;
        PeripheralVisionCosine: number;
        GetPeripheralVisionAngle() : number;
        GetPeripheralVisionCosine() : number;
        HearNoiseDelegate__DelegateSignature(Instigator: $Nullable<UE.Pawn>, Location: UE.Vector, Volume: number) : void;
        SeePawnDelegate__DelegateSignature(Pawn: $Nullable<UE.Pawn>) : void;
        SetPeripheralVisionAngle(NewPeripheralVisionAngle: number) : void;
        SetSensingInterval(NewSensingInterval: number) : void;
        SetSensingUpdatesEnabled(bEnabled: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnSensingComponent;
        static Load(InName: string): PawnSensingComponent;
    }
    
    class PEClassMetaData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddAutoCollapseCategory(InCategory: string) : void;
        AddAutoExpandCategory(InCategory: string) : void;
        AddClassGroup(InGroupName: string) : void;
        AddDontAutoCollapseCategory(InCategory: string) : void;
        AddHideCategory(InCategory: string) : void;
        AddHideFunction(InFunctionName: string) : void;
        AddShowCategory(InCategory: string) : void;
        AddShowFunction(InFunctionName: string) : void;
        AddShowSubCategory(InCategory: string) : void;
        AddSparseDataType(InType: string) : void;
        SetClassFlags(InFlags: number, bInPlaceable: boolean) : void;
        SetClassWithIn(InClassName: string) : void;
        SetConfig(InConfigName: string) : void;
        SetMetaData(InName: string, InValue: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PEClassMetaData;
        static Load(InName: string): PEClassMetaData;
    }
    
    class PEGraphPinType {
        constructor();
        constructor(PinCategory: string, PinSubCategoryObject: UE.Object, PinContainerType: number, bIsReference: boolean, bIn: boolean);
        PinCategory: string;
        PinSubCategoryObject: UE.Object;
        PinContainerType: number;
        bIsReference: boolean;
        bIn: boolean;
        static StaticClass(): Class;
    }
    
    class PEGraphTerminalType {
        constructor();
        constructor(PinCategory: string, PinSubCategoryObject: UE.Object);
        PinCategory: string;
        PinSubCategoryObject: UE.Object;
        static StaticClass(): Class;
    }
    
    class PEParamMetaData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetMetaData(InName: string, InValue: string) : void;
        SetParamFlags(InHighBits: number, InLowBits: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PEParamMetaData;
        static Load(InName: string): PEParamMetaData;
    }
    
    class PEPropertyMetaData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetMetaData(InName: string, InValue: string) : void;
        SetPropertyFlags(InHighBits: number, InLowBits: number) : void;
        SetRepCallbackName(InName: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PEPropertyMetaData;
        static Load(InName: string): PEPropertyMetaData;
    }
    
    class PEFunctionMetaData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetCppImplName(InName: string) : void;
        SetCppValidationImplName(InName: string) : void;
        SetEndpointName(InEndpointName: string) : void;
        SetForceBlueprintImpure(bInForceBlueprintImpure: boolean) : void;
        SetFunctionExportFlags(InFlags: number) : void;
        SetFunctionFlags(InHighBits: number, InLowBits: number) : void;
        SetIsSealedEvent(bInSealedEvent: boolean) : void;
        SetMetaData(InName: string, InValue: string) : void;
        SetRPCId(InRPCId: number) : void;
        SetRPCResponseId(InRPCResponseId: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PEFunctionMetaData;
        static Load(InName: string): PEFunctionMetaData;
    }
    
    class PEBlueprintAsset extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GeneratedClass: UE.Class;
        Blueprint: UE.Blueprint;
        Package: UE.Package;
        NeedSave: boolean;
        HasConstructor: boolean;
        AddFunction(InName: string, IsVoid: boolean, InGraphPinType: UE.PEGraphPinType, InPinValueType: UE.PEGraphTerminalType, InSetFlags: number, InClearFlags: number) : void;
        AddFunctionWithMetaData(InName: string, IsVoid: boolean, InGraphPinType: UE.PEGraphPinType, InPinValueType: UE.PEGraphTerminalType, InSetFlags: number, InClearFlags: number, InMetaData: $Nullable<UE.PEFunctionMetaData>) : void;
        AddMemberVariable(NewVarName: string, InGraphPinType: UE.PEGraphPinType, InPinValueType: UE.PEGraphTerminalType, InLFlags: number, InHFlags: number, InLifetimeCondition: number) : void;
        AddMemberVariableWithMetaData(InNewVarName: string, InGraphPinType: UE.PEGraphPinType, InPinValueType: UE.PEGraphTerminalType, InLFlags: number, InHFLags: number, InLifetimeCondition: number, InMetaData: $Nullable<UE.PEPropertyMetaData>) : void;
        AddParameter(InParameterName: string, InGraphPinType: UE.PEGraphPinType, InPinValueType: UE.PEGraphTerminalType) : void;
        AddParameterWithMetaData(InParameterName: string, InGraphPinType: UE.PEGraphPinType, InPinValueType: UE.PEGraphTerminalType, InMetaData: $Nullable<UE.PEParamMetaData>) : void;
        ClearParameter() : void;
        LoadOrCreate(InName: string, InPath: string, ParentClass: $Nullable<UE.Class>, InSetFlags: number, InClearFlags: number) : boolean;
        LoadOrCreateWithMetaData(InName: string, InPath: string, InParentClass: $Nullable<UE.Class>, InSetFlags: number, InClearFlags: number, InMetaData: $Nullable<UE.PEClassMetaData>) : boolean;
        RemoveNotExistedFunction() : void;
        RemoveNotExistedMemberVariable() : void;
        Save() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PEBlueprintAsset;
        static Load(InName: string): PEBlueprintAsset;
    }
    
    class PEDirectoryWatcher extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnChanged: $MulticastDelegate<(Added: TArray<string>, Modified: TArray<string>, Removed: TArray<string>) => void>;
        UnWatch() : void;
        Watch(InDirectory: string) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PEDirectoryWatcher;
        static Load(InName: string): PEDirectoryWatcher;
    }
    
    enum EAnimationViewportCameraFollowMode { None, Bounds, Bone, EAnimationViewportCameraFollowMode_MAX}
    class ViewportConfigOptions {
        constructor();
        constructor(ViewModeIndex: UE.EViewModeIndex, ViewFOV: number, CameraFollowMode: UE.EAnimationViewportCameraFollowMode, CameraFollowBoneName: string);
        ViewModeIndex: UE.EViewModeIndex;
        ViewFOV: number;
        CameraFollowMode: UE.EAnimationViewportCameraFollowMode;
        CameraFollowBoneName: string;
        static StaticClass(): Class;
    }
    
    class AssetEditorOptions {
        constructor();
        constructor(Context: string, ViewportConfigs: FixSizeArray<UE.ViewportConfigOptions>);
        Context: string;
        ViewportConfigs: FixSizeArray<UE.ViewportConfigOptions>;
        static StaticClass(): Class;
    }
    
    class PersonaOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoAlignFloorToMesh: boolean;
        bShowGrid: boolean;
        bHighlightOrigin: boolean;
        bMuteAudio: boolean;
        bUseAudioAttenuation: boolean;
        ShowMeshStats: number;
        DefaultLocalAxesSelection: number;
        DefaultBoneDrawSelection: number;
        SectionTimingNodeColor: UE.LinearColor;
        NotifyTimingNodeColor: UE.LinearColor;
        BranchingPointTimingNodeColor: UE.LinearColor;
        bUseInlineSocketEditor: boolean;
        bFlattenSkeletonHierarchyWhenFiltering: boolean;
        bHideParentsWhenFiltering: boolean;
        bAllowPreviewMeshCollectionsToSelectFromDifferentSkeletons: boolean;
        bAllowPreviewMeshCollectionsToUseCustomAnimBP: boolean;
        bAllowMeshSectionSelection: boolean;
        NumFolderFiltersInAssetBrowser: number;
        AssetEditorOptions: TArray<UE.AssetEditorOptions>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PersonaOptions;
        static Load(InName: string): PersonaOptions;
    }
    
    class PersonaPreviewSceneController extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PersonaPreviewSceneController;
        static Load(InName: string): PersonaPreviewSceneController;
    }
    
    class PersonaPreviewSceneAnimationController extends UE.PersonaPreviewSceneController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Animation: TSoftObjectPtr<UE.AnimationAsset>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PersonaPreviewSceneAnimationController;
        static Load(InName: string): PersonaPreviewSceneAnimationController;
    }
    
    class PersonaPreviewSceneDefaultController extends UE.PersonaPreviewSceneController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PersonaPreviewSceneDefaultController;
        static Load(InName: string): PersonaPreviewSceneDefaultController;
    }
    
    class PreviewMeshCollectionEntry {
        constructor();
        constructor(SkeletalMesh: TSoftObjectPtr<UE.SkeletalMesh>);
        SkeletalMesh: TSoftObjectPtr<UE.SkeletalMesh>;
        static StaticClass(): Class;
    }
    
    class PreviewMeshCollection extends UE.DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Skeleton: UE.Skeleton;
        SkeletalMeshes: TArray<UE.PreviewMeshCollectionEntry>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PreviewMeshCollection;
        static Load(InName: string): PreviewMeshCollection;
    }
    
    class PersonaPreviewSceneDescription extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PreviewController: UE.Class;
        PreviewControllerInstance: UE.PersonaPreviewSceneController;
        PreviewControllerInstances: TArray<UE.PersonaPreviewSceneController>;
        PreviewMesh: TSoftObjectPtr<UE.SkeletalMesh>;
        PreviewAnimationBlueprint: TSoftObjectPtr<UE.AnimBlueprint>;
        ApplicationMethod: UE.EPreviewAnimationBlueprintApplicationMethod;
        LinkedAnimGraphTag: string;
        AdditionalMeshes: TSoftObjectPtr<UE.DataAsset>;
        DefaultAdditionalMeshes: UE.PreviewMeshCollection;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PersonaPreviewSceneDescription;
        static Load(InName: string): PersonaPreviewSceneDescription;
    }
    
    class PersonaPreviewSceneRefPoseController extends UE.PersonaPreviewSceneController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bResetBoneTransforms: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PersonaPreviewSceneRefPoseController;
        static Load(InName: string): PersonaPreviewSceneRefPoseController;
    }
    
    class PhasedAutomationActorBase extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnFunctionalTestingBegin() : void;
        OnFunctionalTestingComplete() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhasedAutomationActorBase;
        static Load(InName: string): PhasedAutomationActorBase;
    }
    
    class PhysicalAnimationComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StrengthMultiplyer: number;
        SkeletalMeshComponent: UE.SkeletalMeshComponent;
        ApplyPhysicalAnimationProfileBelow(BodyName: string, ProfileName: string, bIncludeSelf?: boolean /* = true */, bClearNotFound?: boolean /* = false */) : void;
        ApplyPhysicalAnimationSettings(BodyName: string, PhysicalAnimationData: UE.PhysicalAnimationData) : void;
        ApplyPhysicalAnimationSettingsBelow(BodyName: string, PhysicalAnimationData: UE.PhysicalAnimationData, bIncludeSelf?: boolean /* = true */) : void;
        GetBodyTargetTransform(BodyName: string) : UE.Transform;
        SetSkeletalMeshComponent(InSkeletalMeshComponent: $Nullable<UE.SkeletalMeshComponent>) : void;
        SetStrengthMultiplyer(InStrengthMultiplyer: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicalAnimationComponent;
        static Load(InName: string): PhysicalAnimationComponent;
    }
    
    class PhysicalMaterialFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysicalMaterialClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicalMaterialFactoryNew;
        static Load(InName: string): PhysicalMaterialFactoryNew;
    }
    
    enum EPhysicsAssetEditorRenderMode { Solid, Wireframe, None, EPhysicsAssetEditorRenderMode_MAX}
    enum EPhysicsAssetEditorConstraintViewMode { None, AllPositions, AllLimits, EPhysicsAssetEditorConstraintViewMode_MAX}
    class PhysicsAssetEditorOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysicsBlend: number;
        bUpdateJointsFromAnimation: boolean;
        PhysicsUpdateMode: UE.EPhysicsTransformUpdateMode;
        PokePauseTime: number;
        PokeBlendTime: number;
        GravScale: number;
        GravityOverrideZ: number;
        bUseGravityOverride: boolean;
        MaxFPS: number;
        HandleLinearDamping: number;
        HandleLinearStiffness: number;
        HandleAngularDamping: number;
        HandleAngularStiffness: number;
        InterpolationSpeed: number;
        PokeStrength: number;
        bShowConstraintsAsPoints: boolean;
        bRenderOnlySelectedConstraints: boolean;
        ConstraintDrawSize: number;
        MeshViewMode: UE.EPhysicsAssetEditorRenderMode;
        CollisionViewMode: UE.EPhysicsAssetEditorRenderMode;
        ConstraintViewMode: UE.EPhysicsAssetEditorConstraintViewMode;
        SimulationMeshViewMode: UE.EPhysicsAssetEditorRenderMode;
        SimulationCollisionViewMode: UE.EPhysicsAssetEditorRenderMode;
        SimulationConstraintViewMode: UE.EPhysicsAssetEditorConstraintViewMode;
        CollisionOpacity: number;
        bSolidRenderingForSelectedOnly: boolean;
        bResetClothWhenSimulating: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsAssetEditorOptions;
        static Load(InName: string): PhysicsAssetEditorOptions;
    }
    
    class PhysicsAssetFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeletalMesh: UE.SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsAssetFactory;
        static Load(InName: string): PhysicsAssetFactory;
    }
    
    enum EPhysAssetFitGeomType { EFG_Box, EFG_Sphyl, EFG_Sphere, EFG_TaperedCapsule, EFG_SingleConvexHull, EFG_MultiConvexHull, EFG_MAX}
    enum EPhysAssetFitVertWeight { EVW_AnyWeight, EVW_DominantWeight, EVW_MAX}
    class PhysAssetCreateParams {
        constructor();
        constructor(MinBoneSize: number, MinWeldSize: number, GeomType: UE.EPhysAssetFitGeomType, VertWeight: UE.EPhysAssetFitVertWeight, bAutoOrientToBone: boolean, bCreateConstraints: boolean, bWalkPastSmall: boolean, bBodyForAll: boolean, bDisableCollisionsByDefault: boolean, AngularConstraintMode: UE.EAngularConstraintMotion, HullCount: number, MaxHullVerts: number);
        MinBoneSize: number;
        MinWeldSize: number;
        GeomType: UE.EPhysAssetFitGeomType;
        VertWeight: UE.EPhysAssetFitVertWeight;
        bAutoOrientToBone: boolean;
        bCreateConstraints: boolean;
        bWalkPastSmall: boolean;
        bBodyForAll: boolean;
        bDisableCollisionsByDefault: boolean;
        AngularConstraintMode: UE.EAngularConstraintMotion;
        HullCount: number;
        MaxHullVerts: number;
        static StaticClass(): Class;
    }
    
    class PhysicsAssetGenerationSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CreateParams: UE.PhysAssetCreateParams;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsAssetGenerationSettings;
        static Load(InName: string): PhysicsAssetGenerationSettings;
    }
    
    class PhysicsAssetThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsAssetThumbnailRenderer;
        static Load(InName: string): PhysicsAssetThumbnailRenderer;
    }
    
    class RigidBodyBase extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RigidBodyBase;
        static Load(InName: string): RigidBodyBase;
    }
    
    class ConstrainComponentPropName {
        constructor();
        constructor(ComponentName: string);
        ComponentName: string;
        static StaticClass(): Class;
    }
    
    enum EConstraintFrame { Frame1, Frame2, EConstraintFrame_MAX}
    class PhysicsConstraintComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstraintActor1: UE.Actor;
        ComponentName1: UE.ConstrainComponentPropName;
        ConstraintActor2: UE.Actor;
        ComponentName2: UE.ConstrainComponentPropName;
        ConstraintSetup: UE.PhysicsConstraintTemplate;
        OnConstraintBroken: $MulticastDelegate<(ConstraintIndex: number) => void>;
        ConstraintInstance: UE.ConstraintInstance;
        BreakConstraint() : void;
        GetConstraintForce(OutLinearForce: $Ref<UE.Vector>, OutAngularForce: $Ref<UE.Vector>) : void;
        GetCurrentSwing1() : number;
        GetCurrentSwing2() : number;
        GetCurrentTwist() : number;
        IsBroken() : boolean;
        SetAngularBreakable(bAngularBreakable: boolean, AngularBreakThreshold: number) : void;
        SetAngularDriveMode(DriveMode: UE.EAngularDriveMode) : void;
        SetAngularDriveParams(PositionStrength: number, VelocityStrength: number, InForceLimit: number) : void;
        SetAngularOrientationDrive(bEnableSwingDrive: boolean, bEnableTwistDrive: boolean) : void;
        SetAngularOrientationTarget(InPosTarget: UE.Rotator) : void;
        SetAngularSwing1Limit(MotionType: UE.EAngularConstraintMotion, Swing1LimitAngle: number) : void;
        SetAngularSwing2Limit(MotionType: UE.EAngularConstraintMotion, Swing2LimitAngle: number) : void;
        SetAngularTwistLimit(ConstraintType: UE.EAngularConstraintMotion, TwistLimitAngle: number) : void;
        SetAngularVelocityDrive(bEnableSwingDrive: boolean, bEnableTwistDrive: boolean) : void;
        SetAngularVelocityDriveSLERP(bEnableSLERP: boolean) : void;
        SetAngularVelocityDriveTwistAndSwing(bEnableTwistDrive: boolean, bEnableSwingDrive: boolean) : void;
        SetAngularVelocityTarget(InVelTarget: UE.Vector) : void;
        SetConstrainedComponents(Component1: $Nullable<UE.PrimitiveComponent>, BoneName1: string, Component2: $Nullable<UE.PrimitiveComponent>, BoneName2: string) : void;
        SetConstraintReferenceFrame(Frame: UE.EConstraintFrame, RefFrame: UE.Transform) : void;
        SetConstraintReferenceOrientation(Frame: UE.EConstraintFrame, PriAxis: UE.Vector, SecAxis: UE.Vector) : void;
        SetConstraintReferencePosition(Frame: UE.EConstraintFrame, RefPosition: UE.Vector) : void;
        SetDisableCollision(bDisableCollision: boolean) : void;
        SetLinearBreakable(bLinearBreakable: boolean, LinearBreakThreshold: number) : void;
        SetLinearDriveParams(PositionStrength: number, VelocityStrength: number, InForceLimit: number) : void;
        SetLinearPositionDrive(bEnableDriveX: boolean, bEnableDriveY: boolean, bEnableDriveZ: boolean) : void;
        SetLinearPositionTarget(InPosTarget: UE.Vector) : void;
        SetLinearVelocityDrive(bEnableDriveX: boolean, bEnableDriveY: boolean, bEnableDriveZ: boolean) : void;
        SetLinearVelocityTarget(InVelTarget: UE.Vector) : void;
        SetLinearXLimit(ConstraintType: UE.ELinearConstraintMotion, LimitSize: number) : void;
        SetLinearYLimit(ConstraintType: UE.ELinearConstraintMotion, LimitSize: number) : void;
        SetLinearZLimit(ConstraintType: UE.ELinearConstraintMotion, LimitSize: number) : void;
        SetOrientationDriveSLERP(bEnableSLERP: boolean) : void;
        SetOrientationDriveTwistAndSwing(bEnableTwistDrive: boolean, bEnableSwingDrive: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsConstraintComponent;
        static Load(InName: string): PhysicsConstraintComponent;
    }
    
    class PhysicsConstraintActor extends UE.RigidBodyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstraintComp: UE.PhysicsConstraintComponent;
        ConstraintActor1: UE.Actor;
        ConstraintActor2: UE.Actor;
        bDisableCollision: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsConstraintActor;
        static Load(InName: string): PhysicsConstraintActor;
    }
    
    class PhysicsHandleComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GrabbedComponent: UE.PrimitiveComponent;
        bSoftAngularConstraint: boolean;
        bSoftLinearConstraint: boolean;
        bInterpolateTarget: boolean;
        LinearDamping: number;
        LinearStiffness: number;
        AngularDamping: number;
        AngularStiffness: number;
        InterpolationSpeed: number;
        GetGrabbedComponent() : UE.PrimitiveComponent;
        GetTargetLocationAndRotation(TargetLocation: $Ref<UE.Vector>, TargetRotation: $Ref<UE.Rotator>) : void;
        GrabComponent(Component: $Nullable<UE.PrimitiveComponent>, InBoneName: string, GrabLocation: UE.Vector, bConstrainRotation: boolean) : void;
        GrabComponentAtLocation(Component: $Nullable<UE.PrimitiveComponent>, InBoneName: string, GrabLocation: UE.Vector) : void;
        GrabComponentAtLocationWithRotation(Component: $Nullable<UE.PrimitiveComponent>, InBoneName: string, Location: UE.Vector, Rotation: UE.Rotator) : void;
        ReleaseComponent() : void;
        SetAngularDamping(NewAngularDamping: number) : void;
        SetAngularStiffness(NewAngularStiffness: number) : void;
        SetInterpolationSpeed(NewInterpolationSpeed: number) : void;
        SetLinearDamping(NewLinearDamping: number) : void;
        SetLinearStiffness(NewLinearStiffness: number) : void;
        SetTargetLocation(NewLocation: UE.Vector) : void;
        SetTargetLocationAndRotation(NewLocation: UE.Vector, NewRotation: UE.Rotator) : void;
        SetTargetRotation(NewRotation: UE.Rotator) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsHandleComponent;
        static Load(InName: string): PhysicsHandleComponent;
    }
    
    class RigidBodyErrorCorrection {
        constructor();
        constructor(PingExtrapolation: number, PingLimit: number, ErrorPerLinearDifference: number, ErrorPerAngularDifference: number, MaxRestoredStateError: number, MaxLinearHardSnapDistance: number, PositionLerp: number, AngleLerp: number, LinearVelocityCoefficient: number, AngularVelocityCoefficient: number, ErrorAccumulationSeconds: number, ErrorAccumulationDistanceSq: number, ErrorAccumulationSimilarity: number);
        PingExtrapolation: number;
        PingLimit: number;
        ErrorPerLinearDifference: number;
        ErrorPerAngularDifference: number;
        MaxRestoredStateError: number;
        MaxLinearHardSnapDistance: number;
        PositionLerp: number;
        AngleLerp: number;
        LinearVelocityCoefficient: number;
        AngularVelocityCoefficient: number;
        ErrorAccumulationSeconds: number;
        ErrorAccumulationDistanceSq: number;
        ErrorAccumulationSimilarity: number;
        static StaticClass(): Class;
    }
    
    enum ESettingsLockedAxis { None, X, Y, Z, Invalid, ESettingsLockedAxis_MAX}
    enum ESettingsDOF { Full3D, YZPlane, XZPlane, XYPlane, ESettingsDOF_MAX}
    class PhysicalSurfaceName {
        constructor();
        constructor(Type: UE.EPhysicalSurface, Name: string);
        Type: UE.EPhysicalSurface;
        Name: string;
        static StaticClass(): Class;
    }
    
    enum EChaosThreadingMode { DedicatedThread, TaskGraph, SingleThread, Num, Invalid, EChaosThreadingMode_MAX}
    enum EChaosSolverTickMode { Fixed, Variable, VariableCapped, VariableCappedWithTarget, EChaosSolverTickMode_MAX}
    enum EChaosBufferMode { Double, Triple, Num, Invalid, EChaosBufferMode_MAX}
    class ChaosPhysicsSettings {
        constructor();
        constructor(DefaultThreadingModel: UE.EChaosThreadingMode, DedicatedThreadTickMode: UE.EChaosSolverTickMode, DedicatedThreadBufferMode: UE.EChaosBufferMode);
        DefaultThreadingModel: UE.EChaosThreadingMode;
        DedicatedThreadTickMode: UE.EChaosSolverTickMode;
        DedicatedThreadBufferMode: UE.EChaosBufferMode;
        static StaticClass(): Class;
    }
    
    class PhysicsSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultGravityZ: number;
        DefaultTerminalVelocity: number;
        DefaultFluidFriction: number;
        SimulateScratchMemorySize: number;
        RagdollAggregateThreshold: number;
        TriangleMeshTriangleMinAreaThreshold: number;
        bEnableShapeSharing: boolean;
        bEnablePCM: boolean;
        bEnableStabilization: boolean;
        bWarnMissingLocks: boolean;
        bEnable2DPhysics: boolean;
        PhysicErrorCorrection: UE.RigidBodyErrorCorrection;
        LockedAxis: UE.ESettingsLockedAxis;
        DefaultDegreesOfFreedom: UE.ESettingsDOF;
        BounceThresholdVelocity: number;
        FrictionCombineMode: UE.EFrictionCombineMode;
        RestitutionCombineMode: UE.EFrictionCombineMode;
        MaxAngularVelocity: number;
        MaxDepenetrationVelocity: number;
        ContactOffsetMultiplier: number;
        MinContactOffset: number;
        MaxContactOffset: number;
        bSimulateSkeletalMeshOnDedicatedServer: boolean;
        DefaultShapeComplexity: UE.ECollisionTraceFlag;
        bDefaultHasComplexCollision: boolean;
        bSuppressFaceRemapTable: boolean;
        bSupportUVFromHitResults: boolean;
        bDisableActiveActors: boolean;
        bDisableKinematicStaticPairs: boolean;
        bDisableKinematicKinematicPairs: boolean;
        bDisableCCD: boolean;
        bEnableEnhancedDeterminism: boolean;
        AnimPhysicsMinDeltaTime: number;
        bSimulateAnimPhysicsAfterReset: boolean;
        MaxPhysicsDeltaTime: number;
        bSubstepping: boolean;
        bSubsteppingAsync: boolean;
        MaxSubstepDeltaTime: number;
        MaxSubsteps: number;
        SyncSceneSmoothingFactor: number;
        InitialAverageFrameRate: number;
        PhysXTreeRebuildRate: number;
        PhysicalSurfaces: TArray<UE.PhysicalSurfaceName>;
        DefaultBroadphaseSettings: UE.BroadphaseSettings;
        ChaosSettings: UE.ChaosPhysicsSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsSettings;
        static Load(InName: string): PhysicsSettings;
    }
    
    class PhysicsSpringComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpringStiffness: number;
        SpringDamping: number;
        SpringLengthAtRest: number;
        SpringRadius: number;
        SpringChannel: UE.ECollisionChannel;
        bIgnoreSelf: boolean;
        SpringCompression: number;
        GetNormalizedCompressionScalar() : number;
        GetSpringCurrentEndPoint() : UE.Vector;
        GetSpringDirection() : UE.Vector;
        GetSpringRestingPoint() : UE.Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsSpringComponent;
        static Load(InName: string): PhysicsSpringComponent;
    }
    
    class PhysicsThrusterComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ThrustStrength: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsThrusterComponent;
        static Load(InName: string): PhysicsThrusterComponent;
    }
    
    class PhysicsThruster extends UE.RigidBodyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ThrusterComponent: UE.PhysicsThrusterComponent;
        ArrowComponent: UE.ArrowComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsThruster;
        static Load(InName: string): PhysicsThruster;
    }
    
    enum EPIEPreviewDeviceType { Unset, Android, IOS, TVOS, Switch, MAX}
    class PIEPreviewDeviceSpecification extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PreviewDeviceType: UE.EPIEPreviewDeviceType;
        GPUFamily: string;
        GLVersion: string;
        VulkanVersion: string;
        AndroidVersion: string;
        DeviceMake: string;
        DeviceModel: string;
        DeviceBuildNumber: string;
        UsingHoudini: boolean;
        Hardware: string;
        Chipset: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PIEPreviewDeviceSpecification;
        static Load(InName: string): PIEPreviewDeviceSpecification;
    }
    
    class PIEPreviewSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WindowPosX: number;
        WindowPosY: number;
        WindowScalingFactor: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PIEPreviewSettings;
        static Load(InName: string): PIEPreviewSettings;
    }
    
    enum EPinnedCommandListType { Command, CustomWidget, EPinnedCommandListType_MAX}
    class PinnedCommandListCommand {
        constructor();
        constructor(Name: string, Binding: string, Type: UE.EPinnedCommandListType);
        Name: string;
        Binding: string;
        Type: UE.EPinnedCommandListType;
        static StaticClass(): Class;
    }
    
    class PinnedCommandListContext {
        constructor();
        constructor(Name: string, Commands: TArray<UE.PinnedCommandListCommand>);
        Name: string;
        Commands: TArray<UE.PinnedCommandListCommand>;
        static StaticClass(): Class;
    }
    
    class PinnedCommandListSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Contexts: TArray<UE.PinnedCommandListContext>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PinnedCommandListSettings;
        static Load(InName: string): PinnedCommandListSettings;
    }
    
    class PivotPlaneTranslationGizmoHandleGroup extends UE.AxisGizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PivotPlaneTranslationGizmoHandleGroup;
        static Load(InName: string): PivotPlaneTranslationGizmoHandleGroup;
    }
    
    class PivotRotationGizmoHandleGroup extends UE.AxisGizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RootFullRotationHandleComponent: UE.SceneComponent;
        FullRotationHandleMeshComponent: UE.GizmoHandleMeshComponent;
        StartRotationIndicatorMeshComponent: UE.GizmoHandleMeshComponent;
        RootStartRotationIdicatorComponent: UE.SceneComponent;
        DeltaRotationIndicatorMeshComponent: UE.GizmoHandleMeshComponent;
        RootDeltaRotationIndicatorComponent: UE.SceneComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PivotRotationGizmoHandleGroup;
        static Load(InName: string): PivotRotationGizmoHandleGroup;
    }
    
    class PivotScaleGizmoHandleGroup extends UE.AxisGizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PivotScaleGizmoHandleGroup;
        static Load(InName: string): PivotScaleGizmoHandleGroup;
    }
    
    class UniformScaleGizmoHandleGroup extends UE.GizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UniformScaleGizmoHandleGroup;
        static Load(InName: string): UniformScaleGizmoHandleGroup;
    }
    
    class PivotTranslationGizmoHandleGroup extends UE.AxisGizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PivotTranslationGizmoHandleGroup;
        static Load(InName: string): PivotTranslationGizmoHandleGroup;
    }
    
    class StretchGizmoHandleGroup extends UE.GizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StretchGizmoHandleGroup;
        static Load(InName: string): StretchGizmoHandleGroup;
    }
    
    class PivotTransformGizmo extends UE.BaseTransformGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UniformScaleGizmoHandleGroup: UE.UniformScaleGizmoHandleGroup;
        TranslationGizmoHandleGroup: UE.PivotTranslationGizmoHandleGroup;
        ScaleGizmoHandleGroup: UE.PivotScaleGizmoHandleGroup;
        PlaneTranslationGizmoHandleGroup: UE.PivotPlaneTranslationGizmoHandleGroup;
        RotationGizmoHandleGroup: UE.PivotRotationGizmoHandleGroup;
        StretchGizmoHandleGroup: UE.StretchGizmoHandleGroup;
        LastDraggingHandle: UE.ActorComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PivotTransformGizmo;
        static Load(InName: string): PivotTransformGizmo;
    }
    
    class PixelInspectorView extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FinalColor: UE.LinearColor;
        SceneColor: UE.LinearColor;
        PreExposure: number;
        Luminance: number;
        HdrColor: UE.LinearColor;
        Normal: UE.Vector;
        PerObjectGBufferData: number;
        Metallic: number;
        Specular: number;
        Roughness: number;
        MaterialShadingModel: UE.EMaterialShadingModel;
        SelectiveOutputMask: number;
        BaseColor: UE.LinearColor;
        IndirectIrradiance: number;
        AmbientOcclusion: number;
        SubSurfaceColor: UE.LinearColor;
        SubsurfaceProfile: UE.Vector;
        Opacity: number;
        ClearCoat: number;
        ClearCoatRoughness: number;
        WorldNormal: UE.Vector;
        BackLit: number;
        Cloth: number;
        EyeTangent: UE.Vector;
        IrisMask: number;
        IrisDistance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PixelInspectorView;
        static Load(InName: string): PixelInspectorView;
    }
    
    class PkgInfoCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PkgInfoCommandlet;
        static Load(InName: string): PkgInfoCommandlet;
    }
    
    class PlacedEditorUtilityBase extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HelpText: string;
        ClearActorSelectionSet() : void;
        GetActorReference(PathToActor: string) : UE.Actor;
        GetLevelViewportCameraInfo(CameraLocation: $Ref<UE.Vector>, CameraRotation: $Ref<UE.Rotator>) : boolean;
        GetSelectionSet() : TArray<UE.Actor>;
        SelectNothing() : void;
        SetActorSelectionState(Actor: $Nullable<UE.Actor>, bShouldBeSelected: boolean) : void;
        SetLevelViewportCameraInfo(CameraLocation: UE.Vector, CameraRotation: UE.Rotator) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlacedEditorUtilityBase;
        static Load(InName: string): PlacedEditorUtilityBase;
    }
    
    class PlanarReflectionComponent extends UE.SceneCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PreviewBox: UE.BoxComponent;
        NormalDistortionStrength: number;
        PrefilterRoughness: number;
        PrefilterRoughnessDistance: number;
        ScreenPercentage: number;
        ExtraFOV: number;
        DistanceFromPlaneFadeStart: number;
        DistanceFromPlaneFadeEnd: number;
        DistanceFromPlaneFadeoutStart: number;
        DistanceFromPlaneFadeoutEnd: number;
        AngleFromPlaneFadeStart: number;
        AngleFromPlaneFadeEnd: number;
        bShowPreviewPlane: boolean;
        bRenderSceneTwoSided: boolean;
        CaptureMaterial: UE.Material;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlanarReflectionComponent;
        static Load(InName: string): PlanarReflectionComponent;
    }
    
    class PlanarReflection extends UE.SceneCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlanarReflectionComponent: UE.PlanarReflectionComponent;
        SpriteComponent: UE.BillboardComponent;
        bShowPreviewPlane: boolean;
        OnInterpToggle(bEnable: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlanarReflection;
        static Load(InName: string): PlanarReflection;
    }
    
    class PlaneFalloff extends UE.FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        MinRange: number;
        MaxRange: number;
        Default: number;
        Distance: number;
        Position: UE.Vector;
        Normal: UE.Vector;
        Falloff: UE.EFieldFalloffType;
        SetPlaneFalloff(Magnitude: number, MinRange: number, MaxRange: number, Default: number, Distance: number, Position: UE.Vector, Normal: UE.Vector, Falloff: UE.EFieldFalloffType) : UE.PlaneFalloff;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlaneFalloff;
        static Load(InName: string): PlaneFalloff;
    }
    
    class PlanePositionGizmo extends UE.InteractiveGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisSource: GizmoAxisSource;
        ParameterSource: GizmoVec2ParameterSource;
        HitTarget: GizmoClickTarget;
        StateTarget: GizmoStateTarget;
        bInInteraction: boolean;
        InteractionOrigin: UE.Vector;
        InteractionNormal: UE.Vector;
        InteractionAxisX: UE.Vector;
        InteractionAxisY: UE.Vector;
        InteractionStartPoint: UE.Vector;
        InteractionCurPoint: UE.Vector;
        InteractionStartParameter: UE.Vector2D;
        InteractionCurParameter: UE.Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlanePositionGizmo;
        static Load(InName: string): PlanePositionGizmo;
    }
    
    class PlanePositionGizmoBuilder extends UE.InteractiveGizmoBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlanePositionGizmoBuilder;
        static Load(InName: string): PlanePositionGizmoBuilder;
    }
    
    class PlaneReflectionCapture extends UE.ReflectionCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlaneReflectionCapture;
        static Load(InName: string): PlaneReflectionCapture;
    }
    
    class PlaneReflectionCaptureComponent extends UE.ReflectionCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InfluenceRadiusScale: number;
        PreviewInfluenceRadius: UE.DrawSphereComponent;
        PreviewCaptureBox: UE.BoxComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlaneReflectionCaptureComponent;
        static Load(InName: string): PlaneReflectionCaptureComponent;
    }
    
    class PlaneTranslationDragOperation extends UE.ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlaneTranslationDragOperation;
        static Load(InName: string): PlaneTranslationDragOperation;
    }
    
    class PlatformEventsComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlatformChangedToLaptopModeDelegate: $MulticastDelegate<() => void>;
        PlatformChangedToTabletModeDelegate: $MulticastDelegate<() => void>;
        IsInLaptopMode() : boolean;
        IsInTabletMode() : boolean;
        PlatformEventDelegate__DelegateSignature() : void;
        SupportsConvertibleLaptops() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlatformEventsComponent;
        static Load(InName: string): PlatformEventsComponent;
    }
    
    enum EApplicationState { Unknown, Inactive, Background, Active, EApplicationState_MAX}
    class PlatformGameInstance extends UE.GameInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ApplicationWillDeactivateDelegate: $MulticastDelegate<() => void>;
        ApplicationHasReactivatedDelegate: $MulticastDelegate<() => void>;
        ApplicationWillEnterBackgroundDelegate: $MulticastDelegate<() => void>;
        ApplicationHasEnteredForegroundDelegate: $MulticastDelegate<() => void>;
        ApplicationWillTerminateDelegate: $MulticastDelegate<() => void>;
        ApplicationShouldUnloadResourcesDelegate: $MulticastDelegate<() => void>;
        ApplicationReceivedStartupArgumentsDelegate: $MulticastDelegate<(StartupArguments: TArray<string>) => void>;
        ApplicationRegisteredForRemoteNotificationsDelegate: $MulticastDelegate<(inArray: TArray<number>) => void>;
        ApplicationRegisteredForUserNotificationsDelegate: $MulticastDelegate<(inInt: number) => void>;
        ApplicationFailedToRegisterForRemoteNotificationsDelegate: $MulticastDelegate<(inString: string) => void>;
        ApplicationReceivedRemoteNotificationDelegate: $MulticastDelegate<(inString: string, inAppState: UE.EApplicationState) => void>;
        ApplicationReceivedLocalNotificationDelegate: $MulticastDelegate<(inString: string, inInt: number, inAppState: UE.EApplicationState) => void>;
        ApplicationReceivedScreenOrientationChangedNotificationDelegate: $MulticastDelegate<(inScreenOrientation: UE.EScreenOrientation) => void>;
        PlatformDelegate__DelegateSignature() : void;
        PlatformFailedToRegisterForRemoteNotificationsDelegate__DelegateSignature(inString: string) : void;
        PlatformReceivedLocalNotificationDelegate__DelegateSignature(inString: string, inInt: number, inAppState: UE.EApplicationState) : void;
        PlatformReceivedRemoteNotificationDelegate__DelegateSignature(inString: string, inAppState: UE.EApplicationState) : void;
        PlatformRegisteredForRemoteNotificationsDelegate__DelegateSignature(inArray: TArray<number>) : void;
        PlatformRegisteredForUserNotificationsDelegate__DelegateSignature(inInt: number) : void;
        PlatformScreenOrientationChangedDelegate__DelegateSignature(inScreenOrientation: UE.EScreenOrientation) : void;
        PlatformStartupArgumentsDelegate__DelegateSignature(StartupArguments: TArray<string>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlatformGameInstance;
        static Load(InName: string): PlatformGameInstance;
    }
    
    class PlatformInterfaceWebResponse extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OriginalURL: string;
        ResponseCode: number;
        Tag: number;
        StringResponse: string;
        BinaryResponse: TArray<number>;
        GetHeader(HeaderIndex: number, Header: $Ref<string>, Value: $Ref<string>) : void;
        GetHeaderValue(HeaderName: string) : string;
        GetNumHeaders() : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlatformInterfaceWebResponse;
        static Load(InName: string): PlatformInterfaceWebResponse;
    }
    
    class PlatformMediaSource extends UE.MediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlatformMediaSources: TMap<string, UE.MediaSource>;
        MediaSource: UE.MediaSource;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlatformMediaSource;
        static Load(InName: string): PlatformMediaSource;
    }
    
    class PlatformMediaSourceFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlatformMediaSourceFactoryNew;
        static Load(InName: string): PlatformMediaSourceFactoryNew;
    }
    
    class PlayerStart extends UE.NavigationObjectBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlayerStartTag: string;
        ArrowComponent: UE.ArrowComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlayerStart;
        static Load(InName: string): PlayerStart;
    }
    
    class PlayerStartPIE extends UE.PlayerStart {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlayerStartPIE;
        static Load(InName: string): PlayerStartPIE;
    }
    
    class BranchingPointNotifyPayload {
        constructor();
        static StaticClass(): Class;
    }
    
    class PlayMontageCallbackProxy extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnCompleted: $MulticastDelegate<(NotifyName: string) => void>;
        OnBlendOut: $MulticastDelegate<(NotifyName: string) => void>;
        OnInterrupted: $MulticastDelegate<(NotifyName: string) => void>;
        OnNotifyBegin: $MulticastDelegate<(NotifyName: string) => void>;
        OnNotifyEnd: $MulticastDelegate<(NotifyName: string) => void>;
        OnMontageBlendingOut(Montage: $Nullable<UE.AnimMontage>, bInterrupted: boolean) : void;
        OnMontageEnded(Montage: $Nullable<UE.AnimMontage>, bInterrupted: boolean) : void;
        OnNotifyBeginReceived(NotifyName: string, BranchingPointNotifyPayload: UE.BranchingPointNotifyPayload) : void;
        OnNotifyEndReceived(NotifyName: string, BranchingPointNotifyPayload: UE.BranchingPointNotifyPayload) : void;
        static CreateProxyObjectForPlayMontage(InSkeletalMeshComponent: $Nullable<UE.SkeletalMeshComponent>, MontageToPlay: $Nullable<UE.AnimMontage>, PlayRate?: number /* = 1.000000 */, StartingPosition?: number /* = 0.000000 */, StartingSection?: string /* = "None" */) : UE.PlayMontageCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlayMontageCallbackProxy;
        static Load(InName: string): PlayMontageCallbackProxy;
    }
    
    class PluginCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PluginCommandlet;
        static Load(InName: string): PluginCommandlet;
    }
    
    class PluginMetadataObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Version: number;
        VersionName: string;
        FriendlyName: string;
        Description: string;
        Category: string;
        CreatedBy: string;
        CreatedByURL: string;
        DocsURL: string;
        MarketplaceURL: string;
        SupportURL: string;
        bCanContainContent: boolean;
        bIsBetaVersion: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PluginMetadataObject;
        static Load(InName: string): PluginMetadataObject;
    }
    
    class PointLight extends UE.Light {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PointLightComponent: UE.PointLightComponent;
        SetLightFalloffExponent(NewLightFalloffExponent: number) : void;
        SetRadius(NewRadius: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PointLight;
        static Load(InName: string): PointLight;
    }
    
    class PolysExporterOBJ extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PolysExporterOBJ;
        static Load(InName: string): PolysExporterOBJ;
    }
    
    class PolysExporterT3D extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PolysExporterT3D;
        static Load(InName: string): PolysExporterT3D;
    }
    
    class PolysFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PolysFactory;
        static Load(InName: string): PolysFactory;
    }
    
    class PopulateDialogueWaveFromCharacterSheetCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PopulateDialogueWaveFromCharacterSheetCommandlet;
        static Load(InName: string): PopulateDialogueWaveFromCharacterSheetCommandlet;
    }
    
    enum EBoneSpaces { WorldSpace, ComponentSpace, EBoneSpaces_MAX}
    class PoseableMeshComponent extends UE.SkinnedMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CopyPoseFromSkeletalComponent(InComponentToCopy: $Nullable<UE.SkeletalMeshComponent>) : void;
        GetBoneLocationByName(BoneName: string, BoneSpace: UE.EBoneSpaces) : UE.Vector;
        GetBoneRotationByName(BoneName: string, BoneSpace: UE.EBoneSpaces) : UE.Rotator;
        GetBoneScaleByName(BoneName: string, BoneSpace: UE.EBoneSpaces) : UE.Vector;
        GetBoneTransformByName(BoneName: string, BoneSpace: UE.EBoneSpaces) : UE.Transform;
        ResetBoneTransformByName(BoneName: string) : void;
        SetBoneLocationByName(BoneName: string, InLocation: UE.Vector, BoneSpace: UE.EBoneSpaces) : void;
        SetBoneRotationByName(BoneName: string, InRotation: UE.Rotator, BoneSpace: UE.EBoneSpaces) : void;
        SetBoneScaleByName(BoneName: string, InScale3D: UE.Vector, BoneSpace: UE.EBoneSpaces) : void;
        SetBoneTransformByName(BoneName: string, InTransform: UE.Transform, BoneSpace: UE.EBoneSpaces) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PoseableMeshComponent;
        static Load(InName: string): PoseableMeshComponent;
    }
    
    class PoseAssetFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceAnimation: UE.AnimSequence;
        PoseNames: TArray<string>;
        TargetSkeleton: UE.Skeleton;
        PreviewSkeletalMesh: UE.SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PoseAssetFactory;
        static Load(InName: string): PoseAssetFactory;
    }
    
    class PostProcessComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: UE.PostProcessSettings;
        Priority: number;
        BlendRadius: number;
        BlendWeight: number;
        bEnabled: boolean;
        bUnbound: boolean;
        AddOrUpdateBlendable(InBlendableObject: BlendableInterface, InWeight?: number /* = 1.000000 */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PostProcessComponent;
        static Load(InName: string): PostProcessComponent;
    }
    
    class PostProcessVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: UE.PostProcessSettings;
        Priority: number;
        BlendRadius: number;
        BlendWeight: number;
        bEnabled: boolean;
        bUnbound: boolean;
        AddOrUpdateBlendable(InBlendableObject: BlendableInterface, InWeight?: number /* = 1.000000 */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PostProcessVolume;
        static Load(InName: string): PostProcessVolume;
    }
    
    class PrecomputedVisibilityOverrideVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OverrideVisibleActors: TArray<UE.Actor>;
        OverrideInvisibleActors: TArray<UE.Actor>;
        OverrideInvisibleLevels: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PrecomputedVisibilityOverrideVolume;
        static Load(InName: string): PrecomputedVisibilityOverrideVolume;
    }
    
    class PrecomputedVisibilityVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PrecomputedVisibilityVolume;
        static Load(InName: string): PrecomputedVisibilityVolume;
    }
    
    class PreviewCollectionInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PreviewCollectionInterface;
        static Load(InName: string): PreviewCollectionInterface;
    }
    
    class PreviewMaterial extends UE.Material {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PreviewMaterial;
        static Load(InName: string): PreviewMaterial;
    }
    
    class PreviewMeshCollectionFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurrentSkeleton: TWeakObjectPtr<UE.Skeleton>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PreviewMeshCollectionFactory;
        static Load(InName: string): PreviewMeshCollectionFactory;
    }
    
    class AssetBundleEntry {
        constructor();
        constructor(BundleScope: UE.PrimaryAssetId, BundleName: string, BundleAssets: TArray<UE.SoftObjectPath>);
        BundleScope: UE.PrimaryAssetId;
        BundleName: string;
        BundleAssets: TArray<UE.SoftObjectPath>;
        static StaticClass(): Class;
    }
    
    class AssetBundleData {
        constructor();
        constructor(Bundles: TArray<UE.AssetBundleEntry>);
        Bundles: TArray<UE.AssetBundleEntry>;
        static StaticClass(): Class;
    }
    
    class PrimaryDataAsset extends UE.DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssetBundleData: UE.AssetBundleData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PrimaryDataAsset;
        static Load(InName: string): PrimaryDataAsset;
    }
    
    class CollectionReference {
        constructor();
        constructor(CollectionName: string);
        CollectionName: string;
        static StaticClass(): Class;
    }
    
    class PrimaryAssetLabel extends UE.PrimaryDataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Rules: UE.PrimaryAssetRules;
        bLabelAssetsInMyDirectory: boolean;
        bIsRuntimeLabel: boolean;
        ExplicitAssets: TArray<TSoftObjectPtr<UE.Object>>;
        ExplicitBlueprints: TArray<TSoftClassPtr<UE.Object>>;
        AssetCollection: UE.CollectionReference;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PrimaryAssetLabel;
        static Load(InName: string): PrimaryAssetLabel;
    }
    
    class PrimitiveStats extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Object: TWeakObjectPtr<UE.Object>;
        Actors: TArray<TWeakObjectPtr<UE.Actor>>;
        Type: string;
        Count: number;
        Sections: number;
        HWInstances: number;
        InstSections: number;
        Triangles: number;
        InstTriangles: number;
        ResourceSize: number;
        VertexColorMem: number;
        InstVertexColorMem: number;
        LightsLM: number;
        LightsOther: number;
        LightsTotal: number;
        ObjLightCost: number;
        LightMapData: number;
        LMSMResolution: number;
        RadiusMin: number;
        RadiusMax: number;
        RadiusAvg: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PrimitiveStats;
        static Load(InName: string): PrimitiveStats;
    }
    
    class FoliageTypeObject {
        constructor();
        constructor(FoliageTypeObject: UE.Object, TypeInstance: UE.FoliageType, bIsAsset: boolean, Type: UE.Class);
        FoliageTypeObject: UE.Object;
        TypeInstance: UE.FoliageType;
        bIsAsset: boolean;
        Type: UE.Class;
        static StaticClass(): Class;
    }
    
    class ProceduralFoliageSpawner extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeed: number;
        TileSize: number;
        NumUniqueTiles: number;
        MinimumQuadTreeSize: number;
        FoliageTypes: TArray<UE.FoliageTypeObject>;
        bNeedsSimulation: boolean;
        Simulate(NumSteps?: number /* = -1 */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageSpawner;
        static Load(InName: string): ProceduralFoliageSpawner;
    }
    
    class ProceduralFoliageComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FoliageSpawner: UE.ProceduralFoliageSpawner;
        TileOverlap: number;
        bAllowLandscape: boolean;
        bAllowBSP: boolean;
        bAllowStaticMesh: boolean;
        bAllowTranslucent: boolean;
        bAllowFoliage: boolean;
        bShowDebugTiles: boolean;
        SpawningVolume: UE.Volume;
        ProceduralGuid: UE.Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageComponent;
        static Load(InName: string): ProceduralFoliageComponent;
    }
    
    class ProceduralFoliageVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProceduralComponent: UE.ProceduralFoliageComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageVolume;
        static Load(InName: string): ProceduralFoliageVolume;
    }
    
    class ProceduralFoliageBlockingVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProceduralFoliageVolume: UE.ProceduralFoliageVolume;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageBlockingVolume;
        static Load(InName: string): ProceduralFoliageBlockingVolume;
    }
    
    class ProceduralFoliageSpawnerFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageSpawnerFactory;
        static Load(InName: string): ProceduralFoliageSpawnerFactory;
    }
    
    class ProceduralFoliageInstance {
        constructor();
        constructor(Location: UE.Vector, Rotation: UE.Quat, Normal: UE.Vector, Age: number, Scale: number, Type: UE.FoliageType);
        Location: UE.Vector;
        Rotation: UE.Quat;
        Normal: UE.Vector;
        Age: number;
        Scale: number;
        Type: UE.FoliageType;
        static StaticClass(): Class;
    }
    
    class ProceduralFoliageTile extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FoliageSpawner: UE.ProceduralFoliageSpawner;
        InstancesArray: TArray<UE.ProceduralFoliageInstance>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageTile;
        static Load(InName: string): ProceduralFoliageTile;
    }
    
    class ProgressBarStyle extends UE.SlateWidgetStyle {
        constructor();
        constructor(BackgroundImage: UE.SlateBrush, FillImage: UE.SlateBrush, MarqueeImage: UE.SlateBrush);
        BackgroundImage: UE.SlateBrush;
        FillImage: UE.SlateBrush;
        MarqueeImage: UE.SlateBrush;
        static StaticClass(): Class;
    }
    
    enum EProgressBarFillType { LeftToRight, RightToLeft, FillFromCenter, TopToBottom, BottomToTop, EProgressBarFillType_MAX}
    class ProgressBar extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetStyle: UE.ProgressBarStyle;
        Style: UE.SlateWidgetStyleAsset;
        BackgroundImage: UE.SlateBrushAsset;
        FillImage: UE.SlateBrushAsset;
        MarqueeImage: UE.SlateBrushAsset;
        Percent: number;
        BarFillType: UE.EProgressBarFillType;
        bIsMarquee: boolean;
        BorderPadding: UE.Vector2D;
        PercentDelegate: $Delegate<() => number>;
        FillColorAndOpacity: UE.LinearColor;
        FillColorAndOpacityDelegate: $Delegate<() => UE.LinearColor>;
        SetFillColorAndOpacity(InColor: UE.LinearColor) : void;
        SetIsMarquee(InbIsMarquee: boolean) : void;
        SetPercent(InPercent: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProgressBar;
        static Load(InName: string): ProgressBar;
    }
    
    class ProgressWidgetStyle extends UE.SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProgressBarStyle: UE.ProgressBarStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProgressWidgetStyle;
        static Load(InName: string): ProgressWidgetStyle;
    }
    
    class ProjectileMovementComponent extends UE.MovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialSpeed: number;
        MaxSpeed: number;
        bRotationFollowsVelocity: boolean;
        bRotationRemainsVertical: boolean;
        bShouldBounce: boolean;
        bInitialVelocityInLocalSpace: boolean;
        bForceSubStepping: boolean;
        bSimulationEnabled: boolean;
        bSweepCollision: boolean;
        bIsHomingProjectile: boolean;
        bBounceAngleAffectsFriction: boolean;
        bIsSliding: boolean;
        bInterpMovement: boolean;
        bInterpRotation: boolean;
        PreviousHitTime: number;
        PreviousHitNormal: UE.Vector;
        ProjectileGravityScale: number;
        Buoyancy: number;
        Bounciness: number;
        Friction: number;
        BounceVelocityStopSimulatingThreshold: number;
        MinFrictionFraction: number;
        OnProjectileBounce: $MulticastDelegate<(ImpactResult: UE.HitResult, ImpactVelocity: UE.Vector) => void>;
        OnProjectileStop: $MulticastDelegate<(ImpactResult: UE.HitResult) => void>;
        HomingAccelerationMagnitude: number;
        HomingTargetComponent: TWeakObjectPtr<UE.SceneComponent>;
        MaxSimulationTimeStep: number;
        MaxSimulationIterations: number;
        BounceAdditionalIterations: number;
        InterpLocationTime: number;
        InterpRotationTime: number;
        InterpLocationMaxLagDistance: number;
        InterpLocationSnapToTargetDistance: number;
        IsInterpolationComplete() : boolean;
        IsVelocityUnderSimulationThreshold() : boolean;
        LimitVelocity(NewVelocity: UE.Vector) : UE.Vector;
        MoveInterpolationTarget(NewLocation: UE.Vector, NewRotation: UE.Rotator) : void;
        OnProjectileBounceDelegate__DelegateSignature(ImpactResult: UE.HitResult, ImpactVelocity: UE.Vector) : void;
        OnProjectileStopDelegate__DelegateSignature(ImpactResult: UE.HitResult) : void;
        ResetInterpolation() : void;
        SetInterpolatedComponent(Component: $Nullable<UE.SceneComponent>) : void;
        SetVelocityInLocalSpace(NewVelocity: UE.Vector) : void;
        StopSimulating(HitResult: UE.HitResult) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProjectileMovementComponent;
        static Load(InName: string): ProjectileMovementComponent;
    }
    
    enum EProjectPackagingBuild { Always, Never, IfProjectHasCode, IfEditorWasBuiltLocally, EProjectPackagingBuild_MAX}
    enum EProjectPackagingBuildConfigurations { PPBC_Debug, PPBC_DebugGame, PPBC_Development, PPBC_Test, PPBC_Shipping, PPBC_MAX}
    enum EProjectPackagingBlueprintNativizationMethod { Disabled, Inclusive, Exclusive, EProjectPackagingBlueprintNativizationMethod_MAX}
    enum EProjectPackagingInternationalizationPresets { English, EFIGS, EFIGSCJK, CJK, All, EProjectPackagingInternationalizationPresets_MAX}
    class ProjectPackagingSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Build: UE.EProjectPackagingBuild;
        BuildConfiguration: UE.EProjectPackagingBuildConfigurations;
        BuildTarget: string;
        StagingDirectory: UE.DirectoryPath;
        FullRebuild: boolean;
        ForDistribution: boolean;
        IncludeDebugFiles: boolean;
        BlueprintNativizationMethod: UE.EProjectPackagingBlueprintNativizationMethod;
        NativizeBlueprintAssets: TArray<UE.FilePath>;
        bIncludeNativizedAssetsInProjectGeneration: boolean;
        bExcludeMonolithicEngineHeadersInNativizedCode: boolean;
        UsePakFile: boolean;
        bGenerateChunks: boolean;
        bGenerateNoChunks: boolean;
        bChunkHardReferencesOnly: boolean;
        bForceOneChunkPerFile: boolean;
        MaxChunkSize: bigint;
        bBuildHttpChunkInstallData: boolean;
        HttpChunkInstallDataDirectory: UE.DirectoryPath;
        PakFileCompressionFormats: string;
        PakFileAdditionalCompressionOptions: string;
        HttpChunkInstallDataVersion: string;
        IncludePrerequisites: boolean;
        IncludeAppLocalPrerequisites: boolean;
        bShareMaterialShaderCode: boolean;
        bSharedMaterialNativeLibraries: boolean;
        ApplocalPrerequisitesDirectory: UE.DirectoryPath;
        IncludeCrashReporter: boolean;
        InternationalizationPreset: UE.EProjectPackagingInternationalizationPresets;
        CulturesToStage: TArray<string>;
        bCookAll: boolean;
        bCookMapsOnly: boolean;
        bCompressed: boolean;
        bEncryptIniFiles: boolean;
        bEncryptPakIndex: boolean;
        GenerateEarlyDownloaderPakFile: boolean;
        bSkipEditorContent: boolean;
        bSkipMovies: boolean;
        UFSMovies: TArray<string>;
        NonUFSMovies: TArray<string>;
        CompressedChunkWildcard: TArray<string>;
        IniKeyBlacklist: TArray<string>;
        IniSectionBlacklist: TArray<string>;
        EarlyDownloaderPakFileFiles: TArray<string>;
        MapsToCook: TArray<UE.FilePath>;
        DirectoriesToAlwaysCook: TArray<UE.DirectoryPath>;
        DirectoriesToNeverCook: TArray<UE.DirectoryPath>;
        DirectoriesToAlwaysStageAsUFS: TArray<UE.DirectoryPath>;
        DirectoriesToAlwaysStageAsNonUFS: TArray<UE.DirectoryPath>;
        DirectoriesToAlwaysStageAsUFSServer: TArray<UE.DirectoryPath>;
        DirectoriesToAlwaysStageAsNonUFSServer: TArray<UE.DirectoryPath>;
        bNativizeBlueprintAssets: boolean;
        bNativizeOnlySelectedBlueprints: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProjectPackagingSettings;
        static Load(InName: string): ProjectPackagingSettings;
    }
    
    enum PropertyEditorTestEnum { PropertyEditorTest_Enum1, PropertyEditorTest_Enum2, PropertyEditorTest_Enum3, PropertyEditorTest_Enum4, PropertyEditorTest_Enum5, PropertyEditorTest_Enum6, PropertyEditorTest_MAX}
    enum EditColor { Red, Orange, Yellow, Green, Blue, Indigo, Violet, Pink, Magenta, Cyan, EditColor_MAX}
    class PropertyEditorTestSubStruct {
        constructor();
        constructor(FirstProperty: number, SecondProperty: number, CustomizedStructInsideUncustomizedStruct: UE.LinearColor, CustomizedStructInsideUncustomizedStruct2: UE.SoftObjectPath);
        FirstProperty: number;
        SecondProperty: number;
        CustomizedStructInsideUncustomizedStruct: UE.LinearColor;
        CustomizedStructInsideUncustomizedStruct2: UE.SoftObjectPath;
        static StaticClass(): Class;
    }
    
    class PropertyEditorTestBasicStruct {
        constructor();
        constructor(IntPropertyInsideAStruct: number, FloatPropertyInsideAStruct: number, ObjectPropertyInsideAStruct: UE.Object, InnerStruct: UE.PropertyEditorTestSubStruct);
        IntPropertyInsideAStruct: number;
        FloatPropertyInsideAStruct: number;
        ObjectPropertyInsideAStruct: UE.Object;
        InnerStruct: UE.PropertyEditorTestSubStruct;
        static StaticClass(): Class;
    }
    
    class PropertyEditTestTextStruct {
        constructor();
        constructor(NormalProperty: string);
        NormalProperty: string;
        static StaticClass(): Class;
    }
    
    class PropertyEditorTestObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Int8Property: number;
        Int16Property: number;
        Int32Property: number;
        Int64Property: bigint;
        ByteProperty: number;
        UnsignedInt16Property: number;
        UnsignedInt32Property: number;
        UnsignedInt64Property: bigint;
        FloatProperty: number;
        DoubleProperty: number;
        NameProperty: string;
        BoolProperty: boolean;
        StringProperty: string;
        TextProperty: string;
        IntPointProperty: UE.IntPoint;
        Vector3Property: UE.Vector;
        Vector2Property: UE.Vector2D;
        Vector4Property: UE.Vector4;
        RotatorProperty: UE.Rotator;
        ObjectProperty: UE.Object;
        ClassProperty: UE.Class;
        ClassPropertyWithAllowed: UE.Class;
        ClassPropertyWithDisallowed: UE.Class;
        SubclassOfTexture: UE.Class;
        SubclassOfWithAllowed: UE.Class;
        SubclassOfWithDisallowed: UE.Class;
        LinearColorProperty: UE.LinearColor;
        ColorProperty: UE.Color;
        EnumByteProperty: UE.PropertyEditorTestEnum;
        EnumProperty: UE.EditColor;
        MatrixProperty: UE.Matrix;
        TransformProperty: UE.Transform;
        IntProperty32Array: TArray<number>;
        BytePropertyArray: TArray<number>;
        FloatPropertyArray: TArray<number>;
        NamePropertyArray: TArray<string>;
        BoolPropertyArray: TArray<boolean>;
        StringPropertyArray: TArray<string>;
        TextPropertyArray: TArray<string>;
        Vector3PropertyArray: TArray<UE.Vector>;
        Vector2PropertyArray: TArray<UE.Vector2D>;
        Vector4PropertyArray: TArray<UE.Vector4>;
        RotatorPropertyArray: TArray<UE.Rotator>;
        ObjectPropertyArray: TArray<UE.Object>;
        ActorPropertyArray: TArray<UE.Actor>;
        LinearColorPropertyArray: TArray<UE.LinearColor>;
        ColorPropertyArray: TArray<UE.Color>;
        EnumPropertyArray: TArray<UE.PropertyEditorTestEnum>;
        StructPropertyArray: TArray<UE.PropertyEditorTestBasicStruct>;
        FixedArrayOfInts: TArray<number>;
        StaticArrayOfInts: FixSizeArray<number>;
        StaticArrayOfIntsWithEnumLabels: FixSizeArray<number>;
        FloatPropertyWithClampedRange: number;
        IntPropertyWithClampedRange: number;
        IntThatCannotBeChanged: number;
        StringThatCannotBeChanged: string;
        ObjectThatCannotBeChanged: UE.PrimitiveComponent;
        StringPasswordProperty: string;
        TextPasswordProperty: string;
        ThisIsBrokenIfItsVisibleInADetailsView: UE.PropertyEditorTestBasicStruct;
        StructWithMultipleInstances1: UE.PropertyEditorTestBasicStruct;
        bEditConditionStructWithMultipleInstances2: boolean;
        StructWithMultipleInstances2: UE.PropertyEditorTestBasicStruct;
        RichCurve: UE.RichCurve;
        AssetReferenceCustomStruct: UE.SoftObjectPath;
        AssetReferenceCustomStructWithThumbnail: UE.SoftObjectPath;
        ExactlyPointLightActorReference: UE.SoftObjectPath;
        LightActorReference: UE.SoftObjectPath;
        ExactPointOrSpotLightActorReference: UE.SoftObjectPath;
        LightOrStaticMeshActorReference: UE.SoftObjectPath;
        NotLightActorReference: UE.SoftObjectPath;
        MaterialOrTextureAssetReference: UE.SoftObjectPath;
        bEditCondition: boolean;
        SimplePropertyWithEditCondition: number;
        bEditConditionAssetReferenceCustomStructWithEditCondition: boolean;
        AssetReferenceCustomStructWithEditCondition: UE.SoftObjectPath;
        ArrayOfStructs: TArray<UE.PropertyEditorTestBasicStruct>;
        Struct: UE.PropertyEditTestTextStruct;
        EditInlineNewStaticMeshComponent: UE.StaticMeshComponent;
        ArrayOfEditInlineNewSMCs: TArray<UE.StaticMeshComponent>;
        TextureProp: UE.Texture;
        StaticMeshProp: UE.StaticMesh;
        AnyMaterialInterface: UE.MaterialInterface;
        OnlyActorsAllowed: UE.Actor;
        Int32Set: TSet<number>;
        FloatSet: TSet<number>;
        StringSet: TSet<string>;
        ObjectSet: TSet<UE.Object>;
        ActorSet: TSet<UE.Actor>;
        EditColorSet: TSet<UE.EditColor>;
        NameSet: TSet<string>;
        Int32ToStringMap: TMap<number, string>;
        StringToColorMap: TMap<string, UE.LinearColor>;
        Int32ToStructMap: TMap<number, UE.PropertyEditorTestBasicStruct>;
        StringToFloatMap: TMap<string, number>;
        StringToObjectMap: TMap<string, UE.Object>;
        StringToActorMap: TMap<string, UE.Actor>;
        ObjectToInt32Map: TMap<UE.Object, number>;
        ObjectToColorMap: TMap<UE.Object, UE.LinearColor>;
        IntToEnumMap: TMap<number, UE.PropertyEditorTestEnum>;
        NameToNameMap: TMap<string, string>;
        IntToCustomMap: TMap<number, UE.PropertyEditorTestBasicStruct>;
        IntToSubStructMap: TMap<number, UE.PropertyEditorTestSubStruct>;
        LinearColorSet: TSet<UE.LinearColor>;
        VectorSet: TSet<UE.Vector>;
        LinearColorToStringMap: TMap<UE.LinearColor, string>;
        VectorToFloatMap: TMap<UE.Vector, number>;
        LinearColorToVectorMap: TMap<UE.LinearColor, UE.Vector>;
        BlendableInterface: BlendableInterface;
        AnimClassInterface: AnimClassInterface;
        LightPropagationVolumeBlendable: BlendableInterface;
        TextureOrBlendableInterface: UE.Object;
        bSubcategory: boolean;
        bSubcategoryAdvanced: boolean;
        bSubcategoryFooSimple: boolean;
        bSubcategoryFooAdvanced: boolean;
        bSubcategoryBarSimple: boolean;
        bSubcategoryBarAdvanced: boolean;
        bSubcategoryLast: boolean;
        bEnablesNext: boolean;
        bEnabledByPrevious: boolean;
        EnumEditCondition: UE.EditColor;
        bEnabledWhenBlue: boolean;
        bEnabledWhenPink: boolean;
        EnumAsByteEditCondition: UE.PropertyEditorTestEnum;
        bEnabledWhenEnumIs2: boolean;
        bEnabledWhenEnumIs4: boolean;
        IntegerEditCondition: number;
        bEnabledWhenIntGreaterOrEqual5: boolean;
        bEnabledWhenIntLessOrEqual10: boolean;
        FloatEditCondition: number;
        bEnabledWhenFloatGreaterThan5: boolean;
        bEnabledWhenFloatLessThan10: boolean;
        bEditConditionForArrays: boolean;
        ArrayWithEditCondition: TArray<UE.Texture2D>;
        ArrayOfStructsWithEditCondition: TArray<UE.PropertyEditorTestBasicStruct>;
        InlineProperty: UE.EComponentMobility;
        PropertyThatHides: UE.EComponentMobility;
        bVisibleWhenStatic: boolean;
        VisibleWhenStationary: number;
        DateTime: UE.DateTime;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyEditorTestObject;
        static Load(InName: string): PropertyEditorTestObject;
    }
    
    class PropertyValueColor extends UE.PropertyValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyValueColor;
        static Load(InName: string): PropertyValueColor;
    }
    
    class PropertyValueMaterial extends UE.PropertyValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyValueMaterial;
        static Load(InName: string): PropertyValueMaterial;
    }
    
    class PropertyValueOption extends UE.PropertyValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyValueOption;
        static Load(InName: string): PropertyValueOption;
    }
    
    class PropertyValueTransform extends UE.PropertyValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyValueTransform;
        static Load(InName: string): PropertyValueTransform;
    }
    
    class PropertyValueVisibility extends UE.PropertyValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyValueVisibility;
        static Load(InName: string): PropertyValueVisibility;
    }
    
    class ProxyLODMeshSimplificationSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProxyLODMeshReductionModuleName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProxyLODMeshSimplificationSettings;
        static Load(InName: string): ProxyLODMeshSimplificationSettings;
    }
    
    class puerts_unreal_demoGameModeBase extends UE.GameModeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): puerts_unreal_demoGameModeBase;
        static Load(InName: string): puerts_unreal_demoGameModeBase;
    }
    
    class PuertsSetting extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AutoModeEnable: boolean;
        DebugEnable: boolean;
        DebugPort: number;
        WaitDebugger: boolean;
        WaitDebuggerTimeout: number;
        NumberOfJsEnv: number;
        WatchDisable: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PuertsSetting;
        static Load(InName: string): PuertsSetting;
    }
    
    class QuitMatchCallbackProxy extends UE.OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;
        static QuitMatch(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>, MatchID: string, Outcome: UE.EMPMatchOutcome, TurnTimeoutInSeconds: number) : UE.QuitMatchCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): QuitMatchCallbackProxy;
        static Load(InName: string): QuitMatchCallbackProxy;
    }
    
    class RadialFalloff extends UE.FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        MinRange: number;
        MaxRange: number;
        Default: number;
        Radius: number;
        Position: UE.Vector;
        Falloff: UE.EFieldFalloffType;
        SetRadialFalloff(Magnitude: number, MinRange: number, MaxRange: number, Default: number, Radius: number, Position: UE.Vector, Falloff: UE.EFieldFalloffType) : UE.RadialFalloff;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RadialFalloff;
        static Load(InName: string): RadialFalloff;
    }
    
    class RadialForceComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Radius: number;
        Falloff: UE.ERadialImpulseFalloff;
        ImpulseStrength: number;
        bImpulseVelChange: boolean;
        bIgnoreOwningActor: boolean;
        ForceStrength: number;
        DestructibleDamage: number;
        ObjectTypesToAffect: TArray<UE.EObjectTypeQuery>;
        AddObjectTypeToAffect(ObjectType: UE.EObjectTypeQuery) : void;
        FireImpulse() : void;
        RemoveObjectTypeToAffect(ObjectType: UE.EObjectTypeQuery) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RadialForceComponent;
        static Load(InName: string): RadialForceComponent;
    }
    
    class RadialForceActor extends UE.RigidBodyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ForceComponent: UE.RadialForceComponent;
        SpriteComponent: UE.BillboardComponent;
        DisableForce() : void;
        EnableForce() : void;
        FireImpulse() : void;
        ToggleForce() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RadialForceActor;
        static Load(InName: string): RadialForceActor;
    }
    
    enum ESetMaskConditionType { Field_Set_Always, Field_Set_IFF_NOT_Interior, Field_Set_IFF_NOT_Exterior, Field_MaskCondition_Max}
    class RadialIntMask extends UE.FieldNodeInt {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Radius: number;
        Position: UE.Vector;
        InteriorValue: number;
        ExteriorValue: number;
        SetMaskCondition: UE.ESetMaskConditionType;
        SetRadialIntMask(Radius: number, Position: UE.Vector, InteriorValue: number, ExteriorValue: number, SetMaskConditionIn: UE.ESetMaskConditionType) : UE.RadialIntMask;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RadialIntMask;
        static Load(InName: string): RadialIntMask;
    }
    
    class RadialVector extends UE.FieldNodeVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        Position: UE.Vector;
        SetRadialVector(Magnitude: number, Position: UE.Vector) : UE.RadialVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RadialVector;
        static Load(InName: string): RadialVector;
    }
    
    class RandomVector extends UE.FieldNodeVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        SetRandomVector(Magnitude: number) : UE.RandomVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RandomVector;
        static Load(InName: string): RandomVector;
    }
    
    class ReactDeclarationGenerator extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Gen() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReactDeclarationGenerator;
        static Load(InName: string): ReactDeclarationGenerator;
    }
    
    class ReactWidget extends UE.UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddChild(Content: $Nullable<UE.Widget>) : UE.PanelSlot;
        RemoveChild(Content: $Nullable<UE.Widget>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReactWidget;
        static Load(InName: string): ReactWidget;
    }
    
    class RecastFilter_UseDefaultArea extends UE.NavigationQueryFilter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RecastFilter_UseDefaultArea;
        static Load(InName: string): RecastFilter_UseDefaultArea;
    }
    
    enum ERecastPartitioning { Monotone, Watershed, ChunkyMonotone, ERecastPartitioning_MAX}
    class RecastNavMesh extends UE.NavigationData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDrawTriangleEdges: boolean;
        bDrawPolyEdges: boolean;
        bDrawFilledPolys: boolean;
        bDrawNavMeshEdges: boolean;
        bDrawTileBounds: boolean;
        bDrawPathCollidingGeometry: boolean;
        bDrawTileLabels: boolean;
        bDrawPolygonLabels: boolean;
        bDrawDefaultPolygonCost: boolean;
        bDrawLabelsOnPathNodes: boolean;
        bDrawNavLinks: boolean;
        bDrawFailedNavLinks: boolean;
        bDrawClusters: boolean;
        bDrawOctree: boolean;
        bDrawOctreeDetails: boolean;
        bDrawMarkedForbiddenPolys: boolean;
        bDistinctlyDrawTilesBeingBuilt: boolean;
        bDrawNavMesh: boolean;
        DrawOffset: number;
        bFixedTilePoolSize: boolean;
        TilePoolSize: number;
        TileSizeUU: number;
        CellSize: number;
        CellHeight: number;
        AgentRadius: number;
        AgentHeight: number;
        AgentMaxHeight: number;
        AgentMaxSlope: number;
        AgentMaxStepHeight: number;
        MinRegionArea: number;
        MergeRegionSize: number;
        MaxSimplificationError: number;
        MaxSimultaneousTileGenerationJobsCount: number;
        TileNumberHardLimit: number;
        PolyRefTileBits: number;
        PolyRefNavPolyBits: number;
        PolyRefSaltBits: number;
        NavMeshOriginOffset: UE.Vector;
        DefaultDrawDistance: number;
        DefaultMaxSearchNodes: number;
        DefaultMaxHierarchicalSearchNodes: number;
        RegionPartitioning: UE.ERecastPartitioning;
        LayerPartitioning: UE.ERecastPartitioning;
        RegionChunkSplits: number;
        LayerChunkSplits: number;
        bSortNavigationAreasByCost: boolean;
        bPerformVoxelFiltering: boolean;
        bMarkLowHeightAreas: boolean;
        bFilterLowSpanSequences: boolean;
        bFilterLowSpanFromTileCache: boolean;
        bDoFullyAsyncNavDataGathering: boolean;
        bUseBetterOffsetsFromCorners: boolean;
        bStoreEmptyTileLayers: boolean;
        bUseVirtualFilters: boolean;
        bAllowNavLinkAsPathEnd: boolean;
        bUseVoxelCache: boolean;
        TileSetUpdateInterval: number;
        HeuristicScale: number;
        VerticalDeviationFromGroundCompensation: number;
        K2_ReplaceAreaInTileBounds(Bounds: UE.Box, OldArea: $Nullable<UE.Class>, NewArea: $Nullable<UE.Class>, ReplaceLinks?: boolean /* = true */) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RecastNavMesh;
        static Load(InName: string): RecastNavMesh;
    }
    
    class RecastNavMeshDataChunk extends UE.NavigationDataChunk {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RecastNavMeshDataChunk;
        static Load(InName: string): RecastNavMeshDataChunk;
    }
    
    class RectangleSplineGenerator extends UE.SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Length: number;
        Width: number;
        bBranchRight: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RectangleSplineGenerator;
        static Load(InName: string): RectangleSplineGenerator;
    }
    
    class RectLightComponent extends UE.LocalLightComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceWidth: number;
        SourceHeight: number;
        BarnDoorAngle: number;
        BarnDoorLength: number;
        SourceTexture: UE.Texture;
        SetBarnDoorAngle(NewValue: number) : void;
        SetBarnDoorLength(NewValue: number) : void;
        SetSourceHeight(NewValue: number) : void;
        SetSourceTexture(bNewValue: $Nullable<UE.Texture>) : void;
        SetSourceWidth(bNewValue: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RectLightComponent;
        static Load(InName: string): RectLightComponent;
    }
    
    class RectLight extends UE.Light {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RectLightComponent: UE.RectLightComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RectLight;
        static Load(InName: string): RectLight;
    }
    
    class ReferenceViewerSchema extends UE.EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReferenceViewerSchema;
        static Load(InName: string): ReferenceViewerSchema;
    }
    
    class ReimportBasicOverlaysFactory extends UE.BasicOverlaysFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportBasicOverlaysFactory;
        static Load(InName: string): ReimportBasicOverlaysFactory;
    }
    
    class ReimportCurveFactory extends UE.CSVImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportCurveFactory;
        static Load(InName: string): ReimportCurveFactory;
    }
    
    class ReimportCurveTableFactory extends UE.CSVImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportCurveTableFactory;
        static Load(InName: string): ReimportCurveTableFactory;
    }
    
    class ReimportDataTableFactory extends UE.CSVImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportDataTableFactory;
        static Load(InName: string): ReimportDataTableFactory;
    }
    
    class ReimportFbxAnimSequenceFactory extends UE.FbxFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportFbxAnimSequenceFactory;
        static Load(InName: string): ReimportFbxAnimSequenceFactory;
    }
    
    class ReimportFbxSceneFactory extends UE.FbxSceneImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportFbxSceneFactory;
        static Load(InName: string): ReimportFbxSceneFactory;
    }
    
    class ReimportFbxSkeletalMeshFactory extends UE.FbxFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportFbxSkeletalMeshFactory;
        static Load(InName: string): ReimportFbxSkeletalMeshFactory;
    }
    
    class ReimportFbxStaticMeshFactory extends UE.FbxFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportFbxStaticMeshFactory;
        static Load(InName: string): ReimportFbxStaticMeshFactory;
    }
    
    class SoundFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoCreateCue: boolean;
        bIncludeAttenuationNode: boolean;
        bIncludeLoopingNode: boolean;
        bIncludeModulatorNode: boolean;
        CueVolume: number;
        CuePackageSuffix: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundFactory;
        static Load(InName: string): SoundFactory;
    }
    
    class ReimportSoundFactory extends UE.SoundFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportSoundFactory;
        static Load(InName: string): ReimportSoundFactory;
    }
    
    class SoundSurroundFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CueVolume: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSurroundFactory;
        static Load(InName: string): SoundSurroundFactory;
    }
    
    class ReimportSoundSurroundFactory extends UE.SoundSurroundFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ReimportPaths: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportSoundSurroundFactory;
        static Load(InName: string): ReimportSoundSurroundFactory;
    }
    
    class SpeedTreeImportFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpeedTreeImportFactory;
        static Load(InName: string): SpeedTreeImportFactory;
    }
    
    class ReimportSpeedTreeFactory extends UE.SpeedTreeImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportSpeedTreeFactory;
        static Load(InName: string): ReimportSpeedTreeFactory;
    }
    
    class TextureFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NoCompression: boolean;
        NoAlpha: boolean;
        bDeferCompression: boolean;
        CompressionSettings: UE.TextureCompressionSettings;
        bCreateMaterial: boolean;
        bRGBToBaseColor: boolean;
        bRGBToEmissive: boolean;
        bAlphaToRoughness: boolean;
        bAlphaToEmissive: boolean;
        bAlphaToOpacity: boolean;
        bAlphaToOpacityMask: boolean;
        bTwoSided: boolean;
        Blending: UE.EBlendMode;
        ShadingModel: UE.EMaterialShadingModel;
        MipGenSettings: UE.TextureMipGenSettings;
        LODGroup: UE.TextureGroup;
        bDitherMipMapAlpha: boolean;
        AlphaCoverageThresholds: UE.Vector4;
        bPreserveBorder: boolean;
        bFlipNormalMapGreenChannel: boolean;
        bUsingExistingSettings: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureFactory;
        static Load(InName: string): TextureFactory;
    }
    
    class ReimportTextureFactory extends UE.TextureFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        pOriginalTex: UE.Texture;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportTextureFactory;
        static Load(InName: string): ReimportTextureFactory;
    }
    
    class VectorFieldStaticFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VectorFieldStaticFactory;
        static Load(InName: string): VectorFieldStaticFactory;
    }
    
    class ReimportVectorFieldStaticFactory extends UE.VectorFieldStaticFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportVectorFieldStaticFactory;
        static Load(InName: string): ReimportVectorFieldStaticFactory;
    }
    
    class RendererOverrideSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bSupportAllShaderPermutations: boolean;
        bForceRecomputeTangents: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RendererOverrideSettings;
        static Load(InName: string): RendererOverrideSettings;
    }
    
    enum EMobileMSAASampleCount { One, Two, Four, Eight, EMobileMSAASampleCount_MAX}
    enum ETranslucentSortPolicy { SortByDistance, SortByProjectedZ, SortAlongAxis, ETranslucentSortPolicy_MAX}
    enum ECustomDepthStencil { Disabled, Enabled, EnabledOnDemand, EnabledWithStencil, ECustomDepthStencil_MAX}
    enum EAlphaChannelMode { Disabled, LinearColorSpaceOnly, AllowThroughTonemapper, EAlphaChannelMode_MAX}
    enum EAutoExposureMethodUI { AEM_Histogram, AEM_Basic, AEM_Manual, AEM_MAX}
    enum EAntiAliasingMethod { AAM_None, AAM_FXAA, AAM_TemporalAA, AAM_MSAA, AAM_MAX}
    enum EDefaultBackBufferPixelFormat { DBBPF_B8G8R8A8, DBBPF_A16B16G16R16_DEPRECATED, DBBPF_FloatRGB_DEPRECATED, DBBPF_FloatRGBA, DBBPF_A2B10G10R10, DBBPF_MAX}
    enum EEarlyZPass { None, OpaqueOnly, OpaqueAndMasked, Auto, EEarlyZPass_MAX}
    enum EClearSceneOptions { NoClear, HardwareClear, QuadAtMaxZ, EClearSceneOptions_MAX}
    enum EGBufferFormat { Force8BitsPerChannel, Default, HighPrecisionNormals, Force16BitsPerChannel, EGBufferFormat_MAX}
    class RendererSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bMobileHDR: boolean;
        bMobileDisableVertexFog: boolean;
        MaxMobileCascades: number;
        MobileMSAASampleCount: UE.EMobileMSAASampleCount;
        bMobileUseLegacyShadingModel: boolean;
        bMobileUseHWsRGBEncoding: boolean;
        bMobileAllowDitheredLODTransition: boolean;
        bMobileAllowSoftwareOcclusionCulling: boolean;
        bDiscardUnusedQualityLevels: boolean;
        bOcclusionCulling: boolean;
        MinScreenRadiusForLights: number;
        MinScreenRadiusForEarlyZPass: number;
        MinScreenRadiusForCSMdepth: number;
        bPrecomputedVisibilityWarning: boolean;
        bTextureStreaming: boolean;
        bUseDXT5NormalMaps: boolean;
        bVirtualTextures: boolean;
        bVirtualTexturedLightmaps: boolean;
        VirtualTextureTileSize: number;
        VirtualTextureTileBorderSize: number;
        VirtualTextureFeedbackFactor: number;
        bVirtualTextureEnableCompressZlib: boolean;
        bVirtualTextureEnableCompressCrunch: boolean;
        bClearCoatEnableSecondNormal: boolean;
        ReflectionCaptureResolution: number;
        ReflectionEnvironmentLightmapMixBasedOnRoughness: boolean;
        bForwardShading: boolean;
        bVertexFoggingForOpaque: boolean;
        bAllowStaticLighting: boolean;
        bUseNormalMapsForStaticLighting: boolean;
        bGenerateMeshDistanceFields: boolean;
        bEightBitMeshDistanceFields: boolean;
        bGenerateLandscapeGIData: boolean;
        bCompressMeshDistanceFields: boolean;
        TessellationAdaptivePixelsPerTriangle: number;
        bSeparateTranslucency: boolean;
        TranslucentSortPolicy: UE.ETranslucentSortPolicy;
        TranslucentSortAxis: UE.Vector;
        CustomDepthStencil: UE.ECustomDepthStencil;
        bCustomDepthTaaJitter: boolean;
        bEnableAlphaChannelInPostProcessing: UE.EAlphaChannelMode;
        bDefaultFeatureBloom: boolean;
        bDefaultFeatureAmbientOcclusion: boolean;
        bDefaultFeatureAmbientOcclusionStaticFraction: boolean;
        bDefaultFeatureAutoExposure: boolean;
        DefaultFeatureAutoExposure: UE.EAutoExposureMethodUI;
        bExtendDefaultLuminanceRangeInAutoExposureSettings: boolean;
        bUsePreExposure: boolean;
        bEnablePreExposureOnlyInTheEditor: boolean;
        bDefaultFeatureMotionBlur: boolean;
        bDefaultFeatureLensFlare: boolean;
        bTemporalUpsampling: boolean;
        bSSGI: boolean;
        DefaultFeatureAntiAliasing: UE.EAntiAliasingMethod;
        DefaultLightUnits: UE.ELightUnits;
        DefaultBackBufferPixelFormat: UE.EDefaultBackBufferPixelFormat;
        bRenderUnbuiltPreviewShadowsInGame: boolean;
        bStencilForLODDither: boolean;
        EarlyZPass: UE.EEarlyZPass;
        bEarlyZPassOnlyMaterialMasking: boolean;
        bDBuffer: boolean;
        ClearSceneMethod: UE.EClearSceneOptions;
        bBasePassOutputsVelocity: boolean;
        bSelectiveBasePassOutputs: boolean;
        bDefaultParticleCutouts: boolean;
        GPUSimulationTextureSizeX: number;
        GPUSimulationTextureSizeY: number;
        bGlobalClipPlane: boolean;
        GBufferFormat: UE.EGBufferFormat;
        bUseGPUMorphTargets: boolean;
        bNvidiaAftermathEnabled: boolean;
        bInstancedStereo: boolean;
        bMultiView: boolean;
        bMobileMultiView: boolean;
        bMobileMultiViewDirect: boolean;
        bRoundRobinOcclusion: boolean;
        bODSCapture: boolean;
        WireframeCullThreshold: number;
        bEnableRayTracing: boolean;
        bEnableRayTracingTextureLOD: boolean;
        bSupportStationarySkylight: boolean;
        bSupportLowQualityLightmaps: boolean;
        bSupportPointLightWholeSceneShadows: boolean;
        bSupportAtmosphericFog: boolean;
        bSupportSkyAtmosphere: boolean;
        bSupportSkyAtmosphereAffectsHeightFog: boolean;
        bSupportSkinCacheShaders: boolean;
        bMobileEnableStaticAndCSMShadowReceivers: boolean;
        bMobileEnableMovableLightCSMShaderCulling: boolean;
        bMobileAllowDistanceFieldShadows: boolean;
        bMobileAllowMovableDirectionalLights: boolean;
        MobileNumDynamicPointLights: number;
        bMobileDynamicPointLightsUseStaticBranch: boolean;
        bMobileAllowMovableSpotlights: boolean;
        SkinCacheSceneMemoryLimitInMB: number;
        bGPUSkinLimit2BoneInfluences: boolean;
        bSupportDepthOnlyIndexBuffers: boolean;
        bSupportReversedIndexBuffers: boolean;
        bSupportMaterialLayers: boolean;
        bLPV: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RendererSettings;
        static Load(InName: string): RendererSettings;
    }
    
    class RenderTargetExporterHDR extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RenderTargetExporterHDR;
        static Load(InName: string): RenderTargetExporterHDR;
    }
    
    class ReplaceActorCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReplaceActorCommandlet;
        static Load(InName: string): ReplaceActorCommandlet;
    }
    
    class ReplaceAssetsCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReplaceAssetsCommandlet;
        static Load(InName: string): ReplaceAssetsCommandlet;
    }
    
    class ReplicationConnectionDriver extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReplicationConnectionDriver;
        static Load(InName: string): ReplicationConnectionDriver;
    }
    
    class RetainerBox extends UE.ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenderOnInvalidation: boolean;
        RenderOnPhase: boolean;
        Phase: number;
        PhaseCount: number;
        EffectMaterial: UE.MaterialInterface;
        TextureParameter: string;
        GetEffectMaterial() : UE.MaterialInstanceDynamic;
        RequestRender() : void;
        SetEffectMaterial(EffectMaterial: $Nullable<UE.MaterialInterface>) : void;
        SetRenderingPhase(RenderPhase: number, TotalPhases: number) : void;
        SetTextureParameter(TextureParameter: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RetainerBox;
        static Load(InName: string): RetainerBox;
    }
    
    class ReturnResultsTerminal extends UE.FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetReturnResultsTerminal() : UE.ReturnResultsTerminal;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReturnResultsTerminal;
        static Load(InName: string): ReturnResultsTerminal;
    }
    
    class ReverbEffectFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReverbEffectFactory;
        static Load(InName: string): ReverbEffectFactory;
    }
    
    class RichCurveKeyProxy extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Value: UE.RichCurveKey;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RichCurveKeyProxy;
        static Load(InName: string): RichCurveKeyProxy;
    }
    
    class RichTextBlockDecorator extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RichTextBlockDecorator;
        static Load(InName: string): RichTextBlockDecorator;
    }
    
    class RichTextBlock extends UE.TextLayoutWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Text: string;
        TextStyleSet: UE.DataTable;
        DecoratorClasses: TArray<UE.Class>;
        bOverrideDefaultStyle: boolean;
        DefaultTextStyleOverride: UE.TextBlockStyle;
        MinDesiredWidth: number;
        InstanceDecorators: TArray<UE.RichTextBlockDecorator>;
        ClearAllDefaultStyleOverrides() : void;
        GetDecoratorByClass(DecoratorClass: $Nullable<UE.Class>) : UE.RichTextBlockDecorator;
        GetText() : string;
        SetAutoWrapText(InAutoTextWrap: boolean) : void;
        SetDefaultColorAndOpacity(InColorAndOpacity: UE.SlateColor) : void;
        SetDefaultFont(InFontInfo: UE.SlateFontInfo) : void;
        SetDefaultShadowColorAndOpacity(InShadowColorAndOpacity: UE.LinearColor) : void;
        SetDefaultShadowOffset(InShadowOffset: UE.Vector2D) : void;
        SetDefaultStrikeBrush(InStrikeBrush: $Ref<UE.SlateBrush>) : void;
        SetDefaultTextStyle(InDefaultTextStyle: UE.TextBlockStyle) : void;
        SetMinDesiredWidth(InMinDesiredWidth: number) : void;
        SetText(InText: string) : void;
        SetTextStyleSet(NewTextStyleSet: $Nullable<UE.DataTable>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RichTextBlock;
        static Load(InName: string): RichTextBlock;
    }
    
    class RichTextBlockImageDecorator extends UE.RichTextBlockDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImageSet: UE.DataTable;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RichTextBlockImageDecorator;
        static Load(InName: string): RichTextBlockImageDecorator;
    }
    
    class RotateOnAngleDragOperation extends UE.ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RotateOnAngleDragOperation;
        static Load(InName: string): RotateOnAngleDragOperation;
    }
    
    class RotatingMovementComponent extends UE.MovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RotationRate: UE.Rotator;
        PivotTranslation: UE.Vector;
        bRotationInLocalSpace: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RotatingMovementComponent;
        static Load(InName: string): RotatingMovementComponent;
    }
    
    class RuntimeOptionsBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RuntimeOptionsBase;
        static Load(InName: string): RuntimeOptionsBase;
    }
    
    class RuntimeVirtualTextureComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VirtualTexture: UE.RuntimeVirtualTexture;
        bUseStreamingLowMipsInEditor: boolean;
        BoundsSourceActor: UE.Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTextureComponent;
        static Load(InName: string): RuntimeVirtualTextureComponent;
    }
    
    class RuntimeVirtualTextureFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTextureFactory;
        static Load(InName: string): RuntimeVirtualTextureFactory;
    }
    
    class RuntimeVirtualTextureThumbnailRenderer extends UE.ThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTextureThumbnailRenderer;
        static Load(InName: string): RuntimeVirtualTextureThumbnailRenderer;
    }
    
    class RuntimeVirtualTextureVolume extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VirtualTextureComponent: UE.RuntimeVirtualTextureComponent;
        Box: UE.BoxComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTextureVolume;
        static Load(InName: string): RuntimeVirtualTextureVolume;
    }
    
    class RVOAvoidanceInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RVOAvoidanceInterface;
        static Load(InName: string): RVOAvoidanceInterface;
    }
    
    class SafeZone extends UE.ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PadLeft: boolean;
        PadRight: boolean;
        PadTop: boolean;
        PadBottom: boolean;
        SetSidesToPad(InPadLeft: boolean, InPadRight: boolean, InPadTop: boolean, InPadBottom: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SafeZone;
        static Load(InName: string): SafeZone;
    }
    
    class SafeZoneSlot extends UE.PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsTitleSafe: boolean;
        SafeAreaScale: UE.Margin;
        HAlign: UE.EHorizontalAlignment;
        VAlign: UE.EVerticalAlignment;
        Padding: UE.Margin;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SafeZoneSlot;
        static Load(InName: string): SafeZoneSlot;
    }
    
    enum EStretch { None, Fill, ScaleToFit, ScaleToFitX, ScaleToFitY, ScaleToFill, ScaleBySafeZone, UserSpecified, EStretch_MAX}
    enum EStretchDirection { Both, DownOnly, UpOnly, EStretchDirection_MAX}
    class ScaleBox extends UE.ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Stretch: UE.EStretch;
        StretchDirection: UE.EStretchDirection;
        UserSpecifiedScale: number;
        IgnoreInheritedScale: boolean;
        SetIgnoreInheritedScale(bInIgnoreInheritedScale: boolean) : void;
        SetStretch(InStretch: UE.EStretch) : void;
        SetStretchDirection(InStretchDirection: UE.EStretchDirection) : void;
        SetUserSpecifiedScale(InUserSpecifiedScale: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScaleBox;
        static Load(InName: string): ScaleBox;
    }
    
    class ScaleBoxSlot extends UE.PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: UE.Margin;
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScaleBoxSlot;
        static Load(InName: string): ScaleBoxSlot;
    }
    
    class ScaleDragOperation extends UE.ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScaleDragOperation;
        static Load(InName: string): ScaleDragOperation;
    }
    
    class Scene extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Scene;
        static Load(InName: string): Scene;
    }
    
    class TextureRenderTargetCube extends UE.TextureRenderTarget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SizeX: number;
        ClearColor: UE.LinearColor;
        OverrideFormat: UE.EPixelFormat;
        bHDR: boolean;
        bForceLinearGamma: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureRenderTargetCube;
        static Load(InName: string): TextureRenderTargetCube;
    }
    
    class SceneCaptureComponentCube extends UE.SceneCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TextureTarget: UE.TextureRenderTargetCube;
        bCaptureRotation: boolean;
        TextureTargetLeft: UE.TextureRenderTargetCube;
        TextureTargetRight: UE.TextureRenderTargetCube;
        TextureTargetODS: UE.TextureRenderTarget2D;
        IPD: number;
        CaptureScene() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneCaptureComponentCube;
        static Load(InName: string): SceneCaptureComponentCube;
    }
    
    class SceneCaptureCube extends UE.SceneCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CaptureComponentCube: UE.SceneCaptureComponentCube;
        OnInterpToggle(bEnable: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneCaptureCube;
        static Load(InName: string): SceneCaptureCube;
    }
    
    class SceneOutlinerMenuContext extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneOutlinerMenuContext;
        static Load(InName: string): SceneOutlinerMenuContext;
    }
    
    class SceneOutlinerSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bHideTemporaryActors: boolean;
        bShowOnlyActorsInCurrentLevel: boolean;
        bHideFoldersContainingHiddenActors: boolean;
        bShowOnlySelectedActors: boolean;
        bShowActorComponents: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneOutlinerSettings;
        static Load(InName: string): SceneOutlinerSettings;
    }
    
    class SceneThumbnailInfo extends UE.ThumbnailInfo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OrbitPitch: number;
        OrbitYaw: number;
        OrbitZoom: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneThumbnailInfo;
        static Load(InName: string): SceneThumbnailInfo;
    }
    
    enum EThumbnailPrimType { TPT_None, TPT_Sphere, TPT_Cube, TPT_Plane, TPT_Cylinder, TPT_MAX}
    class SceneThumbnailInfoWithPrimitive extends UE.SceneThumbnailInfo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PrimitiveType: UE.EThumbnailPrimType;
        PreviewMesh: UE.SoftObjectPath;
        bUserModifiedShape: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneThumbnailInfoWithPrimitive;
        static Load(InName: string): SceneThumbnailInfoWithPrimitive;
    }
    
    class ScreenshotComparisonCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScreenshotComparisonCommandlet;
        static Load(InName: string): ScreenshotComparisonCommandlet;
    }
    
    class ScreenshotFunctionalTest extends UE.ScreenshotFunctionalTestBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCameraCutOnScreenshotPrep: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScreenshotFunctionalTest;
        static Load(InName: string): ScreenshotFunctionalTest;
    }
    
    class ScrollBar extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetStyle: UE.ScrollBarStyle;
        Style: UE.SlateWidgetStyleAsset;
        bAlwaysShowScrollbar: boolean;
        bAlwaysShowScrollbarTrack: boolean;
        Orientation: UE.EOrientation;
        Thickness: UE.Vector2D;
        Padding: UE.Margin;
        SetState(InOffsetFraction: number, InThumbSizeFraction: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScrollBar;
        static Load(InName: string): ScrollBar;
    }
    
    class ScrollBarWidgetStyle extends UE.SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ScrollBarStyle: UE.ScrollBarStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScrollBarWidgetStyle;
        static Load(InName: string): ScrollBarWidgetStyle;
    }
    
    class ScrollBoxStyle extends UE.SlateWidgetStyle {
        constructor();
        constructor(TopShadowBrush: UE.SlateBrush, BottomShadowBrush: UE.SlateBrush, LeftShadowBrush: UE.SlateBrush, RightShadowBrush: UE.SlateBrush);
        TopShadowBrush: UE.SlateBrush;
        BottomShadowBrush: UE.SlateBrush;
        LeftShadowBrush: UE.SlateBrush;
        RightShadowBrush: UE.SlateBrush;
        static StaticClass(): Class;
    }
    
    enum EDescendantScrollDestination { IntoView, TopOrLeft, Center, EDescendantScrollDestination_MAX}
    class ScrollBox extends UE.PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetStyle: UE.ScrollBoxStyle;
        WidgetBarStyle: UE.ScrollBarStyle;
        Style: UE.SlateWidgetStyleAsset;
        BarStyle: UE.SlateWidgetStyleAsset;
        Orientation: UE.EOrientation;
        ScrollBarVisibility: UE.ESlateVisibility;
        ConsumeMouseWheel: UE.EConsumeMouseWheel;
        ScrollbarThickness: UE.Vector2D;
        ScrollbarPadding: UE.Margin;
        AlwaysShowScrollbar: boolean;
        AlwaysShowScrollbarTrack: boolean;
        AllowOverscroll: boolean;
        bAnimateWheelScrolling: boolean;
        NavigationDestination: UE.EDescendantScrollDestination;
        NavigationScrollPadding: number;
        bAllowRightClickDragScrolling: boolean;
        WheelScrollMultiplier: number;
        OnUserScrolled: $MulticastDelegate<(CurrentOffset: number) => void>;
        EndInertialScrolling() : void;
        GetScrollOffset() : number;
        GetScrollOffsetOfEnd() : number;
        GetViewOffsetFraction() : number;
        ScrollToEnd() : void;
        ScrollToStart() : void;
        ScrollWidgetIntoView(WidgetToFind: $Nullable<UE.Widget>, AnimateScroll?: boolean /* = true */, ScrollDestination?: UE.EDescendantScrollDestination /* = IntoView */) : void;
        SetAllowOverscroll(NewAllowOverscroll: boolean) : void;
        SetAlwaysShowScrollbar(NewAlwaysShowScrollbar: boolean) : void;
        SetAnimateWheelScrolling(bShouldAnimateWheelScrolling: boolean) : void;
        SetConsumeMouseWheel(NewConsumeMouseWheel: UE.EConsumeMouseWheel) : void;
        SetOrientation(NewOrientation: UE.EOrientation) : void;
        SetScrollbarPadding(NewScrollbarPadding: UE.Margin) : void;
        SetScrollbarThickness(NewScrollbarThickness: UE.Vector2D) : void;
        SetScrollBarVisibility(NewScrollBarVisibility: UE.ESlateVisibility) : void;
        SetScrollOffset(NewScrollOffset: number) : void;
        SetWheelScrollMultiplier(NewWheelScrollMultiplier: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScrollBox;
        static Load(InName: string): ScrollBox;
    }
    
    class ScrollBoxSlot extends UE.PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: UE.Margin;
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScrollBoxSlot;
        static Load(InName: string): ScrollBoxSlot;
    }
    
    class ScrollBoxWidgetStyle extends UE.SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ScrollBoxStyle: UE.ScrollBoxStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScrollBoxWidgetStyle;
        static Load(InName: string): ScrollBoxWidgetStyle;
    }
    
    class Selection extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Selection;
        static Load(InName: string): Selection;
    }
    
    class SequenceExporterT3D extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequenceExporterT3D;
        static Load(InName: string): SequenceExporterT3D;
    }
    
    class SequenceRecorderActorGroup extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GroupName: string;
        SequenceName: string;
        SequenceRecordingBasePath: UE.DirectoryPath;
        bSpecifyTargetLevelSequence: boolean;
        TargetLevelSequence: UE.LevelSequence;
        bDuplicateTargetLevelSequence: boolean;
        bRecordTargetLevelSequenceLength: boolean;
        RecordedActors: TArray<UE.ActorRecording>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequenceRecorderActorGroup;
        static Load(InName: string): SequenceRecorderActorGroup;
    }
    
    class SequenceRecorderBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static IsRecordingSequence() : boolean;
        static StartRecordingSequence(ActorsToRecord: TArray<UE.Actor>) : void;
        static StopRecordingSequence() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequenceRecorderBlueprintLibrary;
        static Load(InName: string): SequenceRecorderBlueprintLibrary;
    }
    
    class SequenceRecorderGroup extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActorGroups: TArray<UE.SequenceRecorderActorGroup>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequenceRecorderGroup;
        static Load(InName: string): SequenceRecorderGroup;
    }
    
    enum EAudioRecordingMode { None, AudioTrack, EAudioRecordingMode_MAX}
    class SequenceRecorderActorFilter {
        constructor();
        constructor(ActorClassesToRecord: TArray<UE.Class>);
        ActorClassesToRecord: TArray<UE.Class>;
        static StaticClass(): Class;
    }
    
    class PropertiesToRecordForClass {
        constructor();
        constructor(Class: UE.Class, Properties: TArray<string>);
        Class: UE.Class;
        Properties: TArray<string>;
        static StaticClass(): Class;
    }
    
    class PropertiesToRecordForActorClass {
        constructor();
        constructor(Class: UE.Class, Properties: TArray<string>);
        Class: UE.Class;
        Properties: TArray<string>;
        static StaticClass(): Class;
    }
    
    class SettingsForActorClass {
        constructor();
        constructor(Class: UE.Class, bRecordToPossessable: boolean);
        Class: UE.Class;
        bRecordToPossessable: boolean;
        static StaticClass(): Class;
    }
    
    class SequenceRecorderSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCreateLevelSequence: boolean;
        bImmersiveMode: boolean;
        SequenceLength: number;
        RecordingDelay: number;
        bAllowLooping: boolean;
        GlobalTimeDilation: number;
        bIgnoreTimeDilation: boolean;
        AnimationSubDirectory: string;
        RecordAudio: UE.EAudioRecordingMode;
        AudioGain: number;
        bSplitAudioChannelsIntoSeparateTracks: boolean;
        bReplaceRecordedAudio: boolean;
        AudioTrackName: string;
        AudioSubDirectory: string;
        bRecordNearbySpawnedActors: boolean;
        NearbyActorRecordingProximity: number;
        bRecordWorldSettingsActor: boolean;
        bReduceKeys: boolean;
        bAutoSaveAsset: boolean;
        ActorFilter: UE.SequenceRecorderActorFilter;
        LevelSequenceActorsToTrigger: TArray<TLazyObjectPtr<UE.LevelSequenceActor>>;
        DefaultAnimationSettings: UE.AnimationRecordingSettings;
        bRecordSequencerSpawnedActors: boolean;
        ClassesAndPropertiesToRecord: TArray<UE.PropertiesToRecordForClass>;
        ActorsAndPropertiesToRecord: TArray<UE.PropertiesToRecordForActorClass>;
        PerActorSettings: TArray<UE.SettingsForActorClass>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequenceRecorderSettings;
        static Load(InName: string): SequenceRecorderSettings;
    }
    
    class SequencerExportTask extends UE.AssetExportTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SequencerContext: UE.Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequencerExportTask;
        static Load(InName: string): SequencerExportTask;
    }
    
    class SequencerKeyActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        KeyMeshComponent: UE.StaticMeshComponent;
        AssociatedActor: UE.Actor;
        TrackSection: UE.MovieScene3DTransformSection;
        KeyTime: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequencerKeyActor;
        static Load(InName: string): SequencerKeyActor;
    }
    
    class SequencerMeshTrail extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequencerMeshTrail;
        static Load(InName: string): SequencerMeshTrail;
    }
    
    enum EAutoChangeMode { AutoKey, AutoTrack, All, None, EAutoChangeMode_MAX}
    enum EAllowEditsMode { AllEdits, AllowSequencerEditsOnly, AllowLevelEditsOnly, EAllowEditsMode_MAX}
    enum EKeyGroupMode { KeyChanged, KeyGroup, KeyAll, EKeyGroupMode_MAX}
    enum EMovieSceneKeyInterpolation { Auto, User, Break, Linear, Constant, EMovieSceneKeyInterpolation_MAX}
    enum ESequencerSpawnPosition { SSP_Origin, SSP_PlaceInFrontOfCamera, SSP_MAX}
    enum ESequencerZoomPosition { SZP_CurrentTime, SZP_MousePosition, SZP_MAX}
    enum ESequencerLoopMode { SLM_NoLoop, SLM_Loop, SLM_LoopSelectionRange, SLM_MAX}
    enum EFrameNumberDisplayFormats { NonDropFrameTimecode, DropFrameTimecode, Seconds, Frames, MAX_Count, EFrameNumberDisplayFormats_MAX}
    class SequencerSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AutoChangeMode: UE.EAutoChangeMode;
        AllowEditsMode: UE.EAllowEditsMode;
        KeyGroupMode: UE.EKeyGroupMode;
        bKeyInterpPropertiesOnly: boolean;
        KeyInterpolation: UE.EMovieSceneKeyInterpolation;
        bAutoSetTrackDefaults: boolean;
        SpawnPosition: UE.ESequencerSpawnPosition;
        bCreateSpawnableCameras: boolean;
        bShowRangeSlider: boolean;
        bIsSnapEnabled: boolean;
        bSnapKeyTimesToInterval: boolean;
        bSnapKeyTimesToKeys: boolean;
        bSnapSectionTimesToInterval: boolean;
        bSnapSectionTimesToSections: boolean;
        bSnapKeysAndSectionsToPlayRange: boolean;
        bSnapPlayTimeToKeys: boolean;
        bSnapPlayTimeToInterval: boolean;
        bSnapPlayTimeToPressedKey: boolean;
        bSnapPlayTimeToDraggedKey: boolean;
        bSnapCurveValueToInterval: boolean;
        bLabelBrowserVisible: boolean;
        bShowSelectedNodesOnly: boolean;
        bRewindOnRecord: boolean;
        ZoomPosition: UE.ESequencerZoomPosition;
        bAutoScrollEnabled: boolean;
        bLinkCurveEditorTimeRange: boolean;
        bSynchronizeCurveEditorSelection: boolean;
        bIsolateCurveEditorToSelection: boolean;
        LoopMode: UE.ESequencerLoopMode;
        bKeepCursorInPlayRangeWhileScrubbing: boolean;
        bKeepCursorInPlayRange: boolean;
        bKeepPlayRangeInSectionBounds: boolean;
        ZeroPadFrames: number;
        bShowCombinedKeyframes: boolean;
        bInfiniteKeyAreas: boolean;
        bShowChannelColors: boolean;
        bDeleteKeysWhenTrimming: boolean;
        bActivateRealtimeViewports: boolean;
        bEvaluateSubSequencesInIsolation: boolean;
        bRerunConstructionScripts: boolean;
        bShowDebugVisualization: boolean;
        bVisualizePreAndPostRoll: boolean;
        bCompileDirectorOnEvaluate: boolean;
        TrajectoryPathCap: number;
        bShowOutlinerInfoColumn: boolean;
        FrameNumberDisplayFormat: UE.EFrameNumberDisplayFormats;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequencerSettings;
        static Load(InName: string): SequencerSettings;
    }
    
    class SequencerSettingsContainer extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequencerSettingsContainer;
        static Load(InName: string): SequencerSettingsContainer;
    }
    
    class SequencerTrackFilterExtension extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequencerTrackFilterExtension;
        static Load(InName: string): SequencerTrackFilterExtension;
    }
    
    class SetProperty extends UE.Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SetProperty;
        static Load(InName: string): SetProperty;
    }
    
    class ShaderCodeLibraryToolsCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ShaderCodeLibraryToolsCommandlet;
        static Load(InName: string): ShaderCodeLibraryToolsCommandlet;
    }
    
    class ShaderPipelineCacheToolsCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ShaderPipelineCacheToolsCommandlet;
        static Load(InName: string): ShaderPipelineCacheToolsCommandlet;
    }
    
    enum EShadowMapFlags { SMF_None, SMF_Streamed, SMF_MAX}
    class ShadowMapTexture2D extends UE.Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShadowmapFlags: UE.EShadowMapFlags;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ShadowMapTexture2D;
        static Load(InName: string): ShadowMapTexture2D;
    }
    
    class SharedProfiles extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Profiles: TArray<UE.PreviewSceneProfile>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SharedProfiles;
        static Load(InName: string): SharedProfiles;
    }
    
    enum ESheetAxis { AX_Horizontal, AX_XAxis, AX_YAxis, AX_MAX}
    class SheetBuilder extends UE.EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        X: number;
        Y: number;
        XSegments: number;
        YSegments: number;
        Axis: UE.ESheetAxis;
        GroupName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SheetBuilder;
        static Load(InName: string): SheetBuilder;
    }
    
    class ShowLoginUICallbackProxy extends UE.BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(PlayerController: $Nullable<UE.PlayerController>) => void>;
        OnFailure: $MulticastDelegate<(PlayerController: $Nullable<UE.PlayerController>) => void>;
        static ShowExternalLoginUI(WorldContextObject: $Nullable<UE.Object>, InPlayerController: $Nullable<UE.PlayerController>) : UE.ShowLoginUICallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ShowLoginUICallbackProxy;
        static Load(InName: string): ShowLoginUICallbackProxy;
    }
    
    class SignificanceManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SignificanceManagerClassName: UE.SoftClassPath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SignificanceManager;
        static Load(InName: string): SignificanceManager;
    }
    
    class WheelSetup {
        constructor();
        constructor(WheelClass: UE.Class, BoneName: string, AdditionalOffset: UE.Vector, bDisableSteering: boolean);
        WheelClass: UE.Class;
        BoneName: string;
        AdditionalOffset: UE.Vector;
        bDisableSteering: boolean;
        static StaticClass(): Class;
    }
    
    class TireConfigMaterialFriction {
        constructor();
        constructor(PhysicalMaterial: UE.PhysicalMaterial, FrictionScale: number);
        PhysicalMaterial: UE.PhysicalMaterial;
        FrictionScale: number;
        static StaticClass(): Class;
    }
    
    class TireConfig extends UE.DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FrictionScale: number;
        TireFrictionScales: TArray<UE.TireConfigMaterialFriction>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TireConfig;
        static Load(InName: string): TireConfig;
    }
    
    enum EWheelSweepType { SimpleAndComplex, Simple, Complex, EWheelSweepType_MAX}
    class VehicleWheel extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CollisionMesh: UE.StaticMesh;
        bDontCreateShape: boolean;
        bAutoAdjustCollisionSize: boolean;
        Offset: UE.Vector;
        ShapeRadius: number;
        ShapeWidth: number;
        Mass: number;
        DampingRate: number;
        SteerAngle: number;
        bAffectedByHandbrake: boolean;
        TireType: UE.TireType;
        TireConfig: UE.TireConfig;
        LatStiffMaxLoad: number;
        LatStiffValue: number;
        LongStiffValue: number;
        SuspensionForceOffset: number;
        SuspensionMaxRaise: number;
        SuspensionMaxDrop: number;
        SuspensionNaturalFrequency: number;
        SuspensionDampingRatio: number;
        SweepType: UE.EWheelSweepType;
        MaxBrakeTorque: number;
        MaxHandBrakeTorque: number;
        VehicleSim: UE.WheeledVehicleMovementComponent;
        WheelIndex: number;
        DebugLongSlip: number;
        DebugLatSlip: number;
        DebugNormalizedTireLoad: number;
        DebugWheelTorque: number;
        DebugLongForce: number;
        DebugLatForce: number;
        Location: UE.Vector;
        OldLocation: UE.Vector;
        Velocity: UE.Vector;
        GetRotationAngle() : number;
        GetSteerAngle() : number;
        GetSuspensionOffset() : number;
        IsInAir() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VehicleWheel;
        static Load(InName: string): VehicleWheel;
    }
    
    class ReplicatedVehicleState {
        constructor();
        constructor(SteeringInput: number, ThrottleInput: number, BrakeInput: number, HandbrakeInput: number, CurrentGear: number);
        SteeringInput: number;
        ThrottleInput: number;
        BrakeInput: number;
        HandbrakeInput: number;
        CurrentGear: number;
        static StaticClass(): Class;
    }
    
    class VehicleInputRate {
        constructor();
        constructor(RiseRate: number, FallRate: number);
        RiseRate: number;
        FallRate: number;
        static StaticClass(): Class;
    }
    
    class WheeledVehicleMovementComponent extends UE.PawnMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDeprecatedSpringOffsetMode: boolean;
        bReverseAsBrake: boolean;
        bUseRVOAvoidance: boolean;
        bRawHandbrakeInput: boolean;
        bRawGearUpInput: boolean;
        bRawGearDownInput: boolean;
        bWasAvoidanceUpdated: boolean;
        Mass: number;
        WheelSetups: TArray<UE.WheelSetup>;
        DragCoefficient: number;
        ChassisWidth: number;
        ChassisHeight: number;
        DragArea: number;
        EstimatedMaxEngineSpeed: number;
        MaxEngineRPM: number;
        DebugDragMagnitude: number;
        InertiaTensorScale: UE.Vector;
        MinNormalizedTireLoad: number;
        MinNormalizedTireLoadFiltered: number;
        MaxNormalizedTireLoad: number;
        MaxNormalizedTireLoadFiltered: number;
        ThresholdLongitudinalSpeed: number;
        LowForwardSpeedSubStepCount: number;
        HighForwardSpeedSubStepCount: number;
        Wheels: TArray<UE.VehicleWheel>;
        RVOAvoidanceRadius: number;
        RVOAvoidanceHeight: number;
        AvoidanceConsiderationRadius: number;
        RVOSteeringStep: number;
        RVOThrottleStep: number;
        AvoidanceUID: number;
        AvoidanceGroup: UE.NavAvoidanceMask;
        GroupsToAvoid: UE.NavAvoidanceMask;
        GroupsToIgnore: UE.NavAvoidanceMask;
        AvoidanceWeight: number;
        PendingLaunchVelocity: UE.Vector;
        ReplicatedState: UE.ReplicatedVehicleState;
        RawSteeringInput: number;
        RawThrottleInput: number;
        RawBrakeInput: number;
        SteeringInput: number;
        ThrottleInput: number;
        BrakeInput: number;
        HandbrakeInput: number;
        IdleBrakeInput: number;
        StopThreshold: number;
        WrongDirectionThreshold: number;
        ThrottleInputRate: UE.VehicleInputRate;
        BrakeInputRate: UE.VehicleInputRate;
        HandbrakeInputRate: UE.VehicleInputRate;
        SteeringInputRate: UE.VehicleInputRate;
        OverrideController: UE.Controller;
        GetCurrentGear() : number;
        GetEngineMaxRotationSpeed() : number;
        GetEngineRotationSpeed() : number;
        GetForwardSpeed() : number;
        GetTargetGear() : number;
        GetUseAutoGears() : boolean;
        ServerUpdateState(InSteeringInput: number, InThrottleInput: number, InBrakeInput: number, InHandbrakeInput: number, CurrentGear: number) : void;
        SetAvoidanceEnabled(bEnable: boolean) : void;
        SetAvoidanceGroup(GroupFlags: number) : void;
        SetAvoidanceGroupMask(GroupMask: UE.NavAvoidanceMask) : void;
        SetBrakeInput(Brake: number) : void;
        SetGearDown(bNewGearDown: boolean) : void;
        SetGearUp(bNewGearUp: boolean) : void;
        SetGroupsToAvoid(GroupFlags: number) : void;
        SetGroupsToAvoidMask(GroupMask: UE.NavAvoidanceMask) : void;
        SetGroupsToIgnore(GroupFlags: number) : void;
        SetGroupsToIgnoreMask(GroupMask: UE.NavAvoidanceMask) : void;
        SetHandbrakeInput(bNewHandbrake: boolean) : void;
        SetSteeringInput(Steering: number) : void;
        SetTargetGear(GearNum: number, bImmediate: boolean) : void;
        SetThrottleInput(Throttle: number) : void;
        SetUseAutoGears(bUseAuto: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WheeledVehicleMovementComponent;
        static Load(InName: string): WheeledVehicleMovementComponent;
    }
    
    class SimpleWheeledVehicleMovementComponent extends UE.WheeledVehicleMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetBrakeTorque(BrakeTorque: number, WheelIndex: number) : void;
        SetDriveTorque(DriveTorque: number, WheelIndex: number) : void;
        SetSteerAngle(SteerAngle: number, WheelIndex: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SimpleWheeledVehicleMovementComponent;
        static Load(InName: string): SimpleWheeledVehicleMovementComponent;
    }
    
    class SimulatedClientNetConnection extends UE.NetConnection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SimulatedClientNetConnection;
        static Load(InName: string): SimulatedClientNetConnection;
    }
    
    class SingleClickInputBehavior extends UE.AnyButtonInputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HitTestOnRelease: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SingleClickInputBehavior;
        static Load(InName: string): SingleClickInputBehavior;
    }
    
    class SingleClickTool extends UE.InteractiveTool {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SingleClickTool;
        static Load(InName: string): SingleClickTool;
    }
    
    class SingleClickToolBuilder extends UE.InteractiveToolBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SingleClickToolBuilder;
        static Load(InName: string): SingleClickToolBuilder;
    }
    
    class SinglePropertyView extends UE.PropertyViewBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PropertyName: string;
        NameOverride: string;
        GetPropertyName() : string;
        SetPropertyName(NewPropertyName: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SinglePropertyView;
        static Load(InName: string): SinglePropertyView;
    }
    
    class SizeBox extends UE.ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidthOverride: number;
        HeightOverride: number;
        MinDesiredWidth: number;
        MinDesiredHeight: number;
        MaxDesiredWidth: number;
        MaxDesiredHeight: number;
        MinAspectRatio: number;
        MaxAspectRatio: number;
        bOverride_WidthOverride: boolean;
        bOverride_HeightOverride: boolean;
        bOverride_MinDesiredWidth: boolean;
        bOverride_MinDesiredHeight: boolean;
        bOverride_MaxDesiredWidth: boolean;
        bOverride_MaxDesiredHeight: boolean;
        bOverride_MinAspectRatio: boolean;
        bOverride_MaxAspectRatio: boolean;
        ClearHeightOverride() : void;
        ClearMaxAspectRatio() : void;
        ClearMaxDesiredHeight() : void;
        ClearMaxDesiredWidth() : void;
        ClearMinAspectRatio() : void;
        ClearMinDesiredHeight() : void;
        ClearMinDesiredWidth() : void;
        ClearWidthOverride() : void;
        SetHeightOverride(InHeightOverride: number) : void;
        SetMaxAspectRatio(InMaxAspectRatio: number) : void;
        SetMaxDesiredHeight(InMaxDesiredHeight: number) : void;
        SetMaxDesiredWidth(InMaxDesiredWidth: number) : void;
        SetMinAspectRatio(InMinAspectRatio: number) : void;
        SetMinDesiredHeight(InMinDesiredHeight: number) : void;
        SetMinDesiredWidth(InMinDesiredWidth: number) : void;
        SetWidthOverride(InWidthOverride: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SizeBox;
        static Load(InName: string): SizeBox;
    }
    
    class SizeBoxSlot extends UE.PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: UE.Margin;
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SizeBoxSlot;
        static Load(InName: string): SizeBoxSlot;
    }
    
    class SkeletalMeshEditorSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimPreviewFloorColor: UE.Color;
        AnimPreviewSkyColor: UE.Color;
        AnimPreviewSkyBrightness: number;
        AnimPreviewLightBrightness: number;
        AnimPreviewLightingDirection: UE.Rotator;
        AnimPreviewDirectionalColor: UE.Color;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshEditorSettings;
        static Load(InName: string): SkeletalMeshEditorSettings;
    }
    
    class SkeletalMeshExporterFBX extends UE.ExporterFBX {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshExporterFBX;
        static Load(InName: string): SkeletalMeshExporterFBX;
    }
    
    class SkeletalMeshSimplificationSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SkeletalMeshReductionModuleName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshSimplificationSettings;
        static Load(InName: string): SkeletalMeshSimplificationSettings;
    }
    
    class SkeletalMeshSimulationComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysicalMaterial: UE.ChaosPhysicalMaterial;
        ChaosSolverActor: UE.ChaosSolverActor;
        OverridePhysicsAsset: UE.PhysicsAsset;
        bSimulating: boolean;
        bNotifyCollisions: boolean;
        ObjectType: UE.EObjectStateTypeEnum;
        Density: number;
        MinMass: number;
        MaxMass: number;
        CollisionType: UE.ECollisionTypeEnum;
        ImplicitShapeParticlesPerUnitArea: number;
        ImplicitShapeMinNumParticles: number;
        ImplicitShapeMaxNumParticles: number;
        MinLevelSetResolution: number;
        MaxLevelSetResolution: number;
        CollisionGroup: number;
        InitialVelocityType: UE.EInitialVelocityTypeEnum;
        InitialLinearVelocity: UE.Vector;
        InitialAngularVelocity: UE.Vector;
        OnChaosPhysicsCollision: $MulticastDelegate<(CollisionInfo: UE.ChaosPhysicsCollisionInfo) => void>;
        ReceivePhysicsCollision(CollisionInfo: UE.ChaosPhysicsCollisionInfo) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshSimulationComponent;
        static Load(InName: string): SkeletalMeshSimulationComponent;
    }
    
    class SkeletalMeshThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshThumbnailRenderer;
        static Load(InName: string): SkeletalMeshThumbnailRenderer;
    }
    
    class SkeletonFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeletalMesh: UE.SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletonFactory;
        static Load(InName: string): SkeletonFactory;
    }
    
    class SkinWeightImportOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProfileName: string;
        FilePath: string;
        LODIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkinWeightImportOptions;
        static Load(InName: string): SkinWeightImportOptions;
    }
    
    class TentDistribution {
        constructor();
        constructor(TipAltitude: number, TipValue: number, Width: number);
        TipAltitude: number;
        TipValue: number;
        Width: number;
        static StaticClass(): Class;
    }
    
    class SkyAtmosphereComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BottomRadius: number;
        GroundAlbedo: UE.Color;
        AtmosphereHeight: number;
        MultiScatteringFactor: number;
        RayleighScatteringScale: number;
        RayleighScattering: UE.LinearColor;
        RayleighExponentialDistribution: number;
        MieScatteringScale: number;
        MieScattering: UE.LinearColor;
        MieAbsorptionScale: number;
        MieAbsorption: UE.LinearColor;
        MieAnisotropy: number;
        MieExponentialDistribution: number;
        OtherAbsorptionScale: number;
        OtherAbsorption: UE.LinearColor;
        OtherTentDistribution: UE.TentDistribution;
        SkyLuminanceFactor: UE.LinearColor;
        AerialPespectiveViewDistanceScale: number;
        HeightFogContribution: number;
        TransmittanceMinLightElevationAngle: number;
        bStaticLightingBuiltGUID: UE.Guid;
        OverrideAtmosphereLightDirection(AtmosphereLightIndex: number, LightDirection: UE.Vector) : void;
        SetAerialPespectiveViewDistanceScale(NewValue: number) : void;
        SetHeightFogContribution(NewValue: number) : void;
        SetMieAbsorption(NewValue: UE.LinearColor) : void;
        SetMieAbsorptionScale(NewValue: number) : void;
        SetMieAnisotropy(NewValue: number) : void;
        SetMieExponentialDistribution(NewValue: number) : void;
        SetMieScattering(NewValue: UE.LinearColor) : void;
        SetMieScatteringScale(NewValue: number) : void;
        SetOtherAbsorption(NewValue: UE.LinearColor) : void;
        SetOtherAbsorptionScale(NewValue: number) : void;
        SetRayleighExponentialDistribution(NewValue: number) : void;
        SetRayleighScattering(NewValue: UE.LinearColor) : void;
        SetRayleighScatteringScale(NewValue: number) : void;
        SetSkyLuminanceFactor(NewValue: UE.LinearColor) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkyAtmosphereComponent;
        static Load(InName: string): SkyAtmosphereComponent;
    }
    
    class SkyAtmosphere extends UE.Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SkyAtmosphereComponent: UE.SkyAtmosphereComponent;
        ArrowComponent: UE.ArrowComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkyAtmosphere;
        static Load(InName: string): SkyAtmosphere;
    }
    
    class SlateBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AbsoluteToLocal(Geometry: UE.Geometry, AbsoluteCoordinate: UE.Vector2D) : UE.Vector2D;
        static AbsoluteToViewport(WorldContextObject: $Nullable<UE.Object>, AbsoluteDesktopCoordinate: UE.Vector2D, PixelPosition: $Ref<UE.Vector2D>, ViewportPosition: $Ref<UE.Vector2D>) : void;
        static EqualEqual_SlateBrush(A: UE.SlateBrush, B: UE.SlateBrush) : boolean;
        static GetAbsoluteSize(Geometry: UE.Geometry) : UE.Vector2D;
        static GetLocalSize(Geometry: UE.Geometry) : UE.Vector2D;
        static GetLocalTopLeft(Geometry: UE.Geometry) : UE.Vector2D;
        static IsUnderLocation(Geometry: UE.Geometry, AbsoluteCoordinate: UE.Vector2D) : boolean;
        static LocalToAbsolute(Geometry: UE.Geometry, LocalCoordinate: UE.Vector2D) : UE.Vector2D;
        static LocalToViewport(WorldContextObject: $Nullable<UE.Object>, Geometry: UE.Geometry, LocalCoordinate: UE.Vector2D, PixelPosition: $Ref<UE.Vector2D>, ViewportPosition: $Ref<UE.Vector2D>) : void;
        static ScreenToViewport(WorldContextObject: $Nullable<UE.Object>, ScreenPosition: UE.Vector2D, ViewportPosition: $Ref<UE.Vector2D>) : void;
        static ScreenToWidgetAbsolute(WorldContextObject: $Nullable<UE.Object>, ScreenPosition: UE.Vector2D, AbsoluteCoordinate: $Ref<UE.Vector2D>) : void;
        static ScreenToWidgetLocal(WorldContextObject: $Nullable<UE.Object>, Geometry: UE.Geometry, ScreenPosition: UE.Vector2D, LocalCoordinate: $Ref<UE.Vector2D>) : void;
        static TransformScalarAbsoluteToLocal(Geometry: UE.Geometry, AbsoluteScalar: number) : number;
        static TransformScalarLocalToAbsolute(Geometry: UE.Geometry, LocalScalar: number) : number;
        static TransformVectorAbsoluteToLocal(Geometry: UE.Geometry, AbsoluteVector: UE.Vector2D) : UE.Vector2D;
        static TransformVectorLocalToAbsolute(Geometry: UE.Geometry, LocalVector: UE.Vector2D) : UE.Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateBlueprintLibrary;
        static Load(InName: string): SlateBlueprintLibrary;
    }
    
    class SlateBrushAssetFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialTexture: UE.Texture2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateBrushAssetFactory;
        static Load(InName: string): SlateBrushAssetFactory;
    }
    
    class SlateBrushThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateBrushThumbnailRenderer;
        static Load(InName: string): SlateBrushThumbnailRenderer;
    }
    
    class SlateSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bExplicitCanvasChildZOrder: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateSettings;
        static Load(InName: string): SlateSettings;
    }
    
    class SlateTabManagerContext extends UE.ToolMenuContextBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateTabManagerContext;
        static Load(InName: string): SlateTabManagerContext;
    }
    
    class SlateTypes extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateTypes;
        static Load(InName: string): SlateTypes;
    }
    
    class SlateMeshVertex {
        constructor();
        constructor(Position: UE.Vector2D, Color: UE.Color, UV0: UE.Vector2D, UV1: UE.Vector2D, UV2: UE.Vector2D, UV3: UE.Vector2D, UV4: UE.Vector2D, UV5: UE.Vector2D);
        Position: UE.Vector2D;
        Color: UE.Color;
        UV0: UE.Vector2D;
        UV1: UE.Vector2D;
        UV2: UE.Vector2D;
        UV3: UE.Vector2D;
        UV4: UE.Vector2D;
        UV5: UE.Vector2D;
        static StaticClass(): Class;
    }
    
    class SlateVectorArtData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MeshAsset: UE.StaticMesh;
        SourceMaterial: UE.MaterialInterface;
        VertexData: TArray<UE.SlateMeshVertex>;
        IndexData: TArray<number>;
        Material: UE.MaterialInterface;
        ExtentMin: UE.Vector2D;
        ExtentMax: UE.Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateVectorArtData;
        static Load(InName: string): SlateVectorArtData;
    }
    
    class SlateVectorArtDataFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateVectorArtDataFactory;
        static Load(InName: string): SlateVectorArtDataFactory;
    }
    
    class SlateWidgetStyleAssetFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StyleType: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateWidgetStyleAssetFactory;
        static Load(InName: string): SlateWidgetStyleAssetFactory;
    }
    
    class SlateWidgetStyleContainerInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateWidgetStyleContainerInterface;
        static Load(InName: string): SlateWidgetStyleContainerInterface;
    }
    
    class SliderStyle extends UE.SlateWidgetStyle {
        constructor();
        constructor(NormalBarImage: UE.SlateBrush, HoveredBarImage: UE.SlateBrush, DisabledBarImage: UE.SlateBrush, NormalThumbImage: UE.SlateBrush, HoveredThumbImage: UE.SlateBrush, DisabledThumbImage: UE.SlateBrush, BarThickness: number);
        NormalBarImage: UE.SlateBrush;
        HoveredBarImage: UE.SlateBrush;
        DisabledBarImage: UE.SlateBrush;
        NormalThumbImage: UE.SlateBrush;
        HoveredThumbImage: UE.SlateBrush;
        DisabledThumbImage: UE.SlateBrush;
        BarThickness: number;
        static StaticClass(): Class;
    }
    
    class Slider extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Value: number;
        ValueDelegate: $Delegate<() => number>;
        MinValue: number;
        MaxValue: number;
        WidgetStyle: UE.SliderStyle;
        Orientation: UE.EOrientation;
        SliderBarColor: UE.LinearColor;
        SliderHandleColor: UE.LinearColor;
        IndentHandle: boolean;
        Locked: boolean;
        MouseUsesStep: boolean;
        RequiresControllerLock: boolean;
        StepSize: number;
        IsFocusable: boolean;
        OnMouseCaptureBegin: $MulticastDelegate<() => void>;
        OnMouseCaptureEnd: $MulticastDelegate<() => void>;
        OnControllerCaptureBegin: $MulticastDelegate<() => void>;
        OnControllerCaptureEnd: $MulticastDelegate<() => void>;
        OnValueChanged: $MulticastDelegate<(Value: number) => void>;
        GetNormalizedValue() : number;
        GetValue() : number;
        SetIndentHandle(InValue: boolean) : void;
        SetLocked(InValue: boolean) : void;
        SetMaxValue(InValue: number) : void;
        SetMinValue(InValue: number) : void;
        SetSliderBarColor(InValue: UE.LinearColor) : void;
        SetSliderHandleColor(InValue: UE.LinearColor) : void;
        SetStepSize(InValue: number) : void;
        SetValue(InValue: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Slider;
        static Load(InName: string): Slider;
    }
    
    class SmokeTestCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SmokeTestCommandlet;
        static Load(InName: string): SmokeTestCommandlet;
    }
    
    class SoftObjectProperty extends UE.ObjectPropertyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoftObjectProperty;
        static Load(InName: string): SoftObjectProperty;
    }
    
    class SoftClassProperty extends UE.SoftObjectProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoftClassProperty;
        static Load(InName: string): SoftClassProperty;
    }
    
    class SoundAttenuationFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundAttenuationFactory;
        static Load(InName: string): SoundAttenuationFactory;
    }
    
    class SoundClassFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundClassFactory;
        static Load(InName: string): SoundClassFactory;
    }
    
    class SoundClassGraph extends UE.EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundClassGraph;
        static Load(InName: string): SoundClassGraph;
    }
    
    class SoundClassGraphNode extends UE.EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundClass: UE.SoundClass;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundClassGraphNode;
        static Load(InName: string): SoundClassGraphNode;
    }
    
    class SoundClassGraphSchema extends UE.EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundClassGraphSchema;
        static Load(InName: string): SoundClassGraphSchema;
    }
    
    class SoundConcurrencyFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundConcurrencyFactory;
        static Load(InName: string): SoundConcurrencyFactory;
    }
    
    class SoundCueFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialSoundWave: UE.SoundWave;
        InitialDialogueWave: UE.DialogueWave;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueFactoryNew;
        static Load(InName: string): SoundCueFactoryNew;
    }
    
    class SoundCueGraph extends UE.EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueGraph;
        static Load(InName: string): SoundCueGraph;
    }
    
    class SoundCueGraphNode_Base extends UE.EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueGraphNode_Base;
        static Load(InName: string): SoundCueGraphNode_Base;
    }
    
    class SoundCueGraphNode extends UE.SoundCueGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundNode: UE.SoundNode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueGraphNode;
        static Load(InName: string): SoundCueGraphNode;
    }
    
    class SoundCueGraphNode_Root extends UE.SoundCueGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueGraphNode_Root;
        static Load(InName: string): SoundCueGraphNode_Root;
    }
    
    class SoundCueGraphSchema extends UE.EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueGraphSchema;
        static Load(InName: string): SoundCueGraphSchema;
    }
    
    class SoundCueTemplate extends UE.SoundCue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueTemplate;
        static Load(InName: string): SoundCueTemplate;
    }
    
    class SoundCueTemplateCopyFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundCueTemplate: TWeakObjectPtr<UE.SoundCueTemplate>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueTemplateCopyFactory;
        static Load(InName: string): SoundCueTemplateCopyFactory;
    }
    
    class SoundCueTemplateFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueTemplateFactory;
        static Load(InName: string): SoundCueTemplateFactory;
    }
    
    class SoundExporterOGG extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundExporterOGG;
        static Load(InName: string): SoundExporterOGG;
    }
    
    class SoundExporterWAV extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundExporterWAV;
        static Load(InName: string): SoundExporterWAV;
    }
    
    class SoundGroup {
        constructor();
        constructor(SoundGroup: UE.ESoundGroup, DisplayName: string, bAlwaysDecompressOnLoad: boolean, DecompressedDuration: number);
        SoundGroup: UE.ESoundGroup;
        DisplayName: string;
        bAlwaysDecompressOnLoad: boolean;
        DecompressedDuration: number;
        static StaticClass(): Class;
    }
    
    class SoundGroups extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundGroupProfiles: TArray<UE.SoundGroup>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundGroups;
        static Load(InName: string): SoundGroups;
    }
    
    class SoundMixFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundMixFactory;
        static Load(InName: string): SoundMixFactory;
    }
    
    class SoundNodeAssetReferencer extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeAssetReferencer;
        static Load(InName: string): SoundNodeAssetReferencer;
    }
    
    class SoundNodeAttenuation extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AttenuationSettings: UE.SoundAttenuation;
        AttenuationOverrides: UE.SoundAttenuationSettings;
        bOverrideAttenuation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeAttenuation;
        static Load(InName: string): SoundNodeAttenuation;
    }
    
    class SoundNodeBranch extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoolParameterName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeBranch;
        static Load(InName: string): SoundNodeBranch;
    }
    
    class SoundNodeConcatenator extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputVolume: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeConcatenator;
        static Load(InName: string): SoundNodeConcatenator;
    }
    
    class SoundNodeDelay extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DelayMin: number;
        DelayMax: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeDelay;
        static Load(InName: string): SoundNodeDelay;
    }
    
    class DialogueWaveParameter {
        constructor();
        constructor(DialogueWave: UE.DialogueWave, Context: UE.DialogueContext);
        DialogueWave: UE.DialogueWave;
        Context: UE.DialogueContext;
        static StaticClass(): Class;
    }
    
    class SoundNodeDialoguePlayer extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DialogueWaveParameter: UE.DialogueWaveParameter;
        bLooping: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeDialoguePlayer;
        static Load(InName: string): SoundNodeDialoguePlayer;
    }
    
    class DistanceDatum {
        constructor();
        constructor(FadeInDistanceStart: number, FadeInDistanceEnd: number, FadeOutDistanceStart: number, FadeOutDistanceEnd: number, Volume: number);
        FadeInDistanceStart: number;
        FadeInDistanceEnd: number;
        FadeOutDistanceStart: number;
        FadeOutDistanceEnd: number;
        Volume: number;
        static StaticClass(): Class;
    }
    
    class SoundNodeDistanceCrossFade extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CrossFadeInput: TArray<UE.DistanceDatum>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeDistanceCrossFade;
        static Load(InName: string): SoundNodeDistanceCrossFade;
    }
    
    class SoundNodeDoppler extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DopplerIntensity: number;
        bUseSmoothing: boolean;
        SmoothingInterpSpeed: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeDoppler;
        static Load(InName: string): SoundNodeDoppler;
    }
    
    class SoundNodeEnveloper extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LoopStart: number;
        LoopEnd: number;
        DurationAfterLoop: number;
        LoopCount: number;
        bLoopIndefinitely: boolean;
        bLoop: boolean;
        VolumeInterpCurve: UE.DistributionFloatConstantCurve;
        PitchInterpCurve: UE.DistributionFloatConstantCurve;
        VolumeCurve: UE.RuntimeFloatCurve;
        PitchCurve: UE.RuntimeFloatCurve;
        PitchMin: number;
        PitchMax: number;
        VolumeMin: number;
        VolumeMax: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeEnveloper;
        static Load(InName: string): SoundNodeEnveloper;
    }
    
    class SoundNodeGroupControl extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GroupSizes: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeGroupControl;
        static Load(InName: string): SoundNodeGroupControl;
    }
    
    class SoundNodeLooping extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LoopCount: number;
        bLoopIndefinitely: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeLooping;
        static Load(InName: string): SoundNodeLooping;
    }
    
    class SoundNodeMature extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeMature;
        static Load(InName: string): SoundNodeMature;
    }
    
    class SoundNodeMixer extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputVolume: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeMixer;
        static Load(InName: string): SoundNodeMixer;
    }
    
    class SoundNodeModulator extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PitchMin: number;
        PitchMax: number;
        VolumeMin: number;
        VolumeMax: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeModulator;
        static Load(InName: string): SoundNodeModulator;
    }
    
    enum ModulationParamMode { MPM_Normal, MPM_Abs, MPM_Direct, MPM_MAX}
    class ModulatorContinuousParams {
        constructor();
        constructor(ParameterName: string, Default: number, MinInput: number, MaxInput: number, MinOutput: number, MaxOutput: number, ParamMode: UE.ModulationParamMode);
        ParameterName: string;
        Default: number;
        MinInput: number;
        MaxInput: number;
        MinOutput: number;
        MaxOutput: number;
        ParamMode: UE.ModulationParamMode;
        static StaticClass(): Class;
    }
    
    class SoundNodeModulatorContinuous extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PitchModulationParams: UE.ModulatorContinuousParams;
        VolumeModulationParams: UE.ModulatorContinuousParams;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeModulatorContinuous;
        static Load(InName: string): SoundNodeModulatorContinuous;
    }
    
    class SoundNodeOscillator extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bModulateVolume: boolean;
        bModulatePitch: boolean;
        AmplitudeMin: number;
        AmplitudeMax: number;
        FrequencyMin: number;
        FrequencyMax: number;
        OffsetMin: number;
        OffsetMax: number;
        CenterMin: number;
        CenterMax: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeOscillator;
        static Load(InName: string): SoundNodeOscillator;
    }
    
    class SoundNodeParamCrossFade extends UE.SoundNodeDistanceCrossFade {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParamName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeParamCrossFade;
        static Load(InName: string): SoundNodeParamCrossFade;
    }
    
    class SoundNodeQualityLevel extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeQualityLevel;
        static Load(InName: string): SoundNodeQualityLevel;
    }
    
    class SoundNodeRandom extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Weights: TArray<number>;
        HasBeenUsed: TArray<boolean>;
        NumRandomUsed: number;
        PreselectAtLevelLoad: number;
        bShouldExcludeFromBranchCulling: boolean;
        bSoundCueExcludedFromBranchCulling: boolean;
        bRandomizeWithoutReplacement: boolean;
        PIEHiddenNodes: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeRandom;
        static Load(InName: string): SoundNodeRandom;
    }
    
    class SoundNodeSoundClass extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundClassOverride: UE.SoundClass;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeSoundClass;
        static Load(InName: string): SoundNodeSoundClass;
    }
    
    class SoundNodeSwitch extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IntParameterName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeSwitch;
        static Load(InName: string): SoundNodeSwitch;
    }
    
    class SoundNodeWaveParam extends UE.SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WaveParameterName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeWaveParam;
        static Load(InName: string): SoundNodeWaveParam;
    }
    
    class SoundNodeWavePlayer extends UE.SoundNodeAssetReferencer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundWaveAssetPtr: TSoftObjectPtr<UE.SoundWave>;
        SoundWave: UE.SoundWave;
        bLooping: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeWavePlayer;
        static Load(InName: string): SoundNodeWavePlayer;
    }
    
    class SoundSourceBusFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSourceBusFactory;
        static Load(InName: string): SoundSourceBusFactory;
    }
    
    class SoundSourceEffectChainFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSourceEffectChainFactory;
        static Load(InName: string): SoundSourceEffectChainFactory;
    }
    
    class SoundSourceEffectFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundEffectSourcepresetClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSourceEffectFactory;
        static Load(InName: string): SoundSourceEffectFactory;
    }
    
    class SoundSubmixEffectFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundEffectSubmixPresetClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSubmixEffectFactory;
        static Load(InName: string): SoundSubmixEffectFactory;
    }
    
    class SoundSubmixFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSubmixFactory;
        static Load(InName: string): SoundSubmixFactory;
    }
    
    class SoundSubmixGraph extends UE.EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSubmixGraph;
        static Load(InName: string): SoundSubmixGraph;
    }
    
    class SoundSubmixGraphNode extends UE.EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundSubmix: UE.SoundSubmix;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSubmixGraphNode;
        static Load(InName: string): SoundSubmixGraphNode;
    }
    
    class SoundSubmixGraphSchema extends UE.EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSubmixGraphSchema;
        static Load(InName: string): SoundSubmixGraphSchema;
    }
    
    class SoundSurroundExporterWAV extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSurroundExporterWAV;
        static Load(InName: string): SoundSurroundExporterWAV;
    }
    
    class SoundWaveThumbnailRenderer extends UE.ThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundWaveThumbnailRenderer;
        static Load(InName: string): SoundWaveThumbnailRenderer;
    }
    
    class SourceCodeAccessSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PreferredAccessor: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SourceCodeAccessSettings;
        static Load(InName: string): SourceCodeAccessSettings;
    }
    
    class SourceControlState {
        constructor();
        constructor(Filename: string, bIsValid: boolean, bIsUnknown: boolean, bCanCheckIn: boolean, bCanCheckOut: boolean, bIsCheckedOut: boolean, bIsCurrent: boolean, bIsSourceControlled: boolean, bIsAdded: boolean, bIsDeleted: boolean, bIsIgnored: boolean, bCanEdit: boolean, bCanDelete: boolean, bIsModified: boolean, bCanAdd: boolean, bIsConflicted: boolean, bCanRevert: boolean, bIsCheckedOutOther: boolean, CheckedOutOther: string);
        Filename: string;
        bIsValid: boolean;
        bIsUnknown: boolean;
        bCanCheckIn: boolean;
        bCanCheckOut: boolean;
        bIsCheckedOut: boolean;
        bIsCurrent: boolean;
        bIsSourceControlled: boolean;
        bIsAdded: boolean;
        bIsDeleted: boolean;
        bIsIgnored: boolean;
        bCanEdit: boolean;
        bCanDelete: boolean;
        bIsModified: boolean;
        bCanAdd: boolean;
        bIsConflicted: boolean;
        bCanRevert: boolean;
        bIsCheckedOutOther: boolean;
        CheckedOutOther: string;
        static StaticClass(): Class;
    }
    
    class SourceControlHelpers extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CheckInFile(InFile: string, InDescription: string, bSilent?: boolean /* = false */) : boolean;
        static CheckInFiles(InFiles: TArray<string>, InDescription: string, bSilent?: boolean /* = false */) : boolean;
        static CheckOutFile(InFile: string, bSilent?: boolean /* = false */) : boolean;
        static CheckOutFiles(InFiles: TArray<string>, bSilent?: boolean /* = false */) : boolean;
        static CheckOutOrAddFile(InFile: string, bSilent?: boolean /* = false */) : boolean;
        static CopyFile(InSourceFile: string, InDestFile: string, bSilent?: boolean /* = false */) : boolean;
        static CurrentProvider() : string;
        static IsAvailable() : boolean;
        static IsEnabled() : boolean;
        static LastErrorMsg() : string;
        static MarkFileForAdd(InFile: string, bSilent?: boolean /* = false */) : boolean;
        static MarkFileForDelete(InFile: string, bSilent?: boolean /* = false */) : boolean;
        static MarkFilesForAdd(InFiles: TArray<string>, bSilent?: boolean /* = false */) : boolean;
        static QueryFileState(InFile: string, bSilent?: boolean /* = false */) : UE.SourceControlState;
        static RevertFile(InFile: string, bSilent?: boolean /* = false */) : boolean;
        static RevertFiles(InFiles: TArray<string>, bSilent?: boolean /* = false */) : boolean;
        static RevertUnchangedFile(InFile: string, bSilent?: boolean /* = false */) : boolean;
        static RevertUnchangedFiles(InFiles: TArray<string>, bSilent?: boolean /* = false */) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SourceControlHelpers;
        static Load(InName: string): SourceControlHelpers;
    }
    
    class Spacer extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Size: UE.Vector2D;
        SetSize(InSize: UE.Vector2D) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Spacer;
        static Load(InName: string): Spacer;
    }
    
    class SparseDelegateFunction extends UE.DelegateFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SparseDelegateFunction;
        static Load(InName: string): SparseDelegateFunction;
    }
    
    class SpectatorReservation {
        constructor();
        constructor(SpectatorId: UE.UniqueNetIdRepl, Spectator: UE.PlayerReservation);
        SpectatorId: UE.UniqueNetIdRepl;
        Spectator: UE.PlayerReservation;
        static StaticClass(): Class;
    }
    
    enum ESpectatorClientRequestType { NonePending, ExistingSessionReservation, ReservationUpdate, EmptyServerReservation, Reconnect, Abandon, ESpectatorClientRequestType_MAX}
    enum ESpectatorReservationResult { NoResult, RequestPending, GeneralError, SpectatorLimitReached, IncorrectPlayerCount, RequestTimedOut, ReservationDuplicate, ReservationNotFound, ReservationAccepted, ReservationDenied, ReservationDenied_CrossPlayRestriction, ReservationDenied_Banned, ReservationRequestCanceled, ReservationInvalid, BadSessionId, ReservationDenied_ContainsExistingPlayers, ESpectatorReservationResult_MAX}
    class SpectatorBeaconClient extends UE.OnlineBeaconClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DestSessionId: string;
        PendingReservation: UE.SpectatorReservation;
        RequestType: UE.ESpectatorClientRequestType;
        bPendingReservationSent: boolean;
        bCancelReservation: boolean;
        ClientCancelReservationResponse(ReservationResponse: UE.ESpectatorReservationResult) : void;
        ClientReservationResponse(ReservationResponse: UE.ESpectatorReservationResult) : void;
        ClientSendReservationFull() : void;
        ClientSendReservationUpdates(NumRemainingReservations: number) : void;
        ServerCancelReservationRequest(Spectator: UE.UniqueNetIdRepl) : void;
        ServerReservationRequest(SessionId: string, Reservation: UE.SpectatorReservation) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpectatorBeaconClient;
        static Load(InName: string): SpectatorBeaconClient;
    }
    
    class SpectatorBeaconState extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SessionName: string;
        NumConsumedReservations: number;
        MaxReservations: number;
        bRestrictCrossConsole: boolean;
        Reservations: TArray<UE.SpectatorReservation>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpectatorBeaconState;
        static Load(InName: string): SpectatorBeaconState;
    }
    
    class SpectatorBeaconHost extends UE.OnlineBeaconHostObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        State: UE.SpectatorBeaconState;
        bLogoutOnSessionTimeout: boolean;
        SessionTimeoutSecs: number;
        TravelSessionTimeoutSecs: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpectatorBeaconHost;
        static Load(InName: string): SpectatorBeaconHost;
    }
    
    class SpectatorPawnMovement extends UE.FloatingPawnMovement {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIgnoreTimeDilation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpectatorPawnMovement;
        static Load(InName: string): SpectatorPawnMovement;
    }
    
    enum EImportGeometryType { IGT_3D, IGT_Billboards, IGT_Both, IGT_MAX}
    enum EImportLODType { ILT_PaintedFoliage, ILT_IndividualActors, ILT_MAX}
    class SpeedTreeImportData extends UE.AssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TreeScale: number;
        ImportGeometryType: UE.EImportGeometryType;
        LODType: UE.EImportLODType;
        IncludeCollision: boolean;
        MakeMaterialsCheck: boolean;
        IncludeNormalMapCheck: boolean;
        IncludeDetailMapCheck: boolean;
        IncludeSpecularMapCheck: boolean;
        IncludeBranchSeamSmoothing: boolean;
        IncludeSpeedTreeAO: boolean;
        IncludeColorAdjustment: boolean;
        IncludeSubsurface: boolean;
        IncludeVertexProcessingCheck: boolean;
        IncludeWindCheck: boolean;
        IncludeSmoothLODCheck: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpeedTreeImportData;
        static Load(InName: string): SpeedTreeImportData;
    }
    
    class SphereReflectionCapture extends UE.ReflectionCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DrawCaptureRadius: UE.DrawSphereComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SphereReflectionCapture;
        static Load(InName: string): SphereReflectionCapture;
    }
    
    class SphereReflectionCaptureComponent extends UE.ReflectionCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InfluenceRadius: number;
        CaptureDistanceScale: number;
        PreviewInfluenceRadius: UE.DrawSphereComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SphereReflectionCaptureComponent;
        static Load(InName: string): SphereReflectionCaptureComponent;
    }
    
    class SpinBoxStyle extends UE.SlateWidgetStyle {
        constructor();
        constructor(BackgroundBrush: UE.SlateBrush, HoveredBackgroundBrush: UE.SlateBrush, ActiveFillBrush: UE.SlateBrush, InactiveFillBrush: UE.SlateBrush, ArrowsImage: UE.SlateBrush, ForegroundColor: UE.SlateColor, TextPadding: UE.Margin);
        BackgroundBrush: UE.SlateBrush;
        HoveredBackgroundBrush: UE.SlateBrush;
        ActiveFillBrush: UE.SlateBrush;
        InactiveFillBrush: UE.SlateBrush;
        ArrowsImage: UE.SlateBrush;
        ForegroundColor: UE.SlateColor;
        TextPadding: UE.Margin;
        static StaticClass(): Class;
    }
    
    class SpinBox extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Value: number;
        ValueDelegate: $Delegate<() => number>;
        WidgetStyle: UE.SpinBoxStyle;
        Style: UE.SlateWidgetStyleAsset;
        Delta: number;
        SliderExponent: number;
        Font: UE.SlateFontInfo;
        Justification: UE.ETextJustify;
        MinDesiredWidth: number;
        ClearKeyboardFocusOnCommit: boolean;
        SelectAllTextOnCommit: boolean;
        ForegroundColor: UE.SlateColor;
        OnValueChanged: $MulticastDelegate<(InValue: number) => void>;
        OnValueCommitted: $MulticastDelegate<(InValue: number, CommitMethod: UE.ETextCommit) => void>;
        OnBeginSliderMovement: $MulticastDelegate<() => void>;
        OnEndSliderMovement: $MulticastDelegate<(InValue: number) => void>;
        bOverride_MinValue: boolean;
        bOverride_MaxValue: boolean;
        bOverride_MinSliderValue: boolean;
        bOverride_MaxSliderValue: boolean;
        MinValue: number;
        MaxValue: number;
        MinSliderValue: number;
        MaxSliderValue: number;
        ClearMaxSliderValue() : void;
        ClearMaxValue() : void;
        ClearMinSliderValue() : void;
        ClearMinValue() : void;
        GetMaxSliderValue() : number;
        GetMaxValue() : number;
        GetMinSliderValue() : number;
        GetMinValue() : number;
        GetValue() : number;
        OnSpinBoxBeginSliderMovement__DelegateSignature() : void;
        OnSpinBoxValueChangedEvent__DelegateSignature(InValue: number) : void;
        OnSpinBoxValueCommittedEvent__DelegateSignature(InValue: number, CommitMethod: UE.ETextCommit) : void;
        SetForegroundColor(InForegroundColor: UE.SlateColor) : void;
        SetMaxSliderValue(NewValue: number) : void;
        SetMaxValue(NewValue: number) : void;
        SetMinSliderValue(NewValue: number) : void;
        SetMinValue(NewValue: number) : void;
        SetValue(NewValue: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpinBox;
        static Load(InName: string): SpinBox;
    }
    
    class SpinBoxWidgetStyle extends UE.SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpinBoxStyle: UE.SpinBoxStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpinBoxWidgetStyle;
        static Load(InName: string): SpinBoxWidgetStyle;
    }
    
    class SpiralStairBuilder extends UE.EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InnerRadius: number;
        StepWidth: number;
        StepHeight: number;
        StepThickness: number;
        NumStepsPer360: number;
        NumSteps: number;
        GroupName: string;
        SlopedCeiling: boolean;
        SlopedFloor: boolean;
        CounterClockwise: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpiralStairBuilder;
        static Load(InName: string): SpiralStairBuilder;
    }
    
    class SplineMeshActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SplineMeshComponent: UE.SplineMeshComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SplineMeshActor;
        static Load(InName: string): SplineMeshActor;
    }
    
    class SplineMetadataDetailsFactoryBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SplineMetadataDetailsFactoryBase;
        static Load(InName: string): SplineMetadataDetailsFactoryBase;
    }
    
    class SpringArmComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetArmLength: number;
        SocketOffset: UE.Vector;
        TargetOffset: UE.Vector;
        ProbeSize: number;
        ProbeChannel: UE.ECollisionChannel;
        bDoCollisionTest: boolean;
        bUsePawnControlRotation: boolean;
        bInheritPitch: boolean;
        bInheritYaw: boolean;
        bInheritRoll: boolean;
        bEnableCameraLag: boolean;
        bEnableCameraRotationLag: boolean;
        bUseCameraLagSubstepping: boolean;
        bDrawDebugLagMarkers: boolean;
        CameraLagSpeed: number;
        CameraRotationLagSpeed: number;
        CameraLagMaxTimeStep: number;
        CameraLagMaxDistance: number;
        GetTargetRotation() : UE.Rotator;
        GetUnfixedCameraPosition() : UE.Vector;
        IsCollisionFixApplied() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpringArmComponent;
        static Load(InName: string): SpringArmComponent;
    }
    
    class SpriteEditorSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BackgroundColor: UE.Color;
        bShowGridByDefault: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpriteEditorSettings;
        static Load(InName: string): SpriteEditorSettings;
    }
    
    class SquareSplineGenerator extends UE.SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Length: number;
        bBranchRight: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SquareSplineGenerator;
        static Load(InName: string): SquareSplineGenerator;
    }
    
    class SSCSEditorMenuContext extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SSCSEditorMenuContext;
        static Load(InName: string): SSCSEditorMenuContext;
    }
    
    class StabilizeLocalizationKeysCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StabilizeLocalizationKeysCommandlet;
        static Load(InName: string): StabilizeLocalizationKeysCommandlet;
    }
    
    namespace Engine.EditorBlueprintResources.StandardMacros {
        class StandardMacros_C extends UE.Object {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): StandardMacros_C;
            static Load(InName: string): StandardMacros_C;
        }
        
    }

    class StaticMeshExporterFBX extends UE.ExporterFBX {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshExporterFBX;
        static Load(InName: string): StaticMeshExporterFBX;
    }
    
    class StaticMeshExporterOBJ extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshExporterOBJ;
        static Load(InName: string): StaticMeshExporterOBJ;
    }
    
    class StaticMeshLightingInfo extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StaticMeshActor: TWeakObjectPtr<UE.Actor>;
        StaticMesh: TWeakObjectPtr<UE.StaticMesh>;
        LevelName: string;
        TextureMapping: string;
        bTextureMapping: boolean;
        bHasLightmapTexCoords: boolean;
        StaticLightingResolution: number;
        TextureLightMapMemoryUsage: number;
        VertexLightMapMemoryUsage: number;
        LightMapLightCount: number;
        TextureShadowMapMemoryUsage: number;
        VertexShadowMapMemoryUsage: number;
        ShadowMapLightCount: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshLightingInfo;
        static Load(InName: string): StaticMeshLightingInfo;
    }
    
    class StaticMeshSimulationComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Simulating: boolean;
        bNotifyCollisions: boolean;
        ObjectType: UE.EObjectStateTypeEnum;
        Mass: number;
        CollisionType: UE.ECollisionTypeEnum;
        ImplicitType: UE.EImplicitTypeEnum;
        MinLevelSetResolution: number;
        MaxLevelSetResolution: number;
        InitialVelocityType: UE.EInitialVelocityTypeEnum;
        InitialLinearVelocity: UE.Vector;
        InitialAngularVelocity: UE.Vector;
        DamageThreshold: number;
        PhysicalMaterial: UE.ChaosPhysicalMaterial;
        ChaosSolverActor: UE.ChaosSolverActor;
        OnChaosPhysicsCollision: $MulticastDelegate<(CollisionInfo: UE.ChaosPhysicsCollisionInfo) => void>;
        SimulatedComponents: TArray<UE.PrimitiveComponent>;
        ForceRecreatePhysicsState() : void;
        ReceivePhysicsCollision(CollisionInfo: UE.ChaosPhysicsCollisionInfo) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshSimulationComponent;
        static Load(InName: string): StaticMeshSimulationComponent;
    }
    
    class StaticMeshThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshThumbnailRenderer;
        static Load(InName: string): StaticMeshThumbnailRenderer;
    }
    
    class SteamClient extends UE.IPClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SteamClient;
        static Load(InName: string): SteamClient;
    }
    
    class SteamVRChaperoneComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnLeaveBounds: $MulticastDelegate<() => void>;
        OnReturnToBounds: $MulticastDelegate<() => void>;
        GetBounds() : TArray<UE.Vector>;
        SteamVRChaperoneEvent__DelegateSignature() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SteamVRChaperoneComponent;
        static Load(InName: string): SteamVRChaperoneComponent;
    }
    
    enum ESteamVRTrackedDeviceType { Controller, TrackingReference, Other, Invalid, ESteamVRTrackedDeviceType_MAX}
    class SteamVRFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetHandPositionAndOrientation(ControllerIndex: number, Hand: UE.EControllerHand, OutPosition: $Ref<UE.Vector>, OutOrientation: $Ref<UE.Rotator>) : boolean;
        static GetTrackedDevicePositionAndOrientation(DeviceId: number, OutPosition: $Ref<UE.Vector>, OutOrientation: $Ref<UE.Rotator>) : boolean;
        static GetValidTrackedDeviceIds(DeviceType: UE.ESteamVRTrackedDeviceType, OutTrackedDeviceIds: $Ref<TArray<number>>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SteamVRFunctionLibrary;
        static Load(InName: string): SteamVRFunctionLibrary;
    }
    
    class SteamVRAction {
        constructor();
        constructor(Name: string, Path: string);
        Name: string;
        Path: string;
        static StaticClass(): Class;
    }
    
    class SteamVRActionSet {
        constructor();
        constructor(Path: string);
        Path: string;
        static StaticClass(): Class;
    }
    
    enum ESteamVRHand { VR_Left, VR_Right, VR_MAX}
    class SteamVRInputOriginInfo {
        constructor();
        constructor(TrackedDeviceIndex: number, RenderModelComponentName: string, TrackedDeviceModel: string);
        TrackedDeviceIndex: number;
        RenderModelComponentName: string;
        TrackedDeviceModel: string;
        static StaticClass(): Class;
    }
    
    enum ESteamVRInputStringBits { VR_InputString_Hand, VR_InputString_ControllerType, VR_InputString_InputSource, VR_InputString_All, VR_InputString_MAX}
    class SteamVRInputBindingInfo {
        constructor();
        constructor(DevicePathName: string, InputPathName: string, ModeName: string, SlotName: string);
        DevicePathName: string;
        InputPathName: string;
        ModeName: string;
        SlotName: string;
        static StaticClass(): Class;
    }
    
    class SteamVRFingerCurls {
        constructor();
        constructor(Thumb: number, Index: number, Middle: number, Ring: number, Pinky: number);
        Thumb: number;
        Index: number;
        Middle: number;
        Ring: number;
        Pinky: number;
        static StaticClass(): Class;
    }
    
    class SteamVRFingerSplays {
        constructor();
        constructor(Thumb_Index: number, Index_Middle: number, Middle_Ring: number, Ring_Pinky: number);
        Thumb_Index: number;
        Index_Middle: number;
        Middle_Ring: number;
        Ring_Pinky: number;
        static StaticClass(): Class;
    }
    
    enum ESkeletalSummaryDataType { VR_SummaryType_FromAnimation, VR_SummaryType_FromDevice, VR_SummaryType_MAX}
    enum EControllerFidelity { VR_ControllerFidelity_Estimated, VR_ControllerFidelity_Full, VR_ControllerFidelity_Partial, VR_ControllerFidelity_MAX}
    class SteamVRInputDeviceFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static FindSteamVR_Action(ActionName: string, bResult: $Ref<boolean>, FoundAction: $Ref<UE.SteamVRAction>, FoundActionSet: $Ref<UE.SteamVRActionSet>, ActionSet?: string /* = "main" */) : void;
        static FindSteamVR_ActionOrigin(ActionName: string, ActionSet?: string /* = "main" */) : boolean;
        static FindSteamVR_InputBindingInfo(ActionName: string, ActionSet?: string /* = "main" */) : TArray<UE.SteamVRInputBindingInfo>;
        static FindSteamVR_OriginTrackedDeviceInfo(ActionName: string, bResult: $Ref<boolean>, InputOriginInfo: $Ref<UE.SteamVRInputOriginInfo>, ActionSet?: string /* = "main" */) : void;
        static GetControllerFidelity(LeftControllerFidelity: $Ref<UE.EControllerFidelity>, RightControllerFidelity: $Ref<UE.EControllerFidelity>) : void;
        static GetCurlsAndSplaysState(LeftHandState: $Ref<boolean>, RightHandState: $Ref<boolean>) : void;
        static GetFingerCurlsAndSplays(Hand: UE.EHand, FingerCurls: $Ref<UE.SteamVRFingerCurls>, FingerSplays: $Ref<UE.SteamVRFingerSplays>, SummaryDataType?: UE.ESkeletalSummaryDataType /* = VR_SummaryType_FromAnimation */) : void;
        static GetLeftHandPoseData(Position: $Ref<UE.Vector>, Orientation: $Ref<UE.Rotator>, AngularVelocity: $Ref<UE.Vector>, Velocity: $Ref<UE.Vector>) : void;
        static GetPoseSource(bUsingSkeletonPose: $Ref<boolean>) : void;
        static GetRightHandPoseData(Position: $Ref<UE.Vector>, Orientation: $Ref<UE.Rotator>, AngularVelocity: $Ref<UE.Vector>, Velocity: $Ref<UE.Vector>) : void;
        static GetSkeletalState(LeftHandState: $Ref<boolean>, RightHandState: $Ref<boolean>) : void;
        static GetSkeletalTransform(LeftHand: $Ref<UE.SteamVRSkeletonTransform>, RightHand: $Ref<UE.SteamVRSkeletonTransform>, bWithController?: boolean /* = false */) : void;
        static GetSteamVR_ActionArray(SteamVRActions: $Ref<TArray<UE.SteamVRAction>>) : void;
        static GetSteamVR_ActionSetArray(SteamVRActionSets: $Ref<TArray<UE.SteamVRActionSet>>) : void;
        static GetSteamVR_GlobalPredictedSecondsFromNow() : number;
        static GetSteamVR_HandPoseRelativeToNow(Position: $Ref<UE.Vector>, Orientation: $Ref<UE.Rotator>, Hand?: UE.ESteamVRHand /* = VR_Left */, PredictedSecondsFromNow?: number /* = 0.000000 */) : boolean;
        static GetSteamVR_InputBindingInfo(SteamVRActionHandle: UE.SteamVRAction) : TArray<UE.SteamVRInputBindingInfo>;
        static GetSteamVR_OriginLocalizedName(SteamVRAction: UE.SteamVRAction, LocalizedParts: TArray<UE.ESteamVRInputStringBits>, OriginLocalizedName: $Ref<string>) : void;
        static GetSteamVR_OriginTrackedDeviceInfo(SteamVRAction: UE.SteamVRAction, InputOriginInfo: $Ref<UE.SteamVRInputOriginInfo>) : boolean;
        static GetUserIPD() : number;
        static PlaySteamVR_HapticFeedback(Hand: UE.ESteamVRHand, StartSecondsFromNow: number, DurationSeconds?: number /* = 1.000000 */, Frequency?: number /* = 1.000000 */, Amplitude?: number /* = 0.500000 */) : void;
        static ResetSeatedPosition() : boolean;
        static SetCurlsAndSplaysState(NewLeftHandState: boolean, NewRightHandState: boolean) : void;
        static SetPoseSource(bUseSkeletonPose: boolean) : void;
        static SetSteamVR_GlobalPredictedSecondsFromNow(NewValue: number) : number;
        static ShowAllSteamVR_ActionOrigins() : void;
        static ShowSteamVR_ActionOrigin(SteamVRAction: UE.SteamVRAction, SteamVRActionSet: UE.SteamVRActionSet) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SteamVRInputDeviceFunctionLibrary;
        static Load(InName: string): SteamVRInputDeviceFunctionLibrary;
    }
    
    class SteamVRTrackingReferences extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnTrackedDeviceActivated: $MulticastDelegate<(DeviceID: number, DeviceClass: string, DeviceModel: string) => void>;
        OnTrackedDeviceDeactivated: $MulticastDelegate<(DeviceID: number, DeviceClass: string, DeviceModel: string) => void>;
        ActiveDevicePollFrequency: number;
        TrackingReferenceScale: UE.Vector;
        TrackingReferences: TArray<UE.StaticMeshComponent>;
        HideTrackingReferences() : void;
        ShowTrackingReferences(TrackingReferenceMesh: $Nullable<UE.StaticMesh>) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SteamVRTrackingReferences;
        static Load(InName: string): SteamVRTrackingReferences;
    }
    
    class EquirectProps {
        constructor();
        constructor(LeftUVRect: UE.Box2D, RightUVRect: UE.Box2D, LeftScale: UE.Vector2D, RightScale: UE.Vector2D, LeftBias: UE.Vector2D, RightBias: UE.Vector2D);
        LeftUVRect: UE.Box2D;
        RightUVRect: UE.Box2D;
        LeftScale: UE.Vector2D;
        RightScale: UE.Vector2D;
        LeftBias: UE.Vector2D;
        RightBias: UE.Vector2D;
        static StaticClass(): Class;
    }
    
    enum EStereoLayerType { SLT_WorldLocked, SLT_TrackerLocked, SLT_FaceLocked, SLT_MAX}
    enum EStereoLayerShape { SLSH_QuadLayer, SLSH_CylinderLayer, SLSH_CubemapLayer, SLSH_EquirectLayer, SLSH_MAX}
    class StereoLayerComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bLiveTexture: boolean;
        bSupportsDepth: boolean;
        bNoAlphaChannel: boolean;
        Texture: UE.Texture;
        LeftTexture: UE.Texture;
        bQuadPreserveTextureRatio: boolean;
        QuadSize: UE.Vector2D;
        UVRect: UE.Box2D;
        CylinderRadius: number;
        CylinderOverlayArc: number;
        CylinderHeight: number;
        EquirectProps: UE.EquirectProps;
        StereoLayerType: UE.EStereoLayerType;
        StereoLayerShape: UE.EStereoLayerShape;
        Priority: number;
        GetLeftTexture() : UE.Texture;
        GetPriority() : number;
        GetQuadSize() : UE.Vector2D;
        GetTexture() : UE.Texture;
        GetUVRect() : UE.Box2D;
        MarkTextureForUpdate() : void;
        SetEquirectProps(InScaleBiases: UE.EquirectProps) : void;
        SetLeftTexture(InTexture: $Nullable<UE.Texture>) : void;
        SetPriority(InPriority: number) : void;
        SetQuadSize(InQuadSize: UE.Vector2D) : void;
        SetTexture(InTexture: $Nullable<UE.Texture>) : void;
        SetUVRect(InUVRect: UE.Box2D) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StereoLayerComponent;
        static Load(InName: string): StereoLayerComponent;
    }
    
    class StereoLayerFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static EnableAutoLoadingSplashScreen(InAutoShowEnabled: boolean) : void;
        static HideSplashScreen() : void;
        static SetSplashScreen(Texture: $Nullable<UE.Texture>, Scale?: UE.Vector2D /* = (X=1.000,Y=1.000) */, Offset?: UE.Vector /* = 0.000000,0.000000,0.000000 */, bShowLoadingMovie?: boolean /* = false */, bShowOnSet?: boolean /* = false */) : void;
        static ShowSplashScreen() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StereoLayerFunctionLibrary;
        static Load(InName: string): StereoLayerFunctionLibrary;
    }
    
    class StreamingSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AsyncLoadingThreadEnabled: boolean;
        WarnIfTimeLimitExceeded: boolean;
        TimeLimitExceededMultiplier: number;
        TimeLimitExceededMinTime: number;
        MinBulkDataSizeForAsyncLoading: number;
        UseBackgroundLevelStreaming: boolean;
        AsyncLoadingUseFullTimeLimit: boolean;
        AsyncLoadingTimeLimit: number;
        PriorityAsyncLoadingExtraTime: number;
        LevelStreamingActorsUpdateTimeLimit: number;
        PriorityLevelStreamingActorsUpdateExtraTime: number;
        LevelStreamingComponentsRegistrationGranularity: number;
        LevelStreamingUnregisterComponentsTimeLimit: number;
        LevelStreamingComponentsUnregistrationGranularity: number;
        EventDrivenLoaderEnabled: boolean;
        FlushStreamingOnExit: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StreamingSettings;
        static Load(InName: string): StreamingSettings;
    }
    
    class StreamMediaSource extends UE.BaseMediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StreamUrl: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StreamMediaSource;
        static Load(InName: string): StreamMediaSource;
    }
    
    class StreamMediaSourceFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StreamMediaSourceFactoryNew;
        static Load(InName: string): StreamMediaSourceFactoryNew;
    }
    
    class StretchGizmoHandleDragOperation extends UE.ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StretchGizmoHandleDragOperation;
        static Load(InName: string): StretchGizmoHandleDragOperation;
    }
    
    class StringTable extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StringTable;
        static Load(InName: string): StringTable;
    }
    
    class StringTableFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StringTableFactory;
        static Load(InName: string): StringTableFactory;
    }
    
    class StrProperty extends UE.Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StrProperty;
        static Load(InName: string): StrProperty;
    }
    
    class StructureFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StructureFactory;
        static Load(InName: string): StructureFactory;
    }
    
    class StructViewerProjectSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InternalOnlyPaths: TArray<UE.DirectoryPath>;
        InternalOnlyStructs: TArray<TSoftObjectPtr<UE.ScriptStruct>>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StructViewerProjectSettings;
        static Load(InName: string): StructViewerProjectSettings;
    }
    
    enum EStructViewerDeveloperType { SVDT_None, SVDT_CurrentUser, SVDT_All, SVDT_Max, SVDT_MAX}
    class StructViewerSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DisplayInternalStructs: boolean;
        DeveloperFolderType: UE.EStructViewerDeveloperType;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StructViewerSettings;
        static Load(InName: string): StructViewerSettings;
    }
    
    enum ESubmixEffectDynamicsProcessorType { Compressor, Limiter, Expander, Gate, Count, ESubmixEffectDynamicsProcessorType_MAX}
    enum ESubmixEffectDynamicsPeakMode { MeanSquared, RootMeanSquared, Peak, Count, ESubmixEffectDynamicsPeakMode_MAX}
    class SubmixEffectDynamicsProcessorSettings {
        constructor();
        constructor(DynamicsProcessorType: UE.ESubmixEffectDynamicsProcessorType, PeakMode: UE.ESubmixEffectDynamicsPeakMode, LookAheadMsec: number, AttackTimeMsec: number, ReleaseTimeMsec: number, ThresholdDb: number, Ratio: number, KneeBandwidthDb: number, InputGainDb: number, OutputGainDb: number, bChannelLinked: boolean, bAnalogMode: boolean);
        DynamicsProcessorType: UE.ESubmixEffectDynamicsProcessorType;
        PeakMode: UE.ESubmixEffectDynamicsPeakMode;
        LookAheadMsec: number;
        AttackTimeMsec: number;
        ReleaseTimeMsec: number;
        ThresholdDb: number;
        Ratio: number;
        KneeBandwidthDb: number;
        InputGainDb: number;
        OutputGainDb: number;
        bChannelLinked: boolean;
        bAnalogMode: boolean;
        static StaticClass(): Class;
    }
    
    class SubmixEffectDynamicsProcessorPreset extends UE.SoundEffectSubmixPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: UE.SubmixEffectDynamicsProcessorSettings;
        SetSettings(InSettings: UE.SubmixEffectDynamicsProcessorSettings) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubmixEffectDynamicsProcessorPreset;
        static Load(InName: string): SubmixEffectDynamicsProcessorPreset;
    }
    
    class SubmixEffectReverbFastSettings {
        constructor();
        constructor(Density: number, Diffusion: number, Gain: number, GainHF: number, DecayTime: number, DecayHFRatio: number, ReflectionsGain: number, ReflectionsDelay: number, LateGain: number, LateDelay: number, AirAbsorptionGainHF: number, WetLevel: number, DryLevel: number);
        Density: number;
        Diffusion: number;
        Gain: number;
        GainHF: number;
        DecayTime: number;
        DecayHFRatio: number;
        ReflectionsGain: number;
        ReflectionsDelay: number;
        LateGain: number;
        LateDelay: number;
        AirAbsorptionGainHF: number;
        WetLevel: number;
        DryLevel: number;
        static StaticClass(): Class;
    }
    
    class SubmixEffectReverbFastPreset extends UE.SoundEffectSubmixPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: UE.SubmixEffectReverbFastSettings;
        SetSettings(InSettings: UE.SubmixEffectReverbFastSettings) : void;
        SetSettingsWithReverbEffect(InReverbEffect: $Nullable<UE.ReverbEffect>, WetLevel: number, DryLevel?: number /* = 0.000000 */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubmixEffectReverbFastPreset;
        static Load(InName: string): SubmixEffectReverbFastPreset;
    }
    
    class SubmixEffectReverbSettings {
        constructor();
        constructor(Density: number, Diffusion: number, Gain: number, GainHF: number, DecayTime: number, DecayHFRatio: number, ReflectionsGain: number, ReflectionsDelay: number, LateGain: number, LateDelay: number, AirAbsorptionGainHF: number, WetLevel: number, DryLevel: number);
        Density: number;
        Diffusion: number;
        Gain: number;
        GainHF: number;
        DecayTime: number;
        DecayHFRatio: number;
        ReflectionsGain: number;
        ReflectionsDelay: number;
        LateGain: number;
        LateDelay: number;
        AirAbsorptionGainHF: number;
        WetLevel: number;
        DryLevel: number;
        static StaticClass(): Class;
    }
    
    class SubmixEffectReverbPreset extends UE.SoundEffectSubmixPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: UE.SubmixEffectReverbSettings;
        SetSettings(InSettings: UE.SubmixEffectReverbSettings) : void;
        SetSettingsWithReverbEffect(InReverbEffect: $Nullable<UE.ReverbEffect>, WetLevel: number, DryLevel?: number /* = 0.000000 */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubmixEffectReverbPreset;
        static Load(InName: string): SubmixEffectReverbPreset;
    }
    
    class SubmixEffectEQBand {
        constructor();
        constructor(Frequency: number, Bandwidth: number, GainDb: number, bEnabled: boolean);
        Frequency: number;
        Bandwidth: number;
        GainDb: number;
        bEnabled: boolean;
        static StaticClass(): Class;
    }
    
    class SubmixEffectSubmixEQSettings {
        constructor();
        constructor(EQBands: TArray<UE.SubmixEffectEQBand>);
        EQBands: TArray<UE.SubmixEffectEQBand>;
        static StaticClass(): Class;
    }
    
    class SubmixEffectSubmixEQPreset extends UE.SoundEffectSubmixPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: UE.SubmixEffectSubmixEQSettings;
        SetSettings(InSettings: UE.SubmixEffectSubmixEQSettings) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubmixEffectSubmixEQPreset;
        static Load(InName: string): SubmixEffectSubmixEQPreset;
    }
    
    class SubsurfaceProfileFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubsurfaceProfileFactory;
        static Load(InName: string): SubsurfaceProfileFactory;
    }
    
    class SubsurfaceProfileRenderer extends UE.TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubsurfaceProfileRenderer;
        static Load(InName: string): SubsurfaceProfileRenderer;
    }
    
    class WorldSubsystem extends UE.Subsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WorldSubsystem;
        static Load(InName: string): WorldSubsystem;
    }
    
    class SubsystemBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetEngineSubsystem(Class: $Nullable<UE.Class>) : UE.EngineSubsystem;
        static GetGameInstanceSubsystem(ContextObject: $Nullable<UE.Object>, Class: $Nullable<UE.Class>) : UE.GameInstanceSubsystem;
        static GetLocalPlayerSubsystem(ContextObject: $Nullable<UE.Object>, Class: $Nullable<UE.Class>) : UE.LocalPlayerSubsystem;
        static GetLocalPlayerSubSystemFromPlayerController(PlayerController: $Nullable<UE.PlayerController>, Class: $Nullable<UE.Class>) : UE.LocalPlayerSubsystem;
        static GetWorldSubsystem(ContextObject: $Nullable<UE.Object>, Class: $Nullable<UE.Class>) : UE.WorldSubsystem;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubsystemBlueprintLibrary;
        static Load(InName: string): SubsystemBlueprintLibrary;
    }
    
    class SubUVAnimationFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialTexture: UE.Texture2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubUVAnimationFactory;
        static Load(InName: string): SubUVAnimationFactory;
    }
    
    class SwapSoundForDialogueInCuesCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SwapSoundForDialogueInCuesCommandlet;
        static Load(InName: string): SwapSoundForDialogueInCuesCommandlet;
    }
    
    class SwitchActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SceneComponent: UE.SceneComponent;
        GetOptions() : TArray<UE.Actor>;
        GetSelectedOption() : number;
        SelectOption(OptionIndex: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SwitchActor;
        static Load(InName: string): SwitchActor;
    }
    
    class SystemTimeTimecodeProvider extends UE.TimecodeProvider {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FrameRate: UE.FrameRate;
        SetFrameRate(InFrameRate: UE.FrameRate) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SystemTimeTimecodeProvider;
        static Load(InName: string): SystemTimeTimecodeProvider;
    }
    
    class TargetPoint extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpriteComponent: UE.BillboardComponent;
        ArrowComponent: UE.ArrowComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TargetPoint;
        static Load(InName: string): TargetPoint;
    }
    
    class TcpMessagingSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EnableTransport: boolean;
        ListenEndpoint: string;
        ConnectToEndpoints: TArray<string>;
        ConnectionRetryDelay: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TcpMessagingSettings;
        static Load(InName: string): TcpMessagingSettings;
    }
    
    class TemplateBindingGenerator extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Gen() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TemplateBindingGenerator;
        static Load(InName: string): TemplateBindingGenerator;
    }
    
    class TemplateCategoryDef {
        constructor();
        constructor(Key: string, LocalizedDisplayNames: TArray<UE.LocalizedTemplateString>, LocalizedDescriptions: TArray<UE.LocalizedTemplateString>, Icon: string, IsMajorCategory: boolean);
        Key: string;
        LocalizedDisplayNames: TArray<UE.LocalizedTemplateString>;
        LocalizedDescriptions: TArray<UE.LocalizedTemplateString>;
        Icon: string;
        IsMajorCategory: boolean;
        static StaticClass(): Class;
    }
    
    class TemplateCategories extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Categories: TArray<UE.TemplateCategoryDef>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TemplateCategories;
        static Load(InName: string): TemplateCategories;
    }
    
    class TemplateMapMetadata extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TemplateMapMetadata;
        static Load(InName: string): TemplateMapMetadata;
    }
    
    class TerrainSplineActorFactory extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TerrainSplineActorFactory;
        static Load(InName: string): TerrainSplineActorFactory;
    }
    
    class TestBaseCls extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Event1() : void;
        OnEvent1() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBaseCls;
        static Load(InName: string): TestBaseCls;
    }
    
    class TestBeaconClient extends UE.OnlineBeaconClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ClientPing() : void;
        ServerPong() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBeaconClient;
        static Load(InName: string): TestBeaconClient;
    }
    
    class TestBeaconHost extends UE.OnlineBeaconHostObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBeaconHost;
        static Load(InName: string): TestBeaconHost;
    }
    
    namespace Game.StarterContent.TestStruct {
        class TestStruct {
            constructor();
            constructor(speed: number, age: number);
            speed: number;
            age: number;
            static StaticClass(): Class;
        }
        
    }

    namespace Game.StarterContent.TestBlueprint {
        class TestBlueprint_C extends UE.Actor {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            UberGraphFrame: UE.PointerToUberGraphFrame;
            DefaultSceneRoot: UE.SceneComponent;
            B1: boolean;
            I1: number;
            I2: number;
            Bar(NewParam: UE.Game.StarterContent.TestStruct.TestStruct) : void;
            ExecuteUbergraph_TestBlueprint(EntryPoint: number) : void;
            Foo(P1: boolean, P2: number, P3: number) : void;
            ReceiveBeginPlay() : void;
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): TestBlueprint_C;
            static Load(InName: string): TestBlueprint_C;
        }
        
    }

    class TestBTDecorator_CantExecute extends UE.BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBTDecorator_CantExecute;
        static Load(InName: string): TestBTDecorator_CantExecute;
    }
    
    class TestBTDecorator_DelayedAbort extends UE.BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DelayTicks: number;
        bOnlyOnce: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBTDecorator_DelayedAbort;
        static Load(InName: string): TestBTDecorator_DelayedAbort;
    }
    
    class TestBTService_Log extends UE.BTService {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LogActivation: number;
        LogDeactivation: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBTService_Log;
        static Load(InName: string): TestBTService_Log;
    }
    
    class TestBTTask_LatentWithFlags extends UE.BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LogIndexExecuteStart: number;
        LogIndexExecuteFinish: number;
        LogIndexAbortStart: number;
        LogIndexAbortFinish: number;
        ExecuteTicks: number;
        AbortTicks: number;
        KeyNameExecute: string;
        KeyNameAbort: string;
        LogResult: UE.EBTNodeResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBTTask_LatentWithFlags;
        static Load(InName: string): TestBTTask_LatentWithFlags;
    }
    
    class TestBTTask_Log extends UE.BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LogIndex: number;
        LogFinished: number;
        ExecutionTicks: number;
        LogResult: UE.EBTNodeResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBTTask_Log;
        static Load(InName: string): TestBTTask_Log;
    }
    
    class TestBTTask_SetFlag extends UE.BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        KeyName: string;
        bValue: boolean;
        TaskResult: UE.EBTNodeResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBTTask_SetFlag;
        static Load(InName: string): TestBTTask_SetFlag;
    }
    
    class TestBTTask_SetValue extends UE.BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        KeyName: string;
        Value: number;
        TaskResult: UE.EBTNodeResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBTTask_SetValue;
        static Load(InName: string): TestBTTask_SetValue;
    }
    
    class TestMovieSceneSection extends UE.MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestMovieSceneSection;
        static Load(InName: string): TestMovieSceneSection;
    }
    
    class TestMovieSceneSequence extends UE.MovieSceneSequence {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MovieScene: UE.MovieScene;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestMovieSceneSequence;
        static Load(InName: string): TestMovieSceneSequence;
    }
    
    class TestMovieSceneTrack extends UE.MovieSceneTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bHighPassFilter: boolean;
        SectionArray: TArray<UE.MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestMovieSceneTrack;
        static Load(InName: string): TestMovieSceneTrack;
    }
    
    class TestPawnAction_Log extends UE.PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestPawnAction_Log;
        static Load(InName: string): TestPawnAction_Log;
    }
    
    class TestPawnAction_CallFunction extends UE.TestPawnAction_Log {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestPawnAction_CallFunction;
        static Load(InName: string): TestPawnAction_CallFunction;
    }
    
    class TestPhaseComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestPhaseComponent;
        static Load(InName: string): TestPhaseComponent;
    }
    
    namespace Game.StarterContent.TestWidgetBlueprint {
        class TestWidgetBlueprint_C extends UE.UserWidget {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            Button1: UE.Button;
            TextBox: UE.MultiLineEditableTextBox;
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): TestWidgetBlueprint_C;
            static Load(InName: string): TestWidgetBlueprint_C;
        }
        
    }

    class TetrahedronBuilder extends UE.EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Radius: number;
        SphereExtrapolation: number;
        GroupName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TetrahedronBuilder;
        static Load(InName: string): TetrahedronBuilder;
    }
    
    enum ETexAlign { TEXALIGN_None, TEXALIGN_Default, TEXALIGN_Box, TEXALIGN_Planar, TEXALIGN_Fit, TEXALIGN_PlanarAuto, TEXALIGN_PlanarWall, TEXALIGN_PlanarFloor, TEXALIGN_MAX}
    class TexAligner extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefTexAlign: UE.ETexAlign;
        TAxis: number;
        UTile: number;
        VTile: number;
        Desc: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TexAligner;
        static Load(InName: string): TexAligner;
    }
    
    class TexAlignerBox extends UE.TexAligner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TexAlignerBox;
        static Load(InName: string): TexAlignerBox;
    }
    
    class TexAlignerDefault extends UE.TexAligner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TexAlignerDefault;
        static Load(InName: string): TexAlignerDefault;
    }
    
    class TexAlignerFit extends UE.TexAligner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TexAlignerFit;
        static Load(InName: string): TexAlignerFit;
    }
    
    class TexAlignerPlanar extends UE.TexAligner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TexAlignerPlanar;
        static Load(InName: string): TexAlignerPlanar;
    }
    
    class TextAssetCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextAssetCommandlet;
        static Load(InName: string): TextAssetCommandlet;
    }
    
    class TextBinding extends UE.PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetStringValue() : string;
        GetTextValue() : string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextBinding;
        static Load(InName: string): TextBinding;
    }
    
    class TextBlock extends UE.TextLayoutWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Text: string;
        TextDelegate: $Delegate<() => string>;
        ColorAndOpacity: UE.SlateColor;
        ColorAndOpacityDelegate: $Delegate<() => UE.SlateColor>;
        Font: UE.SlateFontInfo;
        StrikeBrush: UE.SlateBrush;
        ShadowOffset: UE.Vector2D;
        ShadowColorAndOpacity: UE.LinearColor;
        ShadowColorAndOpacityDelegate: $Delegate<() => UE.LinearColor>;
        MinDesiredWidth: number;
        bWrapWithInvalidationPanel: boolean;
        bAutoWrapText: boolean;
        bSimpleTextMode: boolean;
        GetDynamicFontMaterial() : UE.MaterialInstanceDynamic;
        GetDynamicOutlineMaterial() : UE.MaterialInstanceDynamic;
        GetText() : string;
        SetAutoWrapText(InAutoTextWrap: boolean) : void;
        SetColorAndOpacity(InColorAndOpacity: UE.SlateColor) : void;
        SetFont(InFontInfo: UE.SlateFontInfo) : void;
        SetMinDesiredWidth(InMinDesiredWidth: number) : void;
        SetOpacity(InOpacity: number) : void;
        SetShadowColorAndOpacity(InShadowColorAndOpacity: UE.LinearColor) : void;
        SetShadowOffset(InShadowOffset: UE.Vector2D) : void;
        SetStrikeBrush(InStrikeBrush: UE.SlateBrush) : void;
        SetText(InText: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextBlock;
        static Load(InName: string): TextBlock;
    }
    
    class TextBlockWidgetStyle extends UE.SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TextBlockStyle: UE.TextBlockStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextBlockWidgetStyle;
        static Load(InName: string): TextBlockWidgetStyle;
    }
    
    class TextBuffer extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextBuffer;
        static Load(InName: string): TextBuffer;
    }
    
    class TextBufferExporterTXT extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextBufferExporterTXT;
        static Load(InName: string): TextBufferExporterTXT;
    }
    
    class TextProperty extends UE.Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextProperty;
        static Load(InName: string): TextProperty;
    }
    
    class TextPropertyTestObject extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultedText: string;
        UndefaultedText: string;
        TransientText: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextPropertyTestObject;
        static Load(InName: string): TextPropertyTestObject;
    }
    
    class TextRenderActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TextRender: UE.TextRenderComponent;
        SpriteComponent: UE.BillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextRenderActor;
        static Load(InName: string): TextRenderActor;
    }
    
    class Texture2DArray extends UE.Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddressX: UE.TextureAddress;
        AddressY: UE.TextureAddress;
        AddressZ: UE.TextureAddress;
        SourceTextures: TArray<UE.Texture2D>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Texture2DArray;
        static Load(InName: string): Texture2DArray;
    }
    
    class Texture2DArrayFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialTextures: TArray<UE.Texture2D>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Texture2DArrayFactory;
        static Load(InName: string): Texture2DArrayFactory;
    }
    
    class Texture2DArrayThumbnailRenderer extends UE.TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Texture2DArrayThumbnailRenderer;
        static Load(InName: string): Texture2DArrayThumbnailRenderer;
    }
    
    class Texture2DFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Width: number;
        Height: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Texture2DFactoryNew;
        static Load(InName: string): Texture2DFactoryNew;
    }
    
    class TextureCubeExporterHDR extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureCubeExporterHDR;
        static Load(InName: string): TextureCubeExporterHDR;
    }
    
    class TextureCubeThumbnailRenderer extends UE.TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureCubeThumbnailRenderer;
        static Load(InName: string): TextureCubeThumbnailRenderer;
    }
    
    class TextureExporterBMP extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureExporterBMP;
        static Load(InName: string): TextureExporterBMP;
    }
    
    class TextureExporterHDR extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureExporterHDR;
        static Load(InName: string): TextureExporterHDR;
    }
    
    class TextureExporterPCX extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureExporterPCX;
        static Load(InName: string): TextureExporterPCX;
    }
    
    class TextureExporterTGA extends UE.Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureExporterTGA;
        static Load(InName: string): TextureExporterTGA;
    }
    
    class TextureImage extends UE.Image {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bMatchSize: boolean;
        TextureName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureImage;
        static Load(InName: string): TextureImage;
    }
    
    class TextureImportSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AutoVTSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureImportSettings;
        static Load(InName: string): TextureImportSettings;
    }
    
    class TextureRenderTargetCubeFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Width: number;
        Format: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureRenderTargetCubeFactoryNew;
        static Load(InName: string): TextureRenderTargetCubeFactoryNew;
    }
    
    class TextureRenderTargetFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Width: number;
        Height: number;
        Format: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureRenderTargetFactoryNew;
        static Load(InName: string): TextureRenderTargetFactoryNew;
    }
    
    class TextureStats extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Texture: TWeakObjectPtr<UE.Texture>;
        Actors: TArray<TWeakObjectPtr<UE.Actor>>;
        Type: string;
        MaxDim: UE.Vector2D;
        CurrentDim: UE.Vector2D;
        Format: UE.EPixelFormat;
        Group: UE.TextureGroup;
        LODBias: number;
        CurrentKB: number;
        FullyLoadedKB: number;
        NumUses: number;
        LastTimeRendered: number;
        Path: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureStats;
        static Load(InName: string): TextureStats;
    }
    
    class TGUnitTestCallee extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IntArgIntRet(Arg: number) : number;
        NoArgNoRet() : void;
        RetInt() : number;
        StrArgIntRet(Str: string) : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TGUnitTestCallee;
        static Load(InName: string): TGUnitTestCallee;
    }
    
    class Throbber extends UE.Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumberOfPieces: number;
        bAnimateHorizontally: boolean;
        bAnimateVertically: boolean;
        bAnimateOpacity: boolean;
        PieceImage: UE.SlateBrushAsset;
        Image: UE.SlateBrush;
        SetAnimateHorizontally(bInAnimateHorizontally: boolean) : void;
        SetAnimateOpacity(bInAnimateOpacity: boolean) : void;
        SetAnimateVertically(bInAnimateVertically: boolean) : void;
        SetNumberOfPieces(InNumberOfPieces: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Throbber;
        static Load(InName: string): Throbber;
    }
    
    class ThumbnailRenderingInfo {
        constructor();
        constructor(ClassNeedingThumbnailName: string, ClassNeedingThumbnail: UE.Class, RendererClassName: string, Renderer: UE.ThumbnailRenderer);
        ClassNeedingThumbnailName: string;
        ClassNeedingThumbnail: UE.Class;
        RendererClassName: string;
        Renderer: UE.ThumbnailRenderer;
        static StaticClass(): Class;
    }
    
    class ThumbnailManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenderableThumbnailTypes: TArray<UE.ThumbnailRenderingInfo>;
        NotSupported: UE.ThumbnailRenderingInfo;
        EditorCube: UE.StaticMesh;
        EditorSphere: UE.StaticMesh;
        EditorCylinder: UE.StaticMesh;
        EditorPlane: UE.StaticMesh;
        EditorSkySphere: UE.StaticMesh;
        FloorPlaneMaterial: UE.Material;
        AmbientCubemap: UE.TextureCube;
        CheckerboardTexture: UE.Texture2D;
        ThumbnailManagerClassName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ThumbnailManager;
        static Load(InName: string): ThumbnailManager;
    }
    
    namespace Game.Blueprints.TypeScript.Tiger {
        class Tiger_C extends UE.Game.Blueprints.TypeScript.Animal.Animal_C {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            UberGraphFrame: UE.PointerToUberGraphFrame;
            Speed: number;
            ExecuteUbergraph_Tiger(EntryPoint: number) : void;
            ReceiveBeginPlay() : void;
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): Tiger_C;
            static Load(InName: string): Tiger_C;
        }
        
    }

    class TileMapActorFactory extends UE.ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TileMapActorFactory;
        static Load(InName: string): TileMapActorFactory;
    }
    
    class TileSetImportMapping {
        constructor();
        constructor(SourceName: string, ImportedTileSet: TWeakObjectPtr<UE.PaperTileSet>, ImportedTexture: TWeakObjectPtr<UE.Texture>);
        SourceName: string;
        ImportedTileSet: TWeakObjectPtr<UE.PaperTileSet>;
        ImportedTexture: TWeakObjectPtr<UE.Texture>;
        static StaticClass(): Class;
    }
    
    class TileMapAssetImportData extends UE.AssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TileSetMap: TArray<UE.TileSetImportMapping>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TileMapAssetImportData;
        static Load(InName: string): TileMapAssetImportData;
    }
    
    class TileMapBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static BreakTile(Tile: UE.PaperTileInfo, TileIndex: $Ref<number>, TileSet: $Ref<UE.PaperTileSet>, bFlipH: $Ref<boolean>, bFlipV: $Ref<boolean>, bFlipD: $Ref<boolean>) : void;
        static GetTileTransform(Tile: UE.PaperTileInfo) : UE.Transform;
        static GetTileUserData(Tile: UE.PaperTileInfo) : string;
        static MakeTile(TileIndex: number, TileSet: $Nullable<UE.PaperTileSet>, bFlipH: boolean, bFlipV: boolean, bFlipD: boolean) : UE.PaperTileInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TileMapBlueprintLibrary;
        static Load(InName: string): TileMapBlueprintLibrary;
    }
    
    class TileMapEditorSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultBackgroundColor: UE.Color;
        bShowGridByDefault: boolean;
        DefaultTileGridColor: UE.Color;
        DefaultMultiTileGridColor: UE.Color;
        DefaultMultiTileGridWidth: number;
        DefaultMultiTileGridHeight: number;
        DefaultMultiTileGridOffsetX: number;
        DefaultMultiTileGridOffsetY: number;
        DefaultLayerGridColor: UE.Color;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TileMapEditorSettings;
        static Load(InName: string): TileMapEditorSettings;
    }
    
    class TileSetEditorSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultBackgroundColor: UE.Color;
        bShowGridByDefault: boolean;
        ExtrusionAmount: number;
        bPadToPowerOf2: boolean;
        bFillWithTransparentBlack: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TileSetEditorSettings;
        static Load(InName: string): TileSetEditorSettings;
    }
    
    class TileSheetPaddingFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceTileSet: UE.PaperTileSet;
        ExtrusionAmount: number;
        bPadToPowerOf2: boolean;
        bFillWithTransparentBlack: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TileSheetPaddingFactory;
        static Load(InName: string): TileSheetPaddingFactory;
    }
    
    enum EListItemAlignment { EvenlyDistributed, EvenlySize, EvenlyWide, LeftAligned, RightAligned, CenterAligned, Fill, EListItemAlignment_MAX}
    class TileView extends UE.ListView {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EntryHeight: number;
        EntryWidth: number;
        TileAlignment: UE.EListItemAlignment;
        bWrapHorizontalNavigation: boolean;
        SetEntryHeight(NewHeight: number) : void;
        SetEntryWidth(NewWidth: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TileView;
        static Load(InName: string): TileView;
    }
    
    class TimelineEventEntry {
        constructor();
        constructor(Time: number, EventFunc: $Delegate<() => void>);
        Time: number;
        EventFunc: $Delegate<() => void>;
        static StaticClass(): Class;
    }
    
    class TimelineVectorTrack {
        constructor();
        constructor(VectorCurve: UE.CurveVector, InterpFunc: $Delegate<(Output: UE.Vector) => void>, TrackName: string, VectorPropertyName: string, VectorProperty: UE.StructProperty);
        VectorCurve: UE.CurveVector;
        InterpFunc: $Delegate<(Output: UE.Vector) => void>;
        TrackName: string;
        VectorPropertyName: string;
        VectorProperty: UE.StructProperty;
        static StaticClass(): Class;
    }
    
    class TimelineFloatTrack {
        constructor();
        constructor(FloatCurve: UE.CurveFloat, InterpFunc: $Delegate<(Output: number) => void>, TrackName: string, FloatPropertyName: string, FloatProperty: UE.FloatProperty);
        FloatCurve: UE.CurveFloat;
        InterpFunc: $Delegate<(Output: number) => void>;
        TrackName: string;
        FloatPropertyName: string;
        FloatProperty: UE.FloatProperty;
        static StaticClass(): Class;
    }
    
    class TimelineLinearColorTrack {
        constructor();
        constructor(LinearColorCurve: UE.CurveLinearColor, InterpFunc: $Delegate<(Output: UE.LinearColor) => void>, TrackName: string, LinearColorPropertyName: string, LinearColorProperty: UE.StructProperty);
        LinearColorCurve: UE.CurveLinearColor;
        InterpFunc: $Delegate<(Output: UE.LinearColor) => void>;
        TrackName: string;
        LinearColorPropertyName: string;
        LinearColorProperty: UE.StructProperty;
        static StaticClass(): Class;
    }
    
    class Timeline {
        constructor();
        constructor(LengthMode: UE.ETimelineLengthMode, bLooping: boolean, bReversePlayback: boolean, bPlaying: boolean, Length: number, PlayRate: number, Position: number, Events: TArray<UE.TimelineEventEntry>, InterpVectors: TArray<UE.TimelineVectorTrack>, InterpFloats: TArray<UE.TimelineFloatTrack>, InterpLinearColors: TArray<UE.TimelineLinearColorTrack>, TimelinePostUpdateFunc: $Delegate<() => void>, TimelineFinishedFunc: $Delegate<() => void>, PropertySetObject: TWeakObjectPtr<UE.Object>, DirectionPropertyName: string, DirectionProperty: UE.Property);
        LengthMode: UE.ETimelineLengthMode;
        bLooping: boolean;
        bReversePlayback: boolean;
        bPlaying: boolean;
        Length: number;
        PlayRate: number;
        Position: number;
        Events: TArray<UE.TimelineEventEntry>;
        InterpVectors: TArray<UE.TimelineVectorTrack>;
        InterpFloats: TArray<UE.TimelineFloatTrack>;
        InterpLinearColors: TArray<UE.TimelineLinearColorTrack>;
        TimelinePostUpdateFunc: $Delegate<() => void>;
        TimelineFinishedFunc: $Delegate<() => void>;
        PropertySetObject: TWeakObjectPtr<UE.Object>;
        DirectionPropertyName: string;
        DirectionProperty: UE.Property;
        static StaticClass(): Class;
    }
    
    class TimelineComponent extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TheTimeline: UE.Timeline;
        bIgnoreTimeDilation: boolean;
        GetIgnoreTimeDilation() : boolean;
        GetPlaybackPosition() : number;
        GetPlayRate() : number;
        GetTimelineLength() : number;
        IsLooping() : boolean;
        IsPlaying() : boolean;
        IsReversing() : boolean;
        OnRep_Timeline() : void;
        Play() : void;
        PlayFromStart() : void;
        Reverse() : void;
        ReverseFromEnd() : void;
        SetFloatCurve(NewFloatCurve: $Nullable<UE.CurveFloat>, FloatTrackName: string) : void;
        SetIgnoreTimeDilation(bNewIgnoreTimeDilation: boolean) : void;
        SetLinearColorCurve(NewLinearColorCurve: $Nullable<UE.CurveLinearColor>, LinearColorTrackName: string) : void;
        SetLooping(bNewLooping: boolean) : void;
        SetNewTime(NewTime: number) : void;
        SetPlaybackPosition(NewPosition: number, bFireEvents: boolean, bFireUpdate?: boolean /* = true */) : void;
        SetPlayRate(NewRate: number) : void;
        SetTimelineLength(NewLength: number) : void;
        SetTimelineLengthMode(NewLengthMode: UE.ETimelineLengthMode) : void;
        SetVectorCurve(NewVectorCurve: $Nullable<UE.CurveVector>, VectorTrackName: string) : void;
        Stop() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TimelineComponent;
        static Load(InName: string): TimelineComponent;
    }
    
    class TimeManagementBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static Add_FrameNumberFrameNumber(A: UE.FrameNumber, B: UE.FrameNumber) : UE.FrameNumber;
        static Add_FrameNumberInteger(A: UE.FrameNumber, B: number) : UE.FrameNumber;
        static Conv_FrameNumberToInteger(InFrameNumber: UE.FrameNumber) : number;
        static Conv_FrameRateToSeconds(InFrameRate: UE.FrameRate) : number;
        static Conv_QualifiedFrameTimeToSeconds(InFrameTime: UE.QualifiedFrameTime) : number;
        static Conv_TimecodeToString(InTimecode: UE.Timecode, bForceSignDisplay?: boolean /* = false */) : string;
        static Divide_FrameNumberInteger(A: UE.FrameNumber, B: number) : UE.FrameNumber;
        static GetTimecode() : UE.Timecode;
        static GetTimecodeFrameRate() : UE.FrameRate;
        static IsValid_Framerate(InFrameRate: UE.FrameRate) : boolean;
        static IsValid_MultipleOf(InFrameRate: UE.FrameRate, OtherFramerate: UE.FrameRate) : boolean;
        static Multiply_FrameNumberInteger(A: UE.FrameNumber, B: number) : UE.FrameNumber;
        static Multiply_SecondsFrameRate(TimeInSeconds: number, FrameRate: UE.FrameRate) : UE.FrameTime;
        static SnapFrameTimeToRate(SourceTime: UE.FrameTime, SourceRate: UE.FrameRate, SnapToRate: UE.FrameRate) : UE.FrameTime;
        static Subtract_FrameNumberFrameNumber(A: UE.FrameNumber, B: UE.FrameNumber) : UE.FrameNumber;
        static Subtract_FrameNumberInteger(A: UE.FrameNumber, B: number) : UE.FrameNumber;
        static TransformTime(SourceTime: UE.FrameTime, SourceRate: UE.FrameRate, DestinationRate: UE.FrameRate) : UE.FrameTime;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TimeManagementBlueprintLibrary;
        static Load(InName: string): TimeManagementBlueprintLibrary;
    }
    
    class TimeSynchronizableMediaSource extends UE.BaseMediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseTimeSynchronization: boolean;
        FrameDelay: number;
        TimeDelay: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TimeSynchronizableMediaSource;
        static Load(InName: string): TimeSynchronizableMediaSource;
    }
    
    class TimeSynchronizationSource extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseForSynchronization: boolean;
        FrameOffset: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TimeSynchronizationSource;
        static Load(InName: string): TimeSynchronizationSource;
    }
    
    class ToFloatField extends UE.FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IntField: UE.FieldNodeInt;
        SetToFloatField(IntegerField: $Nullable<UE.FieldNodeInt>) : UE.ToFloatField;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToFloatField;
        static Load(InName: string): ToFloatField;
    }
    
    class ToIntegerField extends UE.FieldNodeInt {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FloatField: UE.FieldNodeFloat;
        SetToIntegerField(FloatField: $Nullable<UE.FieldNodeFloat>) : UE.ToIntegerField;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToIntegerField;
        static Load(InName: string): ToIntegerField;
    }
    
    class ToolFrameworkComponent extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolFrameworkComponent;
        static Load(InName: string): ToolFrameworkComponent;
    }
    
    class ToolMenuBase extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenuBase;
        static Load(InName: string): ToolMenuBase;
    }
    
    enum EMultiBoxType { MenuBar, ToolBar, VerticalToolBar, Menu, ButtonRow, ToolMenuBar, EMultiBoxType_MAX}
    class ToolMenuOwner {
        constructor();
        static StaticClass(): Class;
    }
    
    class ToolMenuContext {
        constructor();
        constructor(ContextObjects: TArray<UE.Object>);
        ContextObjects: TArray<UE.Object>;
        static StaticClass(): Class;
    }
    
    enum EMultiBlockType { None, ButtonRow, EditableText, Heading, MenuEntry, MenuSeparator, ToolBarButton, ToolBarComboButton, ToolBarSeparator, Widget, EMultiBlockType_MAX}
    enum EUserInterfaceActionType { None, Button, ToggleButton, RadioButton, Check, CollapsedButton, EUserInterfaceActionType_MAX}
    enum EToolMenuInsertType { Default, Before, After, First, EToolMenuInsertType_MAX}
    class ToolMenuInsert {
        constructor();
        constructor(Name: string, Position: UE.EToolMenuInsertType);
        Name: string;
        Position: UE.EToolMenuInsertType;
        static StaticClass(): Class;
    }
    
    class ScriptSlateIcon {
        constructor();
        constructor(StyleSetName: string, StyleName: string, SmallStyleName: string);
        StyleSetName: string;
        StyleName: string;
        SmallStyleName: string;
        static StaticClass(): Class;
    }
    
    class ToolMenuEntryScriptDataAdvanced {
        constructor();
        constructor(TutorialHighlight: string, EntryType: UE.EMultiBlockType, UserInterfaceActionType: UE.EUserInterfaceActionType, bIsSubMenu: boolean, bOpenSubMenuOnClick: boolean, bShouldCloseWindowAfterMenuSelection: boolean, bSimpleComboBox: boolean);
        TutorialHighlight: string;
        EntryType: UE.EMultiBlockType;
        UserInterfaceActionType: UE.EUserInterfaceActionType;
        bIsSubMenu: boolean;
        bOpenSubMenuOnClick: boolean;
        bShouldCloseWindowAfterMenuSelection: boolean;
        bSimpleComboBox: boolean;
        static StaticClass(): Class;
    }
    
    class ToolMenuEntryScriptData {
        constructor();
        constructor(Menu: string, Section: string, Name: string, Label: string, ToolTip: string, Icon: UE.ScriptSlateIcon, OwnerName: string, InsertPosition: UE.ToolMenuInsert, Advanced: UE.ToolMenuEntryScriptDataAdvanced);
        Menu: string;
        Section: string;
        Name: string;
        Label: string;
        ToolTip: string;
        Icon: UE.ScriptSlateIcon;
        OwnerName: string;
        InsertPosition: UE.ToolMenuInsert;
        Advanced: UE.ToolMenuEntryScriptDataAdvanced;
        static StaticClass(): Class;
    }
    
    class ToolMenuEntryScript extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Data: UE.ToolMenuEntryScriptData;
        CanExecute(Context: UE.ToolMenuContext) : boolean;
        ConstructMenuEntry(Menu: $Nullable<UE.ToolMenu>, SectionName: string, Context: UE.ToolMenuContext) : void;
        Execute(Context: UE.ToolMenuContext) : void;
        GetCheckState(Context: UE.ToolMenuContext) : UE.ECheckBoxState;
        GetIcon(Context: UE.ToolMenuContext) : UE.ScriptSlateIcon;
        GetLabel(Context: UE.ToolMenuContext) : string;
        GetToolTip(Context: UE.ToolMenuContext) : string;
        InitEntry(OwnerName: string, Menu: string, Section: string, Name: string, Label?: string /* = "" */, ToolTip?: string /* = "" */) : void;
        IsVisible(Context: UE.ToolMenuContext) : boolean;
        RegisterMenuEntry() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenuEntryScript;
        static Load(InName: string): ToolMenuEntryScript;
    }
    
    class ToolMenuEntry {
        constructor();
        constructor(Name: string, Owner: UE.ToolMenuOwner, Type: UE.EMultiBlockType, UserInterfaceActionType: UE.EUserInterfaceActionType, TutorialHighlightName: string, InsertPosition: UE.ToolMenuInsert, bShouldCloseWindowAfterMenuSelection: boolean, ScriptObject: UE.ToolMenuEntryScript);
        Name: string;
        Owner: UE.ToolMenuOwner;
        Type: UE.EMultiBlockType;
        UserInterfaceActionType: UE.EUserInterfaceActionType;
        TutorialHighlightName: string;
        InsertPosition: UE.ToolMenuInsert;
        bShouldCloseWindowAfterMenuSelection: boolean;
        ScriptObject: UE.ToolMenuEntryScript;
        static StaticClass(): Class;
    }
    
    class ToolMenuSectionDynamic extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstructSections(Menu: $Nullable<UE.ToolMenu>, Context: UE.ToolMenuContext) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenuSectionDynamic;
        static Load(InName: string): ToolMenuSectionDynamic;
    }
    
    class ToolMenuSection {
        constructor();
        constructor(Name: string, Blocks: TArray<UE.ToolMenuEntry>, InsertPosition: UE.ToolMenuInsert, Context: UE.ToolMenuContext, ToolMenuSectionDynamic: UE.ToolMenuSectionDynamic);
        Name: string;
        Blocks: TArray<UE.ToolMenuEntry>;
        InsertPosition: UE.ToolMenuInsert;
        Context: UE.ToolMenuContext;
        ToolMenuSectionDynamic: UE.ToolMenuSectionDynamic;
        static StaticClass(): Class;
    }
    
    class ToolMenu extends UE.ToolMenuBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MenuName: string;
        MenuParent: string;
        StyleName: string;
        TutorialHighlightName: string;
        MenuType: UE.EMultiBoxType;
        bShouldCloseWindowAfterMenuSelection: boolean;
        bCloseSelfOnly: boolean;
        bSearchable: boolean;
        bToolBarIsFocusable: boolean;
        bToolBarForceSmallIcons: boolean;
        bPreventCustomization: boolean;
        MenuOwner: UE.ToolMenuOwner;
        Context: UE.ToolMenuContext;
        Sections: TArray<UE.ToolMenuSection>;
        SubMenuParent: UE.ToolMenu;
        SubMenuSourceEntryName: string;
        AddDynamicSectionScript(SectionName: string, Object: $Nullable<UE.ToolMenuSectionDynamic>) : void;
        AddMenuEntry(SectionName: string, Args: UE.ToolMenuEntry) : void;
        AddMenuEntryObject(InObject: $Nullable<UE.ToolMenuEntryScript>) : void;
        AddSectionScript(SectionName: string, Label?: string /* = "" */, InsertName?: string /* = "None" */, InsertType?: UE.EToolMenuInsertType /* = Default */) : void;
        AddSubMenuScript(Owner: string, SectionName: string, Name: string, Label: string, ToolTip?: string /* = "" */) : UE.ToolMenu;
        InitMenu(Owner: UE.ToolMenuOwner, Name: string, Parent?: string /* = "None" */, Type?: UE.EMultiBoxType /* = Menu */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenu;
        static Load(InName: string): ToolMenu;
    }
    
    class ToolMenuContextExtensions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static FindByClass(Context: UE.ToolMenuContext, InClass: $Nullable<UE.Class>) : UE.Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenuContextExtensions;
        static Load(InName: string): ToolMenuContextExtensions;
    }
    
    enum EToolMenuStringCommandType { Command, Python, Custom, EToolMenuStringCommandType_MAX}
    class ToolMenuStringCommand {
        constructor();
        constructor(Type: UE.EToolMenuStringCommandType, CustomType: string, String: string);
        Type: UE.EToolMenuStringCommandType;
        CustomType: string;
        String: string;
        static StaticClass(): Class;
    }
    
    class ToolMenuEntryExtensions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static BreakScriptSlateIcon(InValue: UE.ScriptSlateIcon, StyleSetName: $Ref<string>, StyleName: $Ref<string>, SmallStyleName: $Ref<string>) : void;
        static BreakStringCommand(InValue: UE.ToolMenuStringCommand, Type: $Ref<UE.EToolMenuStringCommandType>, CustomType: $Ref<string>, String: $Ref<string>) : void;
        static BreakToolMenuOwner(InValue: UE.ToolMenuOwner, Name: $Ref<string>) : void;
        static GetLabel(Target: UE.ToolMenuEntry) : string;
        static GetToolTip(Target: UE.ToolMenuEntry) : string;
        static InitMenuEntry(InOwner: string, InName: string, InLabel: string, InToolTip: string, CommandType: UE.EToolMenuStringCommandType, CustomCommandType: string, CommandString: string) : UE.ToolMenuEntry;
        static MakeScriptSlateIcon(StyleSetName: string, StyleName: string, SmallStyleName?: string /* = "None" */) : UE.ScriptSlateIcon;
        static MakeStringCommand(Type: UE.EToolMenuStringCommandType, CustomType: string, String: string) : UE.ToolMenuStringCommand;
        static MakeToolMenuOwner(Name: string) : UE.ToolMenuOwner;
        static SetIcon(Target: $Ref<UE.ToolMenuEntry>, StyleSetName: string, StyleName?: string /* = "None" */, SmallStyleName?: string /* = "None" */) : void;
        static SetLabel(Target: $Ref<UE.ToolMenuEntry>, Label: string) : void;
        static SetStringCommand(Target: $Ref<UE.ToolMenuEntry>, Type: UE.EToolMenuStringCommandType, CustomType: string, String: string) : void;
        static SetToolTip(Target: $Ref<UE.ToolMenuEntry>, ToolTip: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenuEntryExtensions;
        static Load(InName: string): ToolMenuEntryExtensions;
    }
    
    enum ECustomizedToolMenuVisibility { None, Visible, Hidden, ECustomizedToolMenuVisibility_MAX}
    class CustomizedToolMenuEntry {
        constructor();
        constructor(Visibility: UE.ECustomizedToolMenuVisibility);
        Visibility: UE.ECustomizedToolMenuVisibility;
        static StaticClass(): Class;
    }
    
    class CustomizedToolMenuSection {
        constructor();
        constructor(Visibility: UE.ECustomizedToolMenuVisibility);
        Visibility: UE.ECustomizedToolMenuVisibility;
        static StaticClass(): Class;
    }
    
    class CustomizedToolMenuNameArray {
        constructor();
        constructor(Names: TArray<string>);
        Names: TArray<string>;
        static StaticClass(): Class;
    }
    
    class CustomizedToolMenu {
        constructor();
        constructor(Name: string, Entries: TMap<string, UE.CustomizedToolMenuEntry>, Sections: TMap<string, UE.CustomizedToolMenuSection>, EntryOrder: TMap<string, UE.CustomizedToolMenuNameArray>, SectionOrder: TArray<string>);
        Name: string;
        Entries: TMap<string, UE.CustomizedToolMenuEntry>;
        Sections: TMap<string, UE.CustomizedToolMenuSection>;
        EntryOrder: TMap<string, UE.CustomizedToolMenuNameArray>;
        SectionOrder: TArray<string>;
        static StaticClass(): Class;
    }
    
    class ToolMenus extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CustomizedMenus: TArray<UE.CustomizedToolMenu>;
        Menus: TMap<string, UE.ToolMenu>;
        ExtendMenu(Name: string) : UE.ToolMenu;
        FindMenu(Name: string) : UE.ToolMenu;
        IsMenuRegistered(Name: string) : boolean;
        RefreshAllWidgets() : void;
        RefreshMenuWidget(Name: string) : boolean;
        RegisterMenu(Name: string, Parent?: string /* = "None" */, Type?: UE.EMultiBoxType /* = Menu */, bWarnIfAlreadyRegistered?: boolean /* = true */) : UE.ToolMenu;
        RemoveEntry(MenuName: string, Section: string, Name: string) : void;
        RemoveMenu(MenuName: string) : void;
        RemoveSection(MenuName: string, Section: string) : void;
        SetSectionLabel(MenuName: string, SectionName: string, Label: string) : void;
        SetSectionPosition(MenuName: string, SectionName: string, OtherSectionName: string, PositionType: UE.EToolMenuInsertType) : void;
        UnregisterOwnerByName(InOwnerName: string) : void;
        static AddMenuEntryObject(MenuEntryObject: $Nullable<UE.ToolMenuEntryScript>) : boolean;
        static FindContext(InContext: UE.ToolMenuContext, InClass: $Nullable<UE.Class>) : UE.Object;
        static Get() : UE.ToolMenus;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenus;
        static Load(InName: string): ToolMenus;
    }
    
    class ToolMenuSectionExtensions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AddEntry(Section: $Ref<UE.ToolMenuSection>, Args: UE.ToolMenuEntry) : void;
        static AddEntryObject(Section: $Ref<UE.ToolMenuSection>, InObject: $Nullable<UE.ToolMenuEntryScript>) : void;
        static GetLabel(Section: UE.ToolMenuSection) : string;
        static SetLabel(Section: $Ref<UE.ToolMenuSection>, Label: string) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenuSectionExtensions;
        static Load(InName: string): ToolMenuSectionExtensions;
    }
    
    class TouchInterfaceFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TouchInterfaceFactory;
        static Load(InName: string): TouchInterfaceFactory;
    }
    
    class TransBuffer extends UE.Transactor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TransBuffer;
        static Load(InName: string): TransBuffer;
    }
    
    class TransformGizmo extends UE.InteractiveGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActiveTarget: UE.TransformProxy;
        ActiveComponents: TArray<UE.PrimitiveComponent>;
        ActiveGizmos: TArray<UE.InteractiveGizmo>;
        AxisXSource: UE.GizmoComponentAxisSource;
        AxisYSource: UE.GizmoComponentAxisSource;
        AxisZSource: UE.GizmoComponentAxisSource;
        StateTarget: UE.GizmoTransformChangeStateTarget;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TransformGizmo;
        static Load(InName: string): TransformGizmo;
    }
    
    class TransformGizmoActor extends UE.GizmoActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TranslateX: UE.PrimitiveComponent;
        TranslateY: UE.PrimitiveComponent;
        TranslateZ: UE.PrimitiveComponent;
        TranslateYZ: UE.PrimitiveComponent;
        TranslateXZ: UE.PrimitiveComponent;
        TranslateXY: UE.PrimitiveComponent;
        RotateX: UE.PrimitiveComponent;
        RotateY: UE.PrimitiveComponent;
        RotateZ: UE.PrimitiveComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TransformGizmoActor;
        static Load(InName: string): TransformGizmoActor;
    }
    
    class TransformGizmoBuilder extends UE.InteractiveGizmoBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TransformGizmoBuilder;
        static Load(InName: string): TransformGizmoBuilder;
    }
    
    class TranslationDragOperation extends UE.ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TranslationDragOperation;
        static Load(InName: string): TranslationDragOperation;
    }
    
    class TranslationPickerSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bSubmitTranslationPickerChangesToLocalizationService: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TranslationPickerSettings;
        static Load(InName: string): TranslationPickerSettings;
    }
    
    class TranslationChange {
        constructor();
        constructor(Version: string, DateAndTime: UE.DateTime, Source: string, Translation: string);
        Version: string;
        DateAndTime: UE.DateTime;
        Source: string;
        Translation: string;
        static StaticClass(): Class;
    }
    
    class TranslationContextInfo {
        constructor();
        constructor(Key: string, Context: string, Changes: TArray<UE.TranslationChange>);
        Key: string;
        Context: string;
        Changes: TArray<UE.TranslationChange>;
        static StaticClass(): Class;
    }
    
    class TranslationUnit extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Namespace: string;
        Key: string;
        Source: string;
        Translation: string;
        Contexts: TArray<UE.TranslationContextInfo>;
        HasBeenReviewed: boolean;
        TranslationBeforeImport: string;
        LocresPath: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TranslationUnit;
        static Load(InName: string): TranslationUnit;
    }
    
    class TreeView extends UE.ListView {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BP_OnGetItemChildren: $Delegate<(Item: $Nullable<UE.Object>, Children: $Ref<TArray<UE.Object>>) => void>;
        BP_OnItemExpansionChanged: $MulticastDelegate<(Item: $Nullable<UE.Object>, bIsExpanded: boolean) => void>;
        CollapseAll() : void;
        ExpandAll() : void;
        SetItemExpansion(Item: $Nullable<UE.Object>, bExpandItem: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TreeView;
        static Load(InName: string): TreeView;
    }
    
    class TriggerBase extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CollisionComponent: UE.ShapeComponent;
        SpriteComponent: UE.BillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TriggerBase;
        static Load(InName: string): TriggerBase;
    }
    
    class TriggerBox extends UE.TriggerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TriggerBox;
        static Load(InName: string): TriggerBox;
    }
    
    class TriggerCapsule extends UE.TriggerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TriggerCapsule;
        static Load(InName: string): TriggerCapsule;
    }
    
    class TriggerSphere extends UE.TriggerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TriggerSphere;
        static Load(InName: string): TriggerSphere;
    }
    
    class TriggerVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TriggerVolume;
        static Load(InName: string): TriggerVolume;
    }
    
    class TrueTypeFontFactory extends UE.TextureFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportOptions: UE.FontImportOptions;
        bPropertiesConfigured: boolean;
        bFontSelected: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TrueTypeFontFactory;
        static Load(InName: string): TrueTypeFontFactory;
    }
    
    class TsGameInstance extends UE.GameInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TsGameInstance;
        static Load(InName: string): TsGameInstance;
    }
    
    namespace Game.Blueprints.TypeScript.TsTestActor {
        class TsTestActor_C extends UE.Actor {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            UberGraphFrame: UE.PointerToUberGraphFrame;
            DefaultSceneRoot: UE.SceneComponent;
            tickCount: number;
            actor: UE.Actor;
            cls: UE.Class;
            b: boolean;
            int64_1: bigint;
            int64_2: bigint;
            str: string;
            v: UE.Vector;
            map: TMap<string, number>;
            arr: TArray<UE.Object>;
            set: TSet<string>;
            fname: string;
            Add(a1: number, b1: number) : number;
            ExecuteUbergraph_TsTestActor(EntryPoint: number) : void;
            GetActor() : UE.Actor;
            GetArray() : TArray<UE.Object>;
            GetMap() : TMap<string, number>;
            ReceiveBeginPlay() : void;
            ReceiveTick(DeltaSeconds: number) : void;
            SetActor(p1: $Nullable<UE.Actor>) : void;
            SetArray(p1: $Ref<TArray<UE.Object>>) : void;
            TestCppType(p11: number, p21: number) : string;
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): TsTestActor_C;
            static Load(InName: string): TsTestActor_C;
        }
        
    }

    namespace Game.Blueprints.TypeScript.TsTestGameInstance {
        class TsTestGameInstance_C extends UE.GameInstance {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            UberGraphFrame: UE.PointerToUberGraphFrame;
            ExecuteUbergraph_TsTestGameInstance(EntryPoint: number) : void;
            ReceiveInit() : void;
            ReceiveShutdown() : void;
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): TsTestGameInstance_C;
            static Load(InName: string): TsTestGameInstance_C;
        }
        
    }

    namespace Game.Blueprints.TypeScript.TsTestGameMode {
        class TsTestGameMode_C extends UE.GameModeBase {
            constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
            UberGraphFrame: UE.PointerToUberGraphFrame;
            DefaultSceneRoot: UE.SceneComponent;
            ExecuteUbergraph_TsTestGameMode(EntryPoint: number) : void;
            ReceiveBeginPlay() : void;
            static StaticClass(): Class;
            static Find(OrigInName: string, Outer?: Object): TsTestGameMode_C;
            static Load(InName: string): TsTestGameMode_C;
        }
        
    }

    class TurnBasedBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetIsMyTurn(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>, MatchID: string, bIsMyTurn: $Ref<boolean>) : void;
        static GetMyPlayerIndex(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>, MatchID: string, PlayerIndex: $Ref<number>) : void;
        static GetPlayerDisplayName(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>, MatchID: string, PlayerIndex: number, PlayerDisplayName: $Ref<string>) : void;
        static RegisterTurnBasedMatchInterfaceObject(WorldContextObject: $Nullable<UE.Object>, PlayerController: $Nullable<UE.PlayerController>, Object: $Nullable<UE.Object>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TurnBasedBlueprintLibrary;
        static Load(InName: string): TurnBasedBlueprintLibrary;
    }
    
    class TutorialSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Categories: TArray<UE.TutorialCategory>;
        StartupTutorial: UE.SoftClassPath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TutorialSettings;
        static Load(InName: string): TutorialSettings;
    }
    
    class TutorialProgress {
        constructor();
        constructor(Tutorial: UE.SoftClassPath, CurrentStage: number, bUserDismissed: boolean);
        Tutorial: UE.SoftClassPath;
        CurrentStage: number;
        bUserDismissed: boolean;
        static StaticClass(): Class;
    }
    
    class TutorialStateSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TutorialsProgress: TArray<UE.TutorialProgress>;
        bDismissedAllTutorials: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TutorialStateSettings;
        static Load(InName: string): TutorialStateSettings;
    }
    
    enum ETwitterRequestMethod { TRM_Get, TRM_Post, TRM_Delete, TRM_MAX}
    class TwitterIntegrationBase extends UE.PlatformInterfaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AuthorizeAccounts() : boolean;
        CanShowTweetUI() : boolean;
        GetAccountName(AccountIndex: number) : string;
        GetNumAccounts() : number;
        Init() : void;
        ShowTweetUI(InitialMessage: string, URL: string, Picture: string) : boolean;
        TwitterRequest(URL: string, ParamKeysAndValues: TArray<string>, RequestMethod: UE.ETwitterRequestMethod, AccountIndex: number) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TwitterIntegrationBase;
        static Load(InName: string): TwitterIntegrationBase;
    }
    
    class TypeScriptBlueprint extends UE.Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TypeScriptBlueprint;
        static Load(InName: string): TypeScriptBlueprint;
    }
    
    class TypeScriptGameInstance extends UE.GameInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartNotify: $Delegate<() => void>;
        ShutdownNotify: $Delegate<() => void>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TypeScriptGameInstance;
        static Load(InName: string): TypeScriptGameInstance;
    }
    
    class TypeScriptGeneratedClass extends UE.BlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HasConstructor: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TypeScriptGeneratedClass;
        static Load(InName: string): TypeScriptGeneratedClass;
    }
    
    class TypeScriptObject extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TypeScriptObject;
        static Load(InName: string): TypeScriptObject;
    }
    
    class UdpMessagingSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EnableTransport: boolean;
        bAutoRepair: boolean;
        UnicastEndpoint: string;
        MulticastEndpoint: string;
        MulticastTimeToLive: number;
        StaticEndpoints: TArray<string>;
        EnableTunnel: boolean;
        TunnelUnicastEndpoint: string;
        TunnelMulticastEndpoint: string;
        RemoteTunnelEndpoints: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UdpMessagingSettings;
        static Load(InName: string): UdpMessagingSettings;
    }
    
    class UInt16Property extends UE.NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UInt16Property;
        static Load(InName: string): UInt16Property;
    }
    
    class UInt32Property extends UE.NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UInt32Property;
        static Load(InName: string): UInt32Property;
    }
    
    class UInt64Property extends UE.NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UInt64Property;
        static Load(InName: string): UInt64Property;
    }
    
    enum EPropertyBindingPermissionLevel { Allow, Prevent, PreventAndWarn, PreventAndError, EPropertyBindingPermissionLevel_MAX}
    class WidgetCompilerOptions {
        constructor();
        constructor(bCookSlowConstructionWidgetTree: boolean, bWidgetSupportsDynamicCreation: boolean, bAllowBlueprintTick: boolean, bAllowBlueprintPaint: boolean, PropertyBindingRule: UE.EPropertyBindingPermissionLevel, Rules: TArray<TSoftClassPtr<UE.WidgetCompilerRule>>);
        bCookSlowConstructionWidgetTree: boolean;
        bWidgetSupportsDynamicCreation: boolean;
        bAllowBlueprintTick: boolean;
        bAllowBlueprintPaint: boolean;
        PropertyBindingRule: UE.EPropertyBindingPermissionLevel;
        Rules: TArray<TSoftClassPtr<UE.WidgetCompilerRule>>;
        static StaticClass(): Class;
    }
    
    class DirectoryWidgetCompilerOptions {
        constructor();
        constructor(Directory: UE.DirectoryPath, IgnoredWidgets: TArray<TSoftObjectPtr<UE.WidgetBlueprint>>, Options: UE.WidgetCompilerOptions);
        Directory: UE.DirectoryPath;
        IgnoredWidgets: TArray<TSoftObjectPtr<UE.WidgetBlueprint>>;
        Options: UE.WidgetCompilerOptions;
        static StaticClass(): Class;
    }
    
    class DebugResolution {
        constructor();
        constructor(Width: number, Height: number, Description: string, Color: UE.LinearColor);
        Width: number;
        Height: number;
        Description: string;
        Color: UE.LinearColor;
        static StaticClass(): Class;
    }
    
    class UMGEditorProjectSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultCompilerOptions: UE.WidgetCompilerOptions;
        DirectoryCompilerOptions: TArray<UE.DirectoryWidgetCompilerOptions>;
        bShowWidgetsFromEngineContent: boolean;
        bShowWidgetsFromDeveloperContent: boolean;
        CategoriesToHide: TArray<string>;
        WidgetClassesToHide: TArray<UE.SoftClassPath>;
        bUseWidgetTemplateSelector: boolean;
        DefaultRootWidget: UE.Class;
        DebugResolutions: TArray<UE.DebugResolution>;
        Version: number;
        bCookSlowConstructionWidgetTree: boolean;
        bWidgetSupportsDynamicCreation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UMGEditorProjectSettings;
        static Load(InName: string): UMGEditorProjectSettings;
    }
    
    class UMGManager extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CreateReactWidget(World: $Nullable<UE.World>) : UE.ReactWidget;
        static CreateWidget(World: $Nullable<UE.World>, Class: $Nullable<UE.Class>) : UE.UserWidget;
        static SynchronizeSlotProperties(Slot: $Nullable<UE.PanelSlot>) : void;
        static SynchronizeWidgetProperties(Widget: $Nullable<UE.Widget>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UMGManager;
        static Load(InName: string): UMGManager;
    }
    
    class UndoHistorySettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bShowTransactionDetails: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UndoHistorySettings;
        static Load(InName: string): UndoHistorySettings;
    }
    
    class UniformGridSlot extends UE.PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        Row: number;
        Column: number;
        SetColumn(InColumn: number) : void;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetRow(InRow: number) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UniformGridSlot;
        static Load(InName: string): UniformGridSlot;
    }
    
    class UniformGridPanel extends UE.PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SlotPadding: UE.Margin;
        MinDesiredSlotWidth: number;
        MinDesiredSlotHeight: number;
        AddChildToUniformGrid(Content: $Nullable<UE.Widget>, InRow?: number /* = 0 */, InColumn?: number /* = 0 */) : UE.UniformGridSlot;
        SetMinDesiredSlotHeight(InMinDesiredSlotHeight: number) : void;
        SetMinDesiredSlotWidth(InMinDesiredSlotWidth: number) : void;
        SetSlotPadding(InSlotPadding: UE.Margin) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UniformGridPanel;
        static Load(InName: string): UniformGridPanel;
    }
    
    class UniformInteger extends UE.FieldNodeInt {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        SetUniformInteger(Magnitude: number) : UE.UniformInteger;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UniformInteger;
        static Load(InName: string): UniformInteger;
    }
    
    class UniformScalar extends UE.FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        SetUniformScalar(Magnitude: number) : UE.UniformScalar;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UniformScalar;
        static Load(InName: string): UniformScalar;
    }
    
    class UniformScaleDragOperation extends UE.ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UniformScaleDragOperation;
        static Load(InName: string): UniformScaleDragOperation;
    }
    
    class UniformVector extends UE.FieldNodeVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        Direction: UE.Vector;
        SetUniformVector(Magnitude: number, Direction: UE.Vector) : UE.UniformVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UniformVector;
        static Load(InName: string): UniformVector;
    }
    
    class UnitTestActorChannel extends UE.ActorChannel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnitTestActorChannel;
        static Load(InName: string): UnitTestActorChannel;
    }
    
    class UnitTestChannel extends UE.Channel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnitTestChannel;
        static Load(InName: string): UnitTestChannel;
    }
    
    class UnitTestCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnitTestCommandlet;
        static Load(InName: string): UnitTestCommandlet;
    }
    
    class UnitTestManager extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCapUnitTestCount: boolean;
        MaxUnitTestCount: number;
        bCapUnitTestMemory: boolean;
        MaxMemoryPercent: number;
        AutoCloseMemoryPercent: number;
        MaxAutoCloseCount: number;
        UnitTestSessionCount: number;
        PendingUnitTests: TArray<UE.Class>;
        ActiveUnitTests: TArray<UE.UnitTest>;
        FinishedUnitTests: TArray<UE.UnitTest>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnitTestManager;
        static Load(InName: string): UnitTestManager;
    }
    
    class UnitTestPackageMap extends UE.PackageMapClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnitTestPackageMap;
        static Load(InName: string): UnitTestPackageMap;
    }
    
    class EditorCommandCategory {
        constructor();
        constructor(Parent: string, Name: string);
        Parent: string;
        Name: string;
        static StaticClass(): Class;
    }
    
    class EditorCommand {
        constructor();
        constructor(Parent: string, CommandName: string, ExecCommand: string, Description: string);
        Parent: string;
        CommandName: string;
        ExecCommand: string;
        Description: string;
        static StaticClass(): Class;
    }
    
    class EditorKeyBinding {
        constructor();
        constructor(bCtrlDown: boolean, bAltDown: boolean, bShiftDown: boolean, Key: UE.Key, CommandName: string);
        bCtrlDown: boolean;
        bAltDown: boolean;
        bShiftDown: boolean;
        Key: UE.Key;
        CommandName: string;
        static StaticClass(): Class;
    }
    
    class UnrealEdKeyBindings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        KeyBindings: TArray<UE.EditorKeyBinding>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnrealEdKeyBindings;
        static Load(InName: string): UnrealEdKeyBindings;
    }
    
    class ClassPickerDefaults {
        constructor();
        constructor(ClassName: string, AssetClass: string);
        ClassName: string;
        AssetClass: string;
        static StaticClass(): Class;
    }
    
    class UnrealEdOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditorCategories: TArray<UE.EditorCommandCategory>;
        EditorCommands: TArray<UE.EditorCommand>;
        EditorKeyBindings: UE.UnrealEdKeyBindings;
        bExpandClassPickerClassList: boolean;
        NewAssetDefaultClasses: TArray<UE.ClassPickerDefaults>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnrealEdOptions;
        static Load(InName: string): UnrealEdOptions;
    }
    
    class TemplateMapInfo {
        constructor();
        constructor(ThumbnailTexture: UE.Texture2D, Map: string);
        ThumbnailTexture: UE.Texture2D;
        Map: string;
        static StaticClass(): Class;
    }
    
    class UnrealEdEngine extends UE.EditorEngine {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditorOptionsInst: UE.UnrealEdOptions;
        AutoReimportManager: UE.AutoReimportManager;
        MaterialCopyPasteBuffer: UE.Material;
        MatineeCopyPasteBuffer: TArray<UE.Object>;
        SoundCueCopyPasteBuffer: UE.SoundCue;
        AnimationCompressionAlgorithms: TArray<UE.AnimCompress>;
        PackagesToBeFullyLoadedAtStartup: TArray<string>;
        CurrentLODParentActor: UE.Actor;
        bNeedWarningForPkgEngineVer: boolean;
        bNeedWarningForWritePermission: boolean;
        SortedSpriteCategories: TArray<string>;
        TemplateMapInfos: TArray<UE.TemplateMapInfo>;
        CookServer: UE.CookOnTheFlyServer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnrealEdEngine;
        static Load(InName: string): UnrealEdEngine;
    }
    
    class UnrealEdTypes extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnrealEdTypes;
        static Load(InName: string): UnrealEdTypes;
    }
    
    class UnrealPakCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnrealPakCommandlet;
        static Load(InName: string): UnrealPakCommandlet;
    }
    
    class UpdateGameProjectCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UpdateGameProjectCommandlet;
        static Load(InName: string): UpdateGameProjectCommandlet;
    }
    
    class CapturedPixelsID {
        constructor();
        constructor(Identifiers: TMap<string, string>);
        Identifiers: TMap<string, string>;
        static StaticClass(): Class;
    }
    
    class CapturedPixels {
        constructor();
        static StaticClass(): Class;
    }
    
    class FrameMetrics {
        constructor();
        constructor(TotalElapsedTime: number, FrameDelta: number, FrameNumber: number, NumDroppedFrames: number);
        TotalElapsedTime: number;
        FrameDelta: number;
        FrameNumber: number;
        NumDroppedFrames: number;
        static StaticClass(): Class;
    }
    
    class UserDefinedCaptureProtocol extends UE.MovieSceneImageCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        World: UE.World;
        GenerateFilename(InFrameMetrics: UE.FrameMetrics) : string;
        GetCurrentFrameMetrics() : UE.FrameMetrics;
        OnBeginFinalize() : void;
        OnCanFinalize() : boolean;
        OnCaptureFrame() : void;
        OnFinalize() : void;
        OnPauseCapture() : void;
        OnPixelsReceived(Pixels: UE.CapturedPixels, ID: UE.CapturedPixelsID, FrameMetrics: UE.FrameMetrics) : void;
        OnPreTick() : void;
        OnSetup() : boolean;
        OnStartCapture() : void;
        OnTick() : void;
        OnWarmUp() : void;
        ResolveBuffer(Buffer: $Nullable<UE.Texture>, BufferID: UE.CapturedPixelsID) : void;
        StartCapturingFinalPixels(StreamID: UE.CapturedPixelsID) : void;
        StopCapturingFinalPixels() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserDefinedCaptureProtocol;
        static Load(InName: string): UserDefinedCaptureProtocol;
    }
    
    class UserDefinedEnum extends UE.Enum {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UniqueNameIndex: number;
        EnumDescription: string;
        DisplayNameMap: TMap<string, string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserDefinedEnum;
        static Load(InName: string): UserDefinedEnum;
    }
    
    class UserDefinedImageCaptureProtocol extends UE.UserDefinedCaptureProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Format: UE.EDesiredImageFormat;
        bEnableCompression: boolean;
        CompressionQuality: number;
        GenerateFilenameForBuffer(Buffer: $Nullable<UE.Texture>, StreamID: UE.CapturedPixelsID) : string;
        GenerateFilenameForCurrentFrame() : string;
        WriteImageToDisk(PixelData: UE.CapturedPixels, StreamID: UE.CapturedPixelsID, FrameMetrics: UE.FrameMetrics, bCopyImageData?: boolean /* = false */) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserDefinedImageCaptureProtocol;
        static Load(InName: string): UserDefinedImageCaptureProtocol;
    }
    
    class StructVariableDescription {
        constructor();
        constructor(VarName: string, VarGuid: UE.Guid, FriendlyName: string, DefaultValue: string, Category: string, SubCategory: string, SubCategoryObject: TSoftObjectPtr<UE.Object>, PinValueType: UE.EdGraphTerminalType, ContainerType: UE.EPinContainerType, bIsArray: boolean, bIsSet: boolean, bIsMap: boolean, bInvalidMember: boolean, bDontEditOnInstance: boolean, bEnableSaveGame: boolean, bEnableMultiLineText: boolean, bEnable3dWidget: boolean, CurrentDefaultValue: string, ToolTip: string);
        VarName: string;
        VarGuid: UE.Guid;
        FriendlyName: string;
        DefaultValue: string;
        Category: string;
        SubCategory: string;
        SubCategoryObject: TSoftObjectPtr<UE.Object>;
        PinValueType: UE.EdGraphTerminalType;
        ContainerType: UE.EPinContainerType;
        bIsArray: boolean;
        bIsSet: boolean;
        bIsMap: boolean;
        bInvalidMember: boolean;
        bDontEditOnInstance: boolean;
        bEnableSaveGame: boolean;
        bEnableMultiLineText: boolean;
        bEnable3dWidget: boolean;
        CurrentDefaultValue: string;
        ToolTip: string;
        static StaticClass(): Class;
    }
    
    class UserDefinedStructEditorData extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UniqueNameId: number;
        VariablesDescriptions: TArray<UE.StructVariableDescription>;
        ToolTip: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserDefinedStructEditorData;
        static Load(InName: string): UserDefinedStructEditorData;
    }
    
    enum ERenderFocusRule { Always, NonPointer, NavigationOnly, Never, ERenderFocusRule_MAX}
    class HardwareCursorReference {
        constructor();
        constructor(CursorPath: string, HotSpot: UE.Vector2D);
        CursorPath: string;
        HotSpot: UE.Vector2D;
        static StaticClass(): Class;
    }
    
    enum EUIScalingRule { ShortestSide, LongestSide, Horizontal, Vertical, Custom, EUIScalingRule_MAX}
    class UserInterfaceSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenderFocusRule: UE.ERenderFocusRule;
        HardwareCursors: TMap<UE.EMouseCursor, UE.HardwareCursorReference>;
        SoftwareCursors: TMap<UE.EMouseCursor, UE.SoftClassPath>;
        DefaultCursor: UE.SoftClassPath;
        TextEditBeamCursor: UE.SoftClassPath;
        CrosshairsCursor: UE.SoftClassPath;
        HandCursor: UE.SoftClassPath;
        GrabHandCursor: UE.SoftClassPath;
        GrabHandClosedCursor: UE.SoftClassPath;
        SlashedCircleCursor: UE.SoftClassPath;
        ApplicationScale: number;
        UIScaleRule: UE.EUIScalingRule;
        CustomScalingRuleClass: UE.SoftClassPath;
        UIScaleCurve: UE.RuntimeFloatCurve;
        bAllowHighDPIInGameMode: boolean;
        bLoadWidgetsOnDedicatedServer: boolean;
        CursorClasses: TArray<UE.Object>;
        CustomScalingRuleClassInstance: UE.Class;
        CustomScalingRule: UE.DPICustomScalingRule;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserInterfaceSettings;
        static Load(InName: string): UserInterfaceSettings;
    }
    
    class UserListEntry extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BP_OnEntryReleased() : void;
        BP_OnItemExpansionChanged(bIsExpanded: boolean) : void;
        BP_OnItemSelectionChanged(bIsSelected: boolean) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserListEntry;
        static Load(InName: string): UserListEntry;
    }
    
    class UserListEntryLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetOwningListView(UserListEntry: UserListEntry) : UE.ListViewBase;
        static IsListItemExpanded(UserListEntry: UserListEntry) : boolean;
        static IsListItemSelected(UserListEntry: UserListEntry) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserListEntryLibrary;
        static Load(InName: string): UserListEntryLibrary;
    }
    
    class UserObjectListEntry extends UE.UserListEntry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnListItemObjectSet(ListItemObject: $Nullable<UE.Object>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserObjectListEntry;
        static Load(InName: string): UserObjectListEntry;
    }
    
    class UserObjectListEntryLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetListItemObject(UserObjectListEntry: UserObjectListEntry) : UE.Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserObjectListEntryLibrary;
        static Load(InName: string): UserObjectListEntryLibrary;
    }
    
    class UTT61_DebugReplicateData extends UE.ClientUnitTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UTT61_DebugReplicateData;
        static Load(InName: string): UTT61_DebugReplicateData;
    }
    
    class VariantManagerFactoryNew extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VariantManagerFactoryNew;
        static Load(InName: string): VariantManagerFactoryNew;
    }
    
    enum EVariantManagerTestEnum { None, FirstOption, SecondOption, ThirdOption, EVariantManagerTestEnum_MAX}
    class VariantManagerTestActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EnumWithNoDefault: UE.EVariantManagerTestEnum;
        EnumWithSecondDefault: UE.EVariantManagerTestEnum;
        CapturedByteProperty: number;
        CapturedIntProperty: number;
        CapturedFloatProperty: number;
        bCapturedBoolProperty: boolean;
        CapturedObjectProperty: UE.Object;
        CapturedInterfaceProperty: Interface;
        CapturedNameProperty: string;
        CapturedStrProperty: string;
        CapturedTextProperty: string;
        CapturedRotatorProperty: UE.Rotator;
        CapturedColorProperty: UE.Color;
        CapturedLinearColorProperty: UE.LinearColor;
        CapturedVectorProperty: UE.Vector;
        CapturedQuatProperty: UE.Quat;
        CapturedVector4Property: UE.Vector4;
        CapturedVector2DProperty: UE.Vector2D;
        CapturedIntPointProperty: UE.IntPoint;
        CapturedUObjectArrayProperty: TArray<UE.Object>;
        CapturedVectorArrayProperty: TArray<UE.Vector>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VariantManagerTestActor;
        static Load(InName: string): VariantManagerTestActor;
    }
    
    class VectorExtensionMethods extends UE.ExtensionMethods {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static Set(This: $Ref<UE.Vector>, InX: number, InY: number, InZ: number) : void;
        static ToString(This: $Ref<UE.Vector>) : string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VectorExtensionMethods;
        static Load(InName: string): VectorExtensionMethods;
    }
    
    enum EVectorFieldConstructionOp { VFCO_Extrude, VFCO_Revolve, VFCO_MAX}
    class VectorFieldStatic extends UE.VectorField {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SizeX: number;
        SizeY: number;
        SizeZ: number;
        bAllowCPUAccess: boolean;
        CPUData: TArray<UE.Vector4>;
        SourceFilePath: string;
        AssetImportData: UE.AssetImportData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VectorFieldStatic;
        static Load(InName: string): VectorFieldStatic;
    }
    
    class VectorFieldAnimated extends UE.VectorField {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Texture: UE.Texture2D;
        ConstructionOp: UE.EVectorFieldConstructionOp;
        VolumeSizeX: number;
        VolumeSizeY: number;
        VolumeSizeZ: number;
        SubImagesX: number;
        SubImagesY: number;
        FrameCount: number;
        FramesPerSecond: number;
        bLoop: boolean;
        NoiseField: UE.VectorFieldStatic;
        NoiseScale: number;
        NoiseMax: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VectorFieldAnimated;
        static Load(InName: string): VectorFieldAnimated;
    }
    
    class VectorFieldComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VectorField: UE.VectorField;
        Intensity: number;
        Tightness: number;
        bPreviewVectorField: boolean;
        SetIntensity(NewIntensity: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VectorFieldComponent;
        static Load(InName: string): VectorFieldComponent;
    }
    
    class VectorFieldVolume extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VectorFieldComponent: UE.VectorFieldComponent;
        SpriteComponent: UE.BillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VectorFieldVolume;
        static Load(InName: string): VectorFieldVolume;
    }
    
    class WheeledVehicle extends UE.Pawn {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Mesh: UE.SkeletalMeshComponent;
        VehicleMovement: UE.WheeledVehicleMovementComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WheeledVehicle;
        static Load(InName: string): WheeledVehicle;
    }
    
    class VehicleAnimInstance extends UE.AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WheeledVehicleMovementComponent: UE.WheeledVehicleMovementComponent;
        GetVehicle() : UE.WheeledVehicle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VehicleAnimInstance;
        static Load(InName: string): VehicleAnimInstance;
    }
    
    class VertexColorImportOptions extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UVIndex: number;
        LODIndex: number;
        bRed: boolean;
        bBlue: boolean;
        bGreen: boolean;
        bAlpha: boolean;
        bImportToInstance: boolean;
        bCanImportToInstance: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VertexColorImportOptions;
        static Load(InName: string): VertexColorImportOptions;
    }
    
    class VerticalBoxSlot extends UE.PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Size: UE.SlateChildSize;
        Padding: UE.Margin;
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetSize(InSize: UE.SlateChildSize) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VerticalBoxSlot;
        static Load(InName: string): VerticalBoxSlot;
    }
    
    class VerticalBox extends UE.PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddChildToVerticalBox(Content: $Nullable<UE.Widget>) : UE.VerticalBoxSlot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VerticalBox;
        static Load(InName: string): VerticalBox;
    }
    
    class VideoCaptureProtocol extends UE.FrameGrabberProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseCompression: boolean;
        CompressionQuality: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VideoCaptureProtocol;
        static Load(InName: string): VideoCaptureProtocol;
    }
    
    class Viewport extends UE.ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BackgroundColor: UE.LinearColor;
        GetViewLocation() : UE.Vector;
        GetViewportWorld() : UE.World;
        GetViewRotation() : UE.Rotator;
        SetViewLocation(Location: UE.Vector) : void;
        SetViewRotation(Rotation: UE.Rotator) : void;
        Spawn(ActorClass: $Nullable<UE.Class>) : UE.Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Viewport;
        static Load(InName: string): Viewport;
    }
    
    class ViewportInteractableInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ViewportInteractableInterface;
        static Load(InName: string): ViewportInteractableInterface;
    }
    
    class VirtualTextureSpacePoolConfig {
        constructor();
        constructor(MinTileSize: number, MaxTileSize: number, Formats: TArray<UE.EPixelFormat>, SizeInMegabyte: number, bAllowSizeScale: boolean);
        MinTileSize: number;
        MaxTileSize: number;
        Formats: TArray<UE.EPixelFormat>;
        SizeInMegabyte: number;
        bAllowSizeScale: boolean;
        static StaticClass(): Class;
    }
    
    class VirtualTexturePoolConfig extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultSizeInMegabyte: number;
        Pools: TArray<UE.VirtualTextureSpacePoolConfig>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VirtualTexturePoolConfig;
        static Load(InName: string): VirtualTexturePoolConfig;
    }
    
    class VISettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bScaleWorldFromFloor: boolean;
        bScaleWorldWithDynamicPivot: boolean;
        bAllowSimultaneousWorldScalingAndRotation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VISettings;
        static Load(InName: string): VISettings;
    }
    
    class VisibilityBinding extends UE.PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetValue() : UE.ESlateVisibility;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisibilityBinding;
        static Load(InName: string): VisibilityBinding;
    }
    
    class VisualLoggerAutomationTests extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisualLoggerAutomationTests;
        static Load(InName: string): VisualLoggerAutomationTests;
    }
    
    class VisualLoggerCameraController extends UE.DebugCameraController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PickedActor: UE.Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisualLoggerCameraController;
        static Load(InName: string): VisualLoggerCameraController;
    }
    
    class VisualLoggerDebugSnapshotInterface extends UE.Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisualLoggerDebugSnapshotInterface;
        static Load(InName: string): VisualLoggerDebugSnapshotInterface;
    }
    
    class VisualLoggerExtension extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisualLoggerExtension;
        static Load(InName: string): VisualLoggerExtension;
    }
    
    class VisualLoggerHUD extends UE.DebugCameraHUD {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisualLoggerHUD;
        static Load(InName: string): VisualLoggerHUD;
    }
    
    class VisualLoggerKismetLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static EnableRecording(bEnabled: boolean) : void;
        static LogBox(WorldContextObject: $Nullable<UE.Object>, BoxShape: UE.Box, Text: string, ObjectColor?: UE.LinearColor /* = (R=0.000000,G=0.000000,B=1.000000,A=1.000000) */, LogCategory?: string /* = "VisLogBP" */, bAddToMessageLog?: boolean /* = false */) : void;
        static LogLocation(WorldContextObject: $Nullable<UE.Object>, Location: UE.Vector, Text: string, ObjectColor?: UE.LinearColor /* = (R=0.000000,G=0.000000,B=1.000000,A=1.000000) */, Radius?: number /* = 10.000000 */, LogCategory?: string /* = "VisLogBP" */, bAddToMessageLog?: boolean /* = false */) : void;
        static LogSegment(WorldContextObject: $Nullable<UE.Object>, SegmentStart: UE.Vector, SegmentEnd: UE.Vector, Text: string, ObjectColor?: UE.LinearColor /* = (R=0.000000,G=0.000000,B=1.000000,A=1.000000) */, Thickness?: number /* = 0.000000 */, CategoryName?: string /* = "VisLogBP" */, bAddToMessageLog?: boolean /* = false */) : void;
        static LogText(WorldContextObject: $Nullable<UE.Object>, Text: string, LogCategory?: string /* = "VisLogBP" */, bAddToMessageLog?: boolean /* = false */) : void;
        static RedirectVislog(SourceOwner: $Nullable<UE.Object>, DestinationOwner: $Nullable<UE.Object>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisualLoggerKismetLibrary;
        static Load(InName: string): VisualLoggerKismetLibrary;
    }
    
    class VisualLoggerRenderingActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisualLoggerRenderingActor;
        static Load(InName: string): VisualLoggerRenderingActor;
    }
    
    class VisualLoggerRenderingComponent extends UE.PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisualLoggerRenderingComponent;
        static Load(InName: string): VisualLoggerRenderingComponent;
    }
    
    class VMReflection extends UE.UnitTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VMReflection;
        static Load(InName: string): VMReflection;
    }
    
    class VMTestClassA extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AObjectRef: UE.Object;
        ByteProp: number;
        UInt16Prop: number;
        UInt32Prop: number;
        UInt64Prop: bigint;
        Int8Prop: number;
        Int16Prop: number;
        Int32Prop: number;
        Int64Prop: bigint;
        FloatProp: number;
        DoubleProp: number;
        bBoolPropA: boolean;
        bBoolPropB: boolean;
        bBoolPropC: boolean;
        bBoolPropD: boolean;
        bBoolPropE: boolean;
        NameProp: string;
        StringProp: string;
        TextProp: string;
        BytePropArray: FixSizeArray<number>;
        ObjectPropArray: FixSizeArray<UE.Object>;
        DynBytePropArray: TArray<number>;
        DynBoolPropArray: TArray<boolean>;
        DynObjectPropArray: TArray<UE.Object>;
        DynNamePropArray: TArray<string>;
        DynDoublePropArray: TArray<number>;
        DynFloatPropArray: TArray<number>;
        DynInt16PropArray: TArray<number>;
        DynInt64PropArray: TArray<bigint>;
        DynInt8PropArray: TArray<number>;
        DynIntPropArray: TArray<number>;
        DynUInt16PropArray: TArray<number>;
        DynUIntPropArray: TArray<number>;
        DynUInt64PropArray: TArray<bigint>;
        DynStringPropArray: TArray<string>;
        DynTextPropArray: TArray<string>;
        DynClassPropArray: TArray<UE.Class>;
        DynPawnPropArray: TArray<UE.Pawn>;
        StructProp: UE.Vector;
        StructPropArray: FixSizeArray<UE.Vector>;
        DynStructPropArray: TArray<UE.Vector>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VMTestClassA;
        static Load(InName: string): VMTestClassA;
    }
    
    class VMTestClassB extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BObjectRef: UE.Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VMTestClassB;
        static Load(InName: string): VMTestClassB;
    }
    
    class VoiceChannel extends UE.Channel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VoiceChannel;
        static Load(InName: string): VoiceChannel;
    }
    
    class VoipListenerSynthComponent extends UE.SynthComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IsIdling() : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VoipListenerSynthComponent;
        static Load(InName: string): VoipListenerSynthComponent;
    }
    
    class VOIPStatics extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetMicThreshold(InThreshold: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VOIPStatics;
        static Load(InName: string): VOIPStatics;
    }
    
    class VoiceSettings {
        constructor();
        constructor(ComponentToAttachTo: UE.SceneComponent, AttenuationSettings: UE.SoundAttenuation, SourceEffectChain: UE.SoundEffectSourcePresetChain);
        ComponentToAttachTo: UE.SceneComponent;
        AttenuationSettings: UE.SoundAttenuation;
        SourceEffectChain: UE.SoundEffectSourcePresetChain;
        static StaticClass(): Class;
    }
    
    class VOIPTalker extends UE.ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: UE.VoiceSettings;
        BPOnTalkingBegin(AudioComponent: $Nullable<UE.AudioComponent>) : void;
        BPOnTalkingEnd() : void;
        GetVoiceLevel() : number;
        RegisterWithPlayerState(OwningState: $Nullable<UE.PlayerState>) : void;
        static CreateTalkerForPlayer(OwningState: $Nullable<UE.PlayerState>) : UE.VOIPTalker;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VOIPTalker;
        static Load(InName: string): VOIPTalker;
    }
    
    class VolumeTextureFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialTexture: UE.Texture2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VolumeTextureFactory;
        static Load(InName: string): VolumeTextureFactory;
    }
    
    class VolumeTextureThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialInstance: UE.MaterialInstanceConstant;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VolumeTextureThumbnailRenderer;
        static Load(InName: string): VolumeTextureThumbnailRenderer;
    }
    
    class VolumetricBuilder extends UE.EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Z: number;
        Radius: number;
        NumSheets: number;
        GroupName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VolumetricBuilder;
        static Load(InName: string): VolumetricBuilder;
    }
    
    class VolumetricLightmapDensityVolume extends UE.Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AllowedMipLevelRange: UE.Int32Interval;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VolumetricLightmapDensityVolume;
        static Load(InName: string): VolumetricLightmapDensityVolume;
    }
    
    class VREditorAssetContainer extends UE.DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DockableWindowCloseSound: UE.SoundBase;
        DockableWindowOpenSound: UE.SoundBase;
        DockableWindowDropSound: UE.SoundBase;
        DockableWindowDragSound: UE.SoundBase;
        DropFromContentBrowserSound: UE.SoundBase;
        RadialMenuOpenSound: UE.SoundBase;
        RadialMenuCloseSound: UE.SoundBase;
        TeleportSound: UE.SoundBase;
        ButtonPressSound: UE.SoundCue;
        AutoScaleSound: UE.SoundBase;
        GenericHMDMesh: UE.StaticMesh;
        PlaneMesh: UE.StaticMesh;
        CylinderMesh: UE.StaticMesh;
        LaserPointerStartMesh: UE.StaticMesh;
        LaserPointerMesh: UE.StaticMesh;
        LaserPointerEndMesh: UE.StaticMesh;
        LaserPointerHoverMesh: UE.StaticMesh;
        VivePreControllerMesh: UE.StaticMesh;
        OculusControllerMesh: UE.StaticMesh;
        GenericControllerMesh: UE.StaticMesh;
        TeleportRootMesh: UE.StaticMesh;
        WindowMesh: UE.StaticMesh;
        WindowSelectionBarMesh: UE.StaticMesh;
        WindowCloseButtonMesh: UE.StaticMesh;
        RadialMenuMainMesh: UE.StaticMesh;
        RadialMenuPointerMesh: UE.StaticMesh;
        PointerCursorMesh: UE.StaticMesh;
        LineSegmentCylinderMesh: UE.StaticMesh;
        JointSphereMesh: UE.StaticMesh;
        DockingButtonMesh: UE.StaticMesh;
        GridMaterial: UE.MaterialInterface;
        LaserPointerMaterial: UE.MaterialInterface;
        LaserPointerTranslucentMaterial: UE.MaterialInterface;
        WorldMovementPostProcessMaterial: UE.Material;
        TextMaterial: UE.MaterialInterface;
        VivePreControllerMaterial: UE.MaterialInterface;
        OculusControllerMaterial: UE.MaterialInterface;
        TeleportMaterial: UE.MaterialInterface;
        WindowMaterial: UE.MaterialInterface;
        WindowTranslucentMaterial: UE.MaterialInterface;
        LineMaterial: UE.Material;
        TranslucentTextMaterial: UE.MaterialInterface;
        TextFont: UE.Font;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorAssetContainer;
        static Load(InName: string): VREditorAssetContainer;
    }
    
    class VREditorAvatarActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HeadMeshComponent: UE.StaticMeshComponent;
        WorldMovementGridMeshComponent: UE.StaticMeshComponent;
        WorldMovementGridMID: UE.MaterialInstanceDynamic;
        WorldMovementGridOpacity: number;
        bIsDrawingWorldMovementPostProcess: boolean;
        WorldMovementPostProcessMaterial: UE.MaterialInstanceDynamic;
        ScaleProgressMeshComponent: UE.StaticMeshComponent;
        CurrentScaleProgressMeshComponent: UE.StaticMeshComponent;
        UserScaleIndicatorText: UE.TextRenderComponent;
        FixedUserScaleMID: UE.MaterialInstanceDynamic;
        TranslucentFixedUserScaleMID: UE.MaterialInstanceDynamic;
        CurrentUserScaleMID: UE.MaterialInstanceDynamic;
        TranslucentCurrentUserScaleMID: UE.MaterialInstanceDynamic;
        PostProcessComponent: UE.PostProcessComponent;
        VRMode: UE.VREditorMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorAvatarActor;
        static Load(InName: string): VREditorAvatarActor;
    }
    
    class VREditorBaseActor extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VRMode: UE.VREditorMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorBaseActor;
        static Load(InName: string): VREditorBaseActor;
    }
    
    class VREditorFloatingUICreationContext {
        constructor();
        constructor(WidgetClass: UE.Class, PanelID: string, ParentActor: UE.Actor, PanelSpawnOffset: UE.Transform, PanelSize: UE.Vector2D, PanelMesh: UE.StaticMesh, EditorUISize: number, bHideWindowHandles: boolean, bMaskOutWidgetBackground: boolean, bNoCloseButton: boolean);
        WidgetClass: UE.Class;
        PanelID: string;
        ParentActor: UE.Actor;
        PanelSpawnOffset: UE.Transform;
        PanelSize: UE.Vector2D;
        PanelMesh: UE.StaticMesh;
        EditorUISize: number;
        bHideWindowHandles: boolean;
        bMaskOutWidgetBackground: boolean;
        bNoCloseButton: boolean;
        static StaticClass(): Class;
    }
    
    enum EWidgetSpace { World, Screen, EWidgetSpace_MAX}
    enum EWidgetTimingPolicy { RealTime, GameTime, EWidgetTimingPolicy_MAX}
    enum EWindowVisibility { Visible, SelfHitTestInvisible, EWindowVisibility_MAX}
    enum EWidgetBlendMode { Opaque, Masked, Transparent, EWidgetBlendMode_MAX}
    enum EWidgetGeometryMode { Plane, Cylinder, EWidgetGeometryMode_MAX}
    class WidgetComponent extends UE.MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Space: UE.EWidgetSpace;
        TimingPolicy: UE.EWidgetTimingPolicy;
        WidgetClass: UE.Class;
        DrawSize: UE.IntPoint;
        bManuallyRedraw: boolean;
        bRedrawRequested: boolean;
        RedrawTime: number;
        CurrentDrawSize: UE.IntPoint;
        bDrawAtDesiredSize: boolean;
        Pivot: UE.Vector2D;
        bReceiveHardwareInput: boolean;
        bWindowFocusable: boolean;
        WindowVisibility: UE.EWindowVisibility;
        bApplyGammaCorrection: boolean;
        OwnerPlayer: UE.LocalPlayer;
        BackgroundColor: UE.LinearColor;
        TintColorAndOpacity: UE.LinearColor;
        OpacityFromTexture: number;
        BlendMode: UE.EWidgetBlendMode;
        bIsTwoSided: boolean;
        TickWhenOffscreen: boolean;
        Widget: UE.UserWidget;
        BodySetup: UE.BodySetup;
        TranslucentMaterial: UE.MaterialInterface;
        TranslucentMaterial_OneSided: UE.MaterialInterface;
        OpaqueMaterial: UE.MaterialInterface;
        OpaqueMaterial_OneSided: UE.MaterialInterface;
        MaskedMaterial: UE.MaterialInterface;
        MaskedMaterial_OneSided: UE.MaterialInterface;
        RenderTarget: UE.TextureRenderTarget2D;
        MaterialInstance: UE.MaterialInstanceDynamic;
        bAddedToScreen: boolean;
        bEditTimeUsable: boolean;
        SharedLayerName: string;
        LayerZOrder: number;
        GeometryMode: UE.EWidgetGeometryMode;
        CylinderArcAngle: number;
        GetCurrentDrawSize() : UE.Vector2D;
        GetCylinderArcAngle() : number;
        GetDrawAtDesiredSize() : boolean;
        GetDrawSize() : UE.Vector2D;
        GetGeometryMode() : UE.EWidgetGeometryMode;
        GetManuallyRedraw() : boolean;
        GetMaterialInstance() : UE.MaterialInstanceDynamic;
        GetOwnerPlayer() : UE.LocalPlayer;
        GetPivot() : UE.Vector2D;
        GetRedrawTime() : number;
        GetRenderTarget() : UE.TextureRenderTarget2D;
        GetTickWhenOffscreen() : boolean;
        GetTwoSided() : boolean;
        GetUserWidgetObject() : UE.UserWidget;
        GetWidgetSpace() : UE.EWidgetSpace;
        GetWindowFocusable() : boolean;
        GetWindowVisiblility() : UE.EWindowVisibility;
        RequestRedraw() : void;
        SetBackgroundColor(NewBackgroundColor: UE.LinearColor) : void;
        SetCylinderArcAngle(InCylinderArcAngle: number) : void;
        SetDrawAtDesiredSize(bInDrawAtDesiredSize: boolean) : void;
        SetDrawSize(Size: UE.Vector2D) : void;
        SetGeometryMode(InGeometryMode: UE.EWidgetGeometryMode) : void;
        SetManuallyRedraw(bUseManualRedraw: boolean) : void;
        SetOwnerPlayer(LocalPlayer: $Nullable<UE.LocalPlayer>) : void;
        SetPivot(InPivot: UE.Vector2D) : void;
        SetRedrawTime(InRedrawTime: number) : void;
        SetTickWhenOffscreen(bWantTickWhenOffscreen: boolean) : void;
        SetTintColorAndOpacity(NewTintColorAndOpacity: UE.LinearColor) : void;
        SetTwoSided(bWantTwoSided: boolean) : void;
        SetWidget(Widget: $Nullable<UE.UserWidget>) : void;
        SetWidgetSpace(NewSpace: UE.EWidgetSpace) : void;
        SetWindowFocusable(bInWindowFocusable: boolean) : void;
        SetWindowVisibility(InVisibility: UE.EWindowVisibility) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetComponent;
        static Load(InName: string): WidgetComponent;
    }
    
    enum EVREditorWidgetDrawingPolicy { Always, Hovering, EVREditorWidgetDrawingPolicy_MAX}
    class VREditorWidgetComponent extends UE.WidgetComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DrawingPolicy: UE.EVREditorWidgetDrawingPolicy;
        bIsHovering: boolean;
        bHasEverDrawn: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorWidgetComponent;
        static Load(InName: string): VREditorWidgetComponent;
    }
    
    class VREditorFloatingUI extends UE.VREditorBaseActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CreationContext: UE.VREditorFloatingUICreationContext;
        UserWidget: UE.UserWidget;
        WidgetComponent: UE.VREditorWidgetComponent;
        WindowMeshComponent: UE.StaticMeshComponent;
        UserWidgetClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorFloatingUI;
        static Load(InName: string): VREditorFloatingUI;
    }
    
    class VREditorRadialFloatingUI extends UE.VREditorBaseActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetComponents: TArray<UE.VREditorWidgetComponent>;
        WindowMeshComponent: UE.StaticMeshComponent;
        ArrowMeshComponent: UE.StaticMeshComponent;
        CentralWidgetComponent: UE.VREditorWidgetComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorRadialFloatingUI;
        static Load(InName: string): VREditorRadialFloatingUI;
    }
    
    class VREditorDockableWindow extends UE.VREditorFloatingUI {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DockButtonMeshComponent: UE.StaticMeshComponent;
        SelectionBarMeshComponent: UE.StaticMeshComponent;
        CloseButtonMeshComponent: UE.StaticMeshComponent;
        DockButtonMID: UE.MaterialInstanceDynamic;
        SelectionBarMID: UE.MaterialInstanceDynamic;
        SelectionBarTranslucentMID: UE.MaterialInstanceDynamic;
        CloseButtonMID: UE.MaterialInstanceDynamic;
        CloseButtonTranslucentMID: UE.MaterialInstanceDynamic;
        DragOperationComponent: UE.ViewportDragOperationComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorDockableWindow;
        static Load(InName: string): VREditorDockableWindow;
    }
    
    enum EControllerType { Laser, AssistingLaser, UI, Navigation, Unknown, EControllerType_MAX}
    class VREditorTeleporter extends UE.Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VRMode: UE.VREditorMode;
        TeleportDirectionMeshComponent: UE.StaticMeshComponent;
        HMDMeshComponent: UE.StaticMeshComponent;
        LeftMotionControllerMeshComponent: UE.StaticMeshComponent;
        RightMotionControllerMeshComponent: UE.StaticMeshComponent;
        TeleportMID: UE.MaterialInstanceDynamic;
        InteractorTryingTeleport: UE.ViewportInteractor;
        DoTeleport() : void;
        GetInteractorTryingTeleport() : UE.ViewportInteractor;
        GetSlideDelta(Interactor: $Nullable<UE.VREditorInteractor>, Axis: boolean) : number;
        GetVRMode() : UE.VREditorMode;
        Init(InMode: $Nullable<UE.VREditorMode>) : void;
        IsAiming() : boolean;
        IsTeleporting() : boolean;
        SetColor(Color: UE.LinearColor) : void;
        SetVisibility(bVisible: boolean) : void;
        Shutdown() : void;
        StartAiming(Interactor: $Nullable<UE.ViewportInteractor>) : void;
        StartTeleport() : void;
        StopAiming() : void;
        TeleportDone() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorTeleporter;
        static Load(InName: string): VREditorTeleporter;
    }
    
    class VREditorInteractor extends UE.ViewportInteractor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsUndoRedoSwipeEnabled: boolean;
        MotionControllerComponent: UE.MotionControllerComponent;
        HandMeshComponent: UE.StaticMeshComponent;
        LaserSplineComponent: UE.SplineComponent;
        LaserSplineMeshComponents: TArray<UE.SplineMeshComponent>;
        LaserPointerMID: UE.MaterialInstanceDynamic;
        TranslucentLaserPointerMID: UE.MaterialInstanceDynamic;
        HoverMeshComponent: UE.StaticMeshComponent;
        HoverPointLightComponent: UE.PointLightComponent;
        HandMeshMID: UE.MaterialInstanceDynamic;
        OwningAvatar: UE.Actor;
        ControllerType: UE.EControllerType;
        OverrideControllerType: UE.EControllerType;
        ControllerMotionSource: string;
        VRMode: UE.VREditorMode;
        GetControllerSide() : UE.EControllerHand;
        GetControllerType() : UE.EControllerType;
        GetHMDDeviceType() : string;
        GetLaserEnd() : UE.Vector;
        GetLaserStart() : UE.Vector;
        GetLastTrackpadPosition() : UE.Vector2D;
        GetMotionControllerComponent() : UE.MotionControllerComponent;
        GetSelectAndMoveTriggerValue() : number;
        GetSlideDelta() : number;
        GetTeleportActor() : UE.VREditorTeleporter;
        GetTrackpadPosition() : UE.Vector2D;
        Init(InVRMode: $Nullable<UE.VREditorMode>) : void;
        IsClickingOnUI() : boolean;
        IsHoveringOverUI() : boolean;
        IsTouchingTrackpad() : boolean;
        ReplaceHandMeshComponent(NewMesh: $Nullable<UE.StaticMesh>) : void;
        SetControllerHandSide(InControllerHandSide: string) : void;
        SetControllerType(InControllerType: UE.EControllerType) : void;
        SetForceLaserColor(InColor: UE.LinearColor) : void;
        SetForceShowLaser(bInForceShow: boolean) : void;
        SetupComponent(OwningActor: $Nullable<UE.Actor>) : void;
        TryOverrideControllerType(InControllerType: UE.EControllerType) : boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorInteractor;
        static Load(InName: string): VREditorInteractor;
    }
    
    class VRButton {
        constructor();
        constructor(ButtonWidget: UE.VREditorWidgetComponent);
        ButtonWidget: UE.VREditorWidgetComponent;
        static StaticClass(): Class;
    }
    
    class VRRadialMenuHandler extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VRRadialMenuHandler;
        static Load(InName: string): VRRadialMenuHandler;
    }
    
    class VREditorUISystem extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VRMode: UE.VREditorMode;
        FloatingUIs: TMap<string, UE.VREditorFloatingUI>;
        PreviewWindowInfo: TMap<string, UE.Actor>;
        InfoDisplayPanel: UE.VREditorFloatingUI;
        QuickRadialMenu: UE.VREditorRadialFloatingUI;
        DraggingUI: UE.VREditorDockableWindow;
        ColorPickerUI: UE.VREditorDockableWindow;
        LaserInteractor: UE.VREditorInteractor;
        UIInteractor: UE.VREditorInteractor;
        VRButtons: TArray<UE.VRButton>;
        RadialMenuHandler: UE.VRRadialMenuHandler;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorUISystem;
        static Load(InName: string): VREditorUISystem;
    }
    
    class VREditorPlacement extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VRMode: UE.VREditorMode;
        ViewportWorldInteraction: UE.ViewportWorldInteraction;
        FloatingUIAssetDraggedFrom: UE.WidgetComponent;
        PlacingMaterialOrTextureAsset: UE.Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorPlacement;
        static Load(InName: string): VREditorPlacement;
    }
    
    class VREditorMode extends UE.EditorWorldExtension {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AvatarActor: UE.VREditorAvatarActor;
        UISystem: UE.VREditorUISystem;
        TeleportActor: UE.VREditorTeleporter;
        AutoScalerSystem: UE.VREditorAutoScaler;
        WorldInteraction: UE.ViewportWorldInteraction;
        PlacementSystem: UE.VREditorPlacement;
        Interactors: TArray<UE.VREditorInteractor>;
        AssetContainer: UE.VREditorAssetContainer;
        GetWorldScaleFactor() : number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorMode;
        static Load(InName: string): VREditorMode;
    }
    
    class VREditorAutoScaler extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VRMode: UE.VREditorMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorAutoScaler;
        static Load(InName: string): VREditorAutoScaler;
    }
    
    class VREditorBaseUserWidget extends UE.UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Owner: TWeakObjectPtr<UE.VREditorFloatingUI>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorBaseUserWidget;
        static Load(InName: string): VREditorBaseUserWidget;
    }
    
    class VREditorCameraWidgetComponent extends UE.VREditorWidgetComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorCameraWidgetComponent;
        static Load(InName: string): VREditorCameraWidgetComponent;
    }
    
    class VREditorDockableCameraWindow extends UE.VREditorDockableWindow {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorDockableCameraWindow;
        static Load(InName: string): VREditorDockableCameraWindow;
    }
    
    class VREditorFloatingCameraUI extends UE.VREditorFloatingUI {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OffsetFromCamera: UE.Vector;
        LinkedActor: TWeakObjectPtr<UE.Actor>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorFloatingCameraUI;
        static Load(InName: string): VREditorFloatingCameraUI;
    }
    
    enum EInteractorHand { Right, Left, EInteractorHand_MAX}
    class VRModeSettings extends UE.VISettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnableAutoVREditMode: boolean;
        bAutokeySequences: boolean;
        InteractorHand: UE.EInteractorHand;
        bShowWorldMovementGrid: boolean;
        bShowWorldMovementPostProcess: boolean;
        bShowWorldScaleProgressBar: boolean;
        UIBrightness: number;
        GizmoScale: number;
        DoubleClickTime: number;
        TriggerPressedThreshold_Vive: number;
        TriggerPressedThreshold_Rift: number;
        InteractorClass: TSoftClassPtr<UE.VREditorInteractor>;
        TeleporterClass: TSoftClassPtr<UE.VREditorTeleporter>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VRModeSettings;
        static Load(InName: string): VRModeSettings;
    }
    
    enum EGizmoHandleTypes { All, Translate, Rotate, Scale, EGizmoHandleTypes_MAX}
    class VRScoutingInteractor extends UE.VREditorInteractor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FlyingIndicatorComponent: UE.StaticMeshComponent;
        GetGizmoMode() : UE.EGizmoHandleTypes;
        SetGizmoMode(InGizmoMode: UE.EGizmoHandleTypes) : void;
        static GetSelectedActors() : TArray<UE.Actor>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VRScoutingInteractor;
        static Load(InName: string): VRScoutingInteractor;
    }
    
    class WeakObjectProperty extends UE.ObjectPropertyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WeakObjectProperty;
        static Load(InName: string): WeakObjectProperty;
    }
    
    class WebMPlatFileMediaSourceFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WebMPlatFileMediaSourceFactory;
        static Load(InName: string): WebMPlatFileMediaSourceFactory;
    }
    
    class WebSocketClient extends UE.IPClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WebSocketClient;
        static Load(InName: string): WebSocketClient;
    }
    
    class VehicleEngineData {
        constructor();
        constructor(TorqueCurve: UE.RuntimeFloatCurve, MaxRPM: number, MOI: number, DampingRateFullThrottle: number, DampingRateZeroThrottleClutchEngaged: number, DampingRateZeroThrottleClutchDisengaged: number);
        TorqueCurve: UE.RuntimeFloatCurve;
        MaxRPM: number;
        MOI: number;
        DampingRateFullThrottle: number;
        DampingRateZeroThrottleClutchEngaged: number;
        DampingRateZeroThrottleClutchDisengaged: number;
        static StaticClass(): Class;
    }
    
    enum EVehicleDifferential4W { LimitedSlip_4W, LimitedSlip_FrontDrive, LimitedSlip_RearDrive, Open_4W, Open_FrontDrive, Open_RearDrive, EVehicleDifferential4W_MAX}
    class VehicleDifferential4WData {
        constructor();
        constructor(DifferentialType: UE.EVehicleDifferential4W, FrontRearSplit: number, FrontLeftRightSplit: number, RearLeftRightSplit: number, CentreBias: number, FrontBias: number, RearBias: number);
        DifferentialType: UE.EVehicleDifferential4W;
        FrontRearSplit: number;
        FrontLeftRightSplit: number;
        RearLeftRightSplit: number;
        CentreBias: number;
        FrontBias: number;
        RearBias: number;
        static StaticClass(): Class;
    }
    
    class VehicleGearData {
        constructor();
        constructor(Ratio: number, DownRatio: number, UpRatio: number);
        Ratio: number;
        DownRatio: number;
        UpRatio: number;
        static StaticClass(): Class;
    }
    
    class VehicleTransmissionData {
        constructor();
        constructor(bUseGearAutoBox: boolean, GearSwitchTime: number, GearAutoBoxLatency: number, FinalRatio: number, ForwardGears: TArray<UE.VehicleGearData>, ReverseGearRatio: number, NeutralGearUpRatio: number, ClutchStrength: number);
        bUseGearAutoBox: boolean;
        GearSwitchTime: number;
        GearAutoBoxLatency: number;
        FinalRatio: number;
        ForwardGears: TArray<UE.VehicleGearData>;
        ReverseGearRatio: number;
        NeutralGearUpRatio: number;
        ClutchStrength: number;
        static StaticClass(): Class;
    }
    
    class WheeledVehicleMovementComponent4W extends UE.WheeledVehicleMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EngineSetup: UE.VehicleEngineData;
        DifferentialSetup: UE.VehicleDifferential4WData;
        AckermannAccuracy: number;
        TransmissionSetup: UE.VehicleTransmissionData;
        SteeringCurve: UE.RuntimeFloatCurve;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WheeledVehicleMovementComponent4W;
        static Load(InName: string): WheeledVehicleMovementComponent4W;
    }
    
    class BlueprintWidgetAnimationDelegateBinding {
        constructor();
        constructor(Action: UE.EWidgetAnimationEvent, AnimationToBind: string, FunctionNameToBind: string, UserTag: string);
        Action: UE.EWidgetAnimationEvent;
        AnimationToBind: string;
        FunctionNameToBind: string;
        UserTag: string;
        static StaticClass(): Class;
    }
    
    class WidgetAnimationDelegateBinding extends UE.DynamicBlueprintBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetAnimationDelegateBindings: TArray<UE.BlueprintWidgetAnimationDelegateBinding>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetAnimationDelegateBinding;
        static Load(InName: string): WidgetAnimationDelegateBinding;
    }
    
    class WidgetAnimationPlayCallbackProxy extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Finished: $MulticastDelegate<() => void>;
        static CreatePlayAnimationProxyObject(Result: $Ref<UE.UMGSequencePlayer>, Widget: $Nullable<UE.UserWidget>, InAnimation: $Nullable<UE.WidgetAnimation>, StartAtTime?: number /* = 0.000000 */, NumLoopsToPlay?: number /* = 1 */, PlayMode?: UE.EUMGSequencePlayMode /* = Forward */, PlaybackSpeed?: number /* = 1.000000 */) : UE.WidgetAnimationPlayCallbackProxy;
        static CreatePlayAnimationTimeRangeProxyObject(Result: $Ref<UE.UMGSequencePlayer>, Widget: $Nullable<UE.UserWidget>, InAnimation: $Nullable<UE.WidgetAnimation>, StartAtTime?: number /* = 0.000000 */, EndAtTime?: number /* = 0.000000 */, NumLoopsToPlay?: number /* = 1 */, PlayMode?: UE.EUMGSequencePlayMode /* = Forward */, PlaybackSpeed?: number /* = 1.000000 */) : UE.WidgetAnimationPlayCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetAnimationPlayCallbackProxy;
        static Load(InName: string): WidgetAnimationPlayCallbackProxy;
    }
    
    class WidgetBinding extends UE.PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetValue() : UE.Widget;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetBinding;
        static Load(InName: string): WidgetBinding;
    }
    
    class WidgetBlueprintFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlueprintType: UE.EBlueprintType;
        ParentClass: UE.Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetBlueprintFactory;
        static Load(InName: string): WidgetBlueprintFactory;
    }
    
    enum EWindowTitleBarMode { Overlay, VerticalBox, EWindowTitleBarMode_MAX}
    class NavigationEvent extends UE.InputEvent {
        constructor();
        static StaticClass(): Class;
    }
    
    class WidgetBlueprintLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnGameWindowCloseButtonClickedDelegate__DelegateSignature() : void;
        static CancelDragDrop() : void;
        static CaptureJoystick(Reply: $Ref<UE.EventReply>, CapturingWidget: $Nullable<UE.Widget>, bInAllJoysticks?: boolean /* = false */) : UE.EventReply;
        static CaptureMouse(Reply: $Ref<UE.EventReply>, CapturingWidget: $Nullable<UE.Widget>) : UE.EventReply;
        static ClearUserFocus(Reply: $Ref<UE.EventReply>, bInAllUsers?: boolean /* = false */) : UE.EventReply;
        static Create(WorldContextObject: $Nullable<UE.Object>, WidgetType: $Nullable<UE.Class>, OwningPlayer: $Nullable<UE.PlayerController>) : UE.UserWidget;
        static CreateDragDropOperation(OperationClass: $Nullable<UE.Class>) : UE.DragDropOperation;
        static DetectDrag(Reply: $Ref<UE.EventReply>, WidgetDetectingDrag: $Nullable<UE.Widget>, DragKey: UE.Key) : UE.EventReply;
        static DetectDragIfPressed(PointerEvent: UE.PointerEvent, WidgetDetectingDrag: $Nullable<UE.Widget>, DragKey: UE.Key) : UE.EventReply;
        static DismissAllMenus() : void;
        static DrawBox(Context: $Ref<UE.PaintContext>, Position: UE.Vector2D, Size: UE.Vector2D, Brush: $Nullable<UE.SlateBrushAsset>, Tint?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */) : void;
        static DrawLine(Context: $Ref<UE.PaintContext>, PositionA: UE.Vector2D, PositionB: UE.Vector2D, Tint?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, bAntiAlias?: boolean /* = true */, Thickness?: number /* = 1.000000 */) : void;
        static DrawLines(Context: $Ref<UE.PaintContext>, Points: TArray<UE.Vector2D>, Tint?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, bAntiAlias?: boolean /* = true */, Thickness?: number /* = 1.000000 */) : void;
        static DrawText(Context: $Ref<UE.PaintContext>, InString: string, Position: UE.Vector2D, Tint?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */) : void;
        static DrawTextFormatted(Context: $Ref<UE.PaintContext>, Text: string, Position: UE.Vector2D, Font: $Nullable<UE.Font>, FontSize?: number /* = 16 */, FontTypeFace?: string /* = "Regular" */, Tint?: UE.LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */) : void;
        static EndDragDrop(Reply: $Ref<UE.EventReply>) : UE.EventReply;
        static GetAllWidgetsOfClass(WorldContextObject: $Nullable<UE.Object>, FoundWidgets: $Ref<TArray<UE.UserWidget>>, WidgetClass: $Nullable<UE.Class>, TopLevelOnly?: boolean /* = true */) : void;
        static GetAllWidgetsWithInterface(WorldContextObject: $Nullable<UE.Object>, FoundWidgets: $Ref<TArray<UE.UserWidget>>, Interface: $Nullable<UE.Class>, TopLevelOnly: boolean) : void;
        static GetBrushResource(Brush: UE.SlateBrush) : UE.Object;
        static GetBrushResourceAsMaterial(Brush: UE.SlateBrush) : UE.MaterialInterface;
        static GetBrushResourceAsTexture2D(Brush: UE.SlateBrush) : UE.Texture2D;
        static GetDragDroppingContent() : UE.DragDropOperation;
        static GetDynamicMaterial(Brush: $Ref<UE.SlateBrush>) : UE.MaterialInstanceDynamic;
        static GetInputEventFromCharacterEvent(Event: UE.CharacterEvent) : UE.InputEvent;
        static GetInputEventFromKeyEvent(Event: UE.KeyEvent) : UE.InputEvent;
        static GetInputEventFromNavigationEvent(Event: UE.NavigationEvent) : UE.InputEvent;
        static GetInputEventFromPointerEvent(Event: UE.PointerEvent) : UE.InputEvent;
        static GetKeyEventFromAnalogInputEvent(Event: UE.AnalogInputEvent) : UE.KeyEvent;
        static GetSafeZonePadding(WorldContextObject: $Nullable<UE.Object>, SafePadding: $Ref<UE.Vector4>, SafePaddingScale: $Ref<UE.Vector2D>, SpillOverPadding: $Ref<UE.Vector4>) : void;
        static Handled() : UE.EventReply;
        static IsDragDropping() : boolean;
        static LockMouse(Reply: $Ref<UE.EventReply>, CapturingWidget: $Nullable<UE.Widget>) : UE.EventReply;
        static MakeBrushFromAsset(BrushAsset: $Nullable<UE.SlateBrushAsset>) : UE.SlateBrush;
        static MakeBrushFromMaterial(Material: $Nullable<UE.MaterialInterface>, Width?: number /* = 32 */, Height?: number /* = 32 */) : UE.SlateBrush;
        static MakeBrushFromTexture(Texture: $Nullable<UE.Texture2D>, Width?: number /* = 0 */, Height?: number /* = 0 */) : UE.SlateBrush;
        static NoResourceBrush() : UE.SlateBrush;
        static ReleaseJoystickCapture(Reply: $Ref<UE.EventReply>, bInAllJoysticks?: boolean /* = false */) : UE.EventReply;
        static ReleaseMouseCapture(Reply: $Ref<UE.EventReply>) : UE.EventReply;
        static RestorePreviousWindowTitleBarState() : void;
        static SetBrushResourceToMaterial(Brush: $Ref<UE.SlateBrush>, Material: $Nullable<UE.MaterialInterface>) : void;
        static SetBrushResourceToTexture(Brush: $Ref<UE.SlateBrush>, Texture: $Nullable<UE.Texture2D>) : void;
        static SetColorVisionDeficiencyType(Type: UE.EColorVisionDeficiency, Severity: number, CorrectDeficiency: boolean, ShowCorrectionWithDeficiency: boolean) : void;
        static SetFocusToGameViewport() : void;
        static SetHardwareCursor(WorldContextObject: $Nullable<UE.Object>, CursorShape: UE.EMouseCursor, CursorName: string, HotSpot: UE.Vector2D) : boolean;
        static SetInputMode_GameAndUI(Target: $Nullable<UE.PlayerController>, InWidgetToFocus?: UE.Widget /* = None */, bLockMouseToViewport?: boolean /* = false */, bHideCursorDuringCapture?: boolean /* = true */) : void;
        static SetInputMode_GameAndUIEx(PlayerController: $Nullable<UE.PlayerController>, InWidgetToFocus?: UE.Widget /* = None */, InMouseLockMode?: UE.EMouseLockMode /* = DoNotLock */, bHideCursorDuringCapture?: boolean /* = true */) : void;
        static SetInputMode_GameOnly(PlayerController: $Nullable<UE.PlayerController>) : void;
        static SetInputMode_UIOnly(Target: $Nullable<UE.PlayerController>, InWidgetToFocus?: UE.Widget /* = None */, bLockMouseToViewport?: boolean /* = false */) : void;
        static SetInputMode_UIOnlyEx(PlayerController: $Nullable<UE.PlayerController>, InWidgetToFocus?: UE.Widget /* = None */, InMouseLockMode?: UE.EMouseLockMode /* = DoNotLock */) : void;
        static SetMousePosition(Reply: $Ref<UE.EventReply>, NewMousePosition: UE.Vector2D) : UE.EventReply;
        static SetUserFocus(Reply: $Ref<UE.EventReply>, FocusWidget: $Nullable<UE.Widget>, bInAllUsers?: boolean /* = false */) : UE.EventReply;
        static SetWindowTitleBarCloseButtonActive(bActive: boolean) : void;
        static SetWindowTitleBarOnCloseClickedDelegate(Delegate: $Delegate<() => void>) : void;
        static SetWindowTitleBarState(TitleBarContent: $Nullable<UE.Widget>, Mode: UE.EWindowTitleBarMode, bTitleBarDragEnabled: boolean, bWindowButtonsVisible: boolean, bTitleBarVisible: boolean) : void;
        static Unhandled() : UE.EventReply;
        static UnlockMouse(Reply: $Ref<UE.EventReply>) : UE.EventReply;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetBlueprintLibrary;
        static Load(InName: string): WidgetBlueprintLibrary;
    }
    
    class WidgetCompilerRule extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetCompilerRule;
        static Load(InName: string): WidgetCompilerRule;
    }
    
    class WidgetPaletteFavorites extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Favorites: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetPaletteFavorites;
        static Load(InName: string): WidgetPaletteFavorites;
    }
    
    class WidgetDesignerSettings extends UE.DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GridSnapEnabled: boolean;
        GridSnapSize: number;
        bLockToPanelOnDragByDefault: boolean;
        bShowOutlines: boolean;
        bExecutePreConstructEvent: boolean;
        bRespectLocks: boolean;
        Favorites: UE.WidgetPaletteFavorites;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetDesignerSettings;
        static Load(InName: string): WidgetDesignerSettings;
    }
    
    class WidgetGraphSchema extends UE.EdGraphSchema_K2 {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetGraphSchema;
        static Load(InName: string): WidgetGraphSchema;
    }
    
    enum EWidgetInteractionSource { World, Mouse, CenterScreen, Custom, EWidgetInteractionSource_MAX}
    class WidgetInteractionComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnHoveredWidgetChanged: $MulticastDelegate<(WidgetComponent: $Nullable<UE.WidgetComponent>, PreviousWidgetComponent: $Nullable<UE.WidgetComponent>) => void>;
        VirtualUserIndex: number;
        PointerIndex: number;
        TraceChannel: UE.ECollisionChannel;
        InteractionDistance: number;
        InteractionSource: UE.EWidgetInteractionSource;
        bEnableHitTesting: boolean;
        bShowDebug: boolean;
        DebugColor: UE.LinearColor;
        CustomHitResult: UE.HitResult;
        LocalHitLocation: UE.Vector2D;
        LastLocalHitLocation: UE.Vector2D;
        HoveredWidgetComponent: UE.WidgetComponent;
        LastHitResult: UE.HitResult;
        bIsHoveredWidgetInteractable: boolean;
        bIsHoveredWidgetFocusable: boolean;
        bIsHoveredWidgetHitTestVisible: boolean;
        ArrowComponent: UE.ArrowComponent;
        Get2DHitLocation() : UE.Vector2D;
        GetHoveredWidgetComponent() : UE.WidgetComponent;
        GetLastHitResult() : UE.HitResult;
        IsOverFocusableWidget() : boolean;
        IsOverHitTestVisibleWidget() : boolean;
        IsOverInteractableWidget() : boolean;
        PressAndReleaseKey(Key: UE.Key) : boolean;
        PressKey(Key: UE.Key, bRepeat?: boolean /* = false */) : boolean;
        PressPointerKey(Key: UE.Key) : void;
        ReleaseKey(Key: UE.Key) : boolean;
        ReleasePointerKey(Key: UE.Key) : void;
        ScrollWheel(ScrollDelta: number) : void;
        SendKeyChar(Characters: string, bRepeat?: boolean /* = false */) : boolean;
        SetCustomHitResult(HitResult: UE.HitResult) : void;
        SetFocus(FocusWidget: $Nullable<UE.Widget>) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetInteractionComponent;
        static Load(InName: string): WidgetInteractionComponent;
    }
    
    class WrapBoxSlot extends UE.PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: UE.Margin;
        bFillEmptySpace: boolean;
        FillSpanWhenLessThan: number;
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        SetFillEmptySpace(InbFillEmptySpace: boolean) : void;
        SetFillSpanWhenLessThan(InFillSpanWhenLessThan: number) : void;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WrapBoxSlot;
        static Load(InName: string): WrapBoxSlot;
    }
    
    class WidgetSwitcherSlot extends UE.PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: UE.Margin;
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetSwitcherSlot;
        static Load(InName: string): WidgetSwitcherSlot;
    }
    
    class WidgetLayoutLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetMousePositionOnPlatform() : UE.Vector2D;
        static GetMousePositionOnViewport(WorldContextObject: $Nullable<UE.Object>) : UE.Vector2D;
        static GetMousePositionScaledByDPI(Player: $Nullable<UE.PlayerController>, LocationX: $Ref<number>, LocationY: $Ref<number>) : boolean;
        static GetPlayerScreenWidgetGeometry(PlayerController: $Nullable<UE.PlayerController>) : UE.Geometry;
        static GetViewportScale(WorldContextObject: $Nullable<UE.Object>) : number;
        static GetViewportSize(WorldContextObject: $Nullable<UE.Object>) : UE.Vector2D;
        static GetViewportWidgetGeometry(WorldContextObject: $Nullable<UE.Object>) : UE.Geometry;
        static ProjectWorldLocationToWidgetPosition(PlayerController: $Nullable<UE.PlayerController>, WorldLocation: UE.Vector, ScreenPosition: $Ref<UE.Vector2D>) : boolean;
        static RemoveAllWidgets(WorldContextObject: $Nullable<UE.Object>) : void;
        static SlotAsBorderSlot(Widget: $Nullable<UE.Widget>) : UE.BorderSlot;
        static SlotAsCanvasSlot(Widget: $Nullable<UE.Widget>) : UE.CanvasPanelSlot;
        static SlotAsGridSlot(Widget: $Nullable<UE.Widget>) : UE.GridSlot;
        static SlotAsHorizontalBoxSlot(Widget: $Nullable<UE.Widget>) : UE.HorizontalBoxSlot;
        static SlotAsOverlaySlot(Widget: $Nullable<UE.Widget>) : UE.OverlaySlot;
        static SlotAsSafeBoxSlot(Widget: $Nullable<UE.Widget>) : UE.SafeZoneSlot;
        static SlotAsScaleBoxSlot(Widget: $Nullable<UE.Widget>) : UE.ScaleBoxSlot;
        static SlotAsScrollBoxSlot(Widget: $Nullable<UE.Widget>) : UE.ScrollBoxSlot;
        static SlotAsSizeBoxSlot(Widget: $Nullable<UE.Widget>) : UE.SizeBoxSlot;
        static SlotAsUniformGridSlot(Widget: $Nullable<UE.Widget>) : UE.UniformGridSlot;
        static SlotAsVerticalBoxSlot(Widget: $Nullable<UE.Widget>) : UE.VerticalBoxSlot;
        static SlotAsWidgetSwitcherSlot(Widget: $Nullable<UE.Widget>) : UE.WidgetSwitcherSlot;
        static SlotAsWrapBoxSlot(Widget: $Nullable<UE.Widget>) : UE.WrapBoxSlot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetLayoutLibrary;
        static Load(InName: string): WidgetLayoutLibrary;
    }
    
    class WidgetSlotPair extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetName: string;
        SlotPropertyNames: TArray<string>;
        SlotPropertyValues: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetSlotPair;
        static Load(InName: string): WidgetSlotPair;
    }
    
    class WidgetSwitcher extends UE.PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActiveWidgetIndex: number;
        GetActiveWidget() : UE.Widget;
        GetActiveWidgetIndex() : number;
        GetNumWidgets() : number;
        GetWidgetAtIndex(Index: number) : UE.Widget;
        SetActiveWidget(Widget: $Nullable<UE.Widget>) : void;
        SetActiveWidgetIndex(Index: number) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetSwitcher;
        static Load(InName: string): WidgetSwitcher;
    }
    
    enum EWindSourceType { Directional, Point, EWindSourceType_MAX}
    class WindDirectionalSourceComponent extends UE.SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Strength: number;
        Speed: number;
        MinGustAmount: number;
        MaxGustAmount: number;
        Radius: number;
        bPointWind: boolean;
        SetMaximumGustAmount(InNewMaxGust: number) : void;
        SetMinimumGustAmount(InNewMinGust: number) : void;
        SetRadius(InNewRadius: number) : void;
        SetSpeed(InNewSpeed: number) : void;
        SetStrength(InNewStrength: number) : void;
        SetWindType(InNewType: UE.EWindSourceType) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WindDirectionalSourceComponent;
        static Load(InName: string): WindDirectionalSourceComponent;
    }
    
    class WindDirectionalSource extends UE.Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Component: UE.WindDirectionalSourceComponent;
        ArrowComponent: UE.ArrowComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WindDirectionalSource;
        static Load(InName: string): WindDirectionalSource;
    }
    
    enum ECompilerVersion { Default, VisualStudio2015, VisualStudio2017, VisualStudio2019, ECompilerVersion_MAX}
    enum EDefaultGraphicsRHI { DefaultGraphicsRHI_Default, DefaultGraphicsRHI_DX11, DefaultGraphicsRHI_DX12, DefaultGraphicsRHI_Vulkan, DefaultGraphicsRHI_MAX}
    enum EMinimumSupportedOS { MSOS_Vista, MSOS_MAX}
    class WindowsTargetSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Compiler: UE.ECompilerVersion;
        TargetedRHIs: TArray<string>;
        DefaultGraphicsRHI: UE.EDefaultGraphicsRHI;
        MinimumOSVersion: UE.EMinimumSupportedOS;
        AudioSampleRate: number;
        AudioCallbackBufferFrameSize: number;
        AudioNumBuffersToEnqueue: number;
        AudioMaxChannels: number;
        AudioNumSourceWorkers: number;
        SpatializationPlugin: string;
        ReverbPlugin: string;
        OcclusionPlugin: string;
        CompressionOverrides: UE.PlatformRuntimeAudioCompressionOverrides;
        ChunkSizeKB: number;
        bUseAudioStreamCaching: boolean;
        CacheSizeKB: number;
        bResampleForDevice: boolean;
        MaxSampleRate: number;
        HighSampleRate: number;
        MedSampleRate: number;
        LowSampleRate: number;
        MinSampleRate: number;
        CompressionQualityModifier: number;
        AutoStreamingThreshold: number;
        SoundCueCookQualityIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WindowsTargetSettings;
        static Load(InName: string): WindowsTargetSettings;
    }
    
    class WindowTitleBarArea extends UE.ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bWindowButtonsEnabled: boolean;
        bDoubleClickTogglesFullscreen: boolean;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WindowTitleBarArea;
        static Load(InName: string): WindowTitleBarArea;
    }
    
    class WindowTitleBarAreaSlot extends UE.PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: UE.Margin;
        HorizontalAlignment: UE.EHorizontalAlignment;
        VerticalAlignment: UE.EVerticalAlignment;
        SetHorizontalAlignment(InHorizontalAlignment: UE.EHorizontalAlignment) : void;
        SetPadding(InPadding: UE.Margin) : void;
        SetVerticalAlignment(InVerticalAlignment: UE.EVerticalAlignment) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WindowTitleBarAreaSlot;
        static Load(InName: string): WindowTitleBarAreaSlot;
    }
    
    class WmfFileMediaSourceFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WmfFileMediaSourceFactory;
        static Load(InName: string): WmfFileMediaSourceFactory;
    }
    
    class WmfMediaSettings extends UE.Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AllowNonStandardCodecs: boolean;
        LowLatency: boolean;
        NativeAudioOut: boolean;
        HardwareAcceleratedVideoDecoding: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WmfMediaSettings;
        static Load(InName: string): WmfMediaSettings;
    }
    
    class WorldExtensionMethods extends UE.ExtensionMethods {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SpawnActor(World: $Nullable<UE.World>, Class: $Nullable<UE.Class>, Transform: UE.Transform, SpawnCollisionHandlingOverride: UE.ESpawnActorCollisionHandlingMethod, Owner: $Nullable<UE.Actor>, Instigator: $Nullable<UE.Pawn>) : UE.Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WorldExtensionMethods;
        static Load(InName: string): WorldExtensionMethods;
    }
    
    class WorldFactory extends UE.Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WorldFactory;
        static Load(InName: string): WorldFactory;
    }
    
    enum EOrthoThumbnailDirection { Top, Bottom, Left, Right, Front, Back, EOrthoThumbnailDirection_MAX}
    class WorldThumbnailInfo extends UE.SceneThumbnailInfo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CameraMode: UE.ECameraProjectionMode;
        OrthoDirection: UE.EOrthoThumbnailDirection;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WorldThumbnailInfo;
        static Load(InName: string): WorldThumbnailInfo;
    }
    
    class WorldThumbnailRenderer extends UE.DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GlobalOrbitPitchOffset: number;
        GlobalOrbitYawOffset: number;
        bUseUnlitScene: boolean;
        bAllowWorldThumbnails: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WorldThumbnailRenderer;
        static Load(InName: string): WorldThumbnailRenderer;
    }
    
    class WrangleContentCommandlet extends UE.Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WrangleContentCommandlet;
        static Load(InName: string): WrangleContentCommandlet;
    }
    
    class WrapBox extends UE.PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InnerSlotPadding: UE.Vector2D;
        WrapWidth: number;
        bExplicitWrapWidth: boolean;
        AddChildToWrapBox(Content: $Nullable<UE.Widget>) : UE.WrapBoxSlot;
        SetInnerSlotPadding(InPadding: UE.Vector2D) : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WrapBox;
        static Load(InName: string): WrapBox;
    }
    
    class XRAssetFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AddDeviceVisualizationComponentBlocking(Target: $Nullable<UE.Actor>, XRDeviceId: UE.XRDeviceId, bManualAttachment: boolean, RelativeTransform: UE.Transform) : UE.PrimitiveComponent;
        static AddNamedDeviceVisualizationComponentBlocking(Target: $Nullable<UE.Actor>, SystemName: string, DeviceName: string, bManualAttachment: boolean, RelativeTransform: UE.Transform, XRDeviceId: $Ref<UE.XRDeviceId>) : UE.PrimitiveComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): XRAssetFunctionLibrary;
        static Load(InName: string): XRAssetFunctionLibrary;
    }
    
    class XRLoadingScreenFunctionLibrary extends UE.BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AddLoadingScreenSplash(Texture: $Nullable<UE.Texture>, Translation: UE.Vector, Rotation: UE.Rotator, Size?: UE.Vector2D /* = (X=1.000,Y=1.000) */, DeltaRotation?: UE.Rotator /* =  */, bClearBeforeAdd?: boolean /* = false */) : void;
        static ClearLoadingScreenSplashes() : void;
        static HideLoadingScreen() : void;
        static SetLoadingScreen(Texture: $Nullable<UE.Texture>, Scale: UE.Vector2D, Offset: UE.Vector, bShowLoadingMovie: boolean, bShowOnSet: boolean) : void;
        static ShowLoadingScreen() : void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): XRLoadingScreenFunctionLibrary;
        static Load(InName: string): XRLoadingScreenFunctionLibrary;
    }
    
}
